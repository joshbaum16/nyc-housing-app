"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@grpc";
exports.ids = ["vendor-chunks/@grpc"];
exports.modules = {

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/admin.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/admin.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.registerAdminService = registerAdminService;\nexports.addAdminServicesToServer = addAdminServicesToServer;\nconst registeredAdminServices = [];\nfunction registerAdminService(getServiceDefinition, getHandlers) {\n    registeredAdminServices.push({\n        getServiceDefinition,\n        getHandlers\n    });\n}\nfunction addAdminServicesToServer(server) {\n    for (const { getServiceDefinition, getHandlers } of registeredAdminServices){\n        server.addService(getServiceDefinition(), getHandlers());\n    }\n} //# sourceMappingURL=admin.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYWRtaW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDRCQUE0QixHQUFHRTtBQUMvQkYsZ0NBQWdDLEdBQUdHO0FBQ25DLE1BQU1DLDBCQUEwQixFQUFFO0FBQ2xDLFNBQVNGLHFCQUFxQkcsb0JBQW9CLEVBQUVDLFdBQVc7SUFDM0RGLHdCQUF3QkcsSUFBSSxDQUFDO1FBQUVGO1FBQXNCQztJQUFZO0FBQ3JFO0FBQ0EsU0FBU0gseUJBQXlCSyxNQUFNO0lBQ3BDLEtBQUssTUFBTSxFQUFFSCxvQkFBb0IsRUFBRUMsV0FBVyxFQUFFLElBQUlGLHdCQUF5QjtRQUN6RUksT0FBT0MsVUFBVSxDQUFDSix3QkFBd0JDO0lBQzlDO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYWRtaW4uanM/OTg0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWdpc3RlckFkbWluU2VydmljZSA9IHJlZ2lzdGVyQWRtaW5TZXJ2aWNlO1xuZXhwb3J0cy5hZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXIgPSBhZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXI7XG5jb25zdCByZWdpc3RlcmVkQWRtaW5TZXJ2aWNlcyA9IFtdO1xuZnVuY3Rpb24gcmVnaXN0ZXJBZG1pblNlcnZpY2UoZ2V0U2VydmljZURlZmluaXRpb24sIGdldEhhbmRsZXJzKSB7XG4gICAgcmVnaXN0ZXJlZEFkbWluU2VydmljZXMucHVzaCh7IGdldFNlcnZpY2VEZWZpbml0aW9uLCBnZXRIYW5kbGVycyB9KTtcbn1cbmZ1bmN0aW9uIGFkZEFkbWluU2VydmljZXNUb1NlcnZlcihzZXJ2ZXIpIHtcbiAgICBmb3IgKGNvbnN0IHsgZ2V0U2VydmljZURlZmluaXRpb24sIGdldEhhbmRsZXJzIH0gb2YgcmVnaXN0ZXJlZEFkbWluU2VydmljZXMpIHtcbiAgICAgICAgc2VydmVyLmFkZFNlcnZpY2UoZ2V0U2VydmljZURlZmluaXRpb24oKSwgZ2V0SGFuZGxlcnMoKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRtaW4uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicmVnaXN0ZXJBZG1pblNlcnZpY2UiLCJhZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXIiLCJyZWdpc3RlcmVkQWRtaW5TZXJ2aWNlcyIsImdldFNlcnZpY2VEZWZpbml0aW9uIiwiZ2V0SGFuZGxlcnMiLCJwdXNoIiwic2VydmVyIiwiYWRkU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/admin.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BackoffTimeout = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = \"backoff\";\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */ function uniformRandom(min, max) {\n    return Math.random() * (max - min) + min;\n}\nclass BackoffTimeout {\n    constructor(callback, options){\n        this.callback = callback;\n        /**\n         * The delay time at the start, and after each reset.\n         */ this.initialDelay = INITIAL_BACKOFF_MS;\n        /**\n         * The exponential backoff multiplier.\n         */ this.multiplier = BACKOFF_MULTIPLIER;\n        /**\n         * The maximum delay time\n         */ this.maxDelay = MAX_BACKOFF_MS;\n        /**\n         * The maximum fraction by which the delay time can randomly vary after\n         * applying the multiplier.\n         */ this.jitter = BACKOFF_JITTER;\n        /**\n         * Indicates whether the timer is currently running.\n         */ this.running = false;\n        /**\n         * Indicates whether the timer should keep the Node process running if no\n         * other async operation is doing so.\n         */ this.hasRef = true;\n        /**\n         * The time that the currently running timer was started. Only valid if\n         * running is true.\n         */ this.startTime = new Date();\n        /**\n         * The approximate time that the currently running timer will end. Only valid\n         * if running is true.\n         */ this.endTime = new Date();\n        this.id = BackoffTimeout.getNextId();\n        if (options) {\n            if (options.initialDelay) {\n                this.initialDelay = options.initialDelay;\n            }\n            if (options.multiplier) {\n                this.multiplier = options.multiplier;\n            }\n            if (options.jitter) {\n                this.jitter = options.jitter;\n            }\n            if (options.maxDelay) {\n                this.maxDelay = options.maxDelay;\n            }\n        }\n        this.trace(\"constructed initialDelay=\" + this.initialDelay + \" multiplier=\" + this.multiplier + \" jitter=\" + this.jitter + \" maxDelay=\" + this.maxDelay);\n        this.nextDelay = this.initialDelay;\n        this.timerId = setTimeout(()=>{}, 0);\n        clearTimeout(this.timerId);\n    }\n    static getNextId() {\n        return this.nextId++;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"{\" + this.id + \"} \" + text);\n    }\n    runTimer(delay) {\n        var _a, _b;\n        this.trace(\"runTimer(delay=\" + delay + \")\");\n        this.endTime = this.startTime;\n        this.endTime.setMilliseconds(this.endTime.getMilliseconds() + delay);\n        clearTimeout(this.timerId);\n        this.timerId = setTimeout(()=>{\n            this.trace(\"timer fired\");\n            this.callback();\n            this.running = false;\n        }, delay);\n        if (!this.hasRef) {\n            (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    /**\n     * Call the callback after the current amount of delay time\n     */ runOnce() {\n        this.trace(\"runOnce()\");\n        this.running = true;\n        this.startTime = new Date();\n        this.runTimer(this.nextDelay);\n        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n        const jitterMagnitude = nextBackoff * this.jitter;\n        this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n    }\n    /**\n     * Stop the timer. The callback will not be called until `runOnce` is called\n     * again.\n     */ stop() {\n        this.trace(\"stop()\");\n        clearTimeout(this.timerId);\n        this.running = false;\n    }\n    /**\n     * Reset the delay time to its initial value. If the timer is still running,\n     * retroactively apply that reset to the current timer.\n     */ reset() {\n        this.trace(\"reset() running=\" + this.running);\n        this.nextDelay = this.initialDelay;\n        if (this.running) {\n            const now = new Date();\n            const newEndTime = this.startTime;\n            newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\n            clearTimeout(this.timerId);\n            if (now < newEndTime) {\n                this.runTimer(newEndTime.getTime() - now.getTime());\n            } else {\n                this.running = false;\n            }\n        }\n    }\n    /**\n     * Check whether the timer is currently running.\n     */ isRunning() {\n        return this.running;\n    }\n    /**\n     * Set that while the timer is running, it should keep the Node process\n     * running.\n     */ ref() {\n        var _a, _b;\n        this.hasRef = true;\n        (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * Set that while the timer is running, it should not keep the Node process\n     * running.\n     */ unref() {\n        var _a, _b;\n        this.hasRef = false;\n        (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * Get the approximate timestamp of when the timer will fire. Only valid if\n     * this.isRunning() is true.\n     */ getEndTime() {\n        return this.endTime;\n    }\n}\nexports.BackoffTimeout = BackoffTimeout;\nBackoffTimeout.nextId = 0; //# sourceMappingURL=backoff-timeout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYmFja29mZi10aW1lb3V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBRyxLQUFLO0FBQzlCLE1BQU1HLGNBQWNDLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1FLGNBQWM7QUFDcEIsTUFBTUMscUJBQXFCO0FBQzNCLE1BQU1DLHFCQUFxQjtBQUMzQixNQUFNQyxpQkFBaUI7QUFDdkIsTUFBTUMsaUJBQWlCO0FBQ3ZCOzs7O0NBSUMsR0FDRCxTQUFTQyxjQUFjQyxHQUFHLEVBQUVDLEdBQUc7SUFDM0IsT0FBT0MsS0FBS0MsTUFBTSxLQUFNRixDQUFBQSxNQUFNRCxHQUFFLElBQUtBO0FBQ3pDO0FBQ0EsTUFBTVY7SUFDRmMsWUFBWUMsUUFBUSxFQUFFQyxPQUFPLENBQUU7UUFDM0IsSUFBSSxDQUFDRCxRQUFRLEdBQUdBO1FBQ2hCOztTQUVDLEdBQ0QsSUFBSSxDQUFDRSxZQUFZLEdBQUdaO1FBQ3BCOztTQUVDLEdBQ0QsSUFBSSxDQUFDYSxVQUFVLEdBQUdaO1FBQ2xCOztTQUVDLEdBQ0QsSUFBSSxDQUFDYSxRQUFRLEdBQUdaO1FBQ2hCOzs7U0FHQyxHQUNELElBQUksQ0FBQ2EsTUFBTSxHQUFHWjtRQUNkOztTQUVDLEdBQ0QsSUFBSSxDQUFDYSxPQUFPLEdBQUc7UUFDZjs7O1NBR0MsR0FDRCxJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkOzs7U0FHQyxHQUNELElBQUksQ0FBQ0MsU0FBUyxHQUFHLElBQUlDO1FBQ3JCOzs7U0FHQyxHQUNELElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUlEO1FBQ25CLElBQUksQ0FBQ0UsRUFBRSxHQUFHMUIsZUFBZTJCLFNBQVM7UUFDbEMsSUFBSVgsU0FBUztZQUNULElBQUlBLFFBQVFDLFlBQVksRUFBRTtnQkFDdEIsSUFBSSxDQUFDQSxZQUFZLEdBQUdELFFBQVFDLFlBQVk7WUFDNUM7WUFDQSxJQUFJRCxRQUFRRSxVQUFVLEVBQUU7Z0JBQ3BCLElBQUksQ0FBQ0EsVUFBVSxHQUFHRixRQUFRRSxVQUFVO1lBQ3hDO1lBQ0EsSUFBSUYsUUFBUUksTUFBTSxFQUFFO2dCQUNoQixJQUFJLENBQUNBLE1BQU0sR0FBR0osUUFBUUksTUFBTTtZQUNoQztZQUNBLElBQUlKLFFBQVFHLFFBQVEsRUFBRTtnQkFDbEIsSUFBSSxDQUFDQSxRQUFRLEdBQUdILFFBQVFHLFFBQVE7WUFDcEM7UUFDSjtRQUNBLElBQUksQ0FBQ1MsS0FBSyxDQUFDLDhCQUE4QixJQUFJLENBQUNYLFlBQVksR0FBRyxpQkFBaUIsSUFBSSxDQUFDQyxVQUFVLEdBQUcsYUFBYSxJQUFJLENBQUNFLE1BQU0sR0FBRyxlQUFlLElBQUksQ0FBQ0QsUUFBUTtRQUN2SixJQUFJLENBQUNVLFNBQVMsR0FBRyxJQUFJLENBQUNaLFlBQVk7UUFDbEMsSUFBSSxDQUFDYSxPQUFPLEdBQUdDLFdBQVcsS0FBUSxHQUFHO1FBQ3JDQyxhQUFhLElBQUksQ0FBQ0YsT0FBTztJQUM3QjtJQUNBLE9BQU9ILFlBQVk7UUFDZixPQUFPLElBQUksQ0FBQ00sTUFBTTtJQUN0QjtJQUNBTCxNQUFNTSxJQUFJLEVBQUU7UUFDUi9CLFFBQVF5QixLQUFLLENBQUMzQixZQUFZa0MsWUFBWSxDQUFDQyxLQUFLLEVBQUVoQyxhQUFhLE1BQU0sSUFBSSxDQUFDc0IsRUFBRSxHQUFHLE9BQU9RO0lBQ3RGO0lBQ0FHLFNBQVNDLEtBQUssRUFBRTtRQUNaLElBQUlDLElBQUlDO1FBQ1IsSUFBSSxDQUFDWixLQUFLLENBQUMsb0JBQW9CVSxRQUFRO1FBQ3ZDLElBQUksQ0FBQ2IsT0FBTyxHQUFHLElBQUksQ0FBQ0YsU0FBUztRQUM3QixJQUFJLENBQUNFLE9BQU8sQ0FBQ2dCLGVBQWUsQ0FBQyxJQUFJLENBQUNoQixPQUFPLENBQUNpQixlQUFlLEtBQUtKO1FBQzlETixhQUFhLElBQUksQ0FBQ0YsT0FBTztRQUN6QixJQUFJLENBQUNBLE9BQU8sR0FBR0MsV0FBVztZQUN0QixJQUFJLENBQUNILEtBQUssQ0FBQztZQUNYLElBQUksQ0FBQ2IsUUFBUTtZQUNiLElBQUksQ0FBQ00sT0FBTyxHQUFHO1FBQ25CLEdBQUdpQjtRQUNILElBQUksQ0FBQyxJQUFJLENBQUNoQixNQUFNLEVBQUU7WUFDYmtCLENBQUFBLEtBQUssQ0FBQ0QsS0FBSyxJQUFJLENBQUNULE9BQU8sRUFBRWEsS0FBSyxNQUFNLFFBQVFILE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0ksSUFBSSxDQUFDTDtRQUNsRjtJQUNKO0lBQ0E7O0tBRUMsR0FDRE0sVUFBVTtRQUNOLElBQUksQ0FBQ2pCLEtBQUssQ0FBQztRQUNYLElBQUksQ0FBQ1AsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDRSxTQUFTLEdBQUcsSUFBSUM7UUFDckIsSUFBSSxDQUFDYSxRQUFRLENBQUMsSUFBSSxDQUFDUixTQUFTO1FBQzVCLE1BQU1pQixjQUFjbEMsS0FBS0YsR0FBRyxDQUFDLElBQUksQ0FBQ21CLFNBQVMsR0FBRyxJQUFJLENBQUNYLFVBQVUsRUFBRSxJQUFJLENBQUNDLFFBQVE7UUFDNUUsTUFBTTRCLGtCQUFrQkQsY0FBYyxJQUFJLENBQUMxQixNQUFNO1FBQ2pELElBQUksQ0FBQ1MsU0FBUyxHQUNWaUIsY0FBY3JDLGNBQWMsQ0FBQ3NDLGlCQUFpQkE7SUFDdEQ7SUFDQTs7O0tBR0MsR0FDREMsT0FBTztRQUNILElBQUksQ0FBQ3BCLEtBQUssQ0FBQztRQUNYSSxhQUFhLElBQUksQ0FBQ0YsT0FBTztRQUN6QixJQUFJLENBQUNULE9BQU8sR0FBRztJQUNuQjtJQUNBOzs7S0FHQyxHQUNENEIsUUFBUTtRQUNKLElBQUksQ0FBQ3JCLEtBQUssQ0FBQyxxQkFBcUIsSUFBSSxDQUFDUCxPQUFPO1FBQzVDLElBQUksQ0FBQ1EsU0FBUyxHQUFHLElBQUksQ0FBQ1osWUFBWTtRQUNsQyxJQUFJLElBQUksQ0FBQ0ksT0FBTyxFQUFFO1lBQ2QsTUFBTTZCLE1BQU0sSUFBSTFCO1lBQ2hCLE1BQU0yQixhQUFhLElBQUksQ0FBQzVCLFNBQVM7WUFDakM0QixXQUFXVixlQUFlLENBQUNVLFdBQVdULGVBQWUsS0FBSyxJQUFJLENBQUNiLFNBQVM7WUFDeEVHLGFBQWEsSUFBSSxDQUFDRixPQUFPO1lBQ3pCLElBQUlvQixNQUFNQyxZQUFZO2dCQUNsQixJQUFJLENBQUNkLFFBQVEsQ0FBQ2MsV0FBV0MsT0FBTyxLQUFLRixJQUFJRSxPQUFPO1lBQ3BELE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDL0IsT0FBTyxHQUFHO1lBQ25CO1FBQ0o7SUFDSjtJQUNBOztLQUVDLEdBQ0RnQyxZQUFZO1FBQ1IsT0FBTyxJQUFJLENBQUNoQyxPQUFPO0lBQ3ZCO0lBQ0E7OztLQUdDLEdBQ0RpQyxNQUFNO1FBQ0YsSUFBSWYsSUFBSUM7UUFDUixJQUFJLENBQUNsQixNQUFNLEdBQUc7UUFDYmtCLENBQUFBLEtBQUssQ0FBQ0QsS0FBSyxJQUFJLENBQUNULE9BQU8sRUFBRXdCLEdBQUcsTUFBTSxRQUFRZCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdJLElBQUksQ0FBQ0w7SUFDaEY7SUFDQTs7O0tBR0MsR0FDREksUUFBUTtRQUNKLElBQUlKLElBQUlDO1FBQ1IsSUFBSSxDQUFDbEIsTUFBTSxHQUFHO1FBQ2JrQixDQUFBQSxLQUFLLENBQUNELEtBQUssSUFBSSxDQUFDVCxPQUFPLEVBQUVhLEtBQUssTUFBTSxRQUFRSCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdJLElBQUksQ0FBQ0w7SUFDbEY7SUFDQTs7O0tBR0MsR0FDRGdCLGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQzlCLE9BQU87SUFDdkI7QUFDSjtBQUNBM0Isc0JBQXNCLEdBQUdFO0FBQ3pCQSxlQUFlaUMsTUFBTSxHQUFHLEdBQ3hCLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1ob3VzaW5nLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9iYWNrb2ZmLXRpbWVvdXQuanM/ZmU0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYWNrb2ZmVGltZW91dCA9IHZvaWQgMDtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdiYWNrb2ZmJztcbmNvbnN0IElOSVRJQUxfQkFDS09GRl9NUyA9IDEwMDA7XG5jb25zdCBCQUNLT0ZGX01VTFRJUExJRVIgPSAxLjY7XG5jb25zdCBNQVhfQkFDS09GRl9NUyA9IDEyMDAwMDtcbmNvbnN0IEJBQ0tPRkZfSklUVEVSID0gMC4yO1xuLyoqXG4gKiBHZXQgYSBudW1iZXIgdW5pZm9ybWx5IGF0IHJhbmRvbSBpbiB0aGUgcmFuZ2UgW21pbiwgbWF4KVxuICogQHBhcmFtIG1pblxuICogQHBhcmFtIG1heFxuICovXG5mdW5jdGlvbiB1bmlmb3JtUmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcbn1cbmNsYXNzIEJhY2tvZmZUaW1lb3V0IHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVsYXkgdGltZSBhdCB0aGUgc3RhcnQsIGFuZCBhZnRlciBlYWNoIHJlc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbml0aWFsRGVsYXkgPSBJTklUSUFMX0JBQ0tPRkZfTVM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZXhwb25lbnRpYWwgYmFja29mZiBtdWx0aXBsaWVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tdWx0aXBsaWVyID0gQkFDS09GRl9NVUxUSVBMSUVSO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gZGVsYXkgdGltZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXhEZWxheSA9IE1BWF9CQUNLT0ZGX01TO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gZnJhY3Rpb24gYnkgd2hpY2ggdGhlIGRlbGF5IHRpbWUgY2FuIHJhbmRvbWx5IHZhcnkgYWZ0ZXJcbiAgICAgICAgICogYXBwbHlpbmcgdGhlIG11bHRpcGxpZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmppdHRlciA9IEJBQ0tPRkZfSklUVEVSO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRpbWVyIGlzIGN1cnJlbnRseSBydW5uaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGltZXIgc2hvdWxkIGtlZXAgdGhlIE5vZGUgcHJvY2VzcyBydW5uaW5nIGlmIG5vXG4gICAgICAgICAqIG90aGVyIGFzeW5jIG9wZXJhdGlvbiBpcyBkb2luZyBzby5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzUmVmID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIHRoYXQgdGhlIGN1cnJlbnRseSBydW5uaW5nIHRpbWVyIHdhcyBzdGFydGVkLiBPbmx5IHZhbGlkIGlmXG4gICAgICAgICAqIHJ1bm5pbmcgaXMgdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhcHByb3hpbWF0ZSB0aW1lIHRoYXQgdGhlIGN1cnJlbnRseSBydW5uaW5nIHRpbWVyIHdpbGwgZW5kLiBPbmx5IHZhbGlkXG4gICAgICAgICAqIGlmIHJ1bm5pbmcgaXMgdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW5kVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMuaWQgPSBCYWNrb2ZmVGltZW91dC5nZXROZXh0SWQoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmluaXRpYWxEZWxheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbERlbGF5ID0gb3B0aW9ucy5pbml0aWFsRGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tdWx0aXBsaWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBsaWVyID0gb3B0aW9ucy5tdWx0aXBsaWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaml0dGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5qaXR0ZXIgPSBvcHRpb25zLmppdHRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1heERlbGF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXhEZWxheSA9IG9wdGlvbnMubWF4RGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZSgnY29uc3RydWN0ZWQgaW5pdGlhbERlbGF5PScgKyB0aGlzLmluaXRpYWxEZWxheSArICcgbXVsdGlwbGllcj0nICsgdGhpcy5tdWx0aXBsaWVyICsgJyBqaXR0ZXI9JyArIHRoaXMuaml0dGVyICsgJyBtYXhEZWxheT0nICsgdGhpcy5tYXhEZWxheSk7XG4gICAgICAgIHRoaXMubmV4dERlbGF5ID0gdGhpcy5pbml0aWFsRGVsYXk7XG4gICAgICAgIHRoaXMudGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXROZXh0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRJZCsrO1xuICAgIH1cbiAgICB0cmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgJ3snICsgdGhpcy5pZCArICd9ICcgKyB0ZXh0KTtcbiAgICB9XG4gICAgcnVuVGltZXIoZGVsYXkpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy50cmFjZSgncnVuVGltZXIoZGVsYXk9JyArIGRlbGF5ICsgJyknKTtcbiAgICAgICAgdGhpcy5lbmRUaW1lID0gdGhpcy5zdGFydFRpbWU7XG4gICAgICAgIHRoaXMuZW5kVGltZS5zZXRNaWxsaXNlY29uZHModGhpcy5lbmRUaW1lLmdldE1pbGxpc2Vjb25kcygpICsgZGVsYXkpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICAgICAgdGhpcy50aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCd0aW1lciBmaXJlZCcpO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjaygpO1xuICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1JlZikge1xuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy50aW1lcklkKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIGNhbGxiYWNrIGFmdGVyIHRoZSBjdXJyZW50IGFtb3VudCBvZiBkZWxheSB0aW1lXG4gICAgICovXG4gICAgcnVuT25jZSgpIHtcbiAgICAgICAgdGhpcy50cmFjZSgncnVuT25jZSgpJyk7XG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5ydW5UaW1lcih0aGlzLm5leHREZWxheSk7XG4gICAgICAgIGNvbnN0IG5leHRCYWNrb2ZmID0gTWF0aC5taW4odGhpcy5uZXh0RGVsYXkgKiB0aGlzLm11bHRpcGxpZXIsIHRoaXMubWF4RGVsYXkpO1xuICAgICAgICBjb25zdCBqaXR0ZXJNYWduaXR1ZGUgPSBuZXh0QmFja29mZiAqIHRoaXMuaml0dGVyO1xuICAgICAgICB0aGlzLm5leHREZWxheSA9XG4gICAgICAgICAgICBuZXh0QmFja29mZiArIHVuaWZvcm1SYW5kb20oLWppdHRlck1hZ25pdHVkZSwgaml0dGVyTWFnbml0dWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgdGltZXIuIFRoZSBjYWxsYmFjayB3aWxsIG5vdCBiZSBjYWxsZWQgdW50aWwgYHJ1bk9uY2VgIGlzIGNhbGxlZFxuICAgICAqIGFnYWluLlxuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3N0b3AoKScpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBkZWxheSB0aW1lIHRvIGl0cyBpbml0aWFsIHZhbHVlLiBJZiB0aGUgdGltZXIgaXMgc3RpbGwgcnVubmluZyxcbiAgICAgKiByZXRyb2FjdGl2ZWx5IGFwcGx5IHRoYXQgcmVzZXQgdG8gdGhlIGN1cnJlbnQgdGltZXIuXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3Jlc2V0KCkgcnVubmluZz0nICsgdGhpcy5ydW5uaW5nKTtcbiAgICAgICAgdGhpcy5uZXh0RGVsYXkgPSB0aGlzLmluaXRpYWxEZWxheTtcbiAgICAgICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0VuZFRpbWUgPSB0aGlzLnN0YXJ0VGltZTtcbiAgICAgICAgICAgIG5ld0VuZFRpbWUuc2V0TWlsbGlzZWNvbmRzKG5ld0VuZFRpbWUuZ2V0TWlsbGlzZWNvbmRzKCkgKyB0aGlzLm5leHREZWxheSk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICAgICAgICAgIGlmIChub3cgPCBuZXdFbmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lcihuZXdFbmRUaW1lLmdldFRpbWUoKSAtIG5vdy5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgdGltZXIgaXMgY3VycmVudGx5IHJ1bm5pbmcuXG4gICAgICovXG4gICAgaXNSdW5uaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW5uaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhhdCB3aGlsZSB0aGUgdGltZXIgaXMgcnVubmluZywgaXQgc2hvdWxkIGtlZXAgdGhlIE5vZGUgcHJvY2Vzc1xuICAgICAqIHJ1bm5pbmcuXG4gICAgICovXG4gICAgcmVmKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmhhc1JlZiA9IHRydWU7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMudGltZXJJZCkucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGF0IHdoaWxlIHRoZSB0aW1lciBpcyBydW5uaW5nLCBpdCBzaG91bGQgbm90IGtlZXAgdGhlIE5vZGUgcHJvY2Vzc1xuICAgICAqIHJ1bm5pbmcuXG4gICAgICovXG4gICAgdW5yZWYoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuaGFzUmVmID0gZmFsc2U7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMudGltZXJJZCkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhcHByb3hpbWF0ZSB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgdGltZXIgd2lsbCBmaXJlLiBPbmx5IHZhbGlkIGlmXG4gICAgICogdGhpcy5pc1J1bm5pbmcoKSBpcyB0cnVlLlxuICAgICAqL1xuICAgIGdldEVuZFRpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZFRpbWU7XG4gICAgfVxufVxuZXhwb3J0cy5CYWNrb2ZmVGltZW91dCA9IEJhY2tvZmZUaW1lb3V0O1xuQmFja29mZlRpbWVvdXQubmV4dElkID0gMDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tvZmYtdGltZW91dC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJCYWNrb2ZmVGltZW91dCIsImNvbnN0YW50c18xIiwicmVxdWlyZSIsImxvZ2dpbmciLCJUUkFDRVJfTkFNRSIsIklOSVRJQUxfQkFDS09GRl9NUyIsIkJBQ0tPRkZfTVVMVElQTElFUiIsIk1BWF9CQUNLT0ZGX01TIiwiQkFDS09GRl9KSVRURVIiLCJ1bmlmb3JtUmFuZG9tIiwibWluIiwibWF4IiwiTWF0aCIsInJhbmRvbSIsImNvbnN0cnVjdG9yIiwiY2FsbGJhY2siLCJvcHRpb25zIiwiaW5pdGlhbERlbGF5IiwibXVsdGlwbGllciIsIm1heERlbGF5Iiwiaml0dGVyIiwicnVubmluZyIsImhhc1JlZiIsInN0YXJ0VGltZSIsIkRhdGUiLCJlbmRUaW1lIiwiaWQiLCJnZXROZXh0SWQiLCJ0cmFjZSIsIm5leHREZWxheSIsInRpbWVySWQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwibmV4dElkIiwidGV4dCIsIkxvZ1ZlcmJvc2l0eSIsIkRFQlVHIiwicnVuVGltZXIiLCJkZWxheSIsIl9hIiwiX2IiLCJzZXRNaWxsaXNlY29uZHMiLCJnZXRNaWxsaXNlY29uZHMiLCJ1bnJlZiIsImNhbGwiLCJydW5PbmNlIiwibmV4dEJhY2tvZmYiLCJqaXR0ZXJNYWduaXR1ZGUiLCJzdG9wIiwicmVzZXQiLCJub3ciLCJuZXdFbmRUaW1lIiwiZ2V0VGltZSIsImlzUnVubmluZyIsInJlZiIsImdldEVuZFRpbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js":
/*!******************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-credentials.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CallCredentials = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nfunction isCurrentOauth2Client(client) {\n    return \"getRequestHeaders\" in client && typeof client.getRequestHeaders === \"function\";\n}\n/**\n * A class that represents a generic method of adding authentication-related\n * metadata on a per-request basis.\n */ class CallCredentials {\n    /**\n     * Creates a new CallCredentials object from a given function that generates\n     * Metadata objects.\n     * @param metadataGenerator A function that accepts a set of options, and\n     * generates a Metadata object based on these options, which is passed back\n     * to the caller via a supplied (err, metadata) callback.\n     */ static createFromMetadataGenerator(metadataGenerator) {\n        return new SingleCallCredentials(metadataGenerator);\n    }\n    /**\n     * Create a gRPC credential from a Google credential object.\n     * @param googleCredentials The authentication client to use.\n     * @return The resulting CallCredentials object.\n     */ static createFromGoogleCredential(googleCredentials) {\n        return CallCredentials.createFromMetadataGenerator((options, callback)=>{\n            let getHeaders;\n            if (isCurrentOauth2Client(googleCredentials)) {\n                getHeaders = googleCredentials.getRequestHeaders(options.service_url);\n            } else {\n                getHeaders = new Promise((resolve, reject)=>{\n                    googleCredentials.getRequestMetadata(options.service_url, (err, headers)=>{\n                        if (err) {\n                            reject(err);\n                            return;\n                        }\n                        if (!headers) {\n                            reject(new Error(\"Headers not set by metadata plugin\"));\n                            return;\n                        }\n                        resolve(headers);\n                    });\n                });\n            }\n            getHeaders.then((headers)=>{\n                const metadata = new metadata_1.Metadata();\n                for (const key of Object.keys(headers)){\n                    metadata.add(key, headers[key]);\n                }\n                callback(null, metadata);\n            }, (err)=>{\n                callback(err);\n            });\n        });\n    }\n    static createEmpty() {\n        return new EmptyCallCredentials();\n    }\n}\nexports.CallCredentials = CallCredentials;\nclass ComposedCallCredentials extends CallCredentials {\n    constructor(creds){\n        super();\n        this.creds = creds;\n    }\n    async generateMetadata(options) {\n        const base = new metadata_1.Metadata();\n        const generated = await Promise.all(this.creds.map((cred)=>cred.generateMetadata(options)));\n        for (const gen of generated){\n            base.merge(gen);\n        }\n        return base;\n    }\n    compose(other) {\n        return new ComposedCallCredentials(this.creds.concat([\n            other\n        ]));\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ComposedCallCredentials) {\n            return this.creds.every((value, index)=>value._equals(other.creds[index]));\n        } else {\n            return false;\n        }\n    }\n}\nclass SingleCallCredentials extends CallCredentials {\n    constructor(metadataGenerator){\n        super();\n        this.metadataGenerator = metadataGenerator;\n    }\n    generateMetadata(options) {\n        return new Promise((resolve, reject)=>{\n            this.metadataGenerator(options, (err, metadata)=>{\n                if (metadata !== undefined) {\n                    resolve(metadata);\n                } else {\n                    reject(err);\n                }\n            });\n        });\n    }\n    compose(other) {\n        return new ComposedCallCredentials([\n            this,\n            other\n        ]);\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof SingleCallCredentials) {\n            return this.metadataGenerator === other.metadataGenerator;\n        } else {\n            return false;\n        }\n    }\n}\nclass EmptyCallCredentials extends CallCredentials {\n    generateMetadata(options) {\n        return Promise.resolve(new metadata_1.Metadata());\n    }\n    compose(other) {\n        return other;\n    }\n    _equals(other) {\n        return other instanceof EmptyCallCredentials;\n    }\n} //# sourceMappingURL=call-credentials.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1jcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUJBQXVCLEdBQUcsS0FBSztBQUMvQixNQUFNRyxhQUFhQyxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxTQUFTQyxzQkFBc0JDLE1BQU07SUFDakMsT0FBUSx1QkFBdUJBLFVBQzNCLE9BQU9BLE9BQU9DLGlCQUFpQixLQUFLO0FBQzVDO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTUw7SUFDRjs7Ozs7O0tBTUMsR0FDRCxPQUFPTSw0QkFBNEJDLGlCQUFpQixFQUFFO1FBQ2xELE9BQU8sSUFBSUMsc0JBQXNCRDtJQUNyQztJQUNBOzs7O0tBSUMsR0FDRCxPQUFPRSwyQkFBMkJDLGlCQUFpQixFQUFFO1FBQ2pELE9BQU9WLGdCQUFnQk0sMkJBQTJCLENBQUMsQ0FBQ0ssU0FBU0M7WUFDekQsSUFBSUM7WUFDSixJQUFJVixzQkFBc0JPLG9CQUFvQjtnQkFDMUNHLGFBQWFILGtCQUFrQkwsaUJBQWlCLENBQUNNLFFBQVFHLFdBQVc7WUFDeEUsT0FDSztnQkFDREQsYUFBYSxJQUFJRSxRQUFRLENBQUNDLFNBQVNDO29CQUMvQlAsa0JBQWtCUSxrQkFBa0IsQ0FBQ1AsUUFBUUcsV0FBVyxFQUFFLENBQUNLLEtBQUtDO3dCQUM1RCxJQUFJRCxLQUFLOzRCQUNMRixPQUFPRTs0QkFDUDt3QkFDSjt3QkFDQSxJQUFJLENBQUNDLFNBQVM7NEJBQ1ZILE9BQU8sSUFBSUksTUFBTTs0QkFDakI7d0JBQ0o7d0JBQ0FMLFFBQVFJO29CQUNaO2dCQUNKO1lBQ0o7WUFDQVAsV0FBV1MsSUFBSSxDQUFDRixDQUFBQTtnQkFDWixNQUFNRyxXQUFXLElBQUl0QixXQUFXdUIsUUFBUTtnQkFDeEMsS0FBSyxNQUFNQyxPQUFPN0IsT0FBTzhCLElBQUksQ0FBQ04sU0FBVTtvQkFDcENHLFNBQVNJLEdBQUcsQ0FBQ0YsS0FBS0wsT0FBTyxDQUFDSyxJQUFJO2dCQUNsQztnQkFDQWIsU0FBUyxNQUFNVztZQUNuQixHQUFHSixDQUFBQTtnQkFDQ1AsU0FBU087WUFDYjtRQUNKO0lBQ0o7SUFDQSxPQUFPUyxjQUFjO1FBQ2pCLE9BQU8sSUFBSUM7SUFDZjtBQUNKO0FBQ0EvQix1QkFBdUIsR0FBR0U7QUFDMUIsTUFBTThCLGdDQUFnQzlCO0lBQ2xDK0IsWUFBWUMsS0FBSyxDQUFFO1FBQ2YsS0FBSztRQUNMLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtJQUNqQjtJQUNBLE1BQU1DLGlCQUFpQnRCLE9BQU8sRUFBRTtRQUM1QixNQUFNdUIsT0FBTyxJQUFJakMsV0FBV3VCLFFBQVE7UUFDcEMsTUFBTVcsWUFBWSxNQUFNcEIsUUFBUXFCLEdBQUcsQ0FBQyxJQUFJLENBQUNKLEtBQUssQ0FBQ0ssR0FBRyxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLTCxnQkFBZ0IsQ0FBQ3RCO1FBQ2pGLEtBQUssTUFBTTRCLE9BQU9KLFVBQVc7WUFDekJELEtBQUtNLEtBQUssQ0FBQ0Q7UUFDZjtRQUNBLE9BQU9MO0lBQ1g7SUFDQU8sUUFBUUMsS0FBSyxFQUFFO1FBQ1gsT0FBTyxJQUFJWix3QkFBd0IsSUFBSSxDQUFDRSxLQUFLLENBQUNXLE1BQU0sQ0FBQztZQUFDRDtTQUFNO0lBQ2hFO0lBQ0FFLFFBQVFGLEtBQUssRUFBRTtRQUNYLElBQUksSUFBSSxLQUFLQSxPQUFPO1lBQ2hCLE9BQU87UUFDWDtRQUNBLElBQUlBLGlCQUFpQloseUJBQXlCO1lBQzFDLE9BQU8sSUFBSSxDQUFDRSxLQUFLLENBQUNhLEtBQUssQ0FBQyxDQUFDOUMsT0FBTytDLFFBQVUvQyxNQUFNNkMsT0FBTyxDQUFDRixNQUFNVixLQUFLLENBQUNjLE1BQU07UUFDOUUsT0FDSztZQUNELE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQSxNQUFNdEMsOEJBQThCUjtJQUNoQytCLFlBQVl4QixpQkFBaUIsQ0FBRTtRQUMzQixLQUFLO1FBQ0wsSUFBSSxDQUFDQSxpQkFBaUIsR0FBR0E7SUFDN0I7SUFDQTBCLGlCQUFpQnRCLE9BQU8sRUFBRTtRQUN0QixPQUFPLElBQUlJLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDekIsSUFBSSxDQUFDVixpQkFBaUIsQ0FBQ0ksU0FBUyxDQUFDUSxLQUFLSTtnQkFDbEMsSUFBSUEsYUFBYXdCLFdBQVc7b0JBQ3hCL0IsUUFBUU87Z0JBQ1osT0FDSztvQkFDRE4sT0FBT0U7Z0JBQ1g7WUFDSjtRQUNKO0lBQ0o7SUFDQXNCLFFBQVFDLEtBQUssRUFBRTtRQUNYLE9BQU8sSUFBSVosd0JBQXdCO1lBQUMsSUFBSTtZQUFFWTtTQUFNO0lBQ3BEO0lBQ0FFLFFBQVFGLEtBQUssRUFBRTtRQUNYLElBQUksSUFBSSxLQUFLQSxPQUFPO1lBQ2hCLE9BQU87UUFDWDtRQUNBLElBQUlBLGlCQUFpQmxDLHVCQUF1QjtZQUN4QyxPQUFPLElBQUksQ0FBQ0QsaUJBQWlCLEtBQUttQyxNQUFNbkMsaUJBQWlCO1FBQzdELE9BQ0s7WUFDRCxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0EsTUFBTXNCLDZCQUE2QjdCO0lBQy9CaUMsaUJBQWlCdEIsT0FBTyxFQUFFO1FBQ3RCLE9BQU9JLFFBQVFDLE9BQU8sQ0FBQyxJQUFJZixXQUFXdUIsUUFBUTtJQUNsRDtJQUNBaUIsUUFBUUMsS0FBSyxFQUFFO1FBQ1gsT0FBT0E7SUFDWDtJQUNBRSxRQUFRRixLQUFLLEVBQUU7UUFDWCxPQUFPQSxpQkFBaUJiO0lBQzVCO0FBQ0osRUFDQSw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1jcmVkZW50aWFscy5qcz8yOGIyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNhbGxDcmVkZW50aWFscyA9IHZvaWQgMDtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmZ1bmN0aW9uIGlzQ3VycmVudE9hdXRoMkNsaWVudChjbGllbnQpIHtcbiAgICByZXR1cm4gKCdnZXRSZXF1ZXN0SGVhZGVycycgaW4gY2xpZW50ICYmXG4gICAgICAgIHR5cGVvZiBjbGllbnQuZ2V0UmVxdWVzdEhlYWRlcnMgPT09ICdmdW5jdGlvbicpO1xufVxuLyoqXG4gKiBBIGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhIGdlbmVyaWMgbWV0aG9kIG9mIGFkZGluZyBhdXRoZW50aWNhdGlvbi1yZWxhdGVkXG4gKiBtZXRhZGF0YSBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzLlxuICovXG5jbGFzcyBDYWxsQ3JlZGVudGlhbHMge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ2FsbENyZWRlbnRpYWxzIG9iamVjdCBmcm9tIGEgZ2l2ZW4gZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXNcbiAgICAgKiBNZXRhZGF0YSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSBtZXRhZGF0YUdlbmVyYXRvciBBIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhIHNldCBvZiBvcHRpb25zLCBhbmRcbiAgICAgKiBnZW5lcmF0ZXMgYSBNZXRhZGF0YSBvYmplY3QgYmFzZWQgb24gdGhlc2Ugb3B0aW9ucywgd2hpY2ggaXMgcGFzc2VkIGJhY2tcbiAgICAgKiB0byB0aGUgY2FsbGVyIHZpYSBhIHN1cHBsaWVkIChlcnIsIG1ldGFkYXRhKSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRnJvbU1ldGFkYXRhR2VuZXJhdG9yKG1ldGFkYXRhR2VuZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2luZ2xlQ2FsbENyZWRlbnRpYWxzKG1ldGFkYXRhR2VuZXJhdG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZ1JQQyBjcmVkZW50aWFsIGZyb20gYSBHb29nbGUgY3JlZGVudGlhbCBvYmplY3QuXG4gICAgICogQHBhcmFtIGdvb2dsZUNyZWRlbnRpYWxzIFRoZSBhdXRoZW50aWNhdGlvbiBjbGllbnQgdG8gdXNlLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3VsdGluZyBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGcm9tR29vZ2xlQ3JlZGVudGlhbChnb29nbGVDcmVkZW50aWFscykge1xuICAgICAgICByZXR1cm4gQ2FsbENyZWRlbnRpYWxzLmNyZWF0ZUZyb21NZXRhZGF0YUdlbmVyYXRvcigob3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGxldCBnZXRIZWFkZXJzO1xuICAgICAgICAgICAgaWYgKGlzQ3VycmVudE9hdXRoMkNsaWVudChnb29nbGVDcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgICAgICBnZXRIZWFkZXJzID0gZ29vZ2xlQ3JlZGVudGlhbHMuZ2V0UmVxdWVzdEhlYWRlcnMob3B0aW9ucy5zZXJ2aWNlX3VybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZXRIZWFkZXJzID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnb29nbGVDcmVkZW50aWFscy5nZXRSZXF1ZXN0TWV0YWRhdGEob3B0aW9ucy5zZXJ2aWNlX3VybCwgKGVyciwgaGVhZGVycykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0hlYWRlcnMgbm90IHNldCBieSBtZXRhZGF0YSBwbHVnaW4nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShoZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZXRIZWFkZXJzLnRoZW4oaGVhZGVycyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhLmFkZChrZXksIGhlYWRlcnNba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUVtcHR5KCkge1xuICAgICAgICByZXR1cm4gbmV3IEVtcHR5Q2FsbENyZWRlbnRpYWxzKCk7XG4gICAgfVxufVxuZXhwb3J0cy5DYWxsQ3JlZGVudGlhbHMgPSBDYWxsQ3JlZGVudGlhbHM7XG5jbGFzcyBDb21wb3NlZENhbGxDcmVkZW50aWFscyBleHRlbmRzIENhbGxDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3IoY3JlZHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jcmVkcyA9IGNyZWRzO1xuICAgIH1cbiAgICBhc3luYyBnZW5lcmF0ZU1ldGFkYXRhKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZCA9IGF3YWl0IFByb21pc2UuYWxsKHRoaXMuY3JlZHMubWFwKGNyZWQgPT4gY3JlZC5nZW5lcmF0ZU1ldGFkYXRhKG9wdGlvbnMpKSk7XG4gICAgICAgIGZvciAoY29uc3QgZ2VuIG9mIGdlbmVyYXRlZCkge1xuICAgICAgICAgICAgYmFzZS5tZXJnZShnZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgICBjb21wb3NlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9zZWRDYWxsQ3JlZGVudGlhbHModGhpcy5jcmVkcy5jb25jYXQoW290aGVyXSkpO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQ29tcG9zZWRDYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWRzLmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlLl9lcXVhbHMob3RoZXIuY3JlZHNbaW5kZXhdKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTaW5nbGVDYWxsQ3JlZGVudGlhbHMgZXh0ZW5kcyBDYWxsQ3JlZGVudGlhbHMge1xuICAgIGNvbnN0cnVjdG9yKG1ldGFkYXRhR2VuZXJhdG9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWV0YWRhdGFHZW5lcmF0b3IgPSBtZXRhZGF0YUdlbmVyYXRvcjtcbiAgICB9XG4gICAgZ2VuZXJhdGVNZXRhZGF0YShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhR2VuZXJhdG9yKG9wdGlvbnMsIChlcnIsIG1ldGFkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbXBvc2Uob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NlZENhbGxDcmVkZW50aWFscyhbdGhpcywgb3RoZXJdKTtcbiAgICB9XG4gICAgX2VxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFNpbmdsZUNhbGxDcmVkZW50aWFscykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWV0YWRhdGFHZW5lcmF0b3IgPT09IG90aGVyLm1ldGFkYXRhR2VuZXJhdG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgRW1wdHlDYWxsQ3JlZGVudGlhbHMgZXh0ZW5kcyBDYWxsQ3JlZGVudGlhbHMge1xuICAgIGdlbmVyYXRlTWV0YWRhdGEob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCkpO1xuICAgIH1cbiAgICBjb21wb3NlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlcjtcbiAgICB9XG4gICAgX2VxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBFbXB0eUNhbGxDcmVkZW50aWFscztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxsLWNyZWRlbnRpYWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkNhbGxDcmVkZW50aWFscyIsIm1ldGFkYXRhXzEiLCJyZXF1aXJlIiwiaXNDdXJyZW50T2F1dGgyQ2xpZW50IiwiY2xpZW50IiwiZ2V0UmVxdWVzdEhlYWRlcnMiLCJjcmVhdGVGcm9tTWV0YWRhdGFHZW5lcmF0b3IiLCJtZXRhZGF0YUdlbmVyYXRvciIsIlNpbmdsZUNhbGxDcmVkZW50aWFscyIsImNyZWF0ZUZyb21Hb29nbGVDcmVkZW50aWFsIiwiZ29vZ2xlQ3JlZGVudGlhbHMiLCJvcHRpb25zIiwiY2FsbGJhY2siLCJnZXRIZWFkZXJzIiwic2VydmljZV91cmwiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImdldFJlcXVlc3RNZXRhZGF0YSIsImVyciIsImhlYWRlcnMiLCJFcnJvciIsInRoZW4iLCJtZXRhZGF0YSIsIk1ldGFkYXRhIiwia2V5Iiwia2V5cyIsImFkZCIsImNyZWF0ZUVtcHR5IiwiRW1wdHlDYWxsQ3JlZGVudGlhbHMiLCJDb21wb3NlZENhbGxDcmVkZW50aWFscyIsImNvbnN0cnVjdG9yIiwiY3JlZHMiLCJnZW5lcmF0ZU1ldGFkYXRhIiwiYmFzZSIsImdlbmVyYXRlZCIsImFsbCIsIm1hcCIsImNyZWQiLCJnZW4iLCJtZXJnZSIsImNvbXBvc2UiLCJvdGhlciIsImNvbmNhdCIsIl9lcXVhbHMiLCJldmVyeSIsImluZGV4IiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/call-interface.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-interface.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InterceptingListenerImpl = void 0;\nexports.isInterceptingListener = isInterceptingListener;\nfunction isInterceptingListener(listener) {\n    return listener.onReceiveMetadata !== undefined && listener.onReceiveMetadata.length === 1;\n}\nclass InterceptingListenerImpl {\n    constructor(listener, nextListener){\n        this.listener = listener;\n        this.nextListener = nextListener;\n        this.processingMetadata = false;\n        this.hasPendingMessage = false;\n        this.processingMessage = false;\n        this.pendingStatus = null;\n    }\n    processPendingMessage() {\n        if (this.hasPendingMessage) {\n            this.nextListener.onReceiveMessage(this.pendingMessage);\n            this.pendingMessage = null;\n            this.hasPendingMessage = false;\n        }\n    }\n    processPendingStatus() {\n        if (this.pendingStatus) {\n            this.nextListener.onReceiveStatus(this.pendingStatus);\n        }\n    }\n    onReceiveMetadata(metadata) {\n        this.processingMetadata = true;\n        this.listener.onReceiveMetadata(metadata, (metadata)=>{\n            this.processingMetadata = false;\n            this.nextListener.onReceiveMetadata(metadata);\n            this.processPendingMessage();\n            this.processPendingStatus();\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onReceiveMessage(message) {\n        /* If this listener processes messages asynchronously, the last message may\n         * be reordered with respect to the status */ this.processingMessage = true;\n        this.listener.onReceiveMessage(message, (msg)=>{\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessage = msg;\n                this.hasPendingMessage = true;\n            } else {\n                this.nextListener.onReceiveMessage(msg);\n                this.processPendingStatus();\n            }\n        });\n    }\n    onReceiveStatus(status) {\n        this.listener.onReceiveStatus(status, (processedStatus)=>{\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingStatus = processedStatus;\n            } else {\n                this.nextListener.onReceiveStatus(processedStatus);\n            }\n        });\n    }\n}\nexports.InterceptingListenerImpl = InterceptingListenerImpl; //# sourceMappingURL=call-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdDQUFnQyxHQUFHLEtBQUs7QUFDeENBLDhCQUE4QixHQUFHRztBQUNqQyxTQUFTQSx1QkFBdUJDLFFBQVE7SUFDcEMsT0FBUUEsU0FBU0MsaUJBQWlCLEtBQUtDLGFBQ25DRixTQUFTQyxpQkFBaUIsQ0FBQ0UsTUFBTSxLQUFLO0FBQzlDO0FBQ0EsTUFBTUw7SUFDRk0sWUFBWUosUUFBUSxFQUFFSyxZQUFZLENBQUU7UUFDaEMsSUFBSSxDQUFDTCxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0ssWUFBWSxHQUFHQTtRQUNwQixJQUFJLENBQUNDLGtCQUFrQixHQUFHO1FBQzFCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNDLGFBQWEsR0FBRztJQUN6QjtJQUNBQyx3QkFBd0I7UUFDcEIsSUFBSSxJQUFJLENBQUNILGlCQUFpQixFQUFFO1lBQ3hCLElBQUksQ0FBQ0YsWUFBWSxDQUFDTSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNDLGNBQWM7WUFDdEQsSUFBSSxDQUFDQSxjQUFjLEdBQUc7WUFDdEIsSUFBSSxDQUFDTCxpQkFBaUIsR0FBRztRQUM3QjtJQUNKO0lBQ0FNLHVCQUF1QjtRQUNuQixJQUFJLElBQUksQ0FBQ0osYUFBYSxFQUFFO1lBQ3BCLElBQUksQ0FBQ0osWUFBWSxDQUFDUyxlQUFlLENBQUMsSUFBSSxDQUFDTCxhQUFhO1FBQ3hEO0lBQ0o7SUFDQVIsa0JBQWtCYyxRQUFRLEVBQUU7UUFDeEIsSUFBSSxDQUFDVCxrQkFBa0IsR0FBRztRQUMxQixJQUFJLENBQUNOLFFBQVEsQ0FBQ0MsaUJBQWlCLENBQUNjLFVBQVVBLENBQUFBO1lBQ3RDLElBQUksQ0FBQ1Qsa0JBQWtCLEdBQUc7WUFDMUIsSUFBSSxDQUFDRCxZQUFZLENBQUNKLGlCQUFpQixDQUFDYztZQUNwQyxJQUFJLENBQUNMLHFCQUFxQjtZQUMxQixJQUFJLENBQUNHLG9CQUFvQjtRQUM3QjtJQUNKO0lBQ0EsOERBQThEO0lBQzlERixpQkFBaUJLLE9BQU8sRUFBRTtRQUN0QjttREFDMkMsR0FDM0MsSUFBSSxDQUFDUixpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNSLFFBQVEsQ0FBQ1csZ0JBQWdCLENBQUNLLFNBQVNDLENBQUFBO1lBQ3BDLElBQUksQ0FBQ1QsaUJBQWlCLEdBQUc7WUFDekIsSUFBSSxJQUFJLENBQUNGLGtCQUFrQixFQUFFO2dCQUN6QixJQUFJLENBQUNNLGNBQWMsR0FBR0s7Z0JBQ3RCLElBQUksQ0FBQ1YsaUJBQWlCLEdBQUc7WUFDN0IsT0FDSztnQkFDRCxJQUFJLENBQUNGLFlBQVksQ0FBQ00sZ0JBQWdCLENBQUNNO2dCQUNuQyxJQUFJLENBQUNKLG9CQUFvQjtZQUM3QjtRQUNKO0lBQ0o7SUFDQUMsZ0JBQWdCSSxNQUFNLEVBQUU7UUFDcEIsSUFBSSxDQUFDbEIsUUFBUSxDQUFDYyxlQUFlLENBQUNJLFFBQVFDLENBQUFBO1lBQ2xDLElBQUksSUFBSSxDQUFDYixrQkFBa0IsSUFBSSxJQUFJLENBQUNFLGlCQUFpQixFQUFFO2dCQUNuRCxJQUFJLENBQUNDLGFBQWEsR0FBR1U7WUFDekIsT0FDSztnQkFDRCxJQUFJLENBQUNkLFlBQVksQ0FBQ1MsZUFBZSxDQUFDSztZQUN0QztRQUNKO0lBQ0o7QUFDSjtBQUNBdkIsZ0NBQWdDLEdBQUdFLDBCQUNuQywwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1pbnRlcmZhY2UuanM/OGIzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnRlcmNlcHRpbmdMaXN0ZW5lckltcGwgPSB2b2lkIDA7XG5leHBvcnRzLmlzSW50ZXJjZXB0aW5nTGlzdGVuZXIgPSBpc0ludGVyY2VwdGluZ0xpc3RlbmVyO1xuZnVuY3Rpb24gaXNJbnRlcmNlcHRpbmdMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHJldHVybiAobGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBsaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YS5sZW5ndGggPT09IDEpO1xufVxuY2xhc3MgSW50ZXJjZXB0aW5nTGlzdGVuZXJJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihsaXN0ZW5lciwgbmV4dExpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIgPSBuZXh0TGlzdGVuZXI7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzUGVuZGluZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlbmRpbmdTdGF0dXMgPSBudWxsO1xuICAgIH1cbiAgICBwcm9jZXNzUGVuZGluZ01lc3NhZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1BlbmRpbmdNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKHRoaXMucGVuZGluZ01lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmhhc1BlbmRpbmdNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc1BlbmRpbmdTdGF0dXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdTdGF0dXMpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cyh0aGlzLnBlbmRpbmdTdGF0dXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSwgbWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nU3RhdHVzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAvKiBJZiB0aGlzIGxpc3RlbmVyIHByb2Nlc3NlcyBtZXNzYWdlcyBhc3luY2hyb25vdXNseSwgdGhlIGxhc3QgbWVzc2FnZSBtYXlcbiAgICAgICAgICogYmUgcmVvcmRlcmVkIHdpdGggcmVzcGVjdCB0byB0aGUgc3RhdHVzICovXG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSB0cnVlO1xuICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSwgbXNnID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBtc2c7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNQZW5kaW5nTWVzc2FnZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ1N0YXR1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cyhzdGF0dXMsIHByb2Nlc3NlZFN0YXR1cyA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgfHwgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1N0YXR1cyA9IHByb2Nlc3NlZFN0YXR1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cyhwcm9jZXNzZWRTdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkludGVyY2VwdGluZ0xpc3RlbmVySW1wbCA9IEludGVyY2VwdGluZ0xpc3RlbmVySW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGwtaW50ZXJmYWNlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkludGVyY2VwdGluZ0xpc3RlbmVySW1wbCIsImlzSW50ZXJjZXB0aW5nTGlzdGVuZXIiLCJsaXN0ZW5lciIsIm9uUmVjZWl2ZU1ldGFkYXRhIiwidW5kZWZpbmVkIiwibGVuZ3RoIiwiY29uc3RydWN0b3IiLCJuZXh0TGlzdGVuZXIiLCJwcm9jZXNzaW5nTWV0YWRhdGEiLCJoYXNQZW5kaW5nTWVzc2FnZSIsInByb2Nlc3NpbmdNZXNzYWdlIiwicGVuZGluZ1N0YXR1cyIsInByb2Nlc3NQZW5kaW5nTWVzc2FnZSIsIm9uUmVjZWl2ZU1lc3NhZ2UiLCJwZW5kaW5nTWVzc2FnZSIsInByb2Nlc3NQZW5kaW5nU3RhdHVzIiwib25SZWNlaXZlU3RhdHVzIiwibWV0YWRhdGEiLCJtZXNzYWdlIiwibXNnIiwic3RhdHVzIiwicHJvY2Vzc2VkU3RhdHVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/call-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/call-number.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-number.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getNextCallNumber = getNextCallNumber;\nlet nextCallNumber = 0;\nfunction getNextCallNumber() {\n    return nextCallNumber++;\n} //# sourceMappingURL=call-number.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1udW1iZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHlCQUF5QixHQUFHRTtBQUM1QixJQUFJQyxpQkFBaUI7QUFDckIsU0FBU0Q7SUFDTCxPQUFPQztBQUNYLEVBQ0EsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnljLWhvdXNpbmctYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NhbGwtbnVtYmVyLmpzP2QzZDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0TmV4dENhbGxOdW1iZXIgPSBnZXROZXh0Q2FsbE51bWJlcjtcbmxldCBuZXh0Q2FsbE51bWJlciA9IDA7XG5mdW5jdGlvbiBnZXROZXh0Q2FsbE51bWJlcigpIHtcbiAgICByZXR1cm4gbmV4dENhbGxOdW1iZXIrKztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGwtbnVtYmVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldE5leHRDYWxsTnVtYmVyIiwibmV4dENhbGxOdW1iZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/call-number.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/call.js":
/*!******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ClientDuplexStreamImpl = exports.ClientWritableStreamImpl = exports.ClientReadableStreamImpl = exports.ClientUnaryCallImpl = void 0;\nexports.callErrorFromStatus = callErrorFromStatus;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\n/**\n * Construct a ServiceError from a StatusObject. This function exists primarily\n * as an attempt to make the error stack trace clearly communicate that the\n * error is not necessarily a problem in gRPC itself.\n * @param status\n */ function callErrorFromStatus(status, callerStack) {\n    const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;\n    const error = new Error(message);\n    const stack = `${error.stack}\\nfor call at\\n${callerStack}`;\n    return Object.assign(new Error(message), status, {\n        stack\n    });\n}\nclass ClientUnaryCallImpl extends events_1.EventEmitter {\n    constructor(){\n        super();\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled on client\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n}\nexports.ClientUnaryCallImpl = ClientUnaryCallImpl;\nclass ClientReadableStreamImpl extends stream_1.Readable {\n    constructor(deserialize){\n        super({\n            objectMode: true\n        });\n        this.deserialize = deserialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled on client\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    _read(_size) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n}\nexports.ClientReadableStreamImpl = ClientReadableStreamImpl;\nclass ClientWritableStreamImpl extends stream_1.Writable {\n    constructor(serialize){\n        super({\n            objectMode: true\n        });\n        this.serialize = serialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled on client\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    _write(chunk, encoding, cb) {\n        var _a;\n        const context = {\n            callback: cb\n        };\n        const flags = Number(encoding);\n        if (!Number.isNaN(flags)) {\n            context.flags = flags;\n        }\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n    _final(cb) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n        cb();\n    }\n}\nexports.ClientWritableStreamImpl = ClientWritableStreamImpl;\nclass ClientDuplexStreamImpl extends stream_1.Duplex {\n    constructor(serialize, deserialize){\n        super({\n            objectMode: true\n        });\n        this.serialize = serialize;\n        this.deserialize = deserialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled on client\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    _read(_size) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n    _write(chunk, encoding, cb) {\n        var _a;\n        const context = {\n            callback: cb\n        };\n        const flags = Number(encoding);\n        if (!Number.isNaN(flags)) {\n            context.flags = flags;\n        }\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n    _final(cb) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n        cb();\n    }\n}\nexports.ClientDuplexStreamImpl = ClientDuplexStreamImpl; //# sourceMappingURL=call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsOEJBQThCLEdBQUdBLGdDQUFnQyxHQUFHQSxnQ0FBZ0MsR0FBR0EsMkJBQTJCLEdBQUcsS0FBSztBQUMxSUEsMkJBQTJCLEdBQUdNO0FBQzlCLE1BQU1DLFdBQVdDLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDLE1BQU1DLFdBQVdELG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDLE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDOzs7OztDQUtDLEdBQ0QsU0FBU0Ysb0JBQW9CSyxNQUFNLEVBQUVDLFdBQVc7SUFDNUMsTUFBTUMsVUFBVSxDQUFDLEVBQUVGLE9BQU9HLElBQUksQ0FBQyxDQUFDLEVBQUVKLFlBQVlLLE1BQU0sQ0FBQ0osT0FBT0csSUFBSSxDQUFDLENBQUMsRUFBRSxFQUFFSCxPQUFPSyxPQUFPLENBQUMsQ0FBQztJQUN0RixNQUFNQyxRQUFRLElBQUlDLE1BQU1MO0lBQ3hCLE1BQU1NLFFBQVEsQ0FBQyxFQUFFRixNQUFNRSxLQUFLLENBQUMsZUFBZSxFQUFFUCxZQUFZLENBQUM7SUFDM0QsT0FBT2QsT0FBT3NCLE1BQU0sQ0FBQyxJQUFJRixNQUFNTCxVQUFVRixRQUFRO1FBQUVRO0lBQU07QUFDN0Q7QUFDQSxNQUFNZCw0QkFBNEJFLFNBQVNjLFlBQVk7SUFDbkRDLGFBQWM7UUFDVixLQUFLO0lBQ1Q7SUFDQUMsU0FBUztRQUNMLElBQUlDO1FBQ0hBLENBQUFBLEtBQUssSUFBSSxDQUFDQyxJQUFJLE1BQU0sUUFBUUQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHRSxnQkFBZ0IsQ0FBQ2hCLFlBQVlLLE1BQU0sQ0FBQ1ksU0FBUyxFQUFFO0lBQzVHO0lBQ0FDLFVBQVU7UUFD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LWhvdXNpbmctYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NhbGwuanM/ZmUzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DbGllbnREdXBsZXhTdHJlYW1JbXBsID0gZXhwb3J0cy5DbGllbnRXcml0YWJsZVN0cmVhbUltcGwgPSBleHBvcnRzLkNsaWVudFJlYWRhYmxlU3RyZWFtSW1wbCA9IGV4cG9ydHMuQ2xpZW50VW5hcnlDYWxsSW1wbCA9IHZvaWQgMDtcbmV4cG9ydHMuY2FsbEVycm9yRnJvbVN0YXR1cyA9IGNhbGxFcnJvckZyb21TdGF0dXM7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbi8qKlxuICogQ29uc3RydWN0IGEgU2VydmljZUVycm9yIGZyb20gYSBTdGF0dXNPYmplY3QuIFRoaXMgZnVuY3Rpb24gZXhpc3RzIHByaW1hcmlseVxuICogYXMgYW4gYXR0ZW1wdCB0byBtYWtlIHRoZSBlcnJvciBzdGFjayB0cmFjZSBjbGVhcmx5IGNvbW11bmljYXRlIHRoYXQgdGhlXG4gKiBlcnJvciBpcyBub3QgbmVjZXNzYXJpbHkgYSBwcm9ibGVtIGluIGdSUEMgaXRzZWxmLlxuICogQHBhcmFtIHN0YXR1c1xuICovXG5mdW5jdGlvbiBjYWxsRXJyb3JGcm9tU3RhdHVzKHN0YXR1cywgY2FsbGVyU3RhY2spIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYCR7c3RhdHVzLmNvZGV9ICR7Y29uc3RhbnRzXzEuU3RhdHVzW3N0YXR1cy5jb2RlXX06ICR7c3RhdHVzLmRldGFpbHN9YDtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBjb25zdCBzdGFjayA9IGAke2Vycm9yLnN0YWNrfVxcbmZvciBjYWxsIGF0XFxuJHtjYWxsZXJTdGFja31gO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihtZXNzYWdlKSwgc3RhdHVzLCB7IHN0YWNrIH0pO1xufVxuY2xhc3MgQ2xpZW50VW5hcnlDYWxsSW1wbCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdDYW5jZWxsZWQgb24gY2xpZW50Jyk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICd1bmtub3duJztcbiAgICB9XG59XG5leHBvcnRzLkNsaWVudFVuYXJ5Q2FsbEltcGwgPSBDbGllbnRVbmFyeUNhbGxJbXBsO1xuY2xhc3MgQ2xpZW50UmVhZGFibGVTdHJlYW1JbXBsIGV4dGVuZHMgc3RyZWFtXzEuUmVhZGFibGUge1xuICAgIGNvbnN0cnVjdG9yKGRlc2VyaWFsaXplKSB7XG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELCAnQ2FuY2VsbGVkIG9uIGNsaWVudCcpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UGVlcigpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAndW5rbm93bic7XG4gICAgfVxuICAgIF9yZWFkKF9zaXplKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnRSZWFkKCk7XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnRSZWFkYWJsZVN0cmVhbUltcGwgPSBDbGllbnRSZWFkYWJsZVN0cmVhbUltcGw7XG5jbGFzcyBDbGllbnRXcml0YWJsZVN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5Xcml0YWJsZSB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWFsaXplKSB7XG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdDYW5jZWxsZWQgb24gY2xpZW50Jyk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICd1bmtub3duJztcbiAgICB9XG4gICAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmbGFncyA9IE51bWJlcihlbmNvZGluZyk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGZsYWdzKSkge1xuICAgICAgICAgICAgY29udGV4dC5mbGFncyA9IGZsYWdzO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgY2h1bmspO1xuICAgIH1cbiAgICBfZmluYWwoY2IpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYWxmQ2xvc2UoKTtcbiAgICAgICAgY2IoKTtcbiAgICB9XG59XG5leHBvcnRzLkNsaWVudFdyaXRhYmxlU3RyZWFtSW1wbCA9IENsaWVudFdyaXRhYmxlU3RyZWFtSW1wbDtcbmNsYXNzIENsaWVudER1cGxleFN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5EdXBsZXgge1xuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUpIHtcbiAgICAgICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELCAnQ2FuY2VsbGVkIG9uIGNsaWVudCcpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UGVlcigpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAndW5rbm93bic7XG4gICAgfVxuICAgIF9yZWFkKF9zaXplKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnRSZWFkKCk7XG4gICAgfVxuICAgIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBOdW1iZXIoZW5jb2RpbmcpO1xuICAgICAgICBpZiAoIU51bWJlci5pc05hTihmbGFncykpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIGNodW5rKTtcbiAgICB9XG4gICAgX2ZpbmFsKGNiKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFsZkNsb3NlKCk7XG4gICAgICAgIGNiKCk7XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnREdXBsZXhTdHJlYW1JbXBsID0gQ2xpZW50RHVwbGV4U3RyZWFtSW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2xpZW50RHVwbGV4U3RyZWFtSW1wbCIsIkNsaWVudFdyaXRhYmxlU3RyZWFtSW1wbCIsIkNsaWVudFJlYWRhYmxlU3RyZWFtSW1wbCIsIkNsaWVudFVuYXJ5Q2FsbEltcGwiLCJjYWxsRXJyb3JGcm9tU3RhdHVzIiwiZXZlbnRzXzEiLCJyZXF1aXJlIiwic3RyZWFtXzEiLCJjb25zdGFudHNfMSIsInN0YXR1cyIsImNhbGxlclN0YWNrIiwibWVzc2FnZSIsImNvZGUiLCJTdGF0dXMiLCJkZXRhaWxzIiwiZXJyb3IiLCJFcnJvciIsInN0YWNrIiwiYXNzaWduIiwiRXZlbnRFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJjYW5jZWwiLCJfYSIsImNhbGwiLCJjYW5jZWxXaXRoU3RhdHVzIiwiQ0FOQ0VMTEVEIiwiZ2V0UGVlciIsIl9iIiwiUmVhZGFibGUiLCJkZXNlcmlhbGl6ZSIsIm9iamVjdE1vZGUiLCJfcmVhZCIsIl9zaXplIiwic3RhcnRSZWFkIiwiV3JpdGFibGUiLCJzZXJpYWxpemUiLCJfd3JpdGUiLCJjaHVuayIsImVuY29kaW5nIiwiY2IiLCJjb250ZXh0IiwiY2FsbGJhY2siLCJmbGFncyIsIk51bWJlciIsImlzTmFOIiwic2VuZE1lc3NhZ2VXaXRoQ29udGV4dCIsIl9maW5hbCIsImhhbGZDbG9zZSIsIkR1cGxleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/certificate-provider.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/certificate-provider.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2024 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FileWatcherCertificateProvider = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst TRACER_NAME = \"certificate_provider\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst readFilePromise = (0, util_1.promisify)(fs.readFile);\nclass FileWatcherCertificateProvider {\n    constructor(config){\n        this.config = config;\n        this.refreshTimer = null;\n        this.fileResultPromise = null;\n        this.latestCaUpdate = undefined;\n        this.caListeners = new Set();\n        this.latestIdentityUpdate = undefined;\n        this.identityListeners = new Set();\n        this.lastUpdateTime = null;\n        if (config.certificateFile === undefined !== (config.privateKeyFile === undefined)) {\n            throw new Error(\"certificateFile and privateKeyFile must be set or unset together\");\n        }\n        if (config.certificateFile === undefined && config.caCertificateFile === undefined) {\n            throw new Error(\"At least one of certificateFile and caCertificateFile must be set\");\n        }\n        trace(\"File watcher constructed with config \" + JSON.stringify(config));\n    }\n    updateCertificates() {\n        if (this.fileResultPromise) {\n            return;\n        }\n        this.fileResultPromise = Promise.allSettled([\n            this.config.certificateFile ? readFilePromise(this.config.certificateFile) : Promise.reject(),\n            this.config.privateKeyFile ? readFilePromise(this.config.privateKeyFile) : Promise.reject(),\n            this.config.caCertificateFile ? readFilePromise(this.config.caCertificateFile) : Promise.reject()\n        ]);\n        this.fileResultPromise.then(([certificateResult, privateKeyResult, caCertificateResult])=>{\n            if (!this.refreshTimer) {\n                return;\n            }\n            trace(\"File watcher read certificates certificate \" + certificateResult.status + \", privateKey \" + privateKeyResult.status + \", CA certificate \" + caCertificateResult.status);\n            this.lastUpdateTime = new Date();\n            this.fileResultPromise = null;\n            if (certificateResult.status === \"fulfilled\" && privateKeyResult.status === \"fulfilled\") {\n                this.latestIdentityUpdate = {\n                    certificate: certificateResult.value,\n                    privateKey: privateKeyResult.value\n                };\n            } else {\n                this.latestIdentityUpdate = null;\n            }\n            if (caCertificateResult.status === \"fulfilled\") {\n                this.latestCaUpdate = {\n                    caCertificate: caCertificateResult.value\n                };\n            } else {\n                this.latestCaUpdate = null;\n            }\n            for (const listener of this.identityListeners){\n                listener(this.latestIdentityUpdate);\n            }\n            for (const listener of this.caListeners){\n                listener(this.latestCaUpdate);\n            }\n        });\n        trace(\"File watcher initiated certificate update\");\n    }\n    maybeStartWatchingFiles() {\n        if (!this.refreshTimer) {\n            /* Perform the first read immediately, but only if there was not already\n             * a recent read, to avoid reading from the filesystem significantly more\n             * frequently than configured if the provider quickly switches between\n             * used and unused. */ const timeSinceLastUpdate = this.lastUpdateTime ? new Date().getTime() - this.lastUpdateTime.getTime() : Infinity;\n            if (timeSinceLastUpdate > this.config.refreshIntervalMs) {\n                this.updateCertificates();\n            }\n            if (timeSinceLastUpdate > this.config.refreshIntervalMs * 2) {\n                // Clear out old updates if they are definitely stale\n                this.latestCaUpdate = undefined;\n                this.latestIdentityUpdate = undefined;\n            }\n            this.refreshTimer = setInterval(()=>this.updateCertificates(), this.config.refreshIntervalMs);\n            trace(\"File watcher started watching\");\n        }\n    }\n    maybeStopWatchingFiles() {\n        if (this.caListeners.size === 0 && this.identityListeners.size === 0) {\n            this.fileResultPromise = null;\n            if (this.refreshTimer) {\n                clearInterval(this.refreshTimer);\n                this.refreshTimer = null;\n            }\n        }\n    }\n    addCaCertificateListener(listener) {\n        this.caListeners.add(listener);\n        this.maybeStartWatchingFiles();\n        if (this.latestCaUpdate !== undefined) {\n            process.nextTick(listener, this.latestCaUpdate);\n        }\n    }\n    removeCaCertificateListener(listener) {\n        this.caListeners.delete(listener);\n        this.maybeStopWatchingFiles();\n    }\n    addIdentityCertificateListener(listener) {\n        this.identityListeners.add(listener);\n        this.maybeStartWatchingFiles();\n        if (this.latestIdentityUpdate !== undefined) {\n            process.nextTick(listener, this.latestIdentityUpdate);\n        }\n    }\n    removeIdentityCertificateListener(listener) {\n        this.identityListeners.delete(listener);\n        this.maybeStopWatchingFiles();\n    }\n}\nexports.FileWatcherCertificateProvider = FileWatcherCertificateProvider; //# sourceMappingURL=certificate-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2VydGlmaWNhdGUtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHNDQUFzQyxHQUFHLEtBQUs7QUFDOUMsTUFBTUcsS0FBS0MsbUJBQU9BLENBQUMsY0FBSTtBQUN2QixNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRyxTQUFTSCxtQkFBT0EsQ0FBQyxrQkFBTTtBQUM3QixNQUFNSSxjQUFjO0FBQ3BCLFNBQVNDLE1BQU1DLElBQUk7SUFDZkwsUUFBUUksS0FBSyxDQUFDSCxZQUFZSyxZQUFZLENBQUNDLEtBQUssRUFBRUosYUFBYUU7QUFDL0Q7QUFDQSxNQUFNRyxrQkFBa0IsQ0FBQyxHQUFHTixPQUFPTyxTQUFTLEVBQUVYLEdBQUdZLFFBQVE7QUFDekQsTUFBTWI7SUFDRmMsWUFBWUMsTUFBTSxDQUFFO1FBQ2hCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDQyxjQUFjLEdBQUdDO1FBQ3RCLElBQUksQ0FBQ0MsV0FBVyxHQUFHLElBQUlDO1FBQ3ZCLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUdIO1FBQzVCLElBQUksQ0FBQ0ksaUJBQWlCLEdBQUcsSUFBSUY7UUFDN0IsSUFBSSxDQUFDRyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxPQUFRQyxlQUFlLEtBQUtOLGNBQWdCSixDQUFBQSxPQUFPVyxjQUFjLEtBQUtQLFNBQVEsR0FBSTtZQUNsRixNQUFNLElBQUlRLE1BQU07UUFDcEI7UUFDQSxJQUFJWixPQUFPVSxlQUFlLEtBQUtOLGFBQWFKLE9B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X21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2VydGlmaWNhdGUtcHJvdmlkZXIuanM/ZDRlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyNCBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GaWxlV2F0Y2hlckNlcnRpZmljYXRlUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ2NlcnRpZmljYXRlX3Byb3ZpZGVyJztcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xufVxuY29uc3QgcmVhZEZpbGVQcm9taXNlID0gKDAsIHV0aWxfMS5wcm9taXNpZnkpKGZzLnJlYWRGaWxlKTtcbmNsYXNzIEZpbGVXYXRjaGVyQ2VydGlmaWNhdGVQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLnJlZnJlc2hUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsZVJlc3VsdFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdENhVXBkYXRlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNhTGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmxhdGVzdElkZW50aXR5VXBkYXRlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmlkZW50aXR5TGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmxhc3RVcGRhdGVUaW1lID0gbnVsbDtcbiAgICAgICAgaWYgKChjb25maWcuY2VydGlmaWNhdGVGaWxlID09PSB1bmRlZmluZWQpICE9PSAoY29uZmlnLnByaXZhdGVLZXlGaWxlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NlcnRpZmljYXRlRmlsZSBhbmQgcHJpdmF0ZUtleUZpbGUgbXVzdCBiZSBzZXQgb3IgdW5zZXQgdG9nZXRoZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmNlcnRpZmljYXRlRmlsZSA9PT0gdW5kZWZpbmVkICYmIGNvbmZpZy5jYUNlcnRpZmljYXRlRmlsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0IGxlYXN0IG9uZSBvZiBjZXJ0aWZpY2F0ZUZpbGUgYW5kIGNhQ2VydGlmaWNhdGVGaWxlIG11c3QgYmUgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2UoJ0ZpbGUgd2F0Y2hlciBjb25zdHJ1Y3RlZCB3aXRoIGNvbmZpZyAnICsgSlNPTi5zdHJpbmdpZnkoY29uZmlnKSk7XG4gICAgfVxuICAgIHVwZGF0ZUNlcnRpZmljYXRlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsZVJlc3VsdFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbGVSZXN1bHRQcm9taXNlID0gUHJvbWlzZS5hbGxTZXR0bGVkKFtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmNlcnRpZmljYXRlRmlsZSA/IHJlYWRGaWxlUHJvbWlzZSh0aGlzLmNvbmZpZy5jZXJ0aWZpY2F0ZUZpbGUpIDogUHJvbWlzZS5yZWplY3QoKSxcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnByaXZhdGVLZXlGaWxlID8gcmVhZEZpbGVQcm9taXNlKHRoaXMuY29uZmlnLnByaXZhdGVLZXlGaWxlKSA6IFByb21pc2UucmVqZWN0KCksXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5jYUNlcnRpZmljYXRlRmlsZSA/IHJlYWRGaWxlUHJvbWlzZSh0aGlzLmNvbmZpZy5jYUNlcnRpZmljYXRlRmlsZSkgOiBQcm9taXNlLnJlamVjdCgpXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLmZpbGVSZXN1bHRQcm9taXNlLnRoZW4oKFtjZXJ0aWZpY2F0ZVJlc3VsdCwgcHJpdmF0ZUtleVJlc3VsdCwgY2FDZXJ0aWZpY2F0ZVJlc3VsdF0pID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWZyZXNoVGltZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZSgnRmlsZSB3YXRjaGVyIHJlYWQgY2VydGlmaWNhdGVzIGNlcnRpZmljYXRlICcgKyBjZXJ0aWZpY2F0ZVJlc3VsdC5zdGF0dXMgKyAnLCBwcml2YXRlS2V5ICcgKyBwcml2YXRlS2V5UmVzdWx0LnN0YXR1cyArICcsIENBIGNlcnRpZmljYXRlICcgKyBjYUNlcnRpZmljYXRlUmVzdWx0LnN0YXR1cyk7XG4gICAgICAgICAgICB0aGlzLmxhc3RVcGRhdGVUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuZmlsZVJlc3VsdFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGNlcnRpZmljYXRlUmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgJiYgcHJpdmF0ZUtleVJlc3VsdC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RJZGVudGl0eVVwZGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2VydGlmaWNhdGU6IGNlcnRpZmljYXRlUmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiBwcml2YXRlS2V5UmVzdWx0LnZhbHVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0SWRlbnRpdHlVcGRhdGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhQ2VydGlmaWNhdGVSZXN1bHQuc3RhdHVzID09PSAnZnVsZmlsbGVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q2FVcGRhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNhQ2VydGlmaWNhdGU6IGNhQ2VydGlmaWNhdGVSZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RDYVVwZGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuaWRlbnRpdHlMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcih0aGlzLmxhdGVzdElkZW50aXR5VXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5jYUxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyKHRoaXMubGF0ZXN0Q2FVcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdHJhY2UoJ0ZpbGUgd2F0Y2hlciBpbml0aWF0ZWQgY2VydGlmaWNhdGUgdXBkYXRlJyk7XG4gICAgfVxuICAgIG1heWJlU3RhcnRXYXRjaGluZ0ZpbGVzKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVmcmVzaFRpbWVyKSB7XG4gICAgICAgICAgICAvKiBQZXJmb3JtIHRoZSBmaXJzdCByZWFkIGltbWVkaWF0ZWx5LCBidXQgb25seSBpZiB0aGVyZSB3YXMgbm90IGFscmVhZHlcbiAgICAgICAgICAgICAqIGEgcmVjZW50IHJlYWQsIHRvIGF2b2lkIHJlYWRpbmcgZnJvbSB0aGUgZmlsZXN5c3RlbSBzaWduaWZpY2FudGx5IG1vcmVcbiAgICAgICAgICAgICAqIGZyZXF1ZW50bHkgdGhhbiBjb25maWd1cmVkIGlmIHRoZSBwcm92aWRlciBxdWlja2x5IHN3aXRjaGVzIGJldHdlZW5cbiAgICAgICAgICAgICAqIHVzZWQgYW5kIHVudXNlZC4gKi9cbiAgICAgICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RVcGRhdGUgPSB0aGlzLmxhc3RVcGRhdGVUaW1lID8gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHRoaXMubGFzdFVwZGF0ZVRpbWUuZ2V0VGltZSgpIDogSW5maW5pdHk7XG4gICAgICAgICAgICBpZiAodGltZVNpbmNlTGFzdFVwZGF0ZSA+IHRoaXMuY29uZmlnLnJlZnJlc2hJbnRlcnZhbE1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDZXJ0aWZpY2F0ZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lU2luY2VMYXN0VXBkYXRlID4gdGhpcy5jb25maWcucmVmcmVzaEludGVydmFsTXMgKiAyKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgb3V0IG9sZCB1cGRhdGVzIGlmIHRoZXkgYXJlIGRlZmluaXRlbHkgc3RhbGVcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdENhVXBkYXRlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0SWRlbnRpdHlVcGRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hUaW1lciA9IHNldEludGVydmFsKCgpID0+IHRoaXMudXBkYXRlQ2VydGlmaWNhdGVzKCksIHRoaXMuY29uZmlnLnJlZnJlc2hJbnRlcnZhbE1zKTtcbiAgICAgICAgICAgIHRyYWNlKCdGaWxlIHdhdGNoZXIgc3RhcnRlZCB3YXRjaGluZycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1heWJlU3RvcFdhdGNoaW5nRmlsZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhTGlzdGVuZXJzLnNpemUgPT09IDAgJiYgdGhpcy5pZGVudGl0eUxpc3RlbmVycy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZpbGVSZXN1bHRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZnJlc2hUaW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5yZWZyZXNoVGltZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaFRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRDYUNlcnRpZmljYXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5jYUxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgICAgICB0aGlzLm1heWJlU3RhcnRXYXRjaGluZ0ZpbGVzKCk7XG4gICAgICAgIGlmICh0aGlzLmxhdGVzdENhVXBkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2sobGlzdGVuZXIsIHRoaXMubGF0ZXN0Q2FVcGRhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUNhQ2VydGlmaWNhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmNhTGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICAgIHRoaXMubWF5YmVTdG9wV2F0Y2hpbmdGaWxlcygpO1xuICAgIH1cbiAgICBhZGRJZGVudGl0eUNlcnRpZmljYXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5pZGVudGl0eUxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgICAgICB0aGlzLm1heWJlU3RhcnRXYXRjaGluZ0ZpbGVzKCk7XG4gICAgICAgIGlmICh0aGlzLmxhdGVzdElkZW50aXR5VXBkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2sobGlzdGVuZXIsIHRoaXMubGF0ZXN0SWRlbnRpdHlVcGRhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUlkZW50aXR5Q2VydGlmaWNhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmlkZW50aXR5TGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICAgIHRoaXMubWF5YmVTdG9wV2F0Y2hpbmdGaWxlcygpO1xuICAgIH1cbn1cbmV4cG9ydHMuRmlsZVdhdGNoZXJDZXJ0aWZpY2F0ZVByb3ZpZGVyID0gRmlsZVdhdGNoZXJDZXJ0aWZpY2F0ZVByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2VydGlmaWNhdGUtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRmlsZVdhdGNoZXJDZXJ0aWZpY2F0ZVByb3ZpZGVyIiwiZnMiLCJyZXF1aXJlIiwibG9nZ2luZyIsImNvbnN0YW50c18xIiwidXRpbF8xIiwiVFJBQ0VSX05BTUUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsInJlYWRGaWxlUHJvbWlzZSIsInByb21pc2lmeSIsInJlYWRGaWxlIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJyZWZyZXNoVGltZXIiLCJmaWxlUmVzdWx0UHJvbWlzZSIsImxhdGVzdENhVXBkYXRlIiwidW5kZWZpbmVkIiwiY2FMaXN0ZW5lcnMiLCJTZXQiLCJsYXRlc3RJZGVudGl0eVVwZGF0ZSIsImlkZW50aXR5TGlzdGVuZXJzIiwibGFzdFVwZGF0ZVRpbWUiLCJjZXJ0aWZpY2F0ZUZpbGUiLCJwcml2YXRlS2V5RmlsZSIsIkVycm9yIiwiY2FDZXJ0aWZpY2F0ZUZpbGUiLCJKU09OIiwic3RyaW5naWZ5IiwidXBkYXRlQ2VydGlmaWNhdGVzIiwiUHJvbWlzZSIsImFsbFNldHRsZWQiLCJyZWplY3QiLCJ0aGVuIiwiY2VydGlmaWNhdGVSZXN1bHQiLCJwcml2YXRlS2V5UmVzdWx0IiwiY2FDZXJ0aWZpY2F0ZVJlc3VsdCIsInN0YXR1cyIsIkRhdGUiLCJjZXJ0aWZpY2F0ZSIsInByaXZhdGVLZXkiLCJjYUNlcnRpZmljYXRlIiwibGlzdGVuZXIiLCJtYXliZVN0YXJ0V2F0Y2hpbmdGaWxlcyIsInRpbWVTaW5jZUxhc3RVcGRhdGUiLCJnZXRUaW1lIiwiSW5maW5pdHkiLCJyZWZyZXNoSW50ZXJ2YWxNcyIsInNldEludGVydmFsIiwibWF5YmVTdG9wV2F0Y2hpbmdGaWxlcyIsInNpemUiLCJjbGVhckludGVydmFsIiwiYWRkQ2FDZXJ0aWZpY2F0ZUxpc3RlbmVyIiwiYWRkIiwicHJvY2VzcyIsIm5leHRUaWNrIiwicmVtb3ZlQ2FDZXJ0aWZpY2F0ZUxpc3RlbmVyIiwiZGVsZXRlIiwiYWRkSWRlbnRpdHlDZXJ0aWZpY2F0ZUxpc3RlbmVyIiwicmVtb3ZlSWRlbnRpdHlDZXJ0aWZpY2F0ZUxpc3RlbmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/certificate-provider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-credentials.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ChannelCredentials = void 0;\nexports.createCertificateProviderChannelCredentials = createCertificateProviderChannelCredentials;\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction verifyIsBufferOrNull(obj, friendlyName) {\n    if (obj && !(obj instanceof Buffer)) {\n        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\n    }\n}\n/**\n * A class that contains credentials for communicating over a channel, as well\n * as a set of per-call credentials, which are applied to every method call made\n * over a channel initialized with an instance of this class.\n */ class ChannelCredentials {\n    /**\n     * Returns a copy of this object with the included set of per-call credentials\n     * expanded to include callCredentials.\n     * @param callCredentials A CallCredentials object to associate with this\n     * instance.\n     */ compose(callCredentials) {\n        return new ComposedChannelCredentialsImpl(this, callCredentials);\n    }\n    /**\n     * Return a new ChannelCredentials instance with a given set of credentials.\n     * The resulting instance can be used to construct a Channel that communicates\n     * over TLS.\n     * @param rootCerts The root certificate data.\n     * @param privateKey The client certificate private key, if available.\n     * @param certChain The client certificate key chain, if available.\n     * @param verifyOptions Additional options to modify certificate verification\n     */ static createSsl(rootCerts, privateKey, certChain, verifyOptions) {\n        var _a;\n        verifyIsBufferOrNull(rootCerts, \"Root certificate\");\n        verifyIsBufferOrNull(privateKey, \"Private key\");\n        verifyIsBufferOrNull(certChain, \"Certificate chain\");\n        if (privateKey && !certChain) {\n            throw new Error(\"Private key must be given with accompanying certificate chain\");\n        }\n        if (!privateKey && certChain) {\n            throw new Error(\"Certificate chain must be given with accompanying private key\");\n        }\n        const secureContext = (0, tls_1.createSecureContext)({\n            ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== void 0 ? _a : undefined,\n            key: privateKey !== null && privateKey !== void 0 ? privateKey : undefined,\n            cert: certChain !== null && certChain !== void 0 ? certChain : undefined,\n            ciphers: tls_helpers_1.CIPHER_SUITES\n        });\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n    }\n    /**\n     * Return a new ChannelCredentials instance with credentials created using\n     * the provided secureContext. The resulting instances can be used to\n     * construct a Channel that communicates over TLS. gRPC will not override\n     * anything in the provided secureContext, so the environment variables\n     * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will\n     * not be applied.\n     * @param secureContext The return value of tls.createSecureContext()\n     * @param verifyOptions Additional options to modify certificate verification\n     */ static createFromSecureContext(secureContext, verifyOptions) {\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n    }\n    /**\n     * Return a new ChannelCredentials instance with no credentials.\n     */ static createInsecure() {\n        return new InsecureChannelCredentialsImpl();\n    }\n}\nexports.ChannelCredentials = ChannelCredentials;\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\n    constructor(){\n        super();\n    }\n    compose(callCredentials) {\n        throw new Error(\"Cannot compose insecure credentials\");\n    }\n    _isSecure() {\n        return false;\n    }\n    _equals(other) {\n        return other instanceof InsecureChannelCredentialsImpl;\n    }\n    _createSecureConnector(channelTarget, options, callCredentials) {\n        return {\n            connect (socket) {\n                return Promise.resolve({\n                    socket,\n                    secure: false\n                });\n            },\n            waitForReady: ()=>{\n                return Promise.resolve();\n            },\n            getCallCredentials: ()=>{\n                return callCredentials !== null && callCredentials !== void 0 ? callCredentials : call_credentials_1.CallCredentials.createEmpty();\n            },\n            destroy () {}\n        };\n    }\n}\nfunction getConnectionOptions(secureContext, verifyOptions, channelTarget, options) {\n    var _a, _b, _c, _d;\n    const connectionOptions = {\n        secureContext: secureContext\n    };\n    if (verifyOptions.checkServerIdentity) {\n        connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;\n    }\n    if (verifyOptions.rejectUnauthorized !== undefined) {\n        connectionOptions.rejectUnauthorized = verifyOptions.rejectUnauthorized;\n    }\n    connectionOptions.ALPNProtocols = [\n        \"h2\"\n    ];\n    if (options[\"grpc.ssl_target_name_override\"]) {\n        const sslTargetNameOverride = options[\"grpc.ssl_target_name_override\"];\n        const originalCheckServerIdentity = (_a = connectionOptions.checkServerIdentity) !== null && _a !== void 0 ? _a : tls_1.checkServerIdentity;\n        connectionOptions.checkServerIdentity = (host, cert)=>{\n            return originalCheckServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n    } else {\n        if (\"grpc.http_connect_target\" in options) {\n            /* This is more or less how servername will be set in createSession\n             * if a connection is successfully established through the proxy.\n             * If the proxy is not used, these connectionOptions are discarded\n             * anyway */ const targetPath = (0, resolver_1.getDefaultAuthority)((_b = (0, uri_parser_1.parseUri)(options[\"grpc.http_connect_target\"])) !== null && _b !== void 0 ? _b : {\n                path: \"localhost\"\n            });\n            const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\n            connectionOptions.servername = (_c = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _c !== void 0 ? _c : targetPath;\n        }\n    }\n    if (options[\"grpc-node.tls_enable_trace\"]) {\n        connectionOptions.enableTrace = true;\n    }\n    let realTarget = channelTarget;\n    if (\"grpc.http_connect_target\" in options) {\n        const parsedTarget = (0, uri_parser_1.parseUri)(options[\"grpc.http_connect_target\"]);\n        if (parsedTarget) {\n            realTarget = parsedTarget;\n        }\n    }\n    const targetPath = (0, resolver_1.getDefaultAuthority)(realTarget);\n    const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\n    const remoteHost = (_d = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _d !== void 0 ? _d : targetPath;\n    connectionOptions.host = remoteHost;\n    connectionOptions.servername = remoteHost;\n    return connectionOptions;\n}\nclass SecureConnectorImpl {\n    constructor(connectionOptions, callCredentials){\n        this.connectionOptions = connectionOptions;\n        this.callCredentials = callCredentials;\n    }\n    connect(socket) {\n        const tlsConnectOptions = Object.assign({\n            socket: socket\n        }, this.connectionOptions);\n        return new Promise((resolve, reject)=>{\n            const tlsSocket = (0, tls_1.connect)(tlsConnectOptions, ()=>{\n                if (!tlsSocket.authorized) {\n                    reject(tlsSocket.authorizationError);\n                    return;\n                }\n                resolve({\n                    socket: tlsSocket,\n                    secure: true\n                });\n            });\n            tlsSocket.on(\"error\", (error)=>{\n                reject(error);\n            });\n        });\n    }\n    waitForReady() {\n        return Promise.resolve();\n    }\n    getCallCredentials() {\n        return this.callCredentials;\n    }\n    destroy() {}\n}\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\n    constructor(secureContext, verifyOptions){\n        super();\n        this.secureContext = secureContext;\n        this.verifyOptions = verifyOptions;\n    }\n    _isSecure() {\n        return true;\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof SecureChannelCredentialsImpl) {\n            return this.secureContext === other.secureContext && this.verifyOptions.checkServerIdentity === other.verifyOptions.checkServerIdentity;\n        } else {\n            return false;\n        }\n    }\n    _createSecureConnector(channelTarget, options, callCredentials) {\n        const connectionOptions = getConnectionOptions(this.secureContext, this.verifyOptions, channelTarget, options);\n        return new SecureConnectorImpl(connectionOptions, callCredentials !== null && callCredentials !== void 0 ? callCredentials : call_credentials_1.CallCredentials.createEmpty());\n    }\n}\nclass CertificateProviderChannelCredentialsImpl extends ChannelCredentials {\n    constructor(caCertificateProvider, identityCertificateProvider, verifyOptions){\n        super();\n        this.caCertificateProvider = caCertificateProvider;\n        this.identityCertificateProvider = identityCertificateProvider;\n        this.verifyOptions = verifyOptions;\n        this.refcount = 0;\n        /**\n         * `undefined` means that the certificates have not yet been loaded. `null`\n         * means that an attempt to load them has completed, and has failed.\n         */ this.latestCaUpdate = undefined;\n        /**\n         * `undefined` means that the certificates have not yet been loaded. `null`\n         * means that an attempt to load them has completed, and has failed.\n         */ this.latestIdentityUpdate = undefined;\n        this.caCertificateUpdateListener = this.handleCaCertificateUpdate.bind(this);\n        this.identityCertificateUpdateListener = this.handleIdentityCertitificateUpdate.bind(this);\n        this.secureContextWatchers = [];\n    }\n    _isSecure() {\n        return true;\n    }\n    _equals(other) {\n        var _a, _b;\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof CertificateProviderChannelCredentialsImpl) {\n            return this.caCertificateProvider === other.caCertificateProvider && this.identityCertificateProvider === other.identityCertificateProvider && ((_a = this.verifyOptions) === null || _a === void 0 ? void 0 : _a.checkServerIdentity) === ((_b = other.verifyOptions) === null || _b === void 0 ? void 0 : _b.checkServerIdentity);\n        } else {\n            return false;\n        }\n    }\n    ref() {\n        var _a;\n        if (this.refcount === 0) {\n            this.caCertificateProvider.addCaCertificateListener(this.caCertificateUpdateListener);\n            (_a = this.identityCertificateProvider) === null || _a === void 0 ? void 0 : _a.addIdentityCertificateListener(this.identityCertificateUpdateListener);\n        }\n        this.refcount += 1;\n    }\n    unref() {\n        var _a;\n        this.refcount -= 1;\n        if (this.refcount === 0) {\n            this.caCertificateProvider.removeCaCertificateListener(this.caCertificateUpdateListener);\n            (_a = this.identityCertificateProvider) === null || _a === void 0 ? void 0 : _a.removeIdentityCertificateListener(this.identityCertificateUpdateListener);\n        }\n    }\n    _createSecureConnector(channelTarget, options, callCredentials) {\n        this.ref();\n        return new CertificateProviderChannelCredentialsImpl.SecureConnectorImpl(this, channelTarget, options, callCredentials !== null && callCredentials !== void 0 ? callCredentials : call_credentials_1.CallCredentials.createEmpty());\n    }\n    maybeUpdateWatchers() {\n        if (this.hasReceivedUpdates()) {\n            for (const watcher of this.secureContextWatchers){\n                watcher(this.getLatestSecureContext());\n            }\n            this.secureContextWatchers = [];\n        }\n    }\n    handleCaCertificateUpdate(update) {\n        this.latestCaUpdate = update;\n        this.maybeUpdateWatchers();\n    }\n    handleIdentityCertitificateUpdate(update) {\n        this.latestIdentityUpdate = update;\n        this.maybeUpdateWatchers();\n    }\n    hasReceivedUpdates() {\n        if (this.latestCaUpdate === undefined) {\n            return false;\n        }\n        if (this.identityCertificateProvider && this.latestIdentityUpdate === undefined) {\n            return false;\n        }\n        return true;\n    }\n    getSecureContext() {\n        if (this.hasReceivedUpdates()) {\n            return Promise.resolve(this.getLatestSecureContext());\n        } else {\n            return new Promise((resolve)=>{\n                this.secureContextWatchers.push(resolve);\n            });\n        }\n    }\n    getLatestSecureContext() {\n        var _a, _b;\n        if (!this.latestCaUpdate) {\n            return null;\n        }\n        if (this.identityCertificateProvider !== null && !this.latestIdentityUpdate) {\n            return null;\n        }\n        try {\n            return (0, tls_1.createSecureContext)({\n                ca: this.latestCaUpdate.caCertificate,\n                key: (_a = this.latestIdentityUpdate) === null || _a === void 0 ? void 0 : _a.privateKey,\n                cert: (_b = this.latestIdentityUpdate) === null || _b === void 0 ? void 0 : _b.certificate,\n                ciphers: tls_helpers_1.CIPHER_SUITES\n            });\n        } catch (e) {\n            (0, logging_1.log)(constants_1.LogVerbosity.ERROR, \"Failed to createSecureContext with error \" + e.message);\n            return null;\n        }\n    }\n}\nCertificateProviderChannelCredentialsImpl.SecureConnectorImpl = class {\n    constructor(parent, channelTarget, options, callCredentials){\n        this.parent = parent;\n        this.channelTarget = channelTarget;\n        this.options = options;\n        this.callCredentials = callCredentials;\n    }\n    connect(socket) {\n        return new Promise((resolve, reject)=>{\n            const secureContext = this.parent.getLatestSecureContext();\n            if (!secureContext) {\n                reject(new Error(\"Failed to load credentials\"));\n                return;\n            }\n            if (socket.closed) {\n                reject(new Error(\"Socket closed while loading credentials\"));\n            }\n            const connnectionOptions = getConnectionOptions(secureContext, this.parent.verifyOptions, this.channelTarget, this.options);\n            const tlsConnectOptions = Object.assign({\n                socket: socket\n            }, connnectionOptions);\n            const closeCallback = ()=>{\n                reject(new Error(\"Socket closed\"));\n            };\n            const errorCallback = (error)=>{\n                reject(error);\n            };\n            const tlsSocket = (0, tls_1.connect)(tlsConnectOptions, ()=>{\n                tlsSocket.removeListener(\"close\", closeCallback);\n                tlsSocket.removeListener(\"error\", errorCallback);\n                if (!tlsSocket.authorized) {\n                    reject(tlsSocket.authorizationError);\n                    return;\n                }\n                resolve({\n                    socket: tlsSocket,\n                    secure: true\n                });\n            });\n            tlsSocket.once(\"close\", closeCallback);\n            tlsSocket.once(\"error\", errorCallback);\n        });\n    }\n    async waitForReady() {\n        await this.parent.getSecureContext();\n    }\n    getCallCredentials() {\n        return this.callCredentials;\n    }\n    destroy() {\n        this.parent.unref();\n    }\n};\nfunction createCertificateProviderChannelCredentials(caCertificateProvider, identityCertificateProvider, verifyOptions) {\n    return new CertificateProviderChannelCredentialsImpl(caCertificateProvider, identityCertificateProvider, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n}\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\n    constructor(channelCredentials, callCredentials){\n        super();\n        this.channelCredentials = channelCredentials;\n        this.callCredentials = callCredentials;\n        if (!channelCredentials._isSecure()) {\n            throw new Error(\"Cannot compose insecure credentials\");\n        }\n    }\n    compose(callCredentials) {\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n        return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);\n    }\n    _isSecure() {\n        return true;\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ComposedChannelCredentialsImpl) {\n            return this.channelCredentials._equals(other.channelCredentials) && this.callCredentials._equals(other.callCredentials);\n        } else {\n            return false;\n        }\n    }\n    _createSecureConnector(channelTarget, options, callCredentials) {\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials !== null && callCredentials !== void 0 ? callCredentials : call_credentials_1.CallCredentials.createEmpty());\n        return this.channelCredentials._createSecureConnector(channelTarget, options, combinedCallCredentials);\n    }\n} //# sourceMappingURL=channel-credentials.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1jcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMEJBQTBCLEdBQUcsS0FBSztBQUNsQ0EsbURBQW1ELEdBQUdHO0FBQ3RELE1BQU1DLFFBQVFDLG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCLE1BQU1DLHFCQUFxQkQsbUJBQU9BLENBQUMsNEZBQW9CO0FBQ3ZELE1BQU1FLGdCQUFnQkYsbUJBQU9BLENBQUMsa0ZBQWU7QUFDN0MsTUFBTUcsZUFBZUgsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTUksYUFBYUosbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUssWUFBWUwsbUJBQU9BLENBQUMsMEVBQVc7QUFDckMsTUFBTU0sY0FBY04sbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsOERBQThEO0FBQzlELFNBQVNPLHFCQUFxQkMsR0FBRyxFQUFFQyxZQUFZO0lBQzNDLElBQUlELE9BQU8sQ0FBRUEsQ0FBQUEsZUFBZUUsTUFBSyxHQUFJO1FBQ2pDLE1BQU0sSUFBSUMsVUFBVSxDQUFDLEVBQUVGLGFBQWEsZ0NBQWdDLENBQUM7SUFDekU7QUFDSjtBQUNBOzs7O0NBSUMsR0FDRCxNQUFNWjtJQUNGOzs7OztLQUtDLEdBQ0RlLFFBQVFDLGVBQWUsRUFBRTtRQUNyQixPQUFPLElBQUlDLCtCQUErQixJQUFJLEVBQUVEO0lBQ3BEO0lBQ0E7Ozs7Ozs7O0tBUUMsR0FDRCxPQUFPRSxVQUFVQyxTQUFTLEVBQUVDLFVBQVUsRUFBRUMsU0FBUyxFQUFFQyxhQUFhLEVBQUU7UUFDOUQsSUFBSUM7UUFDSmIscUJBQXFCUyxXQUFXO1FBQ2hDVCxxQkFBcUJVLFlBQVk7UUFDakNWLHFCQUFxQlcsV0FBVztRQUNoQyxJQUFJRCxjQUFjLENBQUNDLFdB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YnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1jcmVkZW50aWFscy5qcz84ZTcwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoYW5uZWxDcmVkZW50aWFscyA9IHZvaWQgMDtcbmV4cG9ydHMuY3JlYXRlQ2VydGlmaWNhdGVQcm92aWRlckNoYW5uZWxDcmVkZW50aWFscyA9IGNyZWF0ZUNlcnRpZmljYXRlUHJvdmlkZXJDaGFubmVsQ3JlZGVudGlhbHM7XG5jb25zdCB0bHNfMSA9IHJlcXVpcmUoXCJ0bHNcIik7XG5jb25zdCBjYWxsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jYWxsLWNyZWRlbnRpYWxzXCIpO1xuY29uc3QgdGxzX2hlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL3Rscy1oZWxwZXJzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiB2ZXJpZnlJc0J1ZmZlck9yTnVsbChvYmosIGZyaWVuZGx5TmFtZSkge1xuICAgIGlmIChvYmogJiYgIShvYmogaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZnJpZW5kbHlOYW1lfSwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBCdWZmZXIuYCk7XG4gICAgfVxufVxuLyoqXG4gKiBBIGNsYXNzIHRoYXQgY29udGFpbnMgY3JlZGVudGlhbHMgZm9yIGNvbW11bmljYXRpbmcgb3ZlciBhIGNoYW5uZWwsIGFzIHdlbGxcbiAqIGFzIGEgc2V0IG9mIHBlci1jYWxsIGNyZWRlbnRpYWxzLCB3aGljaCBhcmUgYXBwbGllZCB0byBldmVyeSBtZXRob2QgY2FsbCBtYWRlXG4gKiBvdmVyIGEgY2hhbm5lbCBpbml0aWFsaXplZCB3aXRoIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gKi9cbmNsYXNzIENoYW5uZWxDcmVkZW50aWFscyB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBvYmplY3Qgd2l0aCB0aGUgaW5jbHVkZWQgc2V0IG9mIHBlci1jYWxsIGNyZWRlbnRpYWxzXG4gICAgICogZXhwYW5kZWQgdG8gaW5jbHVkZSBjYWxsQ3JlZGVudGlhbHMuXG4gICAgICogQHBhcmFtIGNhbGxDcmVkZW50aWFscyBBIENhbGxDcmVkZW50aWFscyBvYmplY3QgdG8gYXNzb2NpYXRlIHdpdGggdGhpc1xuICAgICAqIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNvbXBvc2UoY2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9zZWRDaGFubmVsQ3JlZGVudGlhbHNJbXBsKHRoaXMsIGNhbGxDcmVkZW50aWFscyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBDaGFubmVsQ3JlZGVudGlhbHMgaW5zdGFuY2Ugd2l0aCBhIGdpdmVuIHNldCBvZiBjcmVkZW50aWFscy5cbiAgICAgKiBUaGUgcmVzdWx0aW5nIGluc3RhbmNlIGNhbiBiZSB1c2VkIHRvIGNvbnN0cnVjdCBhIENoYW5uZWwgdGhhdCBjb21tdW5pY2F0ZXNcbiAgICAgKiBvdmVyIFRMUy5cbiAgICAgKiBAcGFyYW0gcm9vdENlcnRzIFRoZSByb290IGNlcnRpZmljYXRlIGRhdGEuXG4gICAgICogQHBhcmFtIHByaXZhdGVLZXkgVGhlIGNsaWVudCBjZXJ0aWZpY2F0ZSBwcml2YXRlIGtleSwgaWYgYXZhaWxhYmxlLlxuICAgICAqIEBwYXJhbSBjZXJ0Q2hhaW4gVGhlIGNsaWVudCBjZXJ0aWZpY2F0ZSBrZXkgY2hhaW4sIGlmIGF2YWlsYWJsZS5cbiAgICAgKiBAcGFyYW0gdmVyaWZ5T3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgdG8gbW9kaWZ5IGNlcnRpZmljYXRlIHZlcmlmaWNhdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTc2wocm9vdENlcnRzLCBwcml2YXRlS2V5LCBjZXJ0Q2hhaW4sIHZlcmlmeU9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2ZXJpZnlJc0J1ZmZlck9yTnVsbChyb290Q2VydHMsICdSb290IGNlcnRpZmljYXRlJyk7XG4gICAgICAgIHZlcmlmeUlzQnVmZmVyT3JOdWxsKHByaXZhdGVLZXksICdQcml2YXRlIGtleScpO1xuICAgICAgICB2ZXJpZnlJc0J1ZmZlck9yTnVsbChjZXJ0Q2hhaW4sICdDZXJ0aWZpY2F0ZSBjaGFpbicpO1xuICAgICAgICBpZiAocHJpdmF0ZUtleSAmJiAhY2VydENoYWluKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByaXZhdGUga2V5IG11c3QgYmUgZ2l2ZW4gd2l0aCBhY2NvbXBhbnlpbmcgY2VydGlmaWNhdGUgY2hhaW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByaXZhdGVLZXkgJiYgY2VydENoYWluKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NlcnRpZmljYXRlIGNoYWluIG11c3QgYmUgZ2l2ZW4gd2l0aCBhY2NvbXBhbnlpbmcgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWN1cmVDb250ZXh0ID0gKDAsIHRsc18xLmNyZWF0ZVNlY3VyZUNvbnRleHQpKHtcbiAgICAgICAgICAgIGNhOiAoX2EgPSByb290Q2VydHMgIT09IG51bGwgJiYgcm9vdENlcnRzICE9PSB2b2lkIDAgPyByb290Q2VydHMgOiAoMCwgdGxzX2hlbHBlcnNfMS5nZXREZWZhdWx0Um9vdHNEYXRhKSgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBrZXk6IHByaXZhdGVLZXkgIT09IG51bGwgJiYgcHJpdmF0ZUtleSAhPT0gdm9pZCAwID8gcHJpdmF0ZUtleSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNlcnQ6IGNlcnRDaGFpbiAhPT0gbnVsbCAmJiBjZXJ0Q2hhaW4gIT09IHZvaWQgMCA/IGNlcnRDaGFpbiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNpcGhlcnM6IHRsc19oZWxwZXJzXzEuQ0lQSEVSX1NVSVRFUyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgU2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbChzZWN1cmVDb250ZXh0LCB2ZXJpZnlPcHRpb25zICE9PSBudWxsICYmIHZlcmlmeU9wdGlvbnMgIT09IHZvaWQgMCA/IHZlcmlmeU9wdGlvbnMgOiB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBDaGFubmVsQ3JlZGVudGlhbHMgaW5zdGFuY2Ugd2l0aCBjcmVkZW50aWFscyBjcmVhdGVkIHVzaW5nXG4gICAgICogdGhlIHByb3ZpZGVkIHNlY3VyZUNvbnRleHQuIFRoZSByZXN1bHRpbmcgaW5zdGFuY2VzIGNhbiBiZSB1c2VkIHRvXG4gICAgICogY29uc3RydWN0IGEgQ2hhbm5lbCB0aGF0IGNvbW11bmljYXRlcyBvdmVyIFRMUy4gZ1JQQyB3aWxsIG5vdCBvdmVycmlkZVxuICAgICAqIGFueXRoaW5nIGluIHRoZSBwcm92aWRlZCBzZWN1cmVDb250ZXh0LCBzbyB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgICogR1JQQ19TU0xfQ0lQSEVSX1NVSVRFUyBhbmQgR1JQQ19ERUZBVUxUX1NTTF9ST09UU19GSUxFX1BBVEggd2lsbFxuICAgICAqIG5vdCBiZSBhcHBsaWVkLlxuICAgICAqIEBwYXJhbSBzZWN1cmVDb250ZXh0IFRoZSByZXR1cm4gdmFsdWUgb2YgdGxzLmNyZWF0ZVNlY3VyZUNvbnRleHQoKVxuICAgICAqIEBwYXJhbSB2ZXJpZnlPcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBtb2RpZnkgY2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZyb21TZWN1cmVDb250ZXh0KHNlY3VyZUNvbnRleHQsIHZlcmlmeU9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsKHNlY3VyZUNvbnRleHQsIHZlcmlmeU9wdGlvbnMgIT09IG51bGwgJiYgdmVyaWZ5T3B0aW9ucyAhPT0gdm9pZCAwID8gdmVyaWZ5T3B0aW9ucyA6IHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IENoYW5uZWxDcmVkZW50aWFscyBpbnN0YW5jZSB3aXRoIG5vIGNyZWRlbnRpYWxzLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJbnNlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwoKTtcbiAgICB9XG59XG5leHBvcnRzLkNoYW5uZWxDcmVkZW50aWFscyA9IENoYW5uZWxDcmVkZW50aWFscztcbmNsYXNzIEluc2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCBleHRlbmRzIENoYW5uZWxDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuICAgIGNvbXBvc2UoY2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXBvc2UgaW5zZWN1cmUgY3JlZGVudGlhbHMnKTtcbiAgICB9XG4gICAgX2lzU2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgSW5zZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsO1xuICAgIH1cbiAgICBfY3JlYXRlU2VjdXJlQ29ubmVjdG9yKGNoYW5uZWxUYXJnZXQsIG9wdGlvbnMsIGNhbGxDcmVkZW50aWFscykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29ubmVjdChzb2NrZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LFxuICAgICAgICAgICAgICAgICAgICBzZWN1cmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2FpdEZvclJlYWR5OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldENhbGxDcmVkZW50aWFsczogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsQ3JlZGVudGlhbHMgIT09IG51bGwgJiYgY2FsbENyZWRlbnRpYWxzICE9PSB2b2lkIDAgPyBjYWxsQ3JlZGVudGlhbHMgOiBjYWxsX2NyZWRlbnRpYWxzXzEuQ2FsbENyZWRlbnRpYWxzLmNyZWF0ZUVtcHR5KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzdHJveSgpIHsgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENvbm5lY3Rpb25PcHRpb25zKHNlY3VyZUNvbnRleHQsIHZlcmlmeU9wdGlvbnMsIGNoYW5uZWxUYXJnZXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgY29uc3QgY29ubmVjdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgIHNlY3VyZUNvbnRleHQ6IHNlY3VyZUNvbnRleHRcbiAgICB9O1xuICAgIGlmICh2ZXJpZnlPcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkpIHtcbiAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eSA9IHZlcmlmeU9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eTtcbiAgICB9XG4gICAgaWYgKHZlcmlmeU9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkID0gdmVyaWZ5T3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gICAgfVxuICAgIGNvbm5lY3Rpb25PcHRpb25zLkFMUE5Qcm90b2NvbHMgPSBbJ2gyJ107XG4gICAgaWYgKG9wdGlvbnNbJ2dycGMuc3NsX3RhcmdldF9uYW1lX292ZXJyaWRlJ10pIHtcbiAgICAgICAgY29uc3Qgc3NsVGFyZ2V0TmFtZU92ZXJyaWRlID0gb3B0aW9uc1snZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUnXTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxDaGVja1NlcnZlcklkZW50aXR5ID0gKF9hID0gY29ubmVjdGlvbk9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGxzXzEuY2hlY2tTZXJ2ZXJJZGVudGl0eTtcbiAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eSA9IChob3N0LCBjZXJ0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxDaGVja1NlcnZlcklkZW50aXR5KHNzbFRhcmdldE5hbWVPdmVycmlkZSwgY2VydCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLnNlcnZlcm5hbWUgPSBzc2xUYXJnZXROYW1lT3ZlcnJpZGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgLyogVGhpcyBpcyBtb3JlIG9yIGxlc3MgaG93IHNlcnZlcm5hbWUgd2lsbCBiZSBzZXQgaW4gY3JlYXRlU2Vzc2lvblxuICAgICAgICAgICAgICogaWYgYSBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlZCB0aHJvdWdoIHRoZSBwcm94eS5cbiAgICAgICAgICAgICAqIElmIHRoZSBwcm94eSBpcyBub3QgdXNlZCwgdGhlc2UgY29ubmVjdGlvbk9wdGlvbnMgYXJlIGRpc2NhcmRlZFxuICAgICAgICAgICAgICogYW55d2F5ICovXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRQYXRoID0gKDAsIHJlc29sdmVyXzEuZ2V0RGVmYXVsdEF1dGhvcml0eSkoKF9iID0gKDAsIHVyaV9wYXJzZXJfMS5wYXJzZVVyaSkob3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0J10pKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7XG4gICAgICAgICAgICAgICAgcGF0aDogJ2xvY2FsaG9zdCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGhvc3RQb3J0ID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KSh0YXJnZXRQYXRoKTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLnNlcnZlcm5hbWUgPSAoX2MgPSBob3N0UG9ydCA9PT0gbnVsbCB8fCBob3N0UG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaG9zdFBvcnQuaG9zdCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdGFyZ2V0UGF0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9uc1snZ3JwYy1ub2RlLnRsc19lbmFibGVfdHJhY2UnXSkge1xuICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5lbmFibGVUcmFjZSA9IHRydWU7XG4gICAgfVxuICAgIGxldCByZWFsVGFyZ2V0ID0gY2hhbm5lbFRhcmdldDtcbiAgICBpZiAoJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCcgaW4gb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXJzZWRUYXJnZXQgPSAoMCwgdXJpX3BhcnNlcl8xLnBhcnNlVXJpKShvcHRpb25zWydncnBjLmh0dHBfY29ubmVjdF90YXJnZXQnXSk7XG4gICAgICAgIGlmIChwYXJzZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJlYWxUYXJnZXQgPSBwYXJzZWRUYXJnZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0UGF0aCA9ICgwLCByZXNvbHZlcl8xLmdldERlZmF1bHRBdXRob3JpdHkpKHJlYWxUYXJnZXQpO1xuICAgIGNvbnN0IGhvc3RQb3J0ID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KSh0YXJnZXRQYXRoKTtcbiAgICBjb25zdCByZW1vdGVIb3N0ID0gKF9kID0gaG9zdFBvcnQgPT09IG51bGwgfHwgaG9zdFBvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhvc3RQb3J0Lmhvc3QpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRhcmdldFBhdGg7XG4gICAgY29ubmVjdGlvbk9wdGlvbnMuaG9zdCA9IHJlbW90ZUhvc3Q7XG4gICAgY29ubmVjdGlvbk9wdGlvbnMuc2VydmVybmFtZSA9IHJlbW90ZUhvc3Q7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb25PcHRpb25zO1xufVxuY2xhc3MgU2VjdXJlQ29ubmVjdG9ySW1wbCB7XG4gICAgY29uc3RydWN0b3IoY29ubmVjdGlvbk9wdGlvbnMsIGNhbGxDcmVkZW50aWFscykge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25PcHRpb25zID0gY29ubmVjdGlvbk9wdGlvbnM7XG4gICAgICAgIHRoaXMuY2FsbENyZWRlbnRpYWxzID0gY2FsbENyZWRlbnRpYWxzO1xuICAgIH1cbiAgICBjb25uZWN0KHNvY2tldCkge1xuICAgICAgICBjb25zdCB0bHNDb25uZWN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBzb2NrZXQ6IHNvY2tldCB9LCB0aGlzLmNvbm5lY3Rpb25PcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRsc1NvY2tldCA9ICgwLCB0bHNfMS5jb25uZWN0KSh0bHNDb25uZWN0T3B0aW9ucywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGxzU29ja2V0LmF1dGhvcml6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHRsc1NvY2tldC5hdXRob3JpemF0aW9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQ6IHRsc1NvY2tldCxcbiAgICAgICAgICAgICAgICAgICAgc2VjdXJlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRsc1NvY2tldC5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3YWl0Rm9yUmVhZHkoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZ2V0Q2FsbENyZWRlbnRpYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsQ3JlZGVudGlhbHM7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7IH1cbn1cbmNsYXNzIFNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwgZXh0ZW5kcyBDaGFubmVsQ3JlZGVudGlhbHMge1xuICAgIGNvbnN0cnVjdG9yKHNlY3VyZUNvbnRleHQsIHZlcmlmeU9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZWN1cmVDb250ZXh0ID0gc2VjdXJlQ29udGV4dDtcbiAgICAgICAgdGhpcy52ZXJpZnlPcHRpb25zID0gdmVyaWZ5T3B0aW9ucztcbiAgICB9XG4gICAgX2lzU2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX2VxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5zZWN1cmVDb250ZXh0ID09PSBvdGhlci5zZWN1cmVDb250ZXh0ICYmXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJpZnlPcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkgPT09XG4gICAgICAgICAgICAgICAgICAgIG90aGVyLnZlcmlmeU9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NyZWF0ZVNlY3VyZUNvbm5lY3RvcihjaGFubmVsVGFyZ2V0LCBvcHRpb25zLCBjYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbk9wdGlvbnMgPSBnZXRDb25uZWN0aW9uT3B0aW9ucyh0aGlzLnNlY3VyZUNvbnRleHQsIHRoaXMudmVyaWZ5T3B0aW9ucywgY2hhbm5lbFRhcmdldCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgU2VjdXJlQ29ubmVjdG9ySW1wbChjb25uZWN0aW9uT3B0aW9ucywgY2FsbENyZWRlbnRpYWxzICE9PSBudWxsICYmIGNhbGxDcmVkZW50aWFscyAhPT0gdm9pZCAwID8gY2FsbENyZWRlbnRpYWxzIDogY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVFbXB0eSgpKTtcbiAgICB9XG59XG5jbGFzcyBDZXJ0aWZpY2F0ZVByb3ZpZGVyQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCBleHRlbmRzIENoYW5uZWxDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3IoY2FDZXJ0aWZpY2F0ZVByb3ZpZGVyLCBpZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXIsIHZlcmlmeU9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jYUNlcnRpZmljYXRlUHJvdmlkZXIgPSBjYUNlcnRpZmljYXRlUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuaWRlbnRpdHlDZXJ0aWZpY2F0ZVByb3ZpZGVyID0gaWRlbnRpdHlDZXJ0aWZpY2F0ZVByb3ZpZGVyO1xuICAgICAgICB0aGlzLnZlcmlmeU9wdGlvbnMgPSB2ZXJpZnlPcHRpb25zO1xuICAgICAgICB0aGlzLnJlZmNvdW50ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGB1bmRlZmluZWRgIG1lYW5zIHRoYXQgdGhlIGNlcnRpZmljYXRlcyBoYXZlIG5vdCB5ZXQgYmVlbiBsb2FkZWQuIGBudWxsYFxuICAgICAgICAgKiBtZWFucyB0aGF0IGFuIGF0dGVtcHQgdG8gbG9hZCB0aGVtIGhhcyBjb21wbGV0ZWQsIGFuZCBoYXMgZmFpbGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXRlc3RDYVVwZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGB1bmRlZmluZWRgIG1lYW5zIHRoYXQgdGhlIGNlcnRpZmljYXRlcyBoYXZlIG5vdCB5ZXQgYmVlbiBsb2FkZWQuIGBudWxsYFxuICAgICAgICAgKiBtZWFucyB0aGF0IGFuIGF0dGVtcHQgdG8gbG9hZCB0aGVtIGhhcyBjb21wbGV0ZWQsIGFuZCBoYXMgZmFpbGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXRlc3RJZGVudGl0eVVwZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jYUNlcnRpZmljYXRlVXBkYXRlTGlzdGVuZXIgPSB0aGlzLmhhbmRsZUNhQ2VydGlmaWNhdGVVcGRhdGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pZGVudGl0eUNlcnRpZmljYXRlVXBkYXRlTGlzdGVuZXIgPSB0aGlzLmhhbmRsZUlkZW50aXR5Q2VydGl0aWZpY2F0ZVVwZGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNlY3VyZUNvbnRleHRXYXRjaGVycyA9IFtdO1xuICAgIH1cbiAgICBfaXNTZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQ2VydGlmaWNhdGVQcm92aWRlckNoYW5uZWxDcmVkZW50aWFsc0ltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhQ2VydGlmaWNhdGVQcm92aWRlciA9PT0gb3RoZXIuY2FDZXJ0aWZpY2F0ZVByb3ZpZGVyICYmXG4gICAgICAgICAgICAgICAgdGhpcy5pZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXIgPT09IG90aGVyLmlkZW50aXR5Q2VydGlmaWNhdGVQcm92aWRlciAmJlxuICAgICAgICAgICAgICAgICgoX2EgPSB0aGlzLnZlcmlmeU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jaGVja1NlcnZlcklkZW50aXR5KSA9PT0gKChfYiA9IG90aGVyLnZlcmlmeU9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jaGVja1NlcnZlcklkZW50aXR5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWYoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMucmVmY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2FDZXJ0aWZpY2F0ZVByb3ZpZGVyLmFkZENhQ2VydGlmaWNhdGVMaXN0ZW5lcih0aGlzLmNhQ2VydGlmaWNhdGVVcGRhdGVMaXN0ZW5lcik7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmlkZW50aXR5Q2VydGlmaWNhdGVQcm92aWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZElkZW50aXR5Q2VydGlmaWNhdGVMaXN0ZW5lcih0aGlzLmlkZW50aXR5Q2VydGlmaWNhdGVVcGRhdGVMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWZjb3VudCArPSAxO1xuICAgIH1cbiAgICB1bnJlZigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnJlZmNvdW50IC09IDE7XG4gICAgICAgIGlmICh0aGlzLnJlZmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNhQ2VydGlmaWNhdGVQcm92aWRlci5yZW1vdmVDYUNlcnRpZmljYXRlTGlzdGVuZXIodGhpcy5jYUNlcnRpZmljYXRlVXBkYXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5pZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVJZGVudGl0eUNlcnRpZmljYXRlTGlzdGVuZXIodGhpcy5pZGVudGl0eUNlcnRpZmljYXRlVXBkYXRlTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jcmVhdGVTZWN1cmVDb25uZWN0b3IoY2hhbm5lbFRhcmdldCwgb3B0aW9ucywgY2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRoaXMucmVmKCk7XG4gICAgICAgIHJldHVybiBuZXcgQ2VydGlmaWNhdGVQcm92aWRlckNoYW5uZWxDcmVkZW50aWFsc0ltcGwuU2VjdXJlQ29ubmVjdG9ySW1wbCh0aGlzLCBjaGFubmVsVGFyZ2V0LCBvcHRpb25zLCBjYWxsQ3JlZGVudGlhbHMgIT09IG51bGwgJiYgY2FsbENyZWRlbnRpYWxzICE9PSB2b2lkIDAgPyBjYWxsQ3JlZGVudGlhbHMgOiBjYWxsX2NyZWRlbnRpYWxzXzEuQ2FsbENyZWRlbnRpYWxzLmNyZWF0ZUVtcHR5KCkpO1xuICAgIH1cbiAgICBtYXliZVVwZGF0ZVdhdGNoZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNSZWNlaXZlZFVwZGF0ZXMoKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB3YXRjaGVyIG9mIHRoaXMuc2VjdXJlQ29udGV4dFdhdGNoZXJzKSB7XG4gICAgICAgICAgICAgICAgd2F0Y2hlcih0aGlzLmdldExhdGVzdFNlY3VyZUNvbnRleHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlY3VyZUNvbnRleHRXYXRjaGVycyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUNhQ2VydGlmaWNhdGVVcGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHRoaXMubGF0ZXN0Q2FVcGRhdGUgPSB1cGRhdGU7XG4gICAgICAgIHRoaXMubWF5YmVVcGRhdGVXYXRjaGVycygpO1xuICAgIH1cbiAgICBoYW5kbGVJZGVudGl0eUNlcnRpdGlmaWNhdGVVcGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHRoaXMubGF0ZXN0SWRlbnRpdHlVcGRhdGUgPSB1cGRhdGU7XG4gICAgICAgIHRoaXMubWF5YmVVcGRhdGVXYXRjaGVycygpO1xuICAgIH1cbiAgICBoYXNSZWNlaXZlZFVwZGF0ZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmxhdGVzdENhVXBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXIgJiYgdGhpcy5sYXRlc3RJZGVudGl0eVVwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldFNlY3VyZUNvbnRleHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1JlY2VpdmVkVXBkYXRlcygpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZ2V0TGF0ZXN0U2VjdXJlQ29udGV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlY3VyZUNvbnRleHRXYXRjaGVycy5wdXNoKHJlc29sdmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TGF0ZXN0U2VjdXJlQ29udGV4dCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCF0aGlzLmxhdGVzdENhVXBkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXIgIT09IG51bGwgJiYgIXRoaXMubGF0ZXN0SWRlbnRpdHlVcGRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHRsc18xLmNyZWF0ZVNlY3VyZUNvbnRleHQpKHtcbiAgICAgICAgICAgICAgICBjYTogdGhpcy5sYXRlc3RDYVVwZGF0ZS5jYUNlcnRpZmljYXRlLFxuICAgICAgICAgICAgICAgIGtleTogKF9hID0gdGhpcy5sYXRlc3RJZGVudGl0eVVwZGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByaXZhdGVLZXksXG4gICAgICAgICAgICAgICAgY2VydDogKF9iID0gdGhpcy5sYXRlc3RJZGVudGl0eVVwZGF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNlcnRpZmljYXRlLFxuICAgICAgICAgICAgICAgIGNpcGhlcnM6IHRsc19oZWxwZXJzXzEuQ0lQSEVSX1NVSVRFU1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICgwLCBsb2dnaW5nXzEubG9nKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsICdGYWlsZWQgdG8gY3JlYXRlU2VjdXJlQ29udGV4dCB3aXRoIGVycm9yICcgKyBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5DZXJ0aWZpY2F0ZVByb3ZpZGVyQ2hhbm5lbENyZWRlbnRpYWxzSW1wbC5TZWN1cmVDb25uZWN0b3JJbXBsID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgY2hhbm5lbFRhcmdldCwgb3B0aW9ucywgY2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmNoYW5uZWxUYXJnZXQgPSBjaGFubmVsVGFyZ2V0O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNhbGxDcmVkZW50aWFscyA9IGNhbGxDcmVkZW50aWFscztcbiAgICB9XG4gICAgY29ubmVjdChzb2NrZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlY3VyZUNvbnRleHQgPSB0aGlzLnBhcmVudC5nZXRMYXRlc3RTZWN1cmVDb250ZXh0KCk7XG4gICAgICAgICAgICBpZiAoIXNlY3VyZUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBjcmVkZW50aWFscycpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc29ja2V0LmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1NvY2tldCBjbG9zZWQgd2hpbGUgbG9hZGluZyBjcmVkZW50aWFscycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbm5uZWN0aW9uT3B0aW9ucyA9IGdldENvbm5lY3Rpb25PcHRpb25zKHNlY3VyZUNvbnRleHQsIHRoaXMucGFyZW50LnZlcmlmeU9wdGlvbnMsIHRoaXMuY2hhbm5lbFRhcmdldCwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHRsc0Nvbm5lY3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHNvY2tldDogc29ja2V0IH0sIGNvbm5uZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBjbG9zZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1NvY2tldCBjbG9zZWQnKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZXJyb3JDYWxsYmFjayA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdGxzU29ja2V0ID0gKDAsIHRsc18xLmNvbm5lY3QpKHRsc0Nvbm5lY3RPcHRpb25zLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGxzU29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsb3NlQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHRsc1NvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRsc1NvY2tldC5hdXRob3JpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh0bHNTb2NrZXQuYXV0aG9yaXphdGlvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0OiB0bHNTb2NrZXQsXG4gICAgICAgICAgICAgICAgICAgIHNlY3VyZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0bHNTb2NrZXQub25jZSgnY2xvc2UnLCBjbG9zZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIHRsc1NvY2tldC5vbmNlKCdlcnJvcicsIGVycm9yQ2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgd2FpdEZvclJlYWR5KCkge1xuICAgICAgICBhd2FpdCB0aGlzLnBhcmVudC5nZXRTZWN1cmVDb250ZXh0KCk7XG4gICAgfVxuICAgIGdldENhbGxDcmVkZW50aWFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbENyZWRlbnRpYWxzO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnBhcmVudC51bnJlZigpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVDZXJ0aWZpY2F0ZVByb3ZpZGVyQ2hhbm5lbENyZWRlbnRpYWxzKGNhQ2VydGlmaWNhdGVQcm92aWRlciwgaWRlbnRpdHlDZXJ0aWZpY2F0ZVByb3ZpZGVyLCB2ZXJpZnlPcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDZXJ0aWZpY2F0ZVByb3ZpZGVyQ2hhbm5lbENyZWRlbnRpYWxzSW1wbChjYUNlcnRpZmljYXRlUHJvdmlkZXIsIGlkZW50aXR5Q2VydGlmaWNhdGVQcm92aWRlciwgdmVyaWZ5T3B0aW9ucyAhPT0gbnVsbCAmJiB2ZXJpZnlPcHRpb25zICE9PSB2b2lkIDAgPyB2ZXJpZnlPcHRpb25zIDoge30pO1xufVxuY2xhc3MgQ29tcG9zZWRDaGFubmVsQ3JlZGVudGlhbHNJbXBsIGV4dGVuZHMgQ2hhbm5lbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsQ3JlZGVudGlhbHMsIGNhbGxDcmVkZW50aWFscykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNoYW5uZWxDcmVkZW50aWFscyA9IGNoYW5uZWxDcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5jYWxsQ3JlZGVudGlhbHMgPSBjYWxsQ3JlZGVudGlhbHM7XG4gICAgICAgIGlmICghY2hhbm5lbENyZWRlbnRpYWxzLl9pc1NlY3VyZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wb3NlIGluc2VjdXJlIGNyZWRlbnRpYWxzJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9zZShjYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgY29tYmluZWRDYWxsQ3JlZGVudGlhbHMgPSB0aGlzLmNhbGxDcmVkZW50aWFscy5jb21wb3NlKGNhbGxDcmVkZW50aWFscyk7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9zZWRDaGFubmVsQ3JlZGVudGlhbHNJbXBsKHRoaXMuY2hhbm5lbENyZWRlbnRpYWxzLCBjb21iaW5lZENhbGxDcmVkZW50aWFscyk7XG4gICAgfVxuICAgIF9pc1NlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDb21wb3NlZENoYW5uZWxDcmVkZW50aWFsc0ltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGFubmVsQ3JlZGVudGlhbHMuX2VxdWFscyhvdGhlci5jaGFubmVsQ3JlZGVudGlhbHMpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsQ3JlZGVudGlhbHMuX2VxdWFscyhvdGhlci5jYWxsQ3JlZGVudGlhbHMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY3JlYXRlU2VjdXJlQ29ubmVjdG9yKGNoYW5uZWxUYXJnZXQsIG9wdGlvbnMsIGNhbGxDcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCBjb21iaW5lZENhbGxDcmVkZW50aWFscyA9IHRoaXMuY2FsbENyZWRlbnRpYWxzLmNvbXBvc2UoY2FsbENyZWRlbnRpYWxzICE9PSBudWxsICYmIGNhbGxDcmVkZW50aWFscyAhPT0gdm9pZCAwID8gY2FsbENyZWRlbnRpYWxzIDogY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVFbXB0eSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbENyZWRlbnRpYWxzLl9jcmVhdGVTZWN1cmVDb25uZWN0b3IoY2hhbm5lbFRhcmdldCwgb3B0aW9ucywgY29tYmluZWRDYWxsQ3JlZGVudGlhbHMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5uZWwtY3JlZGVudGlhbHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2hhbm5lbENyZWRlbnRpYWxzIiwiY3JlYXRlQ2VydGlmaWNhdGVQcm92aWRlckNoYW5uZWxDcmVkZW50aWFscyIsInRsc18xIiwicmVxdWlyZSIsImNhbGxfY3JlZGVudGlhbHNfMSIsInRsc19oZWxwZXJzXzEiLCJ1cmlfcGFyc2VyXzEiLCJyZXNvbHZlcl8xIiwibG9nZ2luZ18xIiwiY29uc3RhbnRzXzEiLCJ2ZXJpZnlJc0J1ZmZlck9yTnVsbCIsIm9iaiIsImZyaWVuZGx5TmFtZSIsIkJ1ZmZlciIsIlR5cGVFcnJvciIsImNvbXBvc2UiLCJjYWxsQ3JlZGVudGlhbHMiLCJDb21wb3NlZENoYW5uZWxDcmVkZW50aWFsc0ltcGwiLCJjcmVhdGVTc2wiLCJyb290Q2VydHMiLCJwcml2YXRlS2V5IiwiY2VydENoYWluIiwidmVyaWZ5T3B0aW9ucyIsIl9hIiwiRXJyb3IiLCJzZWN1cmVDb250ZXh0IiwiY3JlYXRlU2VjdXJlQ29udGV4dCIsImNhIiwiZ2V0RGVmYXVsdFJvb3RzRGF0YSIsInVuZGVmaW5lZCIsImtleSIsImNlcnQiLCJjaXBoZXJzIiwiQ0lQSEVSX1NVSVRFUyIsIlNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwiLCJjcmVhdGVGcm9tU2VjdXJlQ29udGV4dCIsImNyZWF0ZUluc2VjdXJlIiwiSW5zZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsIiwiY29uc3RydWN0b3IiLCJfaXNTZWN1cmUiLCJfZXF1YWxzIiwib3RoZXIiLCJfY3JlYXRlU2VjdXJlQ29ubmVjdG9yIiwiY2hhbm5lbFRhcmdldCIsIm9wdGlvbnMiLCJjb25uZWN0Iiwic29ja2V0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZWN1cmUiLCJ3YWl0Rm9yUmVhZHkiLCJnZXRDYWxsQ3JlZGVudGlhbHMiLCJDYWxsQ3JlZGVudGlhbHMiLCJjcmVhdGVFbXB0eSIsImRlc3Ryb3kiLCJnZXRDb25uZWN0aW9uT3B0aW9ucyIsIl9iIiwiX2MiLCJfZCIsImNvbm5lY3Rpb25PcHRpb25zIiwiY2hlY2tTZXJ2ZXJJZGVudGl0eSIsInJlamVjdFVuYXV0aG9yaXplZCIsIkFMUE5Qcm90b2NvbHMiLCJzc2xUYXJnZXROYW1lT3ZlcnJpZGUiLCJvcmlnaW5hbENoZWNrU2VydmVySWRlbnRpdHkiLCJob3N0Iiwic2VydmVybmFtZSIsInRhcmdldFBhdGgiLCJnZXREZWZhdWx0QXV0aG9yaXR5IiwicGFyc2VVcmkiLCJwYXRoIiwiaG9zdFBvcnQiLCJzcGxpdEhvc3RQb3J0IiwiZW5hYmxlVHJhY2UiLCJyZWFsVGFyZ2V0IiwicGFyc2VkVGFyZ2V0IiwicmVtb3RlSG9zdCIsIlNlY3VyZUNvbm5lY3RvckltcGwiLCJ0bHNDb25uZWN0T3B0aW9ucyIsImFzc2lnbiIsInJlamVjdCIsInRsc1NvY2tldCIsImF1dGhvcml6ZWQiLCJhdXRob3JpemF0aW9uRXJyb3IiLCJvbiIsImVycm9yIiwiQ2VydGlmaWNhdGVQcm92aWRlckNoYW5uZWxDcmVkZW50aWFsc0ltcGwiLCJjYUNlcnRpZmljYXRlUHJvdmlkZXIiLCJpZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXIiLCJyZWZjb3VudCIsImxhdGVzdENhVXBkYXRlIiwibGF0ZXN0SWRlbnRpdHlVcGRhdGUiLCJjYUNlcnRpZmljYXRlVXBkYXRlTGlzdGVuZXIiLCJoYW5kbGVDYUNlcnRpZmljYXRlVXBkYXRlIiwiYmluZCIsImlkZW50aXR5Q2VydGlmaWNhdGVVcGRhdGVMaXN0ZW5lciIsImhhbmRsZUlkZW50aXR5Q2VydGl0aWZpY2F0ZVVwZGF0ZSIsInNlY3VyZUNvbnRleHRXYXRjaGVycyIsInJlZiIsImFkZENhQ2VydGlmaWNhdGVMaXN0ZW5lciIsImFkZElkZW50aXR5Q2VydGlmaWNhdGVMaXN0ZW5lciIsInVucmVmIiwicmVtb3ZlQ2FDZXJ0aWZpY2F0ZUxpc3RlbmVyIiwicmVtb3ZlSWRlbnRpdHlDZXJ0aWZpY2F0ZUxpc3RlbmVyIiwibWF5YmVVcGRhdGVXYXRjaGVycyIsImhhc1JlY2VpdmVkVXBkYXRlcyIsIndhdGNoZXIiLCJnZXRMYXRlc3RTZWN1cmVDb250ZXh0IiwidXBkYXRlIiwiZ2V0U2VjdXJlQ29udGV4dCIsInB1c2giLCJjYUNlcnRpZmljYXRlIiwiY2VydGlmaWNhdGUiLCJlIiwibG9nIiwiTG9nVmVyYm9zaXR5IiwiRVJST1IiLCJtZXNzYWdlIiwicGFyZW50IiwiY2xvc2VkIiwiY29ubm5lY3Rpb25PcHRpb25zIiwiY2xvc2VDYWxsYmFjayIsImVycm9yQ2FsbGJhY2siLCJyZW1vdmVMaXN0ZW5lciIsIm9uY2UiLCJjaGFubmVsQ3JlZGVudGlhbHMiLCJjb21iaW5lZENhbGxDcmVkZW50aWFscyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-options.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-options.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.recognizedOptions = void 0;\nexports.channelOptionsEqual = channelOptionsEqual;\n/**\n * This is for checking provided options at runtime. This is an object for\n * easier membership checking.\n */ exports.recognizedOptions = {\n    \"grpc.ssl_target_name_override\": true,\n    \"grpc.primary_user_agent\": true,\n    \"grpc.secondary_user_agent\": true,\n    \"grpc.default_authority\": true,\n    \"grpc.keepalive_time_ms\": true,\n    \"grpc.keepalive_timeout_ms\": true,\n    \"grpc.keepalive_permit_without_calls\": true,\n    \"grpc.service_config\": true,\n    \"grpc.max_concurrent_streams\": true,\n    \"grpc.initial_reconnect_backoff_ms\": true,\n    \"grpc.max_reconnect_backoff_ms\": true,\n    \"grpc.use_local_subchannel_pool\": true,\n    \"grpc.max_send_message_length\": true,\n    \"grpc.max_receive_message_length\": true,\n    \"grpc.enable_http_proxy\": true,\n    \"grpc.enable_channelz\": true,\n    \"grpc.dns_min_time_between_resolutions_ms\": true,\n    \"grpc.enable_retries\": true,\n    \"grpc.per_rpc_retry_buffer_size\": true,\n    \"grpc.retry_buffer_size\": true,\n    \"grpc.max_connection_age_ms\": true,\n    \"grpc.max_connection_age_grace_ms\": true,\n    \"grpc-node.max_session_memory\": true,\n    \"grpc.service_config_disable_resolution\": true,\n    \"grpc.client_idle_timeout_ms\": true,\n    \"grpc-node.tls_enable_trace\": true,\n    \"grpc.lb.ring_hash.ring_size_cap\": true,\n    \"grpc-node.retry_max_attempts_limit\": true,\n    \"grpc-node.flow_control_window\": true\n};\nfunction channelOptionsEqual(options1, options2) {\n    const keys1 = Object.keys(options1).sort();\n    const keys2 = Object.keys(options2).sort();\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for(let i = 0; i < keys1.length; i += 1){\n        if (keys1[i] !== keys2[i]) {\n            return false;\n        }\n        if (options1[keys1[i]] !== options2[keys2[i]]) {\n            return false;\n        }\n    }\n    return true;\n} //# sourceMappingURL=channel-options.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1vcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx5QkFBeUIsR0FBRyxLQUFLO0FBQ2pDQSwyQkFBMkIsR0FBR0c7QUFDOUI7OztDQUdDLEdBQ0RILHlCQUF5QixHQUFHO0lBQ3hCLGlDQUFpQztJQUNqQywyQkFBMkI7SUFDM0IsNkJBQTZCO0lBQzdCLDBCQUEwQjtJQUMxQiwwQkFBMEI7SUFDMUIsNkJBQTZCO0lBQzdCLHVDQUF1QztJQUN2Qyx1QkFBdUI7SUFDdkIsK0JBQStCO0lBQy9CLHFDQUFxQztJQUNyQyxpQ0FBaUM7SUFDakMsa0NBQWtDO0lBQ2xDLGdDQUFnQztJQUNoQyxtQ0FBbUM7SUFDbkMsMEJBQTBCO0lBQzFCLHdCQUF3QjtJQUN4Qiw0Q0FBNEM7SUFDNUMsdUJBQXVCO0lBQ3ZCLGtDQUFrQztJQUNsQywwQkFBMEI7SUFDMUIsOEJBQThCO0lBQzlCLG9DQUFvQztJQUNwQyxnQ0FBZ0M7SUFDaEMsMENBQTBDO0lBQzFDLCtCQUErQjtJQUMvQiw4QkFBOEI7SUFDOUIsbUNBQW1DO0lBQ25DLHNDQUFzQztJQUN0QyxpQ0FBaUM7QUFDckM7QUFDQSxTQUFTRyxvQkFBb0JDLFFBQVEsRUFBRUMsUUFBUTtJQUMzQyxNQUFNQyxRQUFRUixPQUFPUyxJQUFJLENBQUNILFVBQVVJLElBQUk7SUFDeEMsTUFBTUMsUUFBUVgsT0FBT1MsSUFBSSxDQUFDRixVQUFVRyxJQUFJO0lBQ3hDLElBQUlGLE1BQU1JLE1BQU0sS0FBS0QsTUFBTUMsTUFBTSxFQUFFO1FBQy9CLE9BQU87SUFDWDtJQUNBLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTCxNQUFNSSxNQUFNLEVBQUVDLEtBQUssRUFBRztRQUN0QyxJQUFJTCxLQUFLLENBQUNLLEVBQUUsS0FBS0YsS0FBSyxDQUFDRSxFQUFFLEVBQUU7WUFDdkIsT0FBTztRQUNYO1FBQ0EsSUFBSVAsUUFBUSxDQUFDRSxLQUFLLENBQUNLLEVBQUUsQ0FBQyxLQUFLTixRQUFRLENBQUNJLEtBQUssQ0FBQ0UsRUFBRSxDQUFDLEVBQUU7WUFDM0MsT0FBTztRQUNYO0lBQ0o7SUFDQSxPQUFPO0FBQ1gsRUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1vcHRpb25zLmpzPzc3NmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVjb2duaXplZE9wdGlvbnMgPSB2b2lkIDA7XG5leHBvcnRzLmNoYW5uZWxPcHRpb25zRXF1YWwgPSBjaGFubmVsT3B0aW9uc0VxdWFsO1xuLyoqXG4gKiBUaGlzIGlzIGZvciBjaGVja2luZyBwcm92aWRlZCBvcHRpb25zIGF0IHJ1bnRpbWUuIFRoaXMgaXMgYW4gb2JqZWN0IGZvclxuICogZWFzaWVyIG1lbWJlcnNoaXAgY2hlY2tpbmcuXG4gKi9cbmV4cG9ydHMucmVjb2duaXplZE9wdGlvbnMgPSB7XG4gICAgJ2dycGMuc3NsX3RhcmdldF9uYW1lX292ZXJyaWRlJzogdHJ1ZSxcbiAgICAnZ3JwYy5wcmltYXJ5X3VzZXJfYWdlbnQnOiB0cnVlLFxuICAgICdncnBjLnNlY29uZGFyeV91c2VyX2FnZW50JzogdHJ1ZSxcbiAgICAnZ3JwYy5kZWZhdWx0X2F1dGhvcml0eSc6IHRydWUsXG4gICAgJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnOiB0cnVlLFxuICAgICdncnBjLmtlZXBhbGl2ZV90aW1lb3V0X21zJzogdHJ1ZSxcbiAgICAnZ3JwYy5rZWVwYWxpdmVfcGVybWl0X3dpdGhvdXRfY2FsbHMnOiB0cnVlLFxuICAgICdncnBjLnNlcnZpY2VfY29uZmlnJzogdHJ1ZSxcbiAgICAnZ3JwYy5tYXhfY29uY3VycmVudF9zdHJlYW1zJzogdHJ1ZSxcbiAgICAnZ3JwYy5pbml0aWFsX3JlY29ubmVjdF9iYWNrb2ZmX21zJzogdHJ1ZSxcbiAgICAnZ3JwYy5tYXhfcmVjb25uZWN0X2JhY2tvZmZfbXMnOiB0cnVlLFxuICAgICdncnBjLnVzZV9sb2NhbF9zdWJjaGFubmVsX3Bvb2wnOiB0cnVlLFxuICAgICdncnBjLm1heF9zZW5kX21lc3NhZ2VfbGVuZ3RoJzogdHJ1ZSxcbiAgICAnZ3JwYy5tYXhfcmVjZWl2ZV9tZXNzYWdlX2xlbmd0aCc6IHRydWUsXG4gICAgJ2dycGMuZW5hYmxlX2h0dHBfcHJveHknOiB0cnVlLFxuICAgICdncnBjLmVuYWJsZV9jaGFubmVseic6IHRydWUsXG4gICAgJ2dycGMuZG5zX21pbl90aW1lX2JldHdlZW5fcmVzb2x1dGlvbnNfbXMnOiB0cnVlLFxuICAgICdncnBjLmVuYWJsZV9yZXRyaWVzJzogdHJ1ZSxcbiAgICAnZ3JwYy5wZXJfcnBjX3JldHJ5X2J1ZmZlcl9zaXplJzogdHJ1ZSxcbiAgICAnZ3JwYy5yZXRyeV9idWZmZXJfc2l6ZSc6IHRydWUsXG4gICAgJ2dycGMubWF4X2Nvbm5lY3Rpb25fYWdlX21zJzogdHJ1ZSxcbiAgICAnZ3JwYy5tYXhfY29ubmVjdGlvbl9hZ2VfZ3JhY2VfbXMnOiB0cnVlLFxuICAgICdncnBjLW5vZGUubWF4X3Nlc3Npb25fbWVtb3J5JzogdHJ1ZSxcbiAgICAnZ3JwYy5zZXJ2aWNlX2NvbmZpZ19kaXNhYmxlX3Jlc29sdXRpb24nOiB0cnVlLFxuICAgICdncnBjLmNsaWVudF9pZGxlX3RpbWVvdXRfbXMnOiB0cnVlLFxuICAgICdncnBjLW5vZGUudGxzX2VuYWJsZV90cmFjZSc6IHRydWUsXG4gICAgJ2dycGMubGIucmluZ19oYXNoLnJpbmdfc2l6ZV9jYXAnOiB0cnVlLFxuICAgICdncnBjLW5vZGUucmV0cnlfbWF4X2F0dGVtcHRzX2xpbWl0JzogdHJ1ZSxcbiAgICAnZ3JwYy1ub2RlLmZsb3dfY29udHJvbF93aW5kb3cnOiB0cnVlLFxufTtcbmZ1bmN0aW9uIGNoYW5uZWxPcHRpb25zRXF1YWwob3B0aW9uczEsIG9wdGlvbnMyKSB7XG4gICAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhvcHRpb25zMSkuc29ydCgpO1xuICAgIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXMob3B0aW9uczIpLnNvcnQoKTtcbiAgICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMxLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChrZXlzMVtpXSAhPT0ga2V5czJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9uczFba2V5czFbaV1dICE9PSBvcHRpb25zMltrZXlzMltpXV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5uZWwtb3B0aW9ucy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyZWNvZ25pemVkT3B0aW9ucyIsImNoYW5uZWxPcHRpb25zRXF1YWwiLCJvcHRpb25zMSIsIm9wdGlvbnMyIiwia2V5czEiLCJrZXlzIiwic29ydCIsImtleXMyIiwibGVuZ3RoIiwiaSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/channel.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ChannelImplementation = void 0;\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nconst internal_channel_1 = __webpack_require__(/*! ./internal-channel */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js\");\nclass ChannelImplementation {\n    constructor(target, credentials, options){\n        if (typeof target !== \"string\") {\n            throw new TypeError(\"Channel target must be a string\");\n        }\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n            throw new TypeError(\"Channel credentials must be a ChannelCredentials object\");\n        }\n        if (options) {\n            if (typeof options !== \"object\") {\n                throw new TypeError(\"Channel options must be an object\");\n            }\n        }\n        this.internalChannel = new internal_channel_1.InternalChannel(target, credentials, options);\n    }\n    close() {\n        this.internalChannel.close();\n    }\n    getTarget() {\n        return this.internalChannel.getTarget();\n    }\n    getConnectivityState(tryToConnect) {\n        return this.internalChannel.getConnectivityState(tryToConnect);\n    }\n    watchConnectivityState(currentState, deadline, callback) {\n        this.internalChannel.watchConnectivityState(currentState, deadline, callback);\n    }\n    /**\n     * Get the channelz reference object for this channel. The returned value is\n     * garbage if channelz is disabled for this channel.\n     * @returns\n     */ getChannelzRef() {\n        return this.internalChannel.getChannelzRef();\n    }\n    createCall(method, deadline, host, parentCall, propagateFlags) {\n        if (typeof method !== \"string\") {\n            throw new TypeError(\"Channel#createCall: method must be a string\");\n        }\n        if (!(typeof deadline === \"number\" || deadline instanceof Date)) {\n            throw new TypeError(\"Channel#createCall: deadline must be a number or Date\");\n        }\n        return this.internalChannel.createCall(method, deadline, host, parentCall, propagateFlags);\n    }\n}\nexports.ChannelImplementation = ChannelImplementation; //# sourceMappingURL=channel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNkJBQTZCLEdBQUcsS0FBSztBQUNyQyxNQUFNRyx3QkFBd0JDLG1CQUFPQSxDQUFDLGtHQUF1QjtBQUM3RCxNQUFNQyxxQkFBcUJELG1CQUFPQSxDQUFDLDRGQUFvQjtBQUN2RCxNQUFNRjtJQUNGSSxZQUFZQyxNQUFNLEVBQUVDLFdBQVcsRUFBRUMsT0FBTyxDQUFFO1FBQ3RDLElBQUksT0FBT0YsV0FBVyxVQUFVO1lBQzVCLE1BQU0sSUFBSUcsVUFBVTtRQUN4QjtRQUNBLElBQUksQ0FBRUYsQ0FBQUEsdUJBQXVCTCxzQkFBc0JRLGtCQUFrQixHQUFHO1lBQ3BFLE1BQU0sSUFBSUQsVUFBVTtRQUN4QjtRQUNBLElBQUlELFNBQVM7WUFDVCxJQUFJLE9BQU9BLFlBQVksVUFBVTtnQkFDN0IsTUFBTSxJQUFJQyxVQUFVO1lBQ3hCO1FBQ0o7UUFDQSxJQUFJLENBQUNFLGVBQWUsR0FBRyxJQUFJUCxtQkFBbUJRLGVBQWUsQ0FBQ04sUUFBUUMsYUFBYUM7SUFDdkY7SUFDQUssUUFBUTtRQUNKLElBQUksQ0FBQ0YsZUFBZSxDQUFDRSxLQUFLO0lBQzlCO0lBQ0FDLFlBQVk7UUFDUixPQUFPLElBQUksQ0FBQ0gsZUFBZSxDQUFDRyxTQUFTO0lBQ3pDO0lBQ0FDLHFCQUFxQkMsWUFBWSxFQUFFO1FBQy9CLE9BQU8sSUFBSSxDQUFDTCxlQUFlLENBQUNJLG9CQUFvQixDQUFDQztJQUNyRDtJQUNBQyx1QkFBdUJDLFlBQVksRUFBRUMsUUFBUSxFQUFFQyxRQUFRLEVBQUU7UUFDckQsSUFBSSxDQUFDVCxlQUFlLENBQUNNLHNCQUFzQixDQUFDQyxjQUFjQyxVQUFVQztJQUN4RTtJQUNBOzs7O0tBSUMsR0FDREMsaUJBQWlCO1FBQ2IsT0FBTyxJQUFJLENBQUNWLGVBQWUsQ0FBQ1UsY0FBYztJQUM5QztJQUNBQyxXQUFXQyxNQUFNLEVBQUVKLFFBQVEsRUFBRUssSUFBSSxFQUFFQyxVQUFVLEVBQUVDLGNBQWMsRUFBRTtRQUMzRCxJQUFJLE9BQU9ILFdBQVcsVUFBVTtZQUM1QixNQUFNLElBQUlkLFVBQVU7UUFDeEI7UUFDQSxJQUFJLENBQUUsUUFBT1UsYUFBYSxZQUFZQSxvQkFBb0JRLElBQUcsR0FBSTtZQUM3RCxNQUFNLElBQUlsQixVQUFVO1FBQ3hCO1FBQ0EsT0FBTyxJQUFJLENBQUNFLGVBQWUsQ0FBQ1csVUFBVSxDQUFDQyxRQUFRSixVQUFVSyxNQUFNQyxZQUFZQztJQUMvRTtBQUNKO0FBQ0EzQiw2QkFBNkIsR0FBR0UsdUJBQ2hDLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1ob3VzaW5nLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsLmpzP2NkOGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hhbm5lbEltcGxlbWVudGF0aW9uID0gdm9pZCAwO1xuY29uc3QgY2hhbm5lbF9jcmVkZW50aWFsc18xID0gcmVxdWlyZShcIi4vY2hhbm5lbC1jcmVkZW50aWFsc1wiKTtcbmNvbnN0IGludGVybmFsX2NoYW5uZWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsLWNoYW5uZWxcIik7XG5jbGFzcyBDaGFubmVsSW1wbGVtZW50YXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgY3JlZGVudGlhbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsIHRhcmdldCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoY3JlZGVudGlhbHMgaW5zdGFuY2VvZiBjaGFubmVsX2NyZWRlbnRpYWxzXzEuQ2hhbm5lbENyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCBjcmVkZW50aWFscyBtdXN0IGJlIGEgQ2hhbm5lbENyZWRlbnRpYWxzIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCBvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnRlcm5hbENoYW5uZWwgPSBuZXcgaW50ZXJuYWxfY2hhbm5lbF8xLkludGVybmFsQ2hhbm5lbCh0YXJnZXQsIGNyZWRlbnRpYWxzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxDaGFubmVsLmNsb3NlKCk7XG4gICAgfVxuICAgIGdldFRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxDaGFubmVsLmdldFRhcmdldCgpO1xuICAgIH1cbiAgICBnZXRDb25uZWN0aXZpdHlTdGF0ZSh0cnlUb0Nvbm5lY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxDaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKHRyeVRvQ29ubmVjdCk7XG4gICAgfVxuICAgIHdhdGNoQ29ubmVjdGl2aXR5U3RhdGUoY3VycmVudFN0YXRlLCBkZWFkbGluZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbENoYW5uZWwud2F0Y2hDb25uZWN0aXZpdHlTdGF0ZShjdXJyZW50U3RhdGUsIGRlYWRsaW5lLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2hhbm5lbHogcmVmZXJlbmNlIG9iamVjdCBmb3IgdGhpcyBjaGFubmVsLiBUaGUgcmV0dXJuZWQgdmFsdWUgaXNcbiAgICAgKiBnYXJiYWdlIGlmIGNoYW5uZWx6IGlzIGRpc2FibGVkIGZvciB0aGlzIGNoYW5uZWwuXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBnZXRDaGFubmVselJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxDaGFubmVsLmdldENoYW5uZWx6UmVmKCk7XG4gICAgfVxuICAgIGNyZWF0ZUNhbGwobWV0aG9kLCBkZWFkbGluZSwgaG9zdCwgcGFyZW50Q2FsbCwgcHJvcGFnYXRlRmxhZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsI2NyZWF0ZUNhbGw6IG1ldGhvZCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEodHlwZW9mIGRlYWRsaW5lID09PSAnbnVtYmVyJyB8fCBkZWFkbGluZSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsI2NyZWF0ZUNhbGw6IGRlYWRsaW5lIG11c3QgYmUgYSBudW1iZXIgb3IgRGF0ZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsQ2hhbm5lbC5jcmVhdGVDYWxsKG1ldGhvZCwgZGVhZGxpbmUsIGhvc3QsIHBhcmVudENhbGwsIHByb3BhZ2F0ZUZsYWdzKTtcbiAgICB9XG59XG5leHBvcnRzLkNoYW5uZWxJbXBsZW1lbnRhdGlvbiA9IENoYW5uZWxJbXBsZW1lbnRhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5uZWwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2hhbm5lbEltcGxlbWVudGF0aW9uIiwiY2hhbm5lbF9jcmVkZW50aWFsc18xIiwicmVxdWlyZSIsImludGVybmFsX2NoYW5uZWxfMSIsImNvbnN0cnVjdG9yIiwidGFyZ2V0IiwiY3JlZGVudGlhbHMiLCJvcHRpb25zIiwiVHlwZUVycm9yIiwiQ2hhbm5lbENyZWRlbnRpYWxzIiwiaW50ZXJuYWxDaGFubmVsIiwiSW50ZXJuYWxDaGFubmVsIiwiY2xvc2UiLCJnZXRUYXJnZXQiLCJnZXRDb25uZWN0aXZpdHlTdGF0ZSIsInRyeVRvQ29ubmVjdCIsIndhdGNoQ29ubmVjdGl2aXR5U3RhdGUiLCJjdXJyZW50U3RhdGUiLCJkZWFkbGluZSIsImNhbGxiYWNrIiwiZ2V0Q2hhbm5lbHpSZWYiLCJjcmVhdGVDYWxsIiwibWV0aG9kIiwiaG9zdCIsInBhcmVudENhbGwiLCJwcm9wYWdhdGVGbGFncyIsIkRhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/channel.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channelz.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTrackerStub = exports.ChannelzCallTracker = exports.ChannelzChildrenTrackerStub = exports.ChannelzChildrenTracker = exports.ChannelzTrace = exports.ChannelzTraceStub = void 0;\nexports.unregisterChannelzRef = unregisterChannelzRef;\nexports.getChannelzHandlers = getChannelzHandlers;\nexports.getChannelzServiceDefinition = getChannelzServiceDefinition;\nexports.setup = setup;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst ordered_map_1 = __webpack_require__(/*! @js-sdsl/ordered-map */ \"(rsc)/./node_modules/@js-sdsl/ordered-map/dist/esm/index.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst admin_1 = __webpack_require__(/*! ./admin */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\nfunction channelRefToMessage(ref) {\n    return {\n        channel_id: ref.id,\n        name: ref.name\n    };\n}\nfunction subchannelRefToMessage(ref) {\n    return {\n        subchannel_id: ref.id,\n        name: ref.name\n    };\n}\nfunction serverRefToMessage(ref) {\n    return {\n        server_id: ref.id\n    };\n}\nfunction socketRefToMessage(ref) {\n    return {\n        socket_id: ref.id,\n        name: ref.name\n    };\n}\n/**\n * The loose upper bound on the number of events that should be retained in a\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\n * number that should be large enough to contain the recent relevant\n * information, but small enough to not use excessive memory.\n */ const TARGET_RETAINED_TRACES = 32;\n/**\n * Default number of sockets/servers/channels/subchannels to return\n */ const DEFAULT_MAX_RESULTS = 100;\nclass ChannelzTraceStub {\n    constructor(){\n        this.events = [];\n        this.creationTimestamp = new Date();\n        this.eventsLogged = 0;\n    }\n    addTrace() {}\n    getTraceMessage() {\n        return {\n            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n            num_events_logged: this.eventsLogged,\n            events: []\n        };\n    }\n}\nexports.ChannelzTraceStub = ChannelzTraceStub;\nclass ChannelzTrace {\n    constructor(){\n        this.events = [];\n        this.eventsLogged = 0;\n        this.creationTimestamp = new Date();\n    }\n    addTrace(severity, description, child) {\n        const timestamp = new Date();\n        this.events.push({\n            description: description,\n            severity: severity,\n            timestamp: timestamp,\n            childChannel: (child === null || child === void 0 ? void 0 : child.kind) === \"channel\" ? child : undefined,\n            childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === \"subchannel\" ? child : undefined\n        });\n        // Whenever the trace array gets too large, discard the first half\n        if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\n            this.events = this.events.slice(TARGET_RETAINED_TRACES);\n        }\n        this.eventsLogged += 1;\n    }\n    getTraceMessage() {\n        return {\n            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n            num_events_logged: this.eventsLogged,\n            events: this.events.map((event)=>{\n                return {\n                    description: event.description,\n                    severity: event.severity,\n                    timestamp: dateToProtoTimestamp(event.timestamp),\n                    channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,\n                    subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null\n                };\n            })\n        };\n    }\n}\nexports.ChannelzTrace = ChannelzTrace;\nclass ChannelzChildrenTracker {\n    constructor(){\n        this.channelChildren = new ordered_map_1.OrderedMap();\n        this.subchannelChildren = new ordered_map_1.OrderedMap();\n        this.socketChildren = new ordered_map_1.OrderedMap();\n        this.trackerMap = {\n            [\"channel\" /* EntityTypes.channel */ ]: this.channelChildren,\n            [\"subchannel\" /* EntityTypes.subchannel */ ]: this.subchannelChildren,\n            [\"socket\" /* EntityTypes.socket */ ]: this.socketChildren\n        };\n    }\n    refChild(child) {\n        const tracker = this.trackerMap[child.kind];\n        const trackedChild = tracker.find(child.id);\n        if (trackedChild.equals(tracker.end())) {\n            tracker.setElement(child.id, {\n                ref: child,\n                count: 1\n            }, trackedChild);\n        } else {\n            trackedChild.pointer[1].count += 1;\n        }\n    }\n    unrefChild(child) {\n        const tracker = this.trackerMap[child.kind];\n        const trackedChild = tracker.getElementByKey(child.id);\n        if (trackedChild !== undefined) {\n            trackedChild.count -= 1;\n            if (trackedChild.count === 0) {\n                tracker.eraseElementByKey(child.id);\n            }\n        }\n    }\n    getChildLists() {\n        return {\n            channels: this.channelChildren,\n            subchannels: this.subchannelChildren,\n            sockets: this.socketChildren\n        };\n    }\n}\nexports.ChannelzChildrenTracker = ChannelzChildrenTracker;\nclass ChannelzChildrenTrackerStub extends ChannelzChildrenTracker {\n    refChild() {}\n    unrefChild() {}\n}\nexports.ChannelzChildrenTrackerStub = ChannelzChildrenTrackerStub;\nclass ChannelzCallTracker {\n    constructor(){\n        this.callsStarted = 0;\n        this.callsSucceeded = 0;\n        this.callsFailed = 0;\n        this.lastCallStartedTimestamp = null;\n    }\n    addCallStarted() {\n        this.callsStarted += 1;\n        this.lastCallStartedTimestamp = new Date();\n    }\n    addCallSucceeded() {\n        this.callsSucceeded += 1;\n    }\n    addCallFailed() {\n        this.callsFailed += 1;\n    }\n}\nexports.ChannelzCallTracker = ChannelzCallTracker;\nclass ChannelzCallTrackerStub extends ChannelzCallTracker {\n    addCallStarted() {}\n    addCallSucceeded() {}\n    addCallFailed() {}\n}\nexports.ChannelzCallTrackerStub = ChannelzCallTrackerStub;\nconst entityMaps = {\n    [\"channel\" /* EntityTypes.channel */ ]: new ordered_map_1.OrderedMap(),\n    [\"subchannel\" /* EntityTypes.subchannel */ ]: new ordered_map_1.OrderedMap(),\n    [\"server\" /* EntityTypes.server */ ]: new ordered_map_1.OrderedMap(),\n    [\"socket\" /* EntityTypes.socket */ ]: new ordered_map_1.OrderedMap()\n};\nconst generateRegisterFn = (kind)=>{\n    let nextId = 1;\n    function getNextId() {\n        return nextId++;\n    }\n    const entityMap = entityMaps[kind];\n    return (name, getInfo, channelzEnabled)=>{\n        const id = getNextId();\n        const ref = {\n            id,\n            name,\n            kind\n        };\n        if (channelzEnabled) {\n            entityMap.setElement(id, {\n                ref,\n                getInfo\n            });\n        }\n        return ref;\n    };\n};\nexports.registerChannelzChannel = generateRegisterFn(\"channel\" /* EntityTypes.channel */ );\nexports.registerChannelzSubchannel = generateRegisterFn(\"subchannel\" /* EntityTypes.subchannel */ );\nexports.registerChannelzServer = generateRegisterFn(\"server\" /* EntityTypes.server */ );\nexports.registerChannelzSocket = generateRegisterFn(\"socket\" /* EntityTypes.socket */ );\nfunction unregisterChannelzRef(ref) {\n    entityMaps[ref.kind].eraseElementByKey(ref.id);\n}\n/**\n * Parse a single section of an IPv6 address as two bytes\n * @param addressSection A hexadecimal string of length up to 4\n * @returns The pair of bytes representing this address section\n */ function parseIPv6Section(addressSection) {\n    const numberValue = Number.parseInt(addressSection, 16);\n    return [\n        numberValue / 256 | 0,\n        numberValue % 256\n    ];\n}\n/**\n * Parse a chunk of an IPv6 address string to some number of bytes\n * @param addressChunk Some number of segments of up to 4 hexadecimal\n *   characters each, joined by colons.\n * @returns The list of bytes representing this address chunk\n */ function parseIPv6Chunk(addressChunk) {\n    if (addressChunk === \"\") {\n        return [];\n    }\n    const bytePairs = addressChunk.split(\":\").map((section)=>parseIPv6Section(section));\n    const result = [];\n    return result.concat(...bytePairs);\n}\nfunction isIPv6MappedIPv4(ipAddress) {\n    return (0, net_1.isIPv6)(ipAddress) && ipAddress.toLowerCase().startsWith(\"::ffff:\") && (0, net_1.isIPv4)(ipAddress.substring(7));\n}\n/**\n * Prerequisite: isIPv4(ipAddress)\n * @param ipAddress\n * @returns\n */ function ipv4AddressStringToBuffer(ipAddress) {\n    return Buffer.from(Uint8Array.from(ipAddress.split(\".\").map((segment)=>Number.parseInt(segment))));\n}\n/**\n * Converts an IPv4 or IPv6 address from string representation to binary\n * representation\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\n * @returns\n */ function ipAddressStringToBuffer(ipAddress) {\n    if ((0, net_1.isIPv4)(ipAddress)) {\n        return ipv4AddressStringToBuffer(ipAddress);\n    } else if (isIPv6MappedIPv4(ipAddress)) {\n        return ipv4AddressStringToBuffer(ipAddress.substring(7));\n    } else if ((0, net_1.isIPv6)(ipAddress)) {\n        let leftSection;\n        let rightSection;\n        const doubleColonIndex = ipAddress.indexOf(\"::\");\n        if (doubleColonIndex === -1) {\n            leftSection = ipAddress;\n            rightSection = \"\";\n        } else {\n            leftSection = ipAddress.substring(0, doubleColonIndex);\n            rightSection = ipAddress.substring(doubleColonIndex + 2);\n        }\n        const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\n        const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\n        const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);\n        return Buffer.concat([\n            leftBuffer,\n            middleBuffer,\n            rightBuffer\n        ]);\n    } else {\n        return null;\n    }\n}\nfunction connectivityStateToMessage(state) {\n    switch(state){\n        case connectivity_state_1.ConnectivityState.CONNECTING:\n            return {\n                state: \"CONNECTING\"\n            };\n        case connectivity_state_1.ConnectivityState.IDLE:\n            return {\n                state: \"IDLE\"\n            };\n        case connectivity_state_1.ConnectivityState.READY:\n            return {\n                state: \"READY\"\n            };\n        case connectivity_state_1.ConnectivityState.SHUTDOWN:\n            return {\n                state: \"SHUTDOWN\"\n            };\n        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n            return {\n                state: \"TRANSIENT_FAILURE\"\n            };\n        default:\n            return {\n                state: \"UNKNOWN\"\n            };\n    }\n}\nfunction dateToProtoTimestamp(date) {\n    if (!date) {\n        return null;\n    }\n    const millisSinceEpoch = date.getTime();\n    return {\n        seconds: millisSinceEpoch / 1000 | 0,\n        nanos: millisSinceEpoch % 1000 * 1000000\n    };\n}\nfunction getChannelMessage(channelEntry) {\n    const resolvedInfo = channelEntry.getInfo();\n    const channelRef = [];\n    const subchannelRef = [];\n    resolvedInfo.children.channels.forEach((el)=>{\n        channelRef.push(channelRefToMessage(el[1].ref));\n    });\n    resolvedInfo.children.subchannels.forEach((el)=>{\n        subchannelRef.push(subchannelRefToMessage(el[1].ref));\n    });\n    return {\n        ref: channelRefToMessage(channelEntry.ref),\n        data: {\n            target: resolvedInfo.target,\n            state: connectivityStateToMessage(resolvedInfo.state),\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage()\n        },\n        channel_ref: channelRef,\n        subchannel_ref: subchannelRef\n    };\n}\nfunction GetChannel(call, callback) {\n    const channelId = parseInt(call.request.channel_id, 10);\n    const channelEntry = entityMaps[\"channel\" /* EntityTypes.channel */ ].getElementByKey(channelId);\n    if (channelEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: \"No channel data found for id \" + channelId\n        });\n        return;\n    }\n    callback(null, {\n        channel: getChannelMessage(channelEntry)\n    });\n}\nfunction GetTopChannels(call, callback) {\n    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;\n    const resultList = [];\n    const startId = parseInt(call.request.start_channel_id, 10);\n    const channelEntries = entityMaps[\"channel\" /* EntityTypes.channel */ ];\n    let i;\n    for(i = channelEntries.lowerBound(startId); !i.equals(channelEntries.end()) && resultList.length < maxResults; i = i.next()){\n        resultList.push(getChannelMessage(i.pointer[1]));\n    }\n    callback(null, {\n        channel: resultList,\n        end: i.equals(channelEntries.end())\n    });\n}\nfunction getServerMessage(serverEntry) {\n    const resolvedInfo = serverEntry.getInfo();\n    const listenSocket = [];\n    resolvedInfo.listenerChildren.sockets.forEach((el)=>{\n        listenSocket.push(socketRefToMessage(el[1].ref));\n    });\n    return {\n        ref: serverRefToMessage(serverEntry.ref),\n        data: {\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage()\n        },\n        listen_socket: listenSocket\n    };\n}\nfunction GetServer(call, callback) {\n    const serverId = parseInt(call.request.server_id, 10);\n    const serverEntries = entityMaps[\"server\" /* EntityTypes.server */ ];\n    const serverEntry = serverEntries.getElementByKey(serverId);\n    if (serverEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: \"No server data found for id \" + serverId\n        });\n        return;\n    }\n    callback(null, {\n        server: getServerMessage(serverEntry)\n    });\n}\nfunction GetServers(call, callback) {\n    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;\n    const startId = parseInt(call.request.start_server_id, 10);\n    const serverEntries = entityMaps[\"server\" /* EntityTypes.server */ ];\n    const resultList = [];\n    let i;\n    for(i = serverEntries.lowerBound(startId); !i.equals(serverEntries.end()) && resultList.length < maxResults; i = i.next()){\n        resultList.push(getServerMessage(i.pointer[1]));\n    }\n    callback(null, {\n        server: resultList,\n        end: i.equals(serverEntries.end())\n    });\n}\nfunction GetSubchannel(call, callback) {\n    const subchannelId = parseInt(call.request.subchannel_id, 10);\n    const subchannelEntry = entityMaps[\"subchannel\" /* EntityTypes.subchannel */ ].getElementByKey(subchannelId);\n    if (subchannelEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: \"No subchannel data found for id \" + subchannelId\n        });\n        return;\n    }\n    const resolvedInfo = subchannelEntry.getInfo();\n    const listenSocket = [];\n    resolvedInfo.children.sockets.forEach((el)=>{\n        listenSocket.push(socketRefToMessage(el[1].ref));\n    });\n    const subchannelMessage = {\n        ref: subchannelRefToMessage(subchannelEntry.ref),\n        data: {\n            target: resolvedInfo.target,\n            state: connectivityStateToMessage(resolvedInfo.state),\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage()\n        },\n        socket_ref: listenSocket\n    };\n    callback(null, {\n        subchannel: subchannelMessage\n    });\n}\nfunction subchannelAddressToAddressMessage(subchannelAddress) {\n    var _a;\n    if ((0, subchannel_address_1.isTcpSubchannelAddress)(subchannelAddress)) {\n        return {\n            address: \"tcpip_address\",\n            tcpip_address: {\n                ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : undefined,\n                port: subchannelAddress.port\n            }\n        };\n    } else {\n        return {\n            address: \"uds_address\",\n            uds_address: {\n                filename: subchannelAddress.path\n            }\n        };\n    }\n}\nfunction GetSocket(call, callback) {\n    var _a, _b, _c, _d, _e;\n    const socketId = parseInt(call.request.socket_id, 10);\n    const socketEntry = entityMaps[\"socket\" /* EntityTypes.socket */ ].getElementByKey(socketId);\n    if (socketEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: \"No socket data found for id \" + socketId\n        });\n        return;\n    }\n    const resolvedInfo = socketEntry.getInfo();\n    const securityMessage = resolvedInfo.security ? {\n        model: \"tls\",\n        tls: {\n            cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? \"standard_name\" : \"other_name\",\n            standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : undefined,\n            other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : undefined,\n            local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : undefined,\n            remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : undefined\n        }\n    } : null;\n    const socketMessage = {\n        ref: socketRefToMessage(socketEntry.ref),\n        local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,\n        remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,\n        remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : undefined,\n        security: securityMessage,\n        data: {\n            keep_alives_sent: resolvedInfo.keepAlivesSent,\n            streams_started: resolvedInfo.streamsStarted,\n            streams_succeeded: resolvedInfo.streamsSucceeded,\n            streams_failed: resolvedInfo.streamsFailed,\n            last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),\n            last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),\n            messages_received: resolvedInfo.messagesReceived,\n            messages_sent: resolvedInfo.messagesSent,\n            last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),\n            last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),\n            local_flow_control_window: resolvedInfo.localFlowControlWindow ? {\n                value: resolvedInfo.localFlowControlWindow\n            } : null,\n            remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? {\n                value: resolvedInfo.remoteFlowControlWindow\n            } : null\n        }\n    };\n    callback(null, {\n        socket: socketMessage\n    });\n}\nfunction GetServerSockets(call, callback) {\n    const serverId = parseInt(call.request.server_id, 10);\n    const serverEntry = entityMaps[\"server\" /* EntityTypes.server */ ].getElementByKey(serverId);\n    if (serverEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: \"No server data found for id \" + serverId\n        });\n        return;\n    }\n    const startId = parseInt(call.request.start_socket_id, 10);\n    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;\n    const resolvedInfo = serverEntry.getInfo();\n    // If we wanted to include listener sockets in the result, this line would\n    // instead say\n    // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\n    const allSockets = resolvedInfo.sessionChildren.sockets;\n    const resultList = [];\n    let i;\n    for(i = allSockets.lowerBound(startId); !i.equals(allSockets.end()) && resultList.length < maxResults; i = i.next()){\n        resultList.push(socketRefToMessage(i.pointer[1].ref));\n    }\n    callback(null, {\n        socket_ref: resultList,\n        end: i.equals(allSockets.end())\n    });\n}\nfunction getChannelzHandlers() {\n    return {\n        GetChannel,\n        GetTopChannels,\n        GetServer,\n        GetServers,\n        GetSubchannel,\n        GetSocket,\n        GetServerSockets\n    };\n}\nlet loadedChannelzDefinition = null;\nfunction getChannelzServiceDefinition() {\n    if (loadedChannelzDefinition) {\n        return loadedChannelzDefinition;\n    }\n    /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n     * runtime for users who will not use/enable channelz. */ const loaderLoadSync = (__webpack_require__(/*! @grpc/proto-loader */ \"(rsc)/./node_modules/@grpc/proto-loader/build/src/index.js\").loadSync);\n    const loadedProto = loaderLoadSync(\"channelz.proto\", {\n        keepCase: true,\n        longs: String,\n        enums: String,\n        defaults: true,\n        oneofs: true,\n        includeDirs: [\n            `${__dirname}/../../proto`\n        ]\n    });\n    const channelzGrpcObject = (0, make_client_1.loadPackageDefinition)(loadedProto);\n    loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;\n    return loadedChannelzDefinition;\n}\nfunction setup() {\n    (0, admin_1.registerAdminService)(getChannelzServiceDefinition, getChannelzHandlers);\n} //# sourceMappingURL=channelz.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbHouanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDhCQUE4QixHQUFHQSw4QkFBOEIsR0FBR0Esa0NBQWtDLEdBQUdBLCtCQUErQixHQUFHQSwrQkFBK0IsR0FBR0EsMkJBQTJCLEdBQUdBLG1DQUFtQyxHQUFHQSwrQkFBK0IsR0FBR0EscUJBQXFCLEdBQUdBLHlCQUF5QixHQUFHLEtBQUs7QUFDMVVBLDZCQUE2QixHQUFHWTtBQUNoQ1osMkJBQTJCLEdBQUdhO0FBQzlCYixvQ0FBb0MsR0FBR2M7QUFDdkNkLGFBQWEsR0FBR2U7QUFDaEIsTUFBTUMsUUFBUUMsbUJBQU9BLENBQUMsZ0JBQUs7QUFDM0IsTUFBTUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQyx5RkFBc0I7QUFDcEQsTUFBTUUsdUJBQXVCRixtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTUcsY0FBY0gsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUksdUJBQXVCSixtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTUssVUFBVUwsbUJBQU9BLENBQUMsc0VBQVM7QUFDakMsTUFBTU0sZ0JBQWdCTixtQkFBT0EsQ0FBQyxrRkFBZTtBQUM3QyxTQUFTTyxvQkFBb0JDLEdBQUc7SUFDNUIsT0FBTztRQUNIQyxZQUFZRCxJQUFJRSxFQUFFO1FBQ2xCQyxNQUFNSCxJQUFJRyxJQUFJO0lBQ2xCO0FBQ0o7QUFDQSxTQUFTQyx1QkFBdUJKLEdBQUc7SUFDL0IsT0FBTztRQUNISyxlQUFlTCxJQUFJRSxFQUFFO1FBQ3JCQyxNQUFNSCxJQUFJRyxJQUFJO0lBQ2xCO0FBQ0o7QUFDQSxTQUFTRyxtQkFBbUJOLEdBQUc7SUFDM0IsT0FBTztRQUNITyxXQUFXUCxJQUFJRSxFQUFFO0lBQ3JCO0FBQ0o7QUFD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bUJFLElBQUksQ0FBQ0MsUUFBUSxDQUFDQyxFQUFFLENBQUNDLFFBQVEsQ0FBQ0MsT0FBTztJQUN4RCxPQUFPbEI7QUFDWDtBQUNBLFNBQVN6UDtJQUNKLElBQUdPLFFBQVFxUSxvQkFBb0IsRUFBRTdRLDhCQUE4QkQ7QUFDcEUsRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbHouanM/NjI3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U29ja2V0ID0gZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U2VydmVyID0gZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbCA9IGV4cG9ydHMucmVnaXN0ZXJDaGFubmVsekNoYW5uZWwgPSBleHBvcnRzLkNoYW5uZWx6Q2FsbFRyYWNrZXJTdHViID0gZXhwb3J0cy5DaGFubmVsekNhbGxUcmFja2VyID0gZXhwb3J0cy5DaGFubmVsekNoaWxkcmVuVHJhY2tlclN0dWIgPSBleHBvcnRzLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyID0gZXhwb3J0cy5DaGFubmVselRyYWNlID0gZXhwb3J0cy5DaGFubmVselRyYWNlU3R1YiA9IHZvaWQgMDtcbmV4cG9ydHMudW5yZWdpc3RlckNoYW5uZWx6UmVmID0gdW5yZWdpc3RlckNoYW5uZWx6UmVmO1xuZXhwb3J0cy5nZXRDaGFubmVsekhhbmRsZXJzID0gZ2V0Q2hhbm5lbHpIYW5kbGVycztcbmV4cG9ydHMuZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvbiA9IGdldENoYW5uZWx6U2VydmljZURlZmluaXRpb247XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG5jb25zdCBuZXRfMSA9IHJlcXVpcmUoXCJuZXRcIik7XG5jb25zdCBvcmRlcmVkX21hcF8xID0gcmVxdWlyZShcIkBqcy1zZHNsL29yZGVyZWQtbWFwXCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgYWRtaW5fMSA9IHJlcXVpcmUoXCIuL2FkbWluXCIpO1xuY29uc3QgbWFrZV9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL21ha2UtY2xpZW50XCIpO1xuZnVuY3Rpb24gY2hhbm5lbFJlZlRvTWVzc2FnZShyZWYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFubmVsX2lkOiByZWYuaWQsXG4gICAgICAgIG5hbWU6IHJlZi5uYW1lLFxuICAgIH07XG59XG5mdW5jdGlvbiBzdWJjaGFubmVsUmVmVG9NZXNzYWdlKHJlZikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YmNoYW5uZWxfaWQ6IHJlZi5pZCxcbiAgICAgICAgbmFtZTogcmVmLm5hbWUsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNlcnZlclJlZlRvTWVzc2FnZShyZWYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZXJ2ZXJfaWQ6IHJlZi5pZCxcbiAgICB9O1xufVxuZnVuY3Rpb24gc29ja2V0UmVmVG9NZXNzYWdlKHJlZikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNvY2tldF9pZDogcmVmLmlkLFxuICAgICAgICBuYW1lOiByZWYubmFtZSxcbiAgICB9O1xufVxuLyoqXG4gKiBUaGUgbG9vc2UgdXBwZXIgYm91bmQgb24gdGhlIG51bWJlciBvZiBldmVudHMgdGhhdCBzaG91bGQgYmUgcmV0YWluZWQgaW4gYVxuICogdHJhY2UuIFRoaXMgbWF5IGJlIGV4Y2VlZGVkIGJ5IHVwIHRvIGEgZmFjdG9yIG9mIDIuIEFyYml0cmFyaWx5IGNob3NlbiBhcyBhXG4gKiBudW1iZXIgdGhhdCBzaG91bGQgYmUgbGFyZ2UgZW5vdWdoIHRvIGNvbnRhaW4gdGhlIHJlY2VudCByZWxldmFudFxuICogaW5mb3JtYXRpb24sIGJ1dCBzbWFsbCBlbm91Z2ggdG8gbm90IHVzZSBleGNlc3NpdmUgbWVtb3J5LlxuICovXG5jb25zdCBUQVJHRVRfUkVUQUlORURfVFJBQ0VTID0gMzI7XG4vKipcbiAqIERlZmF1bHQgbnVtYmVyIG9mIHNvY2tldHMvc2VydmVycy9jaGFubmVscy9zdWJjaGFubmVscyB0byByZXR1cm5cbiAqL1xuY29uc3QgREVGQVVMVF9NQVhfUkVTVUxUUyA9IDEwMDtcbmNsYXNzIENoYW5uZWx6VHJhY2VTdHViIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5jcmVhdGlvblRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMuZXZlbnRzTG9nZ2VkID0gMDtcbiAgICB9XG4gICAgYWRkVHJhY2UoKSB7IH1cbiAgICBnZXRUcmFjZU1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGlvbl90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHRoaXMuY3JlYXRpb25UaW1lc3RhbXApLFxuICAgICAgICAgICAgbnVtX2V2ZW50c19sb2dnZWQ6IHRoaXMuZXZlbnRzTG9nZ2VkLFxuICAgICAgICAgICAgZXZlbnRzOiBbXSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkNoYW5uZWx6VHJhY2VTdHViID0gQ2hhbm5lbHpUcmFjZVN0dWI7XG5jbGFzcyBDaGFubmVselRyYWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5ldmVudHNMb2dnZWQgPSAwO1xuICAgICAgICB0aGlzLmNyZWF0aW9uVGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgYWRkVHJhY2Uoc2V2ZXJpdHksIGRlc2NyaXB0aW9uLCBjaGlsZCkge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHNldmVyaXR5OiBzZXZlcml0eSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgICAgICAgICAgY2hpbGRDaGFubmVsOiAoY2hpbGQgPT09IG51bGwgfHwgY2hpbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoaWxkLmtpbmQpID09PSAnY2hhbm5lbCcgPyBjaGlsZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNoaWxkU3ViY2hhbm5lbDogKGNoaWxkID09PSBudWxsIHx8IGNoaWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGlsZC5raW5kKSA9PT0gJ3N1YmNoYW5uZWwnID8gY2hpbGQgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXaGVuZXZlciB0aGUgdHJhY2UgYXJyYXkgZ2V0cyB0b28gbGFyZ2UsIGRpc2NhcmQgdGhlIGZpcnN0IGhhbGZcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmxlbmd0aCA+PSBUQVJHRVRfUkVUQUlORURfVFJBQ0VTICogMikge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLmV2ZW50cy5zbGljZShUQVJHRVRfUkVUQUlORURfVFJBQ0VTKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50c0xvZ2dlZCArPSAxO1xuICAgIH1cbiAgICBnZXRUcmFjZU1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGlvbl90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHRoaXMuY3JlYXRpb25UaW1lc3RhbXApLFxuICAgICAgICAgICAgbnVtX2V2ZW50c19sb2dnZWQ6IHRoaXMuZXZlbnRzTG9nZ2VkLFxuICAgICAgICAgICAgZXZlbnRzOiB0aGlzLmV2ZW50cy5tYXAoZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBldmVudC5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2V2ZXJpdHk6IGV2ZW50LnNldmVyaXR5LFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKGV2ZW50LnRpbWVzdGFtcCksXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxfcmVmOiBldmVudC5jaGlsZENoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2hhbm5lbFJlZlRvTWVzc2FnZShldmVudC5jaGlsZENoYW5uZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxfcmVmOiBldmVudC5jaGlsZFN1YmNoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc3ViY2hhbm5lbFJlZlRvTWVzc2FnZShldmVudC5jaGlsZFN1YmNoYW5uZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbHpUcmFjZSA9IENoYW5uZWx6VHJhY2U7XG5jbGFzcyBDaGFubmVsekNoaWxkcmVuVHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbENoaWxkcmVuID0gbmV3IG9yZGVyZWRfbWFwXzEuT3JkZXJlZE1hcCgpO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbiA9IG5ldyBvcmRlcmVkX21hcF8xLk9yZGVyZWRNYXAoKTtcbiAgICAgICAgdGhpcy5zb2NrZXRDaGlsZHJlbiA9IG5ldyBvcmRlcmVkX21hcF8xLk9yZGVyZWRNYXAoKTtcbiAgICAgICAgdGhpcy50cmFja2VyTWFwID0ge1xuICAgICAgICAgICAgW1wiY2hhbm5lbFwiIC8qIEVudGl0eVR5cGVzLmNoYW5uZWwgKi9dOiB0aGlzLmNoYW5uZWxDaGlsZHJlbixcbiAgICAgICAgICAgIFtcInN1YmNoYW5uZWxcIiAvKiBFbnRpdHlUeXBlcy5zdWJjaGFubmVsICovXTogdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4sXG4gICAgICAgICAgICBbXCJzb2NrZXRcIiAvKiBFbnRpdHlUeXBlcy5zb2NrZXQgKi9dOiB0aGlzLnNvY2tldENoaWxkcmVuLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZWZDaGlsZChjaGlsZCkge1xuICAgICAgICBjb25zdCB0cmFja2VyID0gdGhpcy50cmFja2VyTWFwW2NoaWxkLmtpbmRdO1xuICAgICAgICBjb25zdCB0cmFja2VkQ2hpbGQgPSB0cmFja2VyLmZpbmQoY2hpbGQuaWQpO1xuICAgICAgICBpZiAodHJhY2tlZENoaWxkLmVxdWFscyh0cmFja2VyLmVuZCgpKSkge1xuICAgICAgICAgICAgdHJhY2tlci5zZXRFbGVtZW50KGNoaWxkLmlkLCB7XG4gICAgICAgICAgICAgICAgcmVmOiBjaGlsZCxcbiAgICAgICAgICAgICAgICBjb3VudDogMSxcbiAgICAgICAgICAgIH0sIHRyYWNrZWRDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cmFja2VkQ2hpbGQucG9pbnRlclsxXS5jb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVucmVmQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgY29uc3QgdHJhY2tlciA9IHRoaXMudHJhY2tlck1hcFtjaGlsZC5raW5kXTtcbiAgICAgICAgY29uc3QgdHJhY2tlZENoaWxkID0gdHJhY2tlci5nZXRFbGVtZW50QnlLZXkoY2hpbGQuaWQpO1xuICAgICAgICBpZiAodHJhY2tlZENoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyYWNrZWRDaGlsZC5jb3VudCAtPSAxO1xuICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZC5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRyYWNrZXIuZXJhc2VFbGVtZW50QnlLZXkoY2hpbGQuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldENoaWxkTGlzdHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFubmVsczogdGhpcy5jaGFubmVsQ2hpbGRyZW4sXG4gICAgICAgICAgICBzdWJjaGFubmVsczogdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4sXG4gICAgICAgICAgICBzb2NrZXRzOiB0aGlzLnNvY2tldENoaWxkcmVuLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXIgPSBDaGFubmVsekNoaWxkcmVuVHJhY2tlcjtcbmNsYXNzIENoYW5uZWx6Q2hpbGRyZW5UcmFja2VyU3R1YiBleHRlbmRzIENoYW5uZWx6Q2hpbGRyZW5UcmFja2VyIHtcbiAgICByZWZDaGlsZCgpIHsgfVxuICAgIHVucmVmQ2hpbGQoKSB7IH1cbn1cbmV4cG9ydHMuQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXJTdHViID0gQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXJTdHViO1xuY2xhc3MgQ2hhbm5lbHpDYWxsVHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2FsbHNTdGFydGVkID0gMDtcbiAgICAgICAgdGhpcy5jYWxsc1N1Y2NlZWRlZCA9IDA7XG4gICAgICAgIHRoaXMuY2FsbHNGYWlsZWQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCA9IG51bGw7XG4gICAgfVxuICAgIGFkZENhbGxTdGFydGVkKCkge1xuICAgICAgICB0aGlzLmNhbGxzU3RhcnRlZCArPSAxO1xuICAgICAgICB0aGlzLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgfVxuICAgIGFkZENhbGxTdWNjZWVkZWQoKSB7XG4gICAgICAgIHRoaXMuY2FsbHNTdWNjZWVkZWQgKz0gMTtcbiAgICB9XG4gICAgYWRkQ2FsbEZhaWxlZCgpIHtcbiAgICAgICAgdGhpcy5jYWxsc0ZhaWxlZCArPSAxO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbHpDYWxsVHJhY2tlciA9IENoYW5uZWx6Q2FsbFRyYWNrZXI7XG5jbGFzcyBDaGFubmVsekNhbGxUcmFja2VyU3R1YiBleHRlbmRzIENoYW5uZWx6Q2FsbFRyYWNrZXIge1xuICAgIGFkZENhbGxTdGFydGVkKCkgeyB9XG4gICAgYWRkQ2FsbFN1Y2NlZWRlZCgpIHsgfVxuICAgIGFkZENhbGxGYWlsZWQoKSB7IH1cbn1cbmV4cG9ydHMuQ2hhbm5lbHpDYWxsVHJhY2tlclN0dWIgPSBDaGFubmVsekNhbGxUcmFja2VyU3R1YjtcbmNvbnN0IGVudGl0eU1hcHMgPSB7XG4gICAgW1wiY2hhbm5lbFwiIC8qIEVudGl0eVR5cGVzLmNoYW5uZWwgKi9dOiBuZXcgb3JkZXJlZF9tYXBfMS5PcmRlcmVkTWFwKCksXG4gICAgW1wic3ViY2hhbm5lbFwiIC8qIEVudGl0eVR5cGVzLnN1YmNoYW5uZWwgKi9dOiBuZXcgb3JkZXJlZF9tYXBfMS5PcmRlcmVkTWFwKCksXG4gICAgW1wic2VydmVyXCIgLyogRW50aXR5VHlwZXMuc2VydmVyICovXTogbmV3IG9yZGVyZWRfbWFwXzEuT3JkZXJlZE1hcCgpLFxuICAgIFtcInNvY2tldFwiIC8qIEVudGl0eVR5cGVzLnNvY2tldCAqL106IG5ldyBvcmRlcmVkX21hcF8xLk9yZGVyZWRNYXAoKSxcbn07XG5jb25zdCBnZW5lcmF0ZVJlZ2lzdGVyRm4gPSAoa2luZCkgPT4ge1xuICAgIGxldCBuZXh0SWQgPSAxO1xuICAgIGZ1bmN0aW9uIGdldE5leHRJZCgpIHtcbiAgICAgICAgcmV0dXJuIG5leHRJZCsrO1xuICAgIH1cbiAgICBjb25zdCBlbnRpdHlNYXAgPSBlbnRpdHlNYXBzW2tpbmRdO1xuICAgIHJldHVybiAobmFtZSwgZ2V0SW5mbywgY2hhbm5lbHpFbmFibGVkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gZ2V0TmV4dElkKCk7XG4gICAgICAgIGNvbnN0IHJlZiA9IHsgaWQsIG5hbWUsIGtpbmQgfTtcbiAgICAgICAgaWYgKGNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgZW50aXR5TWFwLnNldEVsZW1lbnQoaWQsIHsgcmVmLCBnZXRJbmZvIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWY7XG4gICAgfTtcbn07XG5leHBvcnRzLnJlZ2lzdGVyQ2hhbm5lbHpDaGFubmVsID0gZ2VuZXJhdGVSZWdpc3RlckZuKFwiY2hhbm5lbFwiIC8qIEVudGl0eVR5cGVzLmNoYW5uZWwgKi8pO1xuZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbCA9IGdlbmVyYXRlUmVnaXN0ZXJGbihcInN1YmNoYW5uZWxcIiAvKiBFbnRpdHlUeXBlcy5zdWJjaGFubmVsICovKTtcbmV4cG9ydHMucmVnaXN0ZXJDaGFubmVselNlcnZlciA9IGdlbmVyYXRlUmVnaXN0ZXJGbihcInNlcnZlclwiIC8qIEVudGl0eVR5cGVzLnNlcnZlciAqLyk7XG5leHBvcnRzLnJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQgPSBnZW5lcmF0ZVJlZ2lzdGVyRm4oXCJzb2NrZXRcIiAvKiBFbnRpdHlUeXBlcy5zb2NrZXQgKi8pO1xuZnVuY3Rpb24gdW5yZWdpc3RlckNoYW5uZWx6UmVmKHJlZikge1xuICAgIGVudGl0eU1hcHNbcmVmLmtpbmRdLmVyYXNlRWxlbWVudEJ5S2V5KHJlZi5pZCk7XG59XG4vKipcbiAqIFBhcnNlIGEgc2luZ2xlIHNlY3Rpb24gb2YgYW4gSVB2NiBhZGRyZXNzIGFzIHR3byBieXRlc1xuICogQHBhcmFtIGFkZHJlc3NTZWN0aW9uIEEgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIGxlbmd0aCB1cCB0byA0XG4gKiBAcmV0dXJucyBUaGUgcGFpciBvZiBieXRlcyByZXByZXNlbnRpbmcgdGhpcyBhZGRyZXNzIHNlY3Rpb25cbiAqL1xuZnVuY3Rpb24gcGFyc2VJUHY2U2VjdGlvbihhZGRyZXNzU2VjdGlvbikge1xuICAgIGNvbnN0IG51bWJlclZhbHVlID0gTnVtYmVyLnBhcnNlSW50KGFkZHJlc3NTZWN0aW9uLCAxNik7XG4gICAgcmV0dXJuIFsobnVtYmVyVmFsdWUgLyAyNTYpIHwgMCwgbnVtYmVyVmFsdWUgJSAyNTZdO1xufVxuLyoqXG4gKiBQYXJzZSBhIGNodW5rIG9mIGFuIElQdjYgYWRkcmVzcyBzdHJpbmcgdG8gc29tZSBudW1iZXIgb2YgYnl0ZXNcbiAqIEBwYXJhbSBhZGRyZXNzQ2h1bmsgU29tZSBudW1iZXIgb2Ygc2VnbWVudHMgb2YgdXAgdG8gNCBoZXhhZGVjaW1hbFxuICogICBjaGFyYWN0ZXJzIGVhY2gsIGpvaW5lZCBieSBjb2xvbnMuXG4gKiBAcmV0dXJucyBUaGUgbGlzdCBvZiBieXRlcyByZXByZXNlbnRpbmcgdGhpcyBhZGRyZXNzIGNodW5rXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSVB2NkNodW5rKGFkZHJlc3NDaHVuaykge1xuICAgIGlmIChhZGRyZXNzQ2h1bmsgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgYnl0ZVBhaXJzID0gYWRkcmVzc0NodW5rXG4gICAgICAgIC5zcGxpdCgnOicpXG4gICAgICAgIC5tYXAoc2VjdGlvbiA9PiBwYXJzZUlQdjZTZWN0aW9uKHNlY3Rpb24pKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICByZXR1cm4gcmVzdWx0LmNvbmNhdCguLi5ieXRlUGFpcnMpO1xufVxuZnVuY3Rpb24gaXNJUHY2TWFwcGVkSVB2NChpcEFkZHJlc3MpIHtcbiAgICByZXR1cm4gKDAsIG5ldF8xLmlzSVB2NikoaXBBZGRyZXNzKSAmJiBpcEFkZHJlc3MudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCc6OmZmZmY6JykgJiYgKDAsIG5ldF8xLmlzSVB2NCkoaXBBZGRyZXNzLnN1YnN0cmluZyg3KSk7XG59XG4vKipcbiAqIFByZXJlcXVpc2l0ZTogaXNJUHY0KGlwQWRkcmVzcylcbiAqIEBwYXJhbSBpcEFkZHJlc3NcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGlwdjRBZGRyZXNzU3RyaW5nVG9CdWZmZXIoaXBBZGRyZXNzKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFVpbnQ4QXJyYXkuZnJvbShpcEFkZHJlc3Muc3BsaXQoJy4nKS5tYXAoc2VnbWVudCA9PiBOdW1iZXIucGFyc2VJbnQoc2VnbWVudCkpKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIElQdjQgb3IgSVB2NiBhZGRyZXNzIGZyb20gc3RyaW5nIHJlcHJlc2VudGF0aW9uIHRvIGJpbmFyeVxuICogcmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSBpcEFkZHJlc3MgYW4gSVAgYWRkcmVzcyBpbiBzdGFuZGFyZCBJUHY0IG9yIElQdjYgdGV4dCBmb3JtYXRcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGlwQWRkcmVzc1N0cmluZ1RvQnVmZmVyKGlwQWRkcmVzcykge1xuICAgIGlmICgoMCwgbmV0XzEuaXNJUHY0KShpcEFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBpcHY0QWRkcmVzc1N0cmluZ1RvQnVmZmVyKGlwQWRkcmVzcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzSVB2Nk1hcHBlZElQdjQoaXBBZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4gaXB2NEFkZHJlc3NTdHJpbmdUb0J1ZmZlcihpcEFkZHJlc3Muc3Vic3RyaW5nKDcpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIG5ldF8xLmlzSVB2NikoaXBBZGRyZXNzKSkge1xuICAgICAgICBsZXQgbGVmdFNlY3Rpb247XG4gICAgICAgIGxldCByaWdodFNlY3Rpb247XG4gICAgICAgIGNvbnN0IGRvdWJsZUNvbG9uSW5kZXggPSBpcEFkZHJlc3MuaW5kZXhPZignOjonKTtcbiAgICAgICAgaWYgKGRvdWJsZUNvbG9uSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBsZWZ0U2VjdGlvbiA9IGlwQWRkcmVzcztcbiAgICAgICAgICAgIHJpZ2h0U2VjdGlvbiA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGVmdFNlY3Rpb24gPSBpcEFkZHJlc3Muc3Vic3RyaW5nKDAsIGRvdWJsZUNvbG9uSW5kZXgpO1xuICAgICAgICAgICAgcmlnaHRTZWN0aW9uID0gaXBBZGRyZXNzLnN1YnN0cmluZyhkb3VibGVDb2xvbkluZGV4ICsgMik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVmdEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHBhcnNlSVB2NkNodW5rKGxlZnRTZWN0aW9uKSk7XG4gICAgICAgIGNvbnN0IHJpZ2h0QnVmZmVyID0gQnVmZmVyLmZyb20ocGFyc2VJUHY2Q2h1bmsocmlnaHRTZWN0aW9uKSk7XG4gICAgICAgIGNvbnN0IG1pZGRsZUJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNiAtIGxlZnRCdWZmZXIubGVuZ3RoIC0gcmlnaHRCdWZmZXIubGVuZ3RoLCAwKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2xlZnRCdWZmZXIsIG1pZGRsZUJ1ZmZlciwgcmlnaHRCdWZmZXJdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbm5lY3Rpdml0eVN0YXRlVG9NZXNzYWdlKHN0YXRlKSB7XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnQ09OTkVDVElORycsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnSURMRScsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ1JFQURZJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV046XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnU0hVVERPV04nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRTpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdUUkFOU0lFTlRfRkFJTFVSRScsXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ1VOS05PV04nLFxuICAgICAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBkYXRlVG9Qcm90b1RpbWVzdGFtcChkYXRlKSB7XG4gICAgaWYgKCFkYXRlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBtaWxsaXNTaW5jZUVwb2NoID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2Vjb25kczogKG1pbGxpc1NpbmNlRXBvY2ggLyAxMDAwKSB8IDAsXG4gICAgICAgIG5hbm9zOiAobWlsbGlzU2luY2VFcG9jaCAlIDEwMDApICogMTAwMDAwMCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2hhbm5lbE1lc3NhZ2UoY2hhbm5lbEVudHJ5KSB7XG4gICAgY29uc3QgcmVzb2x2ZWRJbmZvID0gY2hhbm5lbEVudHJ5LmdldEluZm8oKTtcbiAgICBjb25zdCBjaGFubmVsUmVmID0gW107XG4gICAgY29uc3Qgc3ViY2hhbm5lbFJlZiA9IFtdO1xuICAgIHJlc29sdmVkSW5mby5jaGlsZHJlbi5jaGFubmVscy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgY2hhbm5lbFJlZi5wdXNoKGNoYW5uZWxSZWZUb01lc3NhZ2UoZWxbMV0ucmVmKSk7XG4gICAgfSk7XG4gICAgcmVzb2x2ZWRJbmZvLmNoaWxkcmVuLnN1YmNoYW5uZWxzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBzdWJjaGFubmVsUmVmLnB1c2goc3ViY2hhbm5lbFJlZlRvTWVzc2FnZShlbFsxXS5yZWYpKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWY6IGNoYW5uZWxSZWZUb01lc3NhZ2UoY2hhbm5lbEVudHJ5LnJlZiksXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHRhcmdldDogcmVzb2x2ZWRJbmZvLnRhcmdldCxcbiAgICAgICAgICAgIHN0YXRlOiBjb25uZWN0aXZpdHlTdGF0ZVRvTWVzc2FnZShyZXNvbHZlZEluZm8uc3RhdGUpLFxuICAgICAgICAgICAgY2FsbHNfc3RhcnRlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzU3RhcnRlZCxcbiAgICAgICAgICAgIGNhbGxzX3N1Y2NlZWRlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzU3VjY2VlZGVkLFxuICAgICAgICAgICAgY2FsbHNfZmFpbGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNGYWlsZWQsXG4gICAgICAgICAgICBsYXN0X2NhbGxfc3RhcnRlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5sYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXApLFxuICAgICAgICAgICAgdHJhY2U6IHJlc29sdmVkSW5mby50cmFjZS5nZXRUcmFjZU1lc3NhZ2UoKSxcbiAgICAgICAgfSxcbiAgICAgICAgY2hhbm5lbF9yZWY6IGNoYW5uZWxSZWYsXG4gICAgICAgIHN1YmNoYW5uZWxfcmVmOiBzdWJjaGFubmVsUmVmLFxuICAgIH07XG59XG5mdW5jdGlvbiBHZXRDaGFubmVsKGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY2hhbm5lbElkID0gcGFyc2VJbnQoY2FsbC5yZXF1ZXN0LmNoYW5uZWxfaWQsIDEwKTtcbiAgICBjb25zdCBjaGFubmVsRW50cnkgPSBlbnRpdHlNYXBzW1wiY2hhbm5lbFwiIC8qIEVudGl0eVR5cGVzLmNoYW5uZWwgKi9dLmdldEVsZW1lbnRCeUtleShjaGFubmVsSWQpO1xuICAgIGlmIChjaGFubmVsRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgICAgICAgICAgZGV0YWlsczogJ05vIGNoYW5uZWwgZGF0YSBmb3VuZCBmb3IgaWQgJyArIGNoYW5uZWxJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgeyBjaGFubmVsOiBnZXRDaGFubmVsTWVzc2FnZShjaGFubmVsRW50cnkpIH0pO1xufVxuZnVuY3Rpb24gR2V0VG9wQ2hhbm5lbHMoY2FsbCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBtYXhSZXN1bHRzID0gcGFyc2VJbnQoY2FsbC5yZXF1ZXN0Lm1heF9yZXN1bHRzLCAxMCkgfHwgREVGQVVMVF9NQVhfUkVTVUxUUztcbiAgICBjb25zdCByZXN1bHRMaXN0ID0gW107XG4gICAgY29uc3Qgc3RhcnRJZCA9IHBhcnNlSW50KGNhbGwucmVxdWVzdC5zdGFydF9jaGFubmVsX2lkLCAxMCk7XG4gICAgY29uc3QgY2hhbm5lbEVudHJpZXMgPSBlbnRpdHlNYXBzW1wiY2hhbm5lbFwiIC8qIEVudGl0eVR5cGVzLmNoYW5uZWwgKi9dO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IGNoYW5uZWxFbnRyaWVzLmxvd2VyQm91bmQoc3RhcnRJZCk7ICFpLmVxdWFscyhjaGFubmVsRW50cmllcy5lbmQoKSkgJiYgcmVzdWx0TGlzdC5sZW5ndGggPCBtYXhSZXN1bHRzOyBpID0gaS5uZXh0KCkpIHtcbiAgICAgICAgcmVzdWx0TGlzdC5wdXNoKGdldENoYW5uZWxNZXNzYWdlKGkucG9pbnRlclsxXSkpO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgIGNoYW5uZWw6IHJlc3VsdExpc3QsXG4gICAgICAgIGVuZDogaS5lcXVhbHMoY2hhbm5lbEVudHJpZXMuZW5kKCkpLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2VydmVyTWVzc2FnZShzZXJ2ZXJFbnRyeSkge1xuICAgIGNvbnN0IHJlc29sdmVkSW5mbyA9IHNlcnZlckVudHJ5LmdldEluZm8oKTtcbiAgICBjb25zdCBsaXN0ZW5Tb2NrZXQgPSBbXTtcbiAgICByZXNvbHZlZEluZm8ubGlzdGVuZXJDaGlsZHJlbi5zb2NrZXRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBsaXN0ZW5Tb2NrZXQucHVzaChzb2NrZXRSZWZUb01lc3NhZ2UoZWxbMV0ucmVmKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVmOiBzZXJ2ZXJSZWZUb01lc3NhZ2Uoc2VydmVyRW50cnkucmVmKSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgY2FsbHNfc3RhcnRlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzU3RhcnRlZCxcbiAgICAgICAgICAgIGNhbGxzX3N1Y2NlZWRlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzU3VjY2VlZGVkLFxuICAgICAgICAgICAgY2FsbHNfZmFpbGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNGYWlsZWQsXG4gICAgICAgICAgICBsYXN0X2NhbGxfc3RhcnRlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5sYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXApLFxuICAgICAgICAgICAgdHJhY2U6IHJlc29sdmVkSW5mby50cmFjZS5nZXRUcmFjZU1lc3NhZ2UoKSxcbiAgICAgICAgfSxcbiAgICAgICAgbGlzdGVuX3NvY2tldDogbGlzdGVuU29ja2V0LFxuICAgIH07XG59XG5mdW5jdGlvbiBHZXRTZXJ2ZXIoY2FsbCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZXJ2ZXJJZCA9IHBhcnNlSW50KGNhbGwucmVxdWVzdC5zZXJ2ZXJfaWQsIDEwKTtcbiAgICBjb25zdCBzZXJ2ZXJFbnRyaWVzID0gZW50aXR5TWFwc1tcInNlcnZlclwiIC8qIEVudGl0eVR5cGVzLnNlcnZlciAqL107XG4gICAgY29uc3Qgc2VydmVyRW50cnkgPSBzZXJ2ZXJFbnRyaWVzLmdldEVsZW1lbnRCeUtleShzZXJ2ZXJJZCk7XG4gICAgaWYgKHNlcnZlckVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcbiAgICAgICAgICAgIGRldGFpbHM6ICdObyBzZXJ2ZXIgZGF0YSBmb3VuZCBmb3IgaWQgJyArIHNlcnZlcklkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB7IHNlcnZlcjogZ2V0U2VydmVyTWVzc2FnZShzZXJ2ZXJFbnRyeSkgfSk7XG59XG5mdW5jdGlvbiBHZXRTZXJ2ZXJzKGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgbWF4UmVzdWx0cyA9IHBhcnNlSW50KGNhbGwucmVxdWVzdC5tYXhfcmVzdWx0cywgMTApIHx8IERFRkFVTFRfTUFYX1JFU1VMVFM7XG4gICAgY29uc3Qgc3RhcnRJZCA9IHBhcnNlSW50KGNhbGwucmVxdWVzdC5zdGFydF9zZXJ2ZXJfaWQsIDEwKTtcbiAgICBjb25zdCBzZXJ2ZXJFbnRyaWVzID0gZW50aXR5TWFwc1tcInNlcnZlclwiIC8qIEVudGl0eVR5cGVzLnNlcnZlciAqL107XG4gICAgY29uc3QgcmVzdWx0TGlzdCA9IFtdO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IHNlcnZlckVudHJpZXMubG93ZXJCb3VuZChzdGFydElkKTsgIWkuZXF1YWxzKHNlcnZlckVudHJpZXMuZW5kKCkpICYmIHJlc3VsdExpc3QubGVuZ3RoIDwgbWF4UmVzdWx0czsgaSA9IGkubmV4dCgpKSB7XG4gICAgICAgIHJlc3VsdExpc3QucHVzaChnZXRTZXJ2ZXJNZXNzYWdlKGkucG9pbnRlclsxXSkpO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgIHNlcnZlcjogcmVzdWx0TGlzdCxcbiAgICAgICAgZW5kOiBpLmVxdWFscyhzZXJ2ZXJFbnRyaWVzLmVuZCgpKSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIEdldFN1YmNoYW5uZWwoY2FsbCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzdWJjaGFubmVsSWQgPSBwYXJzZUludChjYWxsLnJlcXVlc3Quc3ViY2hhbm5lbF9pZCwgMTApO1xuICAgIGNvbnN0IHN1YmNoYW5uZWxFbnRyeSA9IGVudGl0eU1hcHNbXCJzdWJjaGFubmVsXCIgLyogRW50aXR5VHlwZXMuc3ViY2hhbm5lbCAqL10uZ2V0RWxlbWVudEJ5S2V5KHN1YmNoYW5uZWxJZCk7XG4gICAgaWYgKHN1YmNoYW5uZWxFbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5OT1RfRk9VTkQsXG4gICAgICAgICAgICBkZXRhaWxzOiAnTm8gc3ViY2hhbm5lbCBkYXRhIGZvdW5kIGZvciBpZCAnICsgc3ViY2hhbm5lbElkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZEluZm8gPSBzdWJjaGFubmVsRW50cnkuZ2V0SW5mbygpO1xuICAgIGNvbnN0IGxpc3RlblNvY2tldCA9IFtdO1xuICAgIHJlc29sdmVkSW5mby5jaGlsZHJlbi5zb2NrZXRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBsaXN0ZW5Tb2NrZXQucHVzaChzb2NrZXRSZWZUb01lc3NhZ2UoZWxbMV0ucmVmKSk7XG4gICAgfSk7XG4gICAgY29uc3Qgc3ViY2hhbm5lbE1lc3NhZ2UgPSB7XG4gICAgICAgIHJlZjogc3ViY2hhbm5lbFJlZlRvTWVzc2FnZShzdWJjaGFubmVsRW50cnkucmVmKSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdGFyZ2V0OiByZXNvbHZlZEluZm8udGFyZ2V0LFxuICAgICAgICAgICAgc3RhdGU6IGNvbm5lY3Rpdml0eVN0YXRlVG9NZXNzYWdlKHJlc29sdmVkSW5mby5zdGF0ZSksXG4gICAgICAgICAgICBjYWxsc19zdGFydGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdGFydGVkLFxuICAgICAgICAgICAgY2FsbHNfc3VjY2VlZGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdWNjZWVkZWQsXG4gICAgICAgICAgICBjYWxsc19mYWlsZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc0ZhaWxlZCxcbiAgICAgICAgICAgIGxhc3RfY2FsbF9zdGFydGVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCksXG4gICAgICAgICAgICB0cmFjZTogcmVzb2x2ZWRJbmZvLnRyYWNlLmdldFRyYWNlTWVzc2FnZSgpLFxuICAgICAgICB9LFxuICAgICAgICBzb2NrZXRfcmVmOiBsaXN0ZW5Tb2NrZXQsXG4gICAgfTtcbiAgICBjYWxsYmFjayhudWxsLCB7IHN1YmNoYW5uZWw6IHN1YmNoYW5uZWxNZXNzYWdlIH0pO1xufVxuZnVuY3Rpb24gc3ViY2hhbm5lbEFkZHJlc3NUb0FkZHJlc3NNZXNzYWdlKHN1YmNoYW5uZWxBZGRyZXNzKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICgoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuaXNUY3BTdWJjaGFubmVsQWRkcmVzcykoc3ViY2hhbm5lbEFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzOiAndGNwaXBfYWRkcmVzcycsXG4gICAgICAgICAgICB0Y3BpcF9hZGRyZXNzOiB7XG4gICAgICAgICAgICAgICAgaXBfYWRkcmVzczogKF9hID0gaXBBZGRyZXNzU3RyaW5nVG9CdWZmZXIoc3ViY2hhbm5lbEFkZHJlc3MuaG9zdCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBwb3J0OiBzdWJjaGFubmVsQWRkcmVzcy5wb3J0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzOiAndWRzX2FkZHJlc3MnLFxuICAgICAgICAgICAgdWRzX2FkZHJlc3M6IHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogc3ViY2hhbm5lbEFkZHJlc3MucGF0aCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gR2V0U29ja2V0KGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCBzb2NrZXRJZCA9IHBhcnNlSW50KGNhbGwucmVxdWVzdC5zb2NrZXRfaWQsIDEwKTtcbiAgICBjb25zdCBzb2NrZXRFbnRyeSA9IGVudGl0eU1hcHNbXCJzb2NrZXRcIiAvKiBFbnRpdHlUeXBlcy5zb2NrZXQgKi9dLmdldEVsZW1lbnRCeUtleShzb2NrZXRJZCk7XG4gICAgaWYgKHNvY2tldEVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcbiAgICAgICAgICAgIGRldGFpbHM6ICdObyBzb2NrZXQgZGF0YSBmb3VuZCBmb3IgaWQgJyArIHNvY2tldElkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZEluZm8gPSBzb2NrZXRFbnRyeS5nZXRJbmZvKCk7XG4gICAgY29uc3Qgc2VjdXJpdHlNZXNzYWdlID0gcmVzb2x2ZWRJbmZvLnNlY3VyaXR5XG4gICAgICAgID8ge1xuICAgICAgICAgICAgbW9kZWw6ICd0bHMnLFxuICAgICAgICAgICAgdGxzOiB7XG4gICAgICAgICAgICAgICAgY2lwaGVyX3N1aXRlOiByZXNvbHZlZEluZm8uc2VjdXJpdHkuY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWVcbiAgICAgICAgICAgICAgICAgICAgPyAnc3RhbmRhcmRfbmFtZSdcbiAgICAgICAgICAgICAgICAgICAgOiAnb3RoZXJfbmFtZScsXG4gICAgICAgICAgICAgICAgc3RhbmRhcmRfbmFtZTogKF9hID0gcmVzb2x2ZWRJbmZvLnNlY3VyaXR5LmNpcGhlclN1aXRlU3RhbmRhcmROYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgb3RoZXJfbmFtZTogKF9iID0gcmVzb2x2ZWRJbmZvLnNlY3VyaXR5LmNpcGhlclN1aXRlT3RoZXJOYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbG9jYWxfY2VydGlmaWNhdGU6IChfYyA9IHJlc29sdmVkSW5mby5zZWN1cml0eS5sb2NhbENlcnRpZmljYXRlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcmVtb3RlX2NlcnRpZmljYXRlOiAoX2QgPSByZXNvbHZlZEluZm8uc2VjdXJpdHkucmVtb3RlQ2VydGlmaWNhdGUpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICAgICAgOiBudWxsO1xuICAgIGNvbnN0IHNvY2tldE1lc3NhZ2UgPSB7XG4gICAgICAgIHJlZjogc29ja2V0UmVmVG9NZXNzYWdlKHNvY2tldEVudHJ5LnJlZiksXG4gICAgICAgIGxvY2FsOiByZXNvbHZlZEluZm8ubG9jYWxBZGRyZXNzXG4gICAgICAgICAgICA/IHN1YmNoYW5uZWxBZGRyZXNzVG9BZGRyZXNzTWVzc2FnZShyZXNvbHZlZEluZm8ubG9jYWxBZGRyZXNzKVxuICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICByZW1vdGU6IHJlc29sdmVkSW5mby5yZW1vdGVBZGRyZXNzXG4gICAgICAgICAgICA/IHN1YmNoYW5uZWxBZGRyZXNzVG9BZGRyZXNzTWVzc2FnZShyZXNvbHZlZEluZm8ucmVtb3RlQWRkcmVzcylcbiAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgcmVtb3RlX25hbWU6IChfZSA9IHJlc29sdmVkSW5mby5yZW1vdGVOYW1lKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB1bmRlZmluZWQsXG4gICAgICAgIHNlY3VyaXR5OiBzZWN1cml0eU1lc3NhZ2UsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGtlZXBfYWxpdmVzX3NlbnQ6IHJlc29sdmVkSW5mby5rZWVwQWxpdmVzU2VudCxcbiAgICAgICAgICAgIHN0cmVhbXNfc3RhcnRlZDogcmVzb2x2ZWRJbmZvLnN0cmVhbXNTdGFydGVkLFxuICAgICAgICAgICAgc3RyZWFtc19zdWNjZWVkZWQ6IHJlc29sdmVkSW5mby5zdHJlYW1zU3VjY2VlZGVkLFxuICAgICAgICAgICAgc3RyZWFtc19mYWlsZWQ6IHJlc29sdmVkSW5mby5zdHJlYW1zRmFpbGVkLFxuICAgICAgICAgICAgbGFzdF9sb2NhbF9zdHJlYW1fY3JlYXRlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5sYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wKSxcbiAgICAgICAgICAgIGxhc3RfcmVtb3RlX3N0cmVhbV9jcmVhdGVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wKSxcbiAgICAgICAgICAgIG1lc3NhZ2VzX3JlY2VpdmVkOiByZXNvbHZlZEluZm8ubWVzc2FnZXNSZWNlaXZlZCxcbiAgICAgICAgICAgIG1lc3NhZ2VzX3NlbnQ6IHJlc29sdmVkSW5mby5tZXNzYWdlc1NlbnQsXG4gICAgICAgICAgICBsYXN0X21lc3NhZ2VfcmVjZWl2ZWRfdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChyZXNvbHZlZEluZm8ubGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCksXG4gICAgICAgICAgICBsYXN0X21lc3NhZ2Vfc2VudF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXApLFxuICAgICAgICAgICAgbG9jYWxfZmxvd19jb250cm9sX3dpbmRvdzogcmVzb2x2ZWRJbmZvLmxvY2FsRmxvd0NvbnRyb2xXaW5kb3dcbiAgICAgICAgICAgICAgICA/IHsgdmFsdWU6IHJlc29sdmVkSW5mby5sb2NhbEZsb3dDb250cm9sV2luZG93IH1cbiAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICByZW1vdGVfZmxvd19jb250cm9sX3dpbmRvdzogcmVzb2x2ZWRJbmZvLnJlbW90ZUZsb3dDb250cm9sV2luZG93XG4gICAgICAgICAgICAgICAgPyB7IHZhbHVlOiByZXNvbHZlZEluZm8ucmVtb3RlRmxvd0NvbnRyb2xXaW5kb3cgfVxuICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGNhbGxiYWNrKG51bGwsIHsgc29ja2V0OiBzb2NrZXRNZXNzYWdlIH0pO1xufVxuZnVuY3Rpb24gR2V0U2VydmVyU29ja2V0cyhjYWxsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlcnZlcklkID0gcGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnNlcnZlcl9pZCwgMTApO1xuICAgIGNvbnN0IHNlcnZlckVudHJ5ID0gZW50aXR5TWFwc1tcInNlcnZlclwiIC8qIEVudGl0eVR5cGVzLnNlcnZlciAqL10uZ2V0RWxlbWVudEJ5S2V5KHNlcnZlcklkKTtcbiAgICBpZiAoc2VydmVyRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgICAgICAgICAgZGV0YWlsczogJ05vIHNlcnZlciBkYXRhIGZvdW5kIGZvciBpZCAnICsgc2VydmVySWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0SWQgPSBwYXJzZUludChjYWxsLnJlcXVlc3Quc3RhcnRfc29ja2V0X2lkLCAxMCk7XG4gICAgY29uc3QgbWF4UmVzdWx0cyA9IHBhcnNlSW50KGNhbGwucmVxdWVzdC5tYXhfcmVzdWx0cywgMTApIHx8IERFRkFVTFRfTUFYX1JFU1VMVFM7XG4gICAgY29uc3QgcmVzb2x2ZWRJbmZvID0gc2VydmVyRW50cnkuZ2V0SW5mbygpO1xuICAgIC8vIElmIHdlIHdhbnRlZCB0byBpbmNsdWRlIGxpc3RlbmVyIHNvY2tldHMgaW4gdGhlIHJlc3VsdCwgdGhpcyBsaW5lIHdvdWxkXG4gICAgLy8gaW5zdGVhZCBzYXlcbiAgICAvLyBjb25zdCBhbGxTb2NrZXRzID0gcmVzb2x2ZWRJbmZvLmxpc3RlbmVyQ2hpbGRyZW4uc29ja2V0cy5jb25jYXQocmVzb2x2ZWRJbmZvLnNlc3Npb25DaGlsZHJlbi5zb2NrZXRzKS5zb3J0KChyZWYxLCByZWYyKSA9PiByZWYxLmlkIC0gcmVmMi5pZCk7XG4gICAgY29uc3QgYWxsU29ja2V0cyA9IHJlc29sdmVkSW5mby5zZXNzaW9uQ2hpbGRyZW4uc29ja2V0cztcbiAgICBjb25zdCByZXN1bHRMaXN0ID0gW107XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gYWxsU29ja2V0cy5sb3dlckJvdW5kKHN0YXJ0SWQpOyAhaS5lcXVhbHMoYWxsU29ja2V0cy5lbmQoKSkgJiYgcmVzdWx0TGlzdC5sZW5ndGggPCBtYXhSZXN1bHRzOyBpID0gaS5uZXh0KCkpIHtcbiAgICAgICAgcmVzdWx0TGlzdC5wdXNoKHNvY2tldFJlZlRvTWVzc2FnZShpLnBvaW50ZXJbMV0ucmVmKSk7XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgc29ja2V0X3JlZjogcmVzdWx0TGlzdCxcbiAgICAgICAgZW5kOiBpLmVxdWFscyhhbGxTb2NrZXRzLmVuZCgpKSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldENoYW5uZWx6SGFuZGxlcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgR2V0Q2hhbm5lbCxcbiAgICAgICAgR2V0VG9wQ2hhbm5lbHMsXG4gICAgICAgIEdldFNlcnZlcixcbiAgICAgICAgR2V0U2VydmVycyxcbiAgICAgICAgR2V0U3ViY2hhbm5lbCxcbiAgICAgICAgR2V0U29ja2V0LFxuICAgICAgICBHZXRTZXJ2ZXJTb2NrZXRzLFxuICAgIH07XG59XG5sZXQgbG9hZGVkQ2hhbm5lbHpEZWZpbml0aW9uID0gbnVsbDtcbmZ1bmN0aW9uIGdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24oKSB7XG4gICAgaWYgKGxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gbG9hZGVkQ2hhbm5lbHpEZWZpbml0aW9uO1xuICAgIH1cbiAgICAvKiBUaGUgcHVycG9zZSBvZiB0aGlzIGNvbXBsZXhpdHkgaXMgdG8gYXZvaWQgbG9hZGluZyBAZ3JwYy9wcm90by1sb2FkZXIgYXRcbiAgICAgKiBydW50aW1lIGZvciB1c2VycyB3aG8gd2lsbCBub3QgdXNlL2VuYWJsZSBjaGFubmVsei4gKi9cbiAgICBjb25zdCBsb2FkZXJMb2FkU3luYyA9IHJlcXVpcmUoJ0BncnBjL3Byb3RvLWxvYWRlcicpXG4gICAgICAgIC5sb2FkU3luYztcbiAgICBjb25zdCBsb2FkZWRQcm90byA9IGxvYWRlckxvYWRTeW5jKCdjaGFubmVsei5wcm90bycsIHtcbiAgICAgICAga2VlcENhc2U6IHRydWUsXG4gICAgICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgICAgIGVudW1zOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHRzOiB0cnVlLFxuICAgICAgICBvbmVvZnM6IHRydWUsXG4gICAgICAgIGluY2x1ZGVEaXJzOiBbYCR7X19kaXJuYW1lfS8uLi8uLi9wcm90b2BdLFxuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5uZWx6R3JwY09iamVjdCA9ICgwLCBtYWtlX2NsaWVudF8xLmxvYWRQYWNrYWdlRGVmaW5pdGlvbikobG9hZGVkUHJvdG8pO1xuICAgIGxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbiA9XG4gICAgICAgIGNoYW5uZWx6R3JwY09iamVjdC5ncnBjLmNoYW5uZWx6LnYxLkNoYW5uZWx6LnNlcnZpY2U7XG4gICAgcmV0dXJuIGxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbjtcbn1cbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgICgwLCBhZG1pbl8xLnJlZ2lzdGVyQWRtaW5TZXJ2aWNlKShnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uLCBnZXRDaGFubmVsekhhbmRsZXJzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5uZWx6LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQiLCJyZWdpc3RlckNoYW5uZWx6U2VydmVyIiwicmVnaXN0ZXJDaGFubmVselN1YmNoYW5uZWwiLCJyZWdpc3RlckNoYW5uZWx6Q2hhbm5lbCIsIkNoYW5uZWx6Q2FsbFRyYWNrZXJTdHViIiwiQ2hhbm5lbHpDYWxsVHJhY2tlciIsIkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyU3R1YiIsIkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyIiwiQ2hhbm5lbHpUcmFjZSIsIkNoYW5uZWx6VHJhY2VTdHViIiwidW5yZWdpc3RlckNoYW5uZWx6UmVmIiwiZ2V0Q2hhbm5lbHpIYW5kbGVycyIsImdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24iLCJzZXR1cCIsIm5ldF8xIiwicmVxdWlyZSIsIm9yZGVyZWRfbWFwXzEiLCJjb25uZWN0aXZpdHlfc3RhdGVfMSIsImNvbnN0YW50c18xIiwic3ViY2hhbm5lbF9hZGRyZXNzXzEiLCJhZG1pbl8xIiwibWFrZV9jbGllbnRfMSIsImNoYW5uZWxSZWZUb01lc3NhZ2UiLCJyZWYiLCJjaGFubmVsX2lkIiwiaWQiLCJuYW1lIiwic3ViY2hhbm5lbFJlZlRvTWVzc2FnZSIsInN1YmNoYW5uZWxfaWQiLCJzZXJ2ZXJSZWZUb01lc3NhZ2UiLCJzZXJ2ZXJfaWQiLCJzb2NrZXRSZWZUb01lc3NhZ2UiLCJzb2NrZXRfaWQiLCJUQVJHRVRfUkVUQUlORURfVFJBQ0VTIiwiREVGQVVMVF9NQVhfUkVTVUxUUyIsImNvbnN0cnVjdG9yIiwiZXZlbnRzIiwiY3JlYXRpb25UaW1lc3RhbXAiLCJEYXRlIiwiZXZlbnRzTG9nZ2VkIiwiYWRkVHJhY2UiLCJnZXRUcmFjZU1lc3NhZ2UiLCJjcmVhdGlvbl90aW1lc3RhbXAiLCJkYXRlVG9Qcm90b1RpbWVzdGFtcCIsIm51bV9ldmVudHNfbG9nZ2VkIiwic2V2ZXJpdHkiLCJkZXNjcmlwdGlvbiIsImNoaWxkIiwidGltZXN0YW1wIiwicHVzaCIsImNoaWxkQ2hhbm5lbCIsImtpbmQiLCJ1bmRlZmluZWQiLCJjaGlsZFN1YmNoYW5uZWwiLCJsZW5ndGgiLCJzbGljZSIsIm1hcCIsImV2ZW50IiwiY2hhbm5lbF9yZWYiLCJzdWJjaGFubmVsX3JlZiIsImNoYW5uZWxDaGlsZHJlbiIsIk9yZGVyZWRNYXAiLCJzdWJjaGFubmVsQ2hpbGRyZW4iLCJzb2NrZXRDaGlsZHJlbiIsInRyYWNrZXJNYXAiLCJyZWZDaGlsZCIsInRyYWNrZXIiLCJ0cmFja2VkQ2hpbGQiLCJmaW5kIiwiZXF1YWxzIiwiZW5kIiwic2V0RWxlbWVudCIsImNvdW50IiwicG9pbnRlciIsInVucmVmQ2hpbGQiLCJnZXRFbGVtZW50QnlLZXkiLCJlcmFzZUVsZW1lbnRCeUtleSIsImdldENoaWxkTGlzdHMiLCJjaGFubmVscyIsInN1YmNoYW5uZWxzIiwic29ja2V0cyIsImNhbGxzU3RhcnRlZCIsImNhbGxzU3VjY2VlZGVkIiwiY2FsbHNGYWlsZWQiLCJsYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXAiLCJhZGRDYWxsU3RhcnRlZCIsImFkZENhbGxTdWNjZWVkZWQiLCJhZGRDYWxsRmFpbGVkIiwiZW50aXR5TWFwcyIsImdlbmVyYXRlUmVnaXN0ZXJGbiIsIm5leHRJZCIsImdldE5leHRJZCIsImVudGl0eU1hcCIsImdldEluZm8iLCJjaGFubmVsekVuYWJsZWQiLCJwYXJzZUlQdjZTZWN0aW9uIiwiYWRkcmVzc1NlY3Rpb24iLCJudW1iZXJWYWx1ZSIsIk51bWJlciIsInBhcnNlSW50IiwicGFyc2VJUHY2Q2h1bmsiLCJhZGRyZXNzQ2h1bmsiLCJieXRlUGFpcnMiLCJzcGxpdCIsInNlY3Rpb24iLCJyZXN1bHQiLCJjb25jYXQiLCJpc0lQdjZNYXBwZWRJUHY0IiwiaXBBZGRyZXNzIiwiaXNJUHY2IiwidG9Mb3dlckNhc2UiLCJzdGFydHNXaXRoIiwiaXNJUHY0Iiwic3Vic3RyaW5nIiwiaXB2NEFkZHJlc3NTdHJpbmdUb0J1ZmZlciIsIkJ1ZmZlciIsImZyb20iLCJVaW50OEFycmF5Iiwic2VnbWVudCIsImlwQWRkcmVzc1N0cmluZ1RvQnVmZmVyIiwibGVmdFNlY3Rpb24iLCJyaWdodFNlY3Rpb24iLCJkb3VibGVDb2xvbkluZGV4IiwiaW5kZXhPZiIsImxlZnRCdWZmZXIiLCJyaWdodEJ1ZmZlciIsIm1pZGRsZUJ1ZmZlciIsImFsbG9jIiwiY29ubmVjdGl2aXR5U3RhdGVUb01lc3NhZ2UiLCJzdGF0ZSIsIkNvbm5lY3Rpdml0eVN0YXRlIiwiQ09OTkVDVElORyIsIklETEUiLCJSRUFEWSIsIlNIVVRET1dOIiwiVFJBTlNJRU5UX0ZBSUxVUkUiLCJkYXRlIiwibWlsbGlzU2luY2VFcG9jaCIsImdldFRpbWUiLCJzZWNvbmRzIiwibmFub3MiLCJnZXRDaGFubmVsTWVzc2FnZSIsImNoYW5uZWxFbnRyeSIsInJlc29sdmVkSW5mbyIsImNoYW5uZWxSZWYiLCJzdWJjaGFubmVsUmVmIiwiY2hpbGRyZW4iLCJmb3JFYWNoIiwiZWwiLCJkYXRhIiwidGFyZ2V0IiwiY2FsbHNfc3RhcnRlZCIsImNhbGxUcmFja2VyIiwiY2FsbHNfc3VjY2VlZGVkIiwiY2FsbHNfZmFpbGVkIiwibGFzdF9jYWxsX3N0YXJ0ZWRfdGltZXN0YW1wIiwidHJhY2UiLCJHZXRDaGFubmVsIiwiY2FsbCIsImNhbGxiYWNrIiwiY2hhbm5lbElkIiwicmVxdWVzdCIsImNvZGUiLCJTdGF0dXMiLCJOT1RfRk9VTkQiLCJkZXRhaWxzIiwiY2hhbm5lbCIsIkdldFRvcENoYW5uZWxzIiwibWF4UmVzdWx0cyIsIm1heF9yZXN1bHRzIiwicmVzdWx0TGlzdCIsInN0YXJ0SWQiLCJzdGFydF9jaGFubmVsX2lkIiwiY2hhbm5lbEVudHJpZXMiLCJpIiwibG93ZXJCb3VuZCIsIm5leHQiLCJnZXRTZXJ2ZXJNZXNzYWdlIiwic2VydmVyRW50cnkiLCJsaXN0ZW5Tb2NrZXQiLCJsaXN0ZW5lckNoaWxkcmVuIiwibGlzdGVuX3NvY2tldCIsIkdldFNlcnZlciIsInNlcnZlcklkIiwic2VydmVyRW50cmllcyIsInNlcnZlciIsIkdldFNlcnZlcnMiLCJzdGFydF9zZXJ2ZXJfaWQiLCJHZXRTdWJjaGFubmVsIiwic3ViY2hhbm5lbElkIiwic3ViY2hhbm5lbEVudHJ5Iiwic3ViY2hhbm5lbE1lc3NhZ2UiLCJzb2NrZXRfcmVmIiwic3ViY2hhbm5lbCIsInN1YmNoYW5uZWxBZGRyZXNzVG9BZGRyZXNzTWVzc2FnZSIsInN1YmNoYW5uZWxBZGRyZXNzIiwiX2EiLCJpc1RjcFN1YmNoYW5uZWxBZGRyZXNzIiwiYWRkcmVzcyIsInRjcGlwX2FkZHJlc3MiLCJpcF9hZGRyZXNzIiwiaG9zdCIsInBvcnQiLCJ1ZHNfYWRkcmVzcyIsImZpbGVuYW1lIiwicGF0aCIsIkdldFNvY2tldCIsIl9iIiwiX2MiLCJfZCIsIl9lIiwic29ja2V0SWQiLCJzb2NrZXRFbnRyeSIsInNlY3VyaXR5TWVzc2FnZSIsInNlY3VyaXR5IiwibW9kZWwiLCJ0bHMiLCJjaXBoZXJfc3VpdGUiLCJjaXBoZXJTdWl0ZVN0YW5kYXJkTmFtZSIsInN0YW5kYXJkX25hbWUiLCJvdGhlcl9uYW1lIiwiY2lwaGVyU3VpdGVPdGhlck5hbWUiLCJsb2NhbF9jZXJ0aWZpY2F0ZSIsImxvY2FsQ2VydGlmaWNhdGUiLCJyZW1vdGVfY2VydGlmaWNhdGUiLCJyZW1vdGVDZXJ0aWZpY2F0ZSIsInNvY2tldE1lc3NhZ2UiLCJsb2NhbCIsImxvY2FsQWRkcmVzcyIsInJlbW90ZSIsInJlbW90ZUFkZHJlc3MiLCJyZW1vdGVfbmFtZSIsInJlbW90ZU5hbWUiLCJrZWVwX2FsaXZlc19zZW50Iiwia2VlcEFsaXZlc1NlbnQiLCJzdHJlYW1zX3N0YXJ0ZWQiLCJzdHJlYW1zU3RhcnRlZCIsInN0cmVhbXNfc3VjY2VlZGVkIiwic3RyZWFtc1N1Y2NlZWRlZCIsInN0cmVhbXNfZmFpbGVkIiwic3RyZWFtc0ZhaWxlZCIsImxhc3RfbG9jYWxfc3RyZWFtX2NyZWF0ZWRfdGltZXN0YW1wIiwibGFzdExvY2FsU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcCIsImxhc3RfcmVtb3RlX3N0cmVhbV9jcmVhdGVkX3RpbWVzdGFtcCIsImxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wIiwibWVzc2FnZXNfcmVjZWl2ZWQiLCJtZXNzYWdlc1JlY2VpdmVkIiwibWVzc2FnZXNfc2VudCIsIm1lc3NhZ2VzU2VudCIsImxhc3RfbWVzc2FnZV9yZWNlaXZlZF90aW1lc3RhbXAiLCJsYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wIiwibGFzdF9tZXNzYWdlX3NlbnRfdGltZXN0YW1wIiwibGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wIiwibG9jYWxfZmxvd19jb250cm9sX3dpbmRvdyIsImxvY2FsRmxvd0NvbnRyb2xXaW5kb3ciLCJyZW1vdGVfZmxvd19jb250cm9sX3dpbmRvdyIsInJlbW90ZUZsb3dDb250cm9sV2luZG93Iiwic29ja2V0IiwiR2V0U2VydmVyU29ja2V0cyIsInN0YXJ0X3NvY2tldF9pZCIsImFsbFNvY2tldHMiLCJzZXNzaW9uQ2hpbGRyZW4iLCJsb2FkZWRDaGFubmVsekRlZmluaXRpb24iLCJsb2FkZXJMb2FkU3luYyIsImxvYWRTeW5jIiwibG9hZGVkUHJvdG8iLCJrZWVwQ2FzZSIsImxvbmdzIiwiU3RyaW5nIiwiZW51bXMiLCJkZWZhdWx0cyIsIm9uZW9mcyIsImluY2x1ZGVEaXJzIiwiX19kaXJuYW1lIiwiY2hhbm5lbHpHcnBjT2JqZWN0IiwibG9hZFBhY2thZ2VEZWZpbml0aW9uIiwiZ3JwYyIsImNoYW5uZWx6IiwidjEiLCJDaGFubmVseiIsInNlcnZpY2UiLCJyZWdpc3RlckFkbWluU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client-interceptors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;\nexports.getInterceptingCall = getInterceptingCall;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst call_interface_1 = __webpack_require__(/*! ./call-interface */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-interface.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/error.js\");\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */ class InterceptorConfigurationError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"InterceptorConfigurationError\";\n        Error.captureStackTrace(this, InterceptorConfigurationError);\n    }\n}\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\nclass ListenerBuilder {\n    constructor(){\n        this.metadata = undefined;\n        this.message = undefined;\n        this.status = undefined;\n    }\n    withOnReceiveMetadata(onReceiveMetadata) {\n        this.metadata = onReceiveMetadata;\n        return this;\n    }\n    withOnReceiveMessage(onReceiveMessage) {\n        this.message = onReceiveMessage;\n        return this;\n    }\n    withOnReceiveStatus(onReceiveStatus) {\n        this.status = onReceiveStatus;\n        return this;\n    }\n    build() {\n        return {\n            onReceiveMetadata: this.metadata,\n            onReceiveMessage: this.message,\n            onReceiveStatus: this.status\n        };\n    }\n}\nexports.ListenerBuilder = ListenerBuilder;\nclass RequesterBuilder {\n    constructor(){\n        this.start = undefined;\n        this.message = undefined;\n        this.halfClose = undefined;\n        this.cancel = undefined;\n    }\n    withStart(start) {\n        this.start = start;\n        return this;\n    }\n    withSendMessage(sendMessage) {\n        this.message = sendMessage;\n        return this;\n    }\n    withHalfClose(halfClose) {\n        this.halfClose = halfClose;\n        return this;\n    }\n    withCancel(cancel) {\n        this.cancel = cancel;\n        return this;\n    }\n    build() {\n        return {\n            start: this.start,\n            sendMessage: this.message,\n            halfClose: this.halfClose,\n            cancel: this.cancel\n        };\n    }\n}\nexports.RequesterBuilder = RequesterBuilder;\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */ const defaultListener = {\n    onReceiveMetadata: (metadata, next)=>{\n        next(metadata);\n    },\n    onReceiveMessage: (message, next)=>{\n        next(message);\n    },\n    onReceiveStatus: (status, next)=>{\n        next(status);\n    }\n};\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */ const defaultRequester = {\n    start: (metadata, listener, next)=>{\n        next(metadata, listener);\n    },\n    sendMessage: (message, next)=>{\n        next(message);\n    },\n    halfClose: (next)=>{\n        next();\n    },\n    cancel: (next)=>{\n        next();\n    }\n};\nclass InterceptingCall {\n    constructor(nextCall, requester){\n        var _a, _b, _c, _d;\n        this.nextCall = nextCall;\n        /**\n         * Indicates that metadata has been passed to the requester's start\n         * method but it has not been passed to the corresponding next callback\n         */ this.processingMetadata = false;\n        /**\n         * Message context for a pending message that is waiting for\n         */ this.pendingMessageContext = null;\n        /**\n         * Indicates that a message has been passed to the requester's sendMessage\n         * method but it has not been passed to the corresponding next callback\n         */ this.processingMessage = false;\n        /**\n         * Indicates that a status was received but could not be propagated because\n         * a message was still being processed.\n         */ this.pendingHalfClose = false;\n        if (requester) {\n            this.requester = {\n                start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\n                sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\n                halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\n                cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel\n            };\n        } else {\n            this.requester = defaultRequester;\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.requester.cancel(()=>{\n            this.nextCall.cancelWithStatus(status, details);\n        });\n    }\n    getPeer() {\n        return this.nextCall.getPeer();\n    }\n    processPendingMessage() {\n        if (this.pendingMessageContext) {\n            this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\n            this.pendingMessageContext = null;\n            this.pendingMessage = null;\n        }\n    }\n    processPendingHalfClose() {\n        if (this.pendingHalfClose) {\n            this.nextCall.halfClose();\n        }\n    }\n    start(metadata, interceptingListener) {\n        var _a, _b, _c, _d, _e, _f;\n        const fullInterceptingListener = {\n            onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : (metadata)=>{},\n            onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : (message)=>{},\n            onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : (status)=>{}\n        };\n        this.processingMetadata = true;\n        this.requester.start(metadata, fullInterceptingListener, (md, listener)=>{\n            var _a, _b, _c;\n            this.processingMetadata = false;\n            let finalInterceptingListener;\n            if ((0, call_interface_1.isInterceptingListener)(listener)) {\n                finalInterceptingListener = listener;\n            } else {\n                const fullListener = {\n                    onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\n                    onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\n                    onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus\n                };\n                finalInterceptingListener = new call_interface_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\n            }\n            this.nextCall.start(md, finalInterceptingListener);\n            this.processPendingMessage();\n            this.processPendingHalfClose();\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessageWithContext(context, message) {\n        this.processingMessage = true;\n        this.requester.sendMessage(message, (finalMessage)=>{\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessageContext = context;\n                this.pendingMessage = message;\n            } else {\n                this.nextCall.sendMessageWithContext(context, finalMessage);\n                this.processPendingHalfClose();\n            }\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    startRead() {\n        this.nextCall.startRead();\n    }\n    halfClose() {\n        this.requester.halfClose(()=>{\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingHalfClose = true;\n            } else {\n                this.nextCall.halfClose();\n            }\n        });\n    }\n}\nexports.InterceptingCall = InterceptingCall;\nfunction getCall(channel, path, options) {\n    var _a, _b;\n    const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;\n    const host = options.host;\n    const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;\n    const propagateFlags = options.propagate_flags;\n    const credentials = options.credentials;\n    const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n    if (credentials) {\n        call.setCredentials(credentials);\n    }\n    return call;\n}\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */ class BaseInterceptingCall {\n    constructor(call, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    methodDefinition){\n        this.call = call;\n        this.methodDefinition = methodDefinition;\n    }\n    cancelWithStatus(status, details) {\n        this.call.cancelWithStatus(status, details);\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessageWithContext(context, message) {\n        let serialized;\n        try {\n            serialized = this.methodDefinition.requestSerialize(message);\n        } catch (e) {\n            this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${(0, error_1.getErrorMessage)(e)}`);\n            return;\n        }\n        this.call.sendMessageWithContext(context, serialized);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    start(metadata, interceptingListener) {\n        let readError = null;\n        this.call.start(metadata, {\n            onReceiveMetadata: (metadata)=>{\n                var _a;\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\n            },\n            onReceiveMessage: (message)=>{\n                var _a;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                let deserialized;\n                try {\n                    deserialized = this.methodDefinition.responseDeserialize(message);\n                } catch (e) {\n                    readError = {\n                        code: constants_1.Status.INTERNAL,\n                        details: `Response message parsing error: ${(0, error_1.getErrorMessage)(e)}`,\n                        metadata: new metadata_1.Metadata()\n                    };\n                    this.call.cancelWithStatus(readError.code, readError.details);\n                    return;\n                }\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\n            },\n            onReceiveStatus: (status)=>{\n                var _a, _b;\n                if (readError) {\n                    (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\n                } else {\n                    (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\n                }\n            }\n        });\n    }\n    startRead() {\n        this.call.startRead();\n    }\n    halfClose() {\n        this.call.halfClose();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */ class BaseUnaryInterceptingCall extends BaseInterceptingCall {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(call, methodDefinition){\n        super(call, methodDefinition);\n    }\n    start(metadata, listener) {\n        var _a, _b;\n        let receivedMessage = false;\n        const wrapperListener = {\n            onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : (metadata)=>{},\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage: (message)=>{\n                var _a;\n                receivedMessage = true;\n                (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\n            },\n            onReceiveStatus: (status)=>{\n                var _a, _b;\n                if (!receivedMessage) {\n                    (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\n                }\n                (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\n            }\n        };\n        super.start(metadata, wrapperListener);\n        this.call.startRead();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */ class BaseStreamingInterceptingCall extends BaseInterceptingCall {\n}\nfunction getBottomInterceptingCall(channel, options, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition) {\n    const call = getCall(channel, methodDefinition.path, options);\n    if (methodDefinition.responseStream) {\n        return new BaseStreamingInterceptingCall(call, methodDefinition);\n    } else {\n        return new BaseUnaryInterceptingCall(call, methodDefinition);\n    }\n}\nfunction getInterceptingCall(interceptorArgs, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition, options, channel) {\n    if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError(\"Both interceptors and interceptor_providers were passed as options \" + \"to the client constructor. Only one of these is allowed.\");\n    }\n    if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError(\"Both interceptors and interceptor_providers were passed as call \" + \"options. Only one of these is allowed.\");\n    }\n    let interceptors = [];\n    // Interceptors passed to the call override interceptors passed to the client constructor\n    if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {\n        interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map((provider)=>provider(methodDefinition))).filter((interceptor)=>interceptor);\n    // Filter out falsy values when providers return nothing\n    } else {\n        interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map((provider)=>provider(methodDefinition))).filter((interceptor)=>interceptor);\n    // Filter out falsy values when providers return nothing\n    }\n    const interceptorOptions = Object.assign({}, options, {\n        method_definition: methodDefinition\n    });\n    /* For each interceptor in the list, the nextCall function passed to it is\n     * based on the next interceptor in the list, using a nextCall function\n     * constructed with the following interceptor in the list, and so on. The\n     * initialValue, which is effectively at the end of the list, is a nextCall\n     * function that invokes getBottomInterceptingCall, the result of which\n     * handles (de)serialization and also gets the underlying call from the\n     * channel. */ const getCall = interceptors.reduceRight((nextCall, nextInterceptor)=>{\n        return (currentOptions)=>nextInterceptor(currentOptions, nextCall);\n    }, (finalOptions)=>getBottomInterceptingCall(channel, finalOptions, methodDefinition));\n    return getCall(interceptorOptions);\n} //# sourceMappingURL=client-interceptors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LWludGVyY2VwdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsd0JBQXdCLEdBQUdBLHdCQUF3QixHQUFHQSx1QkFBdUIsR0FBR0EscUNBQXFDLEdBQUcsS0FBSztBQUM3SEEsMkJBQTJCLEdBQUdNO0FBQzlCLE1BQU1DLGFBQWFDLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1DLG1CQUFtQkQsbUJBQU9BLENBQUMsd0ZBQWtCO0FBQ25ELE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1HLFVBQVVILG1CQUFPQSxDQUFDLHNFQUFTO0FBQ2pDOzs7Q0FHQyxHQUNELE1BQU1ILHNDQUFzQ087SUFDeENDLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWkgsTUFBTUksaUJBQWlCLENBQUMsSUFBSSxFQUFFWDtJQUNsQztBQUNKO0FBQ0FMLHFDQUFxQyxHQUFHSztBQUN4QyxNQUFNRDtJQUNGUyxhQUFjO1FBQ1YsSUFBSSxDQUFDSSxRQUFRLEdBQUdDO1FBQ2hCLElBQUksQ0FBQ0osT0FBTyxHQUFHSTtRQUNmLElBQUksQ0FBQ0MsTUFBTSxHQUFHRDtJQUNsQjtJQUNBRSxzQkFBc0JDLGlCQUFpQixFQUFFO1FBQ3JDLElBQUksQ0FBQ0osUUFBUSxHQUFHSTtRQUNoQixPQUFPLElBQUk7SUFDZjtJQUNBQyxxQkFBcUJDLGdCQUFnQixFQUFFO1FBQ25DLElBQUksQ0FBQ1QsT0FBTyxHQUFHUztRQUNmLE9BQU8sSUFBSTtJQUNmO0lBQ0FDLG9CQUFvQkMsZUFBZSxFQUFFO1FBQ2pDLElBQUksQ0FBQ04sTUFBTSxHQUFHTTtRQUNkLE9BQU8sSUFBSTtJQUNmO0lBQ0FD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OUUsVUFBVStFO1FBQ2hELE9BQU9DLENBQUFBLGlCQUFrQkQsZ0JBQWdCQyxnQkFBZ0JoRjtJQUM3RCxHQUFHLENBQUNpRixlQUFpQnBCLDBCQUEwQjlCLFNBQVNrRCxjQUFjcEM7SUFDdEUsT0FBT2YsUUFBUTZDO0FBQ25CLEVBQ0EsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnljLWhvdXNpbmctYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NsaWVudC1pbnRlcmNlcHRvcnMuanM/MTMwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnRlcmNlcHRpbmdDYWxsID0gZXhwb3J0cy5SZXF1ZXN0ZXJCdWlsZGVyID0gZXhwb3J0cy5MaXN0ZW5lckJ1aWxkZXIgPSBleHBvcnRzLkludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yID0gdm9pZCAwO1xuZXhwb3J0cy5nZXRJbnRlcmNlcHRpbmdDYWxsID0gZ2V0SW50ZXJjZXB0aW5nQ2FsbDtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGNhbGxfaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9jYWxsLWludGVyZmFjZVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xuLyoqXG4gKiBFcnJvciBjbGFzcyBhc3NvY2lhdGVkIHdpdGggcGFzc2luZyBib3RoIGludGVyY2VwdG9ycyBhbmQgaW50ZXJjZXB0b3JcbiAqIHByb3ZpZGVycyB0byBhIGNsaWVudCBjb25zdHJ1Y3RvciBvciBhcyBjYWxsIG9wdGlvbnMuXG4gKi9cbmNsYXNzIEludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcic7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yKTtcbiAgICB9XG59XG5leHBvcnRzLkludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yID0gSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3I7XG5jbGFzcyBMaXN0ZW5lckJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB3aXRoT25SZWNlaXZlTWV0YWRhdGEob25SZWNlaXZlTWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG9uUmVjZWl2ZU1ldGFkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2l0aE9uUmVjZWl2ZU1lc3NhZ2Uob25SZWNlaXZlTWVzc2FnZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBvblJlY2VpdmVNZXNzYWdlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2l0aE9uUmVjZWl2ZVN0YXR1cyhvblJlY2VpdmVTdGF0dXMpIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBvblJlY2VpdmVTdGF0dXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBidWlsZCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhLFxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkxpc3RlbmVyQnVpbGRlciA9IExpc3RlbmVyQnVpbGRlcjtcbmNsYXNzIFJlcXVlc3RlckJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaGFsZkNsb3NlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNhbmNlbCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgd2l0aFN0YXJ0KHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhTZW5kTWVzc2FnZShzZW5kTWVzc2FnZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBzZW5kTWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhIYWxmQ2xvc2UoaGFsZkNsb3NlKSB7XG4gICAgICAgIHRoaXMuaGFsZkNsb3NlID0gaGFsZkNsb3NlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2l0aENhbmNlbChjYW5jZWwpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwgPSBjYW5jZWw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBidWlsZCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0LFxuICAgICAgICAgICAgc2VuZE1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgICAgIGhhbGZDbG9zZTogdGhpcy5oYWxmQ2xvc2UsXG4gICAgICAgICAgICBjYW5jZWw6IHRoaXMuY2FuY2VsLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdGVyQnVpbGRlciA9IFJlcXVlc3RlckJ1aWxkZXI7XG4vKipcbiAqIEEgTGlzdGVuZXIgd2l0aCBhIGRlZmF1bHQgcGFzcy10aHJvdWdoIGltcGxlbWVudGF0aW9uIG9mIGVhY2ggbWV0aG9kLiBVc2VkXG4gKiBmb3IgZmlsbGluZyBvdXQgTGlzdGVuZXJzIHdpdGggc29tZSBtZXRob2RzIG9taXR0ZWQuXG4gKi9cbmNvbnN0IGRlZmF1bHRMaXN0ZW5lciA9IHtcbiAgICBvblJlY2VpdmVNZXRhZGF0YTogKG1ldGFkYXRhLCBuZXh0KSA9PiB7XG4gICAgICAgIG5leHQobWV0YWRhdGEpO1xuICAgIH0sXG4gICAgb25SZWNlaXZlTWVzc2FnZTogKG1lc3NhZ2UsIG5leHQpID0+IHtcbiAgICAgICAgbmV4dChtZXNzYWdlKTtcbiAgICB9LFxuICAgIG9uUmVjZWl2ZVN0YXR1czogKHN0YXR1cywgbmV4dCkgPT4ge1xuICAgICAgICBuZXh0KHN0YXR1cyk7XG4gICAgfSxcbn07XG4vKipcbiAqIEEgUmVxdWVzdGVyIHdpdGggYSBkZWZhdWx0IHBhc3MtdGhyb3VnaCBpbXBsZW1lbnRhdGlvbiBvZiBlYWNoIG1ldGhvZC4gVXNlZFxuICogZm9yIGZpbGxpbmcgb3V0IFJlcXVlc3RlcnMgd2l0aCBzb21lIG1ldGhvZHMgb21pdHRlZC5cbiAqL1xuY29uc3QgZGVmYXVsdFJlcXVlc3RlciA9IHtcbiAgICBzdGFydDogKG1ldGFkYXRhLCBsaXN0ZW5lciwgbmV4dCkgPT4ge1xuICAgICAgICBuZXh0KG1ldGFkYXRhLCBsaXN0ZW5lcik7XG4gICAgfSxcbiAgICBzZW5kTWVzc2FnZTogKG1lc3NhZ2UsIG5leHQpID0+IHtcbiAgICAgICAgbmV4dChtZXNzYWdlKTtcbiAgICB9LFxuICAgIGhhbGZDbG9zZTogbmV4dCA9PiB7XG4gICAgICAgIG5leHQoKTtcbiAgICB9LFxuICAgIGNhbmNlbDogbmV4dCA9PiB7XG4gICAgICAgIG5leHQoKTtcbiAgICB9LFxufTtcbmNsYXNzIEludGVyY2VwdGluZ0NhbGwge1xuICAgIGNvbnN0cnVjdG9yKG5leHRDYWxsLCByZXF1ZXN0ZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICB0aGlzLm5leHRDYWxsID0gbmV4dENhbGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCBtZXRhZGF0YSBoYXMgYmVlbiBwYXNzZWQgdG8gdGhlIHJlcXVlc3RlcidzIHN0YXJ0XG4gICAgICAgICAqIG1ldGhvZCBidXQgaXQgaGFzIG5vdCBiZWVuIHBhc3NlZCB0byB0aGUgY29ycmVzcG9uZGluZyBuZXh0IGNhbGxiYWNrXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWVzc2FnZSBjb250ZXh0IGZvciBhIHBlbmRpbmcgbWVzc2FnZSB0aGF0IGlzIHdhaXRpbmcgZm9yXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlQ29udGV4dCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIG1lc3NhZ2UgaGFzIGJlZW4gcGFzc2VkIHRvIHRoZSByZXF1ZXN0ZXIncyBzZW5kTWVzc2FnZVxuICAgICAgICAgKiBtZXRob2QgYnV0IGl0IGhhcyBub3QgYmVlbiBwYXNzZWQgdG8gdGhlIGNvcnJlc3BvbmRpbmcgbmV4dCBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgYSBzdGF0dXMgd2FzIHJlY2VpdmVkIGJ1dCBjb3VsZCBub3QgYmUgcHJvcGFnYXRlZCBiZWNhdXNlXG4gICAgICAgICAqIGEgbWVzc2FnZSB3YXMgc3RpbGwgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nSGFsZkNsb3NlID0gZmFsc2U7XG4gICAgICAgIGlmIChyZXF1ZXN0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdGVyID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiAoX2EgPSByZXF1ZXN0ZXIuc3RhcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZmF1bHRSZXF1ZXN0ZXIuc3RhcnQsXG4gICAgICAgICAgICAgICAgc2VuZE1lc3NhZ2U6IChfYiA9IHJlcXVlc3Rlci5zZW5kTWVzc2FnZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVmYXVsdFJlcXVlc3Rlci5zZW5kTWVzc2FnZSxcbiAgICAgICAgICAgICAgICBoYWxmQ2xvc2U6IChfYyA9IHJlcXVlc3Rlci5oYWxmQ2xvc2UpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGRlZmF1bHRSZXF1ZXN0ZXIuaGFsZkNsb3NlLFxuICAgICAgICAgICAgICAgIGNhbmNlbDogKF9kID0gcmVxdWVzdGVyLmNhbmNlbCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZGVmYXVsdFJlcXVlc3Rlci5jYW5jZWwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ZXIgPSBkZWZhdWx0UmVxdWVzdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdGVyLmNhbmNlbCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5leHRDYWxsLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDYWxsLmdldFBlZXIoKTtcbiAgICB9XG4gICAgcHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nTWVzc2FnZUNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dENhbGwuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dCh0aGlzLnBlbmRpbmdNZXNzYWdlQ29udGV4dCwgdGhpcy5wZW5kaW5nTWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzUGVuZGluZ0hhbGZDbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0hhbGZDbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydChtZXRhZGF0YSwgaW50ZXJjZXB0aW5nTGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIGNvbnN0IGZ1bGxJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiAoX2IgPSAoX2EgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iaW5kKGludGVyY2VwdGluZ0xpc3RlbmVyKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKG1ldGFkYXRhID0+IHsgfSksXG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiAoX2QgPSAoX2MgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmJpbmQoaW50ZXJjZXB0aW5nTGlzdGVuZXIpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAobWVzc2FnZSA9PiB7IH0pLFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiAoX2YgPSAoX2UgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuYmluZChpbnRlcmNlcHRpbmdMaXN0ZW5lcikpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IChzdGF0dXMgPT4geyB9KSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlcXVlc3Rlci5zdGFydChtZXRhZGF0YSwgZnVsbEludGVyY2VwdGluZ0xpc3RlbmVyLCAobWQsIGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lcjtcbiAgICAgICAgICAgIGlmICgoMCwgY2FsbF9pbnRlcmZhY2VfMS5pc0ludGVyY2VwdGluZ0xpc3RlbmVyKShsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICBmaW5hbEludGVyY2VwdGluZ0xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdWxsTGlzdGVuZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiAoX2EgPSBsaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVmYXVsdExpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiAoX2IgPSBsaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBkZWZhdWx0TGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiAoX2MgPSBsaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGRlZmF1bHRMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmaW5hbEludGVyY2VwdGluZ0xpc3RlbmVyID0gbmV3IGNhbGxfaW50ZXJmYWNlXzEuSW50ZXJjZXB0aW5nTGlzdGVuZXJJbXBsKGZ1bGxMaXN0ZW5lciwgZnVsbEludGVyY2VwdGluZ0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmV4dENhbGwuc3RhcnQobWQsIGZpbmFsSW50ZXJjZXB0aW5nTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ01lc3NhZ2UoKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdIYWxmQ2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlcXVlc3Rlci5zZW5kTWVzc2FnZShtZXNzYWdlLCBmaW5hbE1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZUNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIGZpbmFsTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ0hhbGZDbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dCh7fSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIHN0YXJ0UmVhZCgpIHtcbiAgICAgICAgdGhpcy5uZXh0Q2FsbC5zdGFydFJlYWQoKTtcbiAgICB9XG4gICAgaGFsZkNsb3NlKCkge1xuICAgICAgICB0aGlzLnJlcXVlc3Rlci5oYWxmQ2xvc2UoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhIHx8IHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdIYWxmQ2xvc2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnRlcmNlcHRpbmdDYWxsID0gSW50ZXJjZXB0aW5nQ2FsbDtcbmZ1bmN0aW9uIGdldENhbGwoY2hhbm5lbCwgcGF0aCwgb3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgZGVhZGxpbmUgPSAoX2EgPSBvcHRpb25zLmRlYWRsaW5lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBJbmZpbml0eTtcbiAgICBjb25zdCBob3N0ID0gb3B0aW9ucy5ob3N0O1xuICAgIGNvbnN0IHBhcmVudCA9IChfYiA9IG9wdGlvbnMucGFyZW50KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgIGNvbnN0IHByb3BhZ2F0ZUZsYWdzID0gb3B0aW9ucy5wcm9wYWdhdGVfZmxhZ3M7XG4gICAgY29uc3QgY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzO1xuICAgIGNvbnN0IGNhbGwgPSBjaGFubmVsLmNyZWF0ZUNhbGwocGF0aCwgZGVhZGxpbmUsIGhvc3QsIHBhcmVudCwgcHJvcGFnYXRlRmxhZ3MpO1xuICAgIGlmIChjcmVkZW50aWFscykge1xuICAgICAgICBjYWxsLnNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGw7XG59XG4vKipcbiAqIEludGVyY2VwdGluZ0NhbGwgaW1wbGVtZW50YXRpb24gdGhhdCBkaXJlY3RseSBvd25zIHRoZSB1bmRlcmx5aW5nIENhbGxcbiAqIG9iamVjdCBhbmQgaGFuZGxlcyBzZXJpYWxpemF0aW9uIGFuZCBkZXNlcmFpemxpYXRpb24uXG4gKi9cbmNsYXNzIEJhc2VJbnRlcmNlcHRpbmdDYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIG1ldGhvZERlZmluaXRpb24pIHtcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcbiAgICAgICAgdGhpcy5tZXRob2REZWZpbml0aW9uID0gbWV0aG9kRGVmaW5pdGlvbjtcbiAgICB9XG4gICAgY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5jYWxsLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgICAgIGxldCBzZXJpYWxpemVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VyaWFsaXplZCA9IHRoaXMubWV0aG9kRGVmaW5pdGlvbi5yZXF1ZXN0U2VyaWFsaXplKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGwuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsIGBSZXF1ZXN0IG1lc3NhZ2Ugc2VyaWFsaXphdGlvbiBmYWlsdXJlOiAkeygwLCBlcnJvcl8xLmdldEVycm9yTWVzc2FnZSkoZSl9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgc2VyaWFsaXplZCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoe30sIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBzdGFydChtZXRhZGF0YSwgaW50ZXJjZXB0aW5nTGlzdGVuZXIpIHtcbiAgICAgICAgbGV0IHJlYWRFcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuY2FsbC5zdGFydChtZXRhZGF0YSwge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgKF9hID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChpbnRlcmNlcHRpbmdMaXN0ZW5lciwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGxldCBkZXNlcmlhbGl6ZWQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGVzZXJpYWxpemVkID0gdGhpcy5tZXRob2REZWZpbml0aW9uLnJlc3BvbnNlRGVzZXJpYWxpemUobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRFcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZXNwb25zZSBtZXNzYWdlIHBhcnNpbmcgZXJyb3I6ICR7KDAsIGVycm9yXzEuZ2V0RXJyb3JNZXNzYWdlKShlKX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbC5jYW5jZWxXaXRoU3RhdHVzKHJlYWRFcnJvci5jb2RlLCByZWFkRXJyb3IuZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKF9hID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGludGVyY2VwdGluZ0xpc3RlbmVyLCBkZXNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogc3RhdHVzID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGlmIChyZWFkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaW50ZXJjZXB0aW5nTGlzdGVuZXIsIHJlYWRFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAoX2IgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChpbnRlcmNlcHRpbmdMaXN0ZW5lciwgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhcnRSZWFkKCkge1xuICAgICAgICB0aGlzLmNhbGwuc3RhcnRSZWFkKCk7XG4gICAgfVxuICAgIGhhbGZDbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jYWxsLmhhbGZDbG9zZSgpO1xuICAgIH1cbn1cbi8qKlxuICogQmFzZUludGVyY2VwdGluZ0NhbGwgd2l0aCBzcGVjaWFsLWNhc2VkIGJlaGF2aW9yIGZvciBtZXRob2RzIHdpdGggdW5hcnlcbiAqIHJlc3BvbnNlcy5cbiAqL1xuY2xhc3MgQmFzZVVuYXJ5SW50ZXJjZXB0aW5nQ2FsbCBleHRlbmRzIEJhc2VJbnRlcmNlcHRpbmdDYWxsIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0cnVjdG9yKGNhbGwsIG1ldGhvZERlZmluaXRpb24pIHtcbiAgICAgICAgc3VwZXIoY2FsbCwgbWV0aG9kRGVmaW5pdGlvbik7XG4gICAgfVxuICAgIHN0YXJ0KG1ldGFkYXRhLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVjZWl2ZWRNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHdyYXBwZXJMaXN0ZW5lciA9IHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiAoX2IgPSAoX2EgPSBsaXN0ZW5lciA9PT0gbnVsbCB8fCBsaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iaW5kKGxpc3RlbmVyKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKG1ldGFkYXRhID0+IHsgfSksXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAoX2EgPSBsaXN0ZW5lciA9PT0gbnVsbCB8fCBsaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwobGlzdGVuZXIsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWNlaXZlZE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gbGlzdGVuZXIgPT09IG51bGwgfHwgbGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGxpc3RlbmVyLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKF9iID0gbGlzdGVuZXIgPT09IG51bGwgfHwgbGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwobGlzdGVuZXIsIHN0YXR1cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBzdXBlci5zdGFydChtZXRhZGF0YSwgd3JhcHBlckxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5jYWxsLnN0YXJ0UmVhZCgpO1xuICAgIH1cbn1cbi8qKlxuICogQmFzZUludGVyY2VwdGluZ0NhbGwgd2l0aCBzcGVjaWFsLWNhc2VkIGJlaGF2aW9yIGZvciBtZXRob2RzIHdpdGggc3RyZWFtaW5nXG4gKiByZXNwb25zZXMuXG4gKi9cbmNsYXNzIEJhc2VTdHJlYW1pbmdJbnRlcmNlcHRpbmdDYWxsIGV4dGVuZHMgQmFzZUludGVyY2VwdGluZ0NhbGwge1xufVxuZnVuY3Rpb24gZ2V0Qm90dG9tSW50ZXJjZXB0aW5nQ2FsbChjaGFubmVsLCBvcHRpb25zLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5tZXRob2REZWZpbml0aW9uKSB7XG4gICAgY29uc3QgY2FsbCA9IGdldENhbGwoY2hhbm5lbCwgbWV0aG9kRGVmaW5pdGlvbi5wYXRoLCBvcHRpb25zKTtcbiAgICBpZiAobWV0aG9kRGVmaW5pdGlvbi5yZXNwb25zZVN0cmVhbSkge1xuICAgICAgICByZXR1cm4gbmV3IEJhc2VTdHJlYW1pbmdJbnRlcmNlcHRpbmdDYWxsKGNhbGwsIG1ldGhvZERlZmluaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlVW5hcnlJbnRlcmNlcHRpbmdDYWxsKGNhbGwsIG1ldGhvZERlZmluaXRpb24pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEludGVyY2VwdGluZ0NhbGwoaW50ZXJjZXB0b3JBcmdzLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5tZXRob2REZWZpbml0aW9uLCBvcHRpb25zLCBjaGFubmVsKSB7XG4gICAgaWYgKGludGVyY2VwdG9yQXJncy5jbGllbnRJbnRlcmNlcHRvcnMubGVuZ3RoID4gMCAmJlxuICAgICAgICBpbnRlcmNlcHRvckFyZ3MuY2xpZW50SW50ZXJjZXB0b3JQcm92aWRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IoJ0JvdGggaW50ZXJjZXB0b3JzIGFuZCBpbnRlcmNlcHRvcl9wcm92aWRlcnMgd2VyZSBwYXNzZWQgYXMgb3B0aW9ucyAnICtcbiAgICAgICAgICAgICd0byB0aGUgY2xpZW50IGNvbnN0cnVjdG9yLiBPbmx5IG9uZSBvZiB0aGVzZSBpcyBhbGxvd2VkLicpO1xuICAgIH1cbiAgICBpZiAoaW50ZXJjZXB0b3JBcmdzLmNhbGxJbnRlcmNlcHRvcnMubGVuZ3RoID4gMCAmJlxuICAgICAgICBpbnRlcmNlcHRvckFyZ3MuY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yKCdCb3RoIGludGVyY2VwdG9ycyBhbmQgaW50ZXJjZXB0b3JfcHJvdmlkZXJzIHdlcmUgcGFzc2VkIGFzIGNhbGwgJyArXG4gICAgICAgICAgICAnb3B0aW9ucy4gT25seSBvbmUgb2YgdGhlc2UgaXMgYWxsb3dlZC4nKTtcbiAgICB9XG4gICAgbGV0IGludGVyY2VwdG9ycyA9IFtdO1xuICAgIC8vIEludGVyY2VwdG9ycyBwYXNzZWQgdG8gdGhlIGNhbGwgb3ZlcnJpZGUgaW50ZXJjZXB0b3JzIHBhc3NlZCB0byB0aGUgY2xpZW50IGNvbnN0cnVjdG9yXG4gICAgaWYgKGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JzLmxlbmd0aCA+IDAgfHxcbiAgICAgICAgaW50ZXJjZXB0b3JBcmdzLmNhbGxJbnRlcmNlcHRvclByb3ZpZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGludGVyY2VwdG9ycyA9IFtdXG4gICAgICAgICAgICAuY29uY2F0KGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JzLCBpbnRlcmNlcHRvckFyZ3MuY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzLm1hcChwcm92aWRlciA9PiBwcm92aWRlcihtZXRob2REZWZpbml0aW9uKSkpXG4gICAgICAgICAgICAuZmlsdGVyKGludGVyY2VwdG9yID0+IGludGVyY2VwdG9yKTtcbiAgICAgICAgLy8gRmlsdGVyIG91dCBmYWxzeSB2YWx1ZXMgd2hlbiBwcm92aWRlcnMgcmV0dXJuIG5vdGhpbmdcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGludGVyY2VwdG9ycyA9IFtdXG4gICAgICAgICAgICAuY29uY2F0KGludGVyY2VwdG9yQXJncy5jbGllbnRJbnRlcmNlcHRvcnMsIGludGVyY2VwdG9yQXJncy5jbGllbnRJbnRlcmNlcHRvclByb3ZpZGVycy5tYXAocHJvdmlkZXIgPT4gcHJvdmlkZXIobWV0aG9kRGVmaW5pdGlvbikpKVxuICAgICAgICAgICAgLmZpbHRlcihpbnRlcmNlcHRvciA9PiBpbnRlcmNlcHRvcik7XG4gICAgICAgIC8vIEZpbHRlciBvdXQgZmFsc3kgdmFsdWVzIHdoZW4gcHJvdmlkZXJzIHJldHVybiBub3RoaW5nXG4gICAgfVxuICAgIGNvbnN0IGludGVyY2VwdG9yT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgbWV0aG9kX2RlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXG4gICAgfSk7XG4gICAgLyogRm9yIGVhY2ggaW50ZXJjZXB0b3IgaW4gdGhlIGxpc3QsIHRoZSBuZXh0Q2FsbCBmdW5jdGlvbiBwYXNzZWQgdG8gaXQgaXNcbiAgICAgKiBiYXNlZCBvbiB0aGUgbmV4dCBpbnRlcmNlcHRvciBpbiB0aGUgbGlzdCwgdXNpbmcgYSBuZXh0Q2FsbCBmdW5jdGlvblxuICAgICAqIGNvbnN0cnVjdGVkIHdpdGggdGhlIGZvbGxvd2luZyBpbnRlcmNlcHRvciBpbiB0aGUgbGlzdCwgYW5kIHNvIG9uLiBUaGVcbiAgICAgKiBpbml0aWFsVmFsdWUsIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QsIGlzIGEgbmV4dENhbGxcbiAgICAgKiBmdW5jdGlvbiB0aGF0IGludm9rZXMgZ2V0Qm90dG9tSW50ZXJjZXB0aW5nQ2FsbCwgdGhlIHJlc3VsdCBvZiB3aGljaFxuICAgICAqIGhhbmRsZXMgKGRlKXNlcmlhbGl6YXRpb24gYW5kIGFsc28gZ2V0cyB0aGUgdW5kZXJseWluZyBjYWxsIGZyb20gdGhlXG4gICAgICogY2hhbm5lbC4gKi9cbiAgICBjb25zdCBnZXRDYWxsID0gaW50ZXJjZXB0b3JzLnJlZHVjZVJpZ2h0KChuZXh0Q2FsbCwgbmV4dEludGVyY2VwdG9yKSA9PiB7XG4gICAgICAgIHJldHVybiBjdXJyZW50T3B0aW9ucyA9PiBuZXh0SW50ZXJjZXB0b3IoY3VycmVudE9wdGlvbnMsIG5leHRDYWxsKTtcbiAgICB9LCAoZmluYWxPcHRpb25zKSA9PiBnZXRCb3R0b21JbnRlcmNlcHRpbmdDYWxsKGNoYW5uZWwsIGZpbmFsT3B0aW9ucywgbWV0aG9kRGVmaW5pdGlvbikpO1xuICAgIHJldHVybiBnZXRDYWxsKGludGVyY2VwdG9yT3B0aW9ucyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnQtaW50ZXJjZXB0b3JzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkludGVyY2VwdGluZ0NhbGwiLCJSZXF1ZXN0ZXJCdWlsZGVyIiwiTGlzdGVuZXJCdWlsZGVyIiwiSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IiLCJnZXRJbnRlcmNlcHRpbmdDYWxsIiwibWV0YWRhdGFfMSIsInJlcXVpcmUiLCJjYWxsX2ludGVyZmFjZV8xIiwiY29uc3RhbnRzXzEiLCJlcnJvcl8xIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJuYW1lIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJtZXRhZGF0YSIsInVuZGVmaW5lZCIsInN0YXR1cyIsIndpdGhPblJlY2VpdmVNZXRhZGF0YSIsIm9uUmVjZWl2ZU1ldGFkYXRhIiwid2l0aE9uUmVjZWl2ZU1lc3NhZ2UiLCJvblJlY2VpdmVNZXNzYWdlIiwid2l0aE9uUmVjZWl2ZVN0YXR1cyIsIm9uUmVjZWl2ZVN0YXR1cyIsImJ1aWxkIiwic3RhcnQiLCJoYWxmQ2xvc2UiLCJjYW5jZWwiLCJ3aXRoU3RhcnQiLCJ3aXRoU2VuZE1lc3NhZ2UiLCJzZW5kTWVzc2FnZSIsIndpdGhIYWxmQ2xvc2UiLCJ3aXRoQ2FuY2VsIiwiZGVmYXVsdExpc3RlbmVyIiwibmV4dCIsImRlZmF1bHRSZXF1ZXN0ZXIiLCJsaXN0ZW5lciIsIm5leHRDYWxsIiwicmVxdWVzdGVyIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJwcm9jZXNzaW5nTWV0YWRhdGEiLCJwZW5kaW5nTWVzc2FnZUNvbnRleHQiLCJwcm9jZXNzaW5nTWVzc2FnZSIsInBlbmRpbmdIYWxmQ2xvc2UiLCJjYW5jZWxXaXRoU3RhdHVzIiwiZGV0YWlscyIsImdldFBlZXIiLCJwcm9jZXNzUGVuZGluZ01lc3NhZ2UiLCJzZW5kTWVzc2FnZVdpdGhDb250ZXh0IiwicGVuZGluZ01lc3NhZ2UiLCJwcm9jZXNzUGVuZGluZ0hhbGZDbG9zZSIsImludGVyY2VwdGluZ0xpc3RlbmVyIiwiX2UiLCJfZiIsImZ1bGxJbnRlcmNlcHRpbmdMaXN0ZW5lciIsImJpbmQiLCJtZCIsImZpbmFsSW50ZXJjZXB0aW5nTGlzdGVuZXIiLCJpc0ludGVyY2VwdGluZ0xpc3RlbmVyIiwiZnVsbExpc3RlbmVyIiwiSW50ZXJjZXB0aW5nTGlzdGVuZXJJbXBsIiwiY29udGV4dCIsImZpbmFsTWVzc2FnZSIsInN0YXJ0UmVhZCIsImdldENhbGwiLCJjaGFubmVsIiwicGF0aCIsIm9wdGlvbnMiLCJkZWFkbGluZSIsIkluZmluaXR5IiwiaG9zdCIsInBhcmVudCIsInByb3BhZ2F0ZUZsYWdzIiwicHJvcGFnYXRlX2ZsYWdzIiwiY3JlZGVudGlhbHMiLCJjYWxsIiwiY3JlYXRlQ2FsbCIsInNldENyZWRlbnRpYWxzIiwiQmFzZUludGVyY2VwdGluZ0NhbGwiLCJtZXRob2REZWZpbml0aW9uIiwic2VyaWFsaXplZCIsInJlcXVlc3RTZXJpYWxpemUiLCJlIiwiU3RhdHVzIiwiSU5URVJOQUwiLCJnZXRFcnJvck1lc3NhZ2UiLCJyZWFkRXJyb3IiLCJkZXNlcmlhbGl6ZWQiLCJyZXNwb25zZURlc2VyaWFsaXplIiwiY29kZSIsIk1ldGFkYXRhIiwiQmFzZVVuYXJ5SW50ZXJjZXB0aW5nQ2FsbCIsInJlY2VpdmVkTWVzc2FnZSIsIndyYXBwZXJMaXN0ZW5lciIsIkJhc2VTdHJlYW1pbmdJbnRlcmNlcHRpbmdDYWxsIiwiZ2V0Qm90dG9tSW50ZXJjZXB0aW5nQ2FsbCIsInJlc3BvbnNlU3RyZWFtIiwiaW50ZXJjZXB0b3JBcmdzIiwiY2xpZW50SW50ZXJjZXB0b3JzIiwibGVuZ3RoIiwiY2xpZW50SW50ZXJjZXB0b3JQcm92aWRlcnMiLCJjYWxsSW50ZXJjZXB0b3JzIiwiY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzIiwiaW50ZXJjZXB0b3JzIiwiY29uY2F0IiwibWFwIiwicHJvdmlkZXIiLCJmaWx0ZXIiLCJpbnRlcmNlcHRvciIsImludGVyY2VwdG9yT3B0aW9ucyIsImFzc2lnbiIsIm1ldGhvZF9kZWZpbml0aW9uIiwicmVkdWNlUmlnaHQiLCJuZXh0SW50ZXJjZXB0b3IiLCJjdXJyZW50T3B0aW9ucyIsImZpbmFsT3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/client.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Client = void 0;\nconst call_1 = __webpack_require__(/*! ./call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call.js\");\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\nconst CHANNEL_SYMBOL = Symbol();\nconst INTERCEPTOR_SYMBOL = Symbol();\nconst INTERCEPTOR_PROVIDER_SYMBOL = Symbol();\nconst CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();\nfunction isFunction(arg) {\n    return typeof arg === \"function\";\n}\nfunction getErrorStackString(error) {\n    var _a;\n    return ((_a = error.stack) === null || _a === void 0 ? void 0 : _a.split(\"\\n\").slice(1).join(\"\\n\")) || \"no stack trace available\";\n}\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */ class Client {\n    constructor(address, credentials, options = {}){\n        var _a, _b;\n        options = Object.assign({}, options);\n        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];\n        delete options.interceptors;\n        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];\n        delete options.interceptor_providers;\n        if (this[INTERCEPTOR_SYMBOL].length > 0 && this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {\n            throw new Error(\"Both interceptors and interceptor_providers were passed as options \" + \"to the client constructor. Only one of these is allowed.\");\n        }\n        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] = options.callInvocationTransformer;\n        delete options.callInvocationTransformer;\n        if (options.channelOverride) {\n            this[CHANNEL_SYMBOL] = options.channelOverride;\n        } else if (options.channelFactoryOverride) {\n            const channelFactoryOverride = options.channelFactoryOverride;\n            delete options.channelFactoryOverride;\n            this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);\n        } else {\n            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);\n        }\n    }\n    close() {\n        this[CHANNEL_SYMBOL].close();\n    }\n    getChannel() {\n        return this[CHANNEL_SYMBOL];\n    }\n    waitForReady(deadline, callback) {\n        const checkState = (err)=>{\n            if (err) {\n                callback(new Error(\"Failed to connect before the deadline\"));\n                return;\n            }\n            let newState;\n            try {\n                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\n            } catch (e) {\n                callback(new Error(\"The channel has been closed\"));\n                return;\n            }\n            if (newState === connectivity_state_1.ConnectivityState.READY) {\n                callback();\n            } else {\n                try {\n                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\n                } catch (e) {\n                    callback(new Error(\"The channel has been closed\"));\n                }\n            }\n        };\n        setImmediate(checkState);\n    }\n    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n        if (isFunction(arg1)) {\n            return {\n                metadata: new metadata_1.Metadata(),\n                options: {},\n                callback: arg1\n            };\n        } else if (isFunction(arg2)) {\n            if (arg1 instanceof metadata_1.Metadata) {\n                return {\n                    metadata: arg1,\n                    options: {},\n                    callback: arg2\n                };\n            } else {\n                return {\n                    metadata: new metadata_1.Metadata(),\n                    options: arg1,\n                    callback: arg2\n                };\n            }\n        } else {\n            if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && isFunction(arg3))) {\n                throw new Error(\"Incorrect arguments passed\");\n            }\n            return {\n                metadata: arg1,\n                options: arg2,\n                callback: arg3\n            };\n        }\n    }\n    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientUnaryCallImpl(),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */ emitter.call = call;\n        let responseMessage = null;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: (metadata)=>{\n                emitter.emit(\"metadata\", metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage (message) {\n                if (responseMessage !== null) {\n                    call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, \"Too many responses received\");\n                }\n                responseMessage = message;\n            },\n            onReceiveStatus (status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    if (responseMessage === null) {\n                        const callerStack = getErrorStackString(callerStackError);\n                        callProperties.callback((0, call_1.callErrorFromStatus)({\n                            code: constants_1.Status.UNIMPLEMENTED,\n                            details: \"No message received\",\n                            metadata: status.metadata\n                        }, callerStack));\n                    } else {\n                        callProperties.callback(null, responseMessage);\n                    }\n                } else {\n                    const callerStack = getErrorStackString(callerStackError);\n                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */ callerStackError = null;\n                emitter.emit(\"status\", status);\n            }\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return emitter;\n    }\n    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientWritableStreamImpl(serialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */ emitter.call = call;\n        let responseMessage = null;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: (metadata)=>{\n                emitter.emit(\"metadata\", metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage (message) {\n                if (responseMessage !== null) {\n                    call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, \"Too many responses received\");\n                }\n                responseMessage = message;\n                call.startRead();\n            },\n            onReceiveStatus (status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    if (responseMessage === null) {\n                        const callerStack = getErrorStackString(callerStackError);\n                        callProperties.callback((0, call_1.callErrorFromStatus)({\n                            code: constants_1.Status.UNIMPLEMENTED,\n                            details: \"No message received\",\n                            metadata: status.metadata\n                        }, callerStack));\n                    } else {\n                        callProperties.callback(null, responseMessage);\n                    }\n                } else {\n                    const callerStack = getErrorStackString(callerStackError);\n                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */ callerStackError = null;\n                emitter.emit(\"status\", status);\n            }\n        });\n        return emitter;\n    }\n    checkMetadataAndOptions(arg1, arg2) {\n        let metadata;\n        let options;\n        if (arg1 instanceof metadata_1.Metadata) {\n            metadata = arg1;\n            if (arg2) {\n                options = arg2;\n            } else {\n                options = {};\n            }\n        } else {\n            if (arg1) {\n                options = arg1;\n            } else {\n                options = {};\n            }\n            metadata = new metadata_1.Metadata();\n        }\n        return {\n            metadata,\n            options\n        };\n    }\n    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientReadableStreamImpl(deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */ stream.call = call;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata (metadata) {\n                stream.emit(\"metadata\", metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage (message) {\n                stream.push(message);\n            },\n            onReceiveStatus (status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    const callerStack = getErrorStackString(callerStackError);\n                    stream.emit(\"error\", (0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */ callerStackError = null;\n                stream.emit(\"status\", status);\n            }\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return stream;\n    }\n    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */ stream.call = call;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata (metadata) {\n                stream.emit(\"metadata\", metadata);\n            },\n            onReceiveMessage (message) {\n                stream.push(message);\n            },\n            onReceiveStatus (status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    const callerStack = getErrorStackString(callerStackError);\n                    stream.emit(\"error\", (0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */ callerStackError = null;\n                stream.emit(\"status\", status);\n            }\n        });\n        return stream;\n    }\n}\nexports.Client = Client; //# sourceMappingURL=client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixNQUFNRyxTQUFTQyxtQkFBT0EsQ0FBQyxvRUFBUTtBQUMvQixNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQywwRUFBVztBQUNyQyxNQUFNRSx1QkFBdUJGLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNRyxjQUFjSCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNSSxhQUFhSixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNSyx3QkFBd0JMLG1CQUFPQSxDQUFDLGtHQUF1QjtBQUM3RCxNQUFNTSxpQkFBaUJDO0FBQ3ZCLE1BQU1DLHFCQUFxQkQ7QUFDM0IsTUFBTUUsOEJBQThCRjtBQUNwQyxNQUFNRyxxQ0FBcUNIO0FBQzNDLFNBQVNJLFdBQVdDLEdBQUc7SUFDbkIsT0FBTyxPQUFPQSxRQUFRO0FBQzFCO0FBQ0EsU0FBU0Msb0JBQW9CQyxLQUFLO0lBQzlCLElBQUlDO0lBQ0osT0FBTyxDQUFDLENBQUNBLEtBQUtELE1BQU1FLEtBQUssTUFBTSxRQUFRRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdFLEtBQUssQ0FBQyxNQUFNQyxLQUFLLENBQUMsR0FBR0MsSUFBSSxDQUFDLEtBQUksS0FBTTtBQUMzRztBQUNBOzs7Q0FHQyxHQUNELE1BQU1yQjtJQUNGc0IsWUFBWUMsT0FBTyxFQUFFQyxXQUFXLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLENBQUU7UUFDNUMsSUFBSVIsSUFBSVM7UUFDUkQsVUFBVTdCLE9BQU8rQixNQUFNLENBQUMsQ0FBQyxHQUFHRjtRQUM1QixJQUFJLENBQUNmLG1CQUFtQixHQUFHLENBQUNPLEtBQUtRLFFBQVFHLFlBQVksTUFBTSxRQUFRWCxPQUFPLEtBQUssSUFBSUEsS0FBSyxFQUFFO1FBQzFGLE9BQU9RLFFBQVFHLFlBQVk7UUFDM0IsSUFBSSxDQUFDakIsNEJBQTRCLEdBQUcsQ0FBQ2UsS0FBS0QsUUFBUUkscUJBQXFCLE1BQU0sUUFBUUgsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRTtRQUM1RyxPQUFPRCxRQUFRSSxxQkFBcUI7UUFDcEMsSUFBSSxJQUFJLENBQUNuQixtQkFBbUIsQ0FBQ29CLE1BQU0sR0FBRyxLQUNsQyxJQUFJLENBQUNuQiw0QkFBNEIsQ0FBQ21CLE1BQU0sR0FBRyxHQUFHO1lBQzlDLE1BQU0sSUFBSUMsTUFBTSx3RUFDWjtRQUNSO1FBQ0EsSUFBSSxDQUFDbkIsbUNBQW1DLEdBQ3BDYSxRQUFRTyx5QkFBeUI7UUFDckMsT0FBT1AsUUFBUU8seUJBQXlCO1FBQ3hDLElBQUlQLFFBQVFRLGVBQWUsRUFBRTtZQUN6QixJQUFJLENBQUN6QixlQUFlLEdBQUdpQixRQUFRUSxlQUFlO1FBQ2xELE9BQ0ssSUFBSVIsUUFBUVMsc0JBQXNCLEVBQUU7WUFDckMsTUFBTUEseUJBQXlCVCxRQUFRUyxzQkFBc0I7WUFDN0QsT0FBT1QsUUFBUVMsc0JBQXNCO1lBQ3JDLElBQUksQ0FBQzFCLGVBQWUsR0FBRzBCLHVCQUF1QlgsU0FBU0MsYUFBYUM7UUFDeEUsT0FDSztZQUNELElBQUksQ0FBQ2pCLGVBQWUsR0FBRyxJQUFJTCxVQUFVZ0MscUJBQXFCLENBQUNaLFNBQVNDLGFBQWFDO1FBQ3JGO0lBQ0o7SUFDQVcsUUFBUTtRQUNKLElBQUksQ0FBQzVCLGVBQWUsQ0FBQzRCLEtBQUs7SUFDOUI7SUFDQUMsYUFBYTtRQUNULE9BQU8sSUFBSSxDQUFDN0IsZUFBZTtJQUMvQjtJQUNBOEIsYUFBYUMsUUFBUSxFQUFFQyxRQUFRLEVBQUU7UUFDN0IsTUFBTUMsYUFBYSxDQUFDQztZQUNoQixJQUFJQSxLQUFLO2dCQUNMRixTQUFTLElBQUlULE1BQU07Z0JBQ25CO1lBQ0o7WUFDQSxJQUFJWTtZQUNKLElBQUk7Z0JBQ0FBLFdBQVcsSUFBSSxDQUFDbkMsZUFBZSxDQUFDb0Msb0JBQW9CLENBQUM7WUFDekQsRUFDQSxPQUFPQyxHQUFHO2dCQUNOTCxTQUFTLElBQUlULE1BQU07Z0JBQ25CO1lBQ0o7WUFDQSxJQUFJWSxhQUFhdkMscUJBQXFCMEMsaUJBQWlCLENBQUNDLEtBQUssRUFBRTtnQkFDM0RQO1lBQ0osT0FDSztnQkFDRCxJQUFJO29CQUNBLElBQUksQ0FBQ2hDLGVBQWUsQ0FBQ3dDLHNCQUFzQixDQUFDTCxVQUFVSixVQUFVRTtnQkFDcEUsRUFDQSxPQUFPSSxHQUFHO29CQUNOTCxTQUFTLElBQUlULE1BQU07Z0JBQ3ZCO1lBQ0o7UUFDSjtRQUNBa0IsYUFBYVI7SUFDakI7SUFDQVMsb0NBQW9DQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFO1FBQ2xELElBQUl4QyxXQUFXc0MsT0FBTztZQUNsQixPQUFPO2dCQUFFRyxVQUFVLElBQUloRCxXQUFXaUQsUUFBUTtnQkFBSTlCLFNBQVMsQ0FBQztnQkFBR2UsVUFBVVc7WUFBSztRQUM5RSxPQUNLLElBQUl0QyxXQUFXdUMsT0FBTztZQUN2QixJQUFJRCxnQkFBZ0I3QyxXQUFXaUQsUUFBUSxFQUFFO2dCQUNyQyxPQUFPO29CQUFFRCxVQUFVSDtvQkFBTTFCLFNBQVMsQ0FBQztvQkFBR2UsVUFBVVk7Z0JBQUs7WUFDekQsT0FDSztnQkFDRCxPQUFPO29CQUFFRSxVQUFVLElBQUloRCxXQUFXaUQsUUFBUTtvQkFBSTlCLFNBQVMwQjtvQkFBTVgsVUFBVVk7Z0JBQUs7WUFDaEY7UUFDSixPQUNLO1lBQ0QsSUFBSSxDQUFFRCxDQUFBQSxnQkFBZ0I3QyxXQUFXaUQsUUFBUSxJQUNyQ0gsZ0JBQWdCeEQsVUFDaEJpQixXQUFXd0MsS0FBSSxHQUFJO2dCQUNuQixNQUFNLElBQUl0QixNQUFNO1lBQ3BCO1lBQ0EsT0FBTztnQkFBRXVCLFVBQVVIO2dCQUFNMUIsU0FBUzJCO2dCQUFNWixVQUFVYTtZQUFLO1FBQzNEO0lBQ0o7SUFDQUcsaUJBQWlCQyxNQUFNLEVBQUVDLFNBQVMsRUFBRUMsV0FBVyxFQUFFQyxRQUFRLEVBQUVOLFFBQVEsRUFBRTdCLE9BQU8sRUFBRWUsUUFBUSxFQUFFO1FBQ3BGLElBQUl2QixJQUFJUztRQUNSLE1BQU1tQyxtQkFBbUIsSUFBSSxDQUFDWCxtQ0FBbUMsQ0FBQ0ksVUFBVTdCLFNBQVNlO1FBQ3JGLE1BQU1zQixtQkFBbUI7WUFDckJDLE1BQU1OO1lBQ05PLGVBQWU7WUFDZkMsZ0JBQWdCO1lBQ2hCQyxrQkFBa0JSO1lBQ2xCUyxxQkFBcUJSO1FBQ3pCO1FBQ0EsSUFBSVMsaUJBQWlCO1lBQ2pCUixVQUFVQTtZQUNWTixVQUFVTyxpQkFBaUJQLFFBQVE7WUFDbkNlLE1BQU0sSUFBSXBFLE9BQU9xRSxtQkFBbUI7WUFDcENDLFNBQVMsSUFBSSxDQUFDL0QsZUFBZTtZQUM3QnNELGtCQUFrQkE7WUFDbEJVLGFBQWFYLGlCQUFpQnBDLE9BQU87WUFDckNlLFVBQVVxQixpQkFBaUJyQixRQUFRO1FBQ3ZDO1FBQ0EsSUFBSSxJQUFJLENBQUM1QixtQ0FBbUMsRUFBRTtZQUMxQ3dELGlCQUFpQixJQUFJLENBQUN4RCxtQ0FBbUMsQ0FBQ3dEO1FBQzlEO1FBQ0EsTUFBTUssVUFBVUwsZUFBZUMsSUFBSTtRQUNuQyxNQUFNSyxrQkFBa0I7WUFDcEJDLG9CQUFvQixJQUFJLENBQUNqRSxtQkFBbUI7WUFDNUNrRSw0QkFBNEIsSUFBSSxDQUFDakUsNEJBQTRCO1lBQzdEa0Usa0JBQWtCLENBQUM1RCxLQUFLbUQsZUFBZUksV0FBVyxDQUFDNUMsWUFBWSxNQUFNLFFBQVFYLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUU7WUFDcEc2RCwwQkFBMEIsQ0FBQ3BELEtBQUswQyxlQUFlSSxXQUFXLENBQUMzQyxxQkFBcUIsTUFBTSxRQUFRSCxPQUFPLEtBQUssSUFBSUEsS0FBSyxFQUFFO1FBQ3pIO1FBQ0EsTUFBTTJDLE9BQU8sQ0FBQyxHQUFHOUQsc0JBQXNCd0UsbUJBQW1CLEVBQUVMLGlCQUFpQk4sZUFBZU4sZ0JBQWdCLEVBQUVNLGVBQWVJLFdBQVcsRUFBRUosZUFBZUcsT0FBTztRQUNoSzs7OzRCQUdvQixHQUNwQkUsUUFBUUosSUFBSSxHQUFHQTtRQUNmLElBQUlXLGtCQUFrQjtRQUN0QixJQUFJQyxpQkFBaUI7UUFDckIsSUFBSUMsbUJBQW1CLElBQUluRDtRQUMzQnNDLEtBQUtjLEtBQUssQ0FBQ2YsZUFBZWQsUUFBUSxFQUFFO1lBQ2hDOEIsbUJBQW1COUIsQ0FBQUE7Z0JBQ2ZtQixRQUFRWSxJQUFJLENBQUMsWUFBWS9CO1lBQzdCO1lBQ0EsOERBQThEO1lBQzlEZ0Msa0JBQWlCQyxPQUFPO2dCQUNwQixJQUFJUCxvQkFBb0IsTUFBTTtvQkFDMUJYLEtBQUttQixnQkFBZ0IsQ0FBQ25GLFlBQVlvRixNQUFNLENBQUNDLGFBQWEsRUFBRTtnQkFDNUQ7Z0JBQ0FWLGtCQUFrQk87WUFDdEI7WUFDQUksaUJBQWdCQyxNQUFNO2dCQUNsQixJQUFJWCxnQkFBZ0I7b0JBQ2hCO2dCQUNKO2dCQUNBQSxpQkFBaUI7Z0JBQ2pCLElBQUlXLE9BQU9DLElBQUksS0FBS3hGLFlBQVlvRixNQUFNLENBQUNLLEVBQUUsRUFBRTtvQkFDdkMsSUFBSWQsb0JBQW9CLE1BQU07d0JBQzFCLE1BQU1lLGNBQWNoRixvQkFBb0JtRTt3QkFDeENkLGVBQWU1QixRQUFRLENBQUMsQ0FBQyxHQUFHdkMsT0FBTytGLG1CQUFtQixFQUFFOzRCQUNwREgsTUFBTXhGLFlBQVlvRixNQUFNLENBQUNDLGFBQWE7NEJBQ3RDTyxTQUFTOzRCQUNUM0MsVUFBVXNDLE9BQU90QyxRQUFRO3dCQUM3QixHQUFHeUM7b0JBQ1AsT0FDSzt3QkFDRDNCLGVBQWU1QixRQUFRLENBQUMsTUFBTXdDO29CQUNsQztnQkFDSixPQUNLO29CQUNELE1BQU1lLGNBQWNoRixvQkFBb0JtRTtvQkFDeENkLGVBQWU1QixRQUFRLENBQUMsQ0FBQyxHQUFHdkMsT0FBTytGLG1CQUFtQixFQUFFSixRQUFRRztnQkFDcEU7Z0JBQ0E7NkNBQzZCLEdBQzdCYixtQkFBbUI7Z0JBQ25CVCxRQUFRWSxJQUFJLENBQUMsVUFBVU87WUFDM0I7UUFDSjtRQUNBdkIsS0FBSzZCLFdBQVcsQ0FBQ3RDO1FBQ2pCUyxLQUFLOEIsU0FBUztRQUNkLE9BQU8xQjtJQUNYO0lBQ0EyQix3QkFBd0IzQyxNQUFNLEVBQUVDLFNBQVMsRUFBRUMsV0FBVyxFQUFFTCxRQUFRLEVBQUU3QixPQUFPLEVBQUVlLFFBQVEsRUFBRTtRQUNqRixJQUFJdkIsSUFBSVM7UUFDUixNQUFNbUMsbUJBQW1CLElBQUksQ0FBQ1gsbUNBQW1DLENBQUNJLFVBQVU3QixTQUFTZTtRQUNyRixNQUFNc0IsbUJBQW1CO1lBQ3JCQyxNQUFNTjtZQUNOTyxlQUFlO1lBQ2ZDLGdCQUFnQjtZQUNoQkMsa0JBQWtCUjtZQUNsQlMscUJBQXFCUjtRQUN6QjtRQUNBLElBQUlTLGlCQUFpQjtZQUNqQmQsVUFBVU8saUJBQWlCUCxRQUFRO1lBQ25DZSxNQUFNLElBQUlwRSxPQUFPb0csd0JBQXdCLENBQUMzQztZQUMxQ2EsU0FBUyxJQUFJLENBQUMvRCxlQUFlO1lBQzdCc0Qsa0JBQWtCQTtZQUNsQlUsYUFBYVgsaUJBQWlCcEMsT0FBTztZQUNyQ2UsVUFBVXFCLGlCQUFpQnJCLFFBQVE7UUFDdkM7UUFDQSxJQUFJLElBQUksQ0FBQzVCLG1DQUFtQyxFQUFFO1lBQzFDd0QsaUJBQWlCLElBQUksQ0FBQ3hELG1DQUFtQyxDQUFDd0Q7UUFDOUQ7UUFDQSxNQUFNSyxVQUFVTCxlQUFlQyxJQUFJO1FBQ25DLE1BQU1LLGtCQUFrQjtZQUNwQkMsb0JBQW9CLElBQUksQ0FBQ2pFLG1CQUFtQjtZQUM1Q2tFLDRCQUE0QixJQUFJLENBQUNqRSw0QkFBNEI7WUFDN0RrRSxrQkFBa0IsQ0FBQzVELEtBQUttRCxlQUFlSSxXQUFXLENBQUM1QyxZQUFZLE1BQU0sUUFBUVgsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRTtZQUNwRzZELDBCQUEwQixDQUFDcEQsS0FBSzBDLGVBQWVJLFdBQVcsQ0FBQzNDLHFCQUFxQixNQUFNLFFBQVFILE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUU7UUFDekg7UUFDQSxNQUFNMkMsT0FBTyxDQUFDLEdBQUc5RCxzQkFBc0J3RSxtQkFBbUIsRUFBRUwsaUJBQWlCTixlQUFlTixnQkFBZ0IsRUFBRU0sZUFBZUksV0FBVyxFQUFFSixlQUFlRyxPQUFPO1FBQ2hLOzs7NEJBR29CLEdBQ3BCRSxRQUFRSixJQUFJLEdBQUdBO1FBQ2YsSUFBSVcsa0JBQWtCO1FBQ3RCLElBQUlDLGlCQUFpQjtRQUNyQixJQUFJQyxtQkFBbUIsSUFBSW5EO1FBQzNCc0MsS0FBS2MsS0FBSyxDQUFDZixlQUFlZCxRQUFRLEVBQUU7WUFDaEM4QixtQkFBbUI5QixDQUFBQTtnQkFDZm1CLFFBQVFZLElBQUksQ0FBQyxZQUFZL0I7WUFDN0I7WUFDQSw4REFBOEQ7WUFDOURnQyxrQkFBaUJDLE9BQU87Z0JBQ3BCLElBQUlQLG9CQUFvQixNQUFNO29CQUMxQlgsS0FBS21CLGdCQUFnQixDQUFDbkYsWUFBWW9GLE1BQU0sQ0FBQ0MsYUFBYSxFQUFFO2dCQUM1RDtnQkFDQVYsa0JBQWtCTztnQkFDbEJsQixLQUFLaUMsU0FBUztZQUNsQjtZQUNBWCxpQkFBZ0JDLE1BQU07Z0JBQ2xCLElBQUlYLGdCQUFnQjtvQkFDaEI7Z0JBQ0o7Z0JBQ0FBLGlCQUFpQjtnQkFDakIsSUFBSVcsT0FBT0MsSUFBSSxLQUFLeEYsWUFBWW9GLE1BQU0sQ0FBQ0ssRUFBRSxFQUFFO29CQUN2QyxJQUFJZCxvQkFBb0IsTUFBTTt3QkFDMUIsTUFBTWUsY0FBY2hGLG9CQUFvQm1FO3dCQUN4Q2QsZUFBZTVCLFFBQVEsQ0FBQyxDQUFDLEdBQUd2QyxPQUFPK0YsbUJBQW1CLEVBQUU7NEJBQ3BESCxNQUFNeEYsWUFBWW9GLE1BQU0sQ0FBQ0MsYUFBYTs0QkFDdENPLFNBQVM7NEJBQ1QzQyxVQUFVc0MsT0FBT3RDLFFBQVE7d0JBQzdCLEdBQUd5QztvQkFDUCxPQUNLO3dCQUNEM0IsZUFBZTVCLFFBQVEsQ0FBQyxNQUFNd0M7b0JBQ2xDO2dCQUNKLE9BQ0s7b0JBQ0QsTUFBTWUsY0FBY2hGLG9CQUFvQm1FO29CQUN4Q2QsZUFBZTVCLFFBQVEsQ0FBQyxDQUFDLEdBQUd2QyxPQUFPK0YsbUJBQW1CLEVBQUVKLFFBQVFHO2dCQUNwRTtnQkFDQTs2Q0FDNkIsR0FDN0JiLG1CQUFtQjtnQkFDbkJULFFBQVFZLElBQUksQ0FBQyxVQUFVTztZQUMzQjtRQUNKO1FBQ0EsT0FBT25CO0lBQ1g7SUFDQThCLHdCQUF3QnBELElBQUksRUFBRUMsSUFBSSxFQUFFO1FBQ2hDLElBQUlFO1FBQ0osSUFBSTdCO1FBQ0osSUFBSTBCLGdCQUFnQjdDLFdBQVdpRCxRQUFRLEVBQUU7WUFDckNELFdBQVdIO1lBQ1gsSUFBSUMsTUFBTTtnQkFDTjNCLFVBQVUyQjtZQUNkLE9BQ0s7Z0JBQ0QzQixVQUFVLENBQUM7WUFDZjtRQUNKLE9BQ0s7WUFDRCxJQUFJMEIsTUFBTTtnQkFDTjFCLFVBQVUwQjtZQUNkLE9BQ0s7Z0JBQ0QxQixVQUFVLENBQUM7WUFDZjtZQUNBNkIsV0FBVyxJQUFJaEQsV0FBV2lELFFBQVE7UUFDdEM7UUFDQSxPQUFPO1lBQUVEO1lBQVU3QjtRQUFRO0lBQy9CO0lBQ0ErRSx3QkFBd0IvQyxNQUFNLEVBQUVDLFNBQVMsRUFBRUMsV0FBVyxFQUFFQyxRQUFRLEVBQUVOLFFBQVEsRUFBRTdCLE9BQU8sRUFBRTtRQUNqRixJQUFJUixJQUFJUztRQUNSLE1BQU1tQyxtQkFBbUIsSUFBSSxDQUFDMEMsdUJBQXVCLENBQUNqRCxVQUFVN0I7UUFDaEUsTUFBTXFDLG1CQUFtQjtZQUNyQkMsTUFBTU47WUFDTk8sZUFBZTtZQUNmQyxnQkFBZ0I7WUFDaEJDLGtCQUFrQlI7WUFDbEJTLHFCQUFxQlI7UUFDekI7UUFDQSxJQUFJUyxpQkFBaUI7WUFDakJSLFVBQVVBO1lBQ1ZOLFVBQVVPLGlCQUFpQlAsUUFBUTtZQUNuQ2UsTUFBTSxJQUFJcEUsT0FBT3dHLHdCQUF3QixDQUFDOUM7WUFDMUNZLFNBQVMsSUFBSSxDQUFDL0QsZUFBZTtZQUM3QnNELGtCQUFrQkE7WUFDbEJVLGFBQWFYLGlCQUFpQnBDLE9BQU87UUFDekM7UUFDQSxJQUFJLElBQUksQ0FBQ2IsbUNBQW1DLEVBQUU7WUFDMUN3RCxpQkFBaUIsSUFBSSxDQUFDeEQsbUNBQW1DLENBQUN3RDtRQUM5RDtRQUNBLE1BQU1zQyxTQUFTdEMsZUFBZUMsSUFBSTtRQUNsQyxNQUFNSyxrQkFBa0I7WUFDcEJDLG9CQUFvQixJQUFJLENBQUNqRSxtQkFBbUI7WUFDNUNrRSw0QkFBNEIsSUFBSSxDQUFDakUsNEJBQTRCO1lBQzdEa0Usa0JBQWtCLENBQUM1RCxLQUFLbUQsZUFBZUksV0FBVyxDQUFDNUMsWUFBWSxNQUFNLFFBQVFYLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUU7WUFDcEc2RCwwQkFBMEIsQ0FBQ3BELEtBQUswQyxlQUFlSSxXQUFXLENBQUMzQyxxQkFBcUIsTUFBTSxRQUFRSCxPQUFPLEtBQUssSUFBSUEsS0FBSyxFQUFFO1FBQ3pIO1FBQ0EsTUFBTTJDLE9BQU8sQ0FBQyxHQUFHOUQsc0JBQXNCd0UsbUJBQW1CLEVBQUVMLGlCQUFpQk4sZUFBZU4sZ0JBQWdCLEVBQUVNLGVBQWVJLFdBQVcsRUFBRUosZUFBZUcsT0FBTztRQUNoSzs7OzRCQUdvQixHQUNwQm1DLE9BQU9yQyxJQUFJLEdBQUdBO1FBQ2QsSUFBSVksaUJBQWlCO1FBQ3JCLElBQUlDLG1CQUFtQixJQUFJbkQ7UUFDM0JzQyxLQUFLYyxLQUFLLENBQUNmLGVBQWVkLFFBQVEsRUFBRTtZQUNoQzhCLG1CQUFrQjlCLFFBQVE7Z0JBQ3RCb0QsT0FBT3JCLElBQUksQ0FBQyxZQUFZL0I7WUFDNUI7WUFDQSw4REFBOEQ7WUFDOURnQyxrQkFBaUJDLE9BQU87Z0JBQ3BCbUIsT0FBT0MsSUFBSSxDQUFDcEI7WUFDaEI7WUFDQUksaUJBQWdCQyxNQUFNO2dCQUNsQixJQUFJWCxnQkFBZ0I7b0JBQ2hCO2dCQUNKO2dCQUNBQSxpQkFBaUI7Z0JBQ2pCeUIsT0FBT0MsSUFBSSxDQUFDO2dCQUNaLElBQUlmLE9BQU9DLElBQUksS0FBS3hGLFlBQVlvRixNQUFNLENBQUNLLEVBQUUsRUFBRTtvQkFDdkMsTUFBTUMsY0FBY2hGLG9CQUFvQm1FO29CQUN4Q3dCLE9BQU9yQixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUdwRixPQUFPK0YsbUJBQW1CLEVBQUVKLFFBQVFHO2dCQUNqRTtnQkFDQTs2Q0FDNkIsR0FDN0JiLG1CQUFtQjtnQkFDbkJ3QixPQUFPckIsSUFBSSxDQUFDLFVBQVVPO1lBQzFCO1FBQ0o7UUFDQXZCLEtBQUs2QixXQUFXLENBQUN0QztRQUNqQlMsS0FBSzhCLFNBQVM7UUFDZCxPQUFPTztJQUNYO0lBQ0FFLHNCQUFzQm5ELE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxXQUFXLEVBQUVMLFFBQVEsRUFBRTdCLE9BQU8sRUFBRTtRQUNyRSxJQUFJUixJQUFJUztRQUNSLE1BQU1tQyxtQkFBbUIsSUFBSSxDQUFDMEMsdUJBQXVCLENBQUNqRCxVQUFVN0I7UUFDaEUsTUFBTXFDLG1CQUFtQjtZQUNyQkMsTUFBTU47WUFDTk8sZUFBZTtZQUNmQyxnQkFBZ0I7WUFDaEJDLGtCQUFrQlI7WUFDbEJTLHFCQUFxQlI7UUFDekI7UUFDQSxJQUFJUyxpQkFBaUI7WUFDakJkLFVBQVVPLGlCQUFpQlAsUUFBUTtZQUNuQ2UsTUFBTSxJQUFJcEUsT0FBTzRHLHNCQUFzQixDQUFDbkQsV0FBV0M7WUFDbkRZLFNBQVMsSUFBSSxDQUFDL0QsZUFBZTtZQUM3QnNELGtCQUFrQkE7WUFDbEJVLGFBQWFYLGlCQUFpQnBDLE9BQU87UUFDekM7UUFDQSxJQUFJLElBQUksQ0FBQ2IsbUNBQW1DLEVBQUU7WUFDMUN3RCxpQkFBaUIsSUFBSSxDQUFDeEQsbUNBQW1DLENBQUN3RDtRQUM5RDtRQUNBLE1BQU1zQyxTQUFTdEMsZUFBZUMsSUFBSTtRQUNsQyxNQUFNSyxrQkFBa0I7WUFDcEJDLG9CQUFvQixJQUFJLENBQUNqRSxtQkFBbUI7WUFDNUNrRSw0QkFBNEIsSUFBSSxDQUFDakUsNEJBQTRCO1lBQzdEa0Usa0JBQWtCLENBQUM1RCxLQUFLbUQsZUFBZUksV0FBVyxDQUFDNUMsWUFBWSxNQUFNLFFBQVFYLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUU7WUFDcEc2RCwwQkFBMEIsQ0FBQ3BELEtBQUswQyxlQUFlSSxXQUFXLENBQUMzQyxxQkFBcUIsTUFBTSxRQUFRSCxPQUFPLEtBQUssSUFBSUEsS0FBSyxFQUFFO1FBQ3pIO1FBQ0EsTUFBTTJDLE9BQU8sQ0FBQyxHQUFHOUQsc0JBQXNCd0UsbUJBQW1CLEVBQUVMLGlCQUFpQk4sZUFBZU4sZ0JBQWdCLEVBQUVNLGVBQWVJLFdBQVcsRUFBRUosZUFBZUcsT0FBTztRQUNoSzs7OzRCQUdvQixHQUNwQm1DLE9BQU9yQyxJQUFJLEdBQUdBO1FBQ2QsSUFBSVksaUJBQWlCO1FBQ3JCLElBQUlDLG1CQUFtQixJQUFJbkQ7UUFDM0JzQyxLQUFLYyxLQUFLLENBQUNmLGVBQWVkLFFBQVEsRUFBRTtZQUNoQzhCLG1CQUFrQjlCLFFBQVE7Z0JBQ3RCb0QsT0FBT3JCLElBQUksQ0FBQyxZQUFZL0I7WUFDNUI7WUFDQWdDLGtCQUFpQkMsT0FBTztnQkFDcEJtQixPQUFPQyxJQUFJLENBQUNwQjtZQUNoQjtZQUNBSSxpQkFBZ0JDLE1BQU07Z0JBQ2xCLElBQUlYLGdCQUFnQjtvQkFDaEI7Z0JBQ0o7Z0JBQ0FBLGlCQUFpQjtnQkFDakJ5QixPQUFPQyxJQUFJLENBQUM7Z0JBQ1osSUFBSWYsT0FBT0MsSUFBSSxLQUFLeEYsWUFBWW9GLE1BQU0sQ0FBQ0ssRUFBRSxFQUFFO29CQUN2QyxNQUFNQyxjQUFjaEYsb0JBQW9CbUU7b0JBQ3hDd0IsT0FBT3JCLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBR3BGLE9BQU8rRixtQkFBbUIsRUFBRUosUUFBUUc7Z0JBQ2pFO2dCQUNBOzZDQUM2QixHQUM3QmIsbUJBQW1CO2dCQUNuQndCLE9BQU9yQixJQUFJLENBQUMsVUFBVU87WUFDMUI7UUFDSjtRQUNBLE9BQU9jO0lBQ1g7QUFDSjtBQUNBNUcsY0FBYyxHQUFHRSxRQUNqQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LmpzPzgyNjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2xpZW50ID0gdm9pZCAwO1xuY29uc3QgY2FsbF8xID0gcmVxdWlyZShcIi4vY2FsbFwiKTtcbmNvbnN0IGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWxcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgY2xpZW50X2ludGVyY2VwdG9yc18xID0gcmVxdWlyZShcIi4vY2xpZW50LWludGVyY2VwdG9yc1wiKTtcbmNvbnN0IENIQU5ORUxfU1lNQk9MID0gU3ltYm9sKCk7XG5jb25zdCBJTlRFUkNFUFRPUl9TWU1CT0wgPSBTeW1ib2woKTtcbmNvbnN0IElOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTCA9IFN5bWJvbCgpO1xuY29uc3QgQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTCA9IFN5bWJvbCgpO1xuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGdldEVycm9yU3RhY2tTdHJpbmcoZXJyb3IpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSBlcnJvci5zdGFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNwbGl0KCdcXG4nKS5zbGljZSgxKS5qb2luKCdcXG4nKSkgfHwgJ25vIHN0YWNrIHRyYWNlIGF2YWlsYWJsZSc7XG59XG4vKipcbiAqIEEgZ2VuZXJpYyBnUlBDIGNsaWVudC4gUHJpbWFyaWx5IHVzZWZ1bCBhcyBhIGJhc2UgY2xhc3MgZm9yIGFsbCBnZW5lcmF0ZWRcbiAqIGNsaWVudHMuXG4gKi9cbmNsYXNzIENsaWVudCB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgY3JlZGVudGlhbHMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXSA9IChfYSA9IG9wdGlvbnMuaW50ZXJjZXB0b3JzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuaW50ZXJjZXB0b3JzO1xuICAgICAgICB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0gPSAoX2IgPSBvcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycztcbiAgICAgICAgaWYgKHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXS5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIGludGVyY2VwdG9ycyBhbmQgaW50ZXJjZXB0b3JfcHJvdmlkZXJzIHdlcmUgcGFzc2VkIGFzIG9wdGlvbnMgJyArXG4gICAgICAgICAgICAgICAgJ3RvIHRoZSBjbGllbnQgY29uc3RydWN0b3IuIE9ubHkgb25lIG9mIHRoZXNlIGlzIGFsbG93ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXSA9XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXI7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmNhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXI7XG4gICAgICAgIGlmIChvcHRpb25zLmNoYW5uZWxPdmVycmlkZSkge1xuICAgICAgICAgICAgdGhpc1tDSEFOTkVMX1NZTUJPTF0gPSBvcHRpb25zLmNoYW5uZWxPdmVycmlkZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmNoYW5uZWxGYWN0b3J5T3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxGYWN0b3J5T3ZlcnJpZGUgPSBvcHRpb25zLmNoYW5uZWxGYWN0b3J5T3ZlcnJpZGU7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5jaGFubmVsRmFjdG9yeU92ZXJyaWRlO1xuICAgICAgICAgICAgdGhpc1tDSEFOTkVMX1NZTUJPTF0gPSBjaGFubmVsRmFjdG9yeU92ZXJyaWRlKGFkZHJlc3MsIGNyZWRlbnRpYWxzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbQ0hBTk5FTF9TWU1CT0xdID0gbmV3IGNoYW5uZWxfMS5DaGFubmVsSW1wbGVtZW50YXRpb24oYWRkcmVzcywgY3JlZGVudGlhbHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzW0NIQU5ORUxfU1lNQk9MXS5jbG9zZSgpO1xuICAgIH1cbiAgICBnZXRDaGFubmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tDSEFOTkVMX1NZTUJPTF07XG4gICAgfVxuICAgIHdhaXRGb3JSZWFkeShkZWFkbGluZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgY2hlY2tTdGF0ZSA9IChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb25uZWN0IGJlZm9yZSB0aGUgZGVhZGxpbmUnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5ld1N0YXRlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRoaXNbQ0hBTk5FTF9TWU1CT0xdLmdldENvbm5lY3Rpdml0eVN0YXRlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ1RoZSBjaGFubmVsIGhhcyBiZWVuIGNsb3NlZCcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbQ0hBTk5FTF9TWU1CT0xdLndhdGNoQ29ubmVjdGl2aXR5U3RhdGUobmV3U3RhdGUsIGRlYWRsaW5lLCBjaGVja1N0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdUaGUgY2hhbm5lbCBoYXMgYmVlbiBjbG9zZWQnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzZXRJbW1lZGlhdGUoY2hlY2tTdGF0ZSk7XG4gICAgfVxuICAgIGNoZWNrT3B0aW9uYWxVbmFyeVJlc3BvbnNlQXJndW1lbnRzKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oYXJnMSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLCBvcHRpb25zOiB7fSwgY2FsbGJhY2s6IGFyZzEgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGFyZzIpKSB7XG4gICAgICAgICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRhZGF0YTogYXJnMSwgb3B0aW9uczoge30sIGNhbGxiYWNrOiBhcmcyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSwgb3B0aW9uczogYXJnMSwgY2FsbGJhY2s6IGFyZzIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghKGFyZzEgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLk1ldGFkYXRhICYmXG4gICAgICAgICAgICAgICAgYXJnMiBpbnN0YW5jZW9mIE9iamVjdCAmJlxuICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24oYXJnMykpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgYXJndW1lbnRzIHBhc3NlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgbWV0YWRhdGE6IGFyZzEsIG9wdGlvbnM6IGFyZzIsIGNhbGxiYWNrOiBhcmczIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWFrZVVuYXJ5UmVxdWVzdChtZXRob2QsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIGFyZ3VtZW50LCBtZXRhZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgY2hlY2tlZEFyZ3VtZW50cyA9IHRoaXMuY2hlY2tPcHRpb25hbFVuYXJ5UmVzcG9uc2VBcmd1bWVudHMobWV0YWRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgY29uc3QgbWV0aG9kRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIHBhdGg6IG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW06IGZhbHNlLFxuICAgICAgICAgICAgcmVzcG9uc2VTdHJlYW06IGZhbHNlLFxuICAgICAgICAgICAgcmVxdWVzdFNlcmlhbGl6ZTogc2VyaWFsaXplLFxuICAgICAgICAgICAgcmVzcG9uc2VEZXNlcmlhbGl6ZTogZGVzZXJpYWxpemUsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjYWxsUHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIGFyZ3VtZW50OiBhcmd1bWVudCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjaGVja2VkQXJndW1lbnRzLm1ldGFkYXRhLFxuICAgICAgICAgICAgY2FsbDogbmV3IGNhbGxfMS5DbGllbnRVbmFyeUNhbGxJbXBsKCksXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzW0NIQU5ORUxfU1lNQk9MXSxcbiAgICAgICAgICAgIG1ldGhvZERlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXG4gICAgICAgICAgICBjYWxsT3B0aW9uczogY2hlY2tlZEFyZ3VtZW50cy5vcHRpb25zLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNoZWNrZWRBcmd1bWVudHMuY2FsbGJhY2ssXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKSB7XG4gICAgICAgICAgICBjYWxsUHJvcGVydGllcyA9IHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0oY2FsbFByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBjYWxsUHJvcGVydGllcy5jYWxsO1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvckFyZ3MgPSB7XG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvcnM6IHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXSxcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzOiB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JzOiAoX2EgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzOiAoX2IgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYWxsID0gKDAsIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5nZXRJbnRlcmNlcHRpbmdDYWxsKShpbnRlcmNlcHRvckFyZ3MsIGNhbGxQcm9wZXJ0aWVzLm1ldGhvZERlZmluaXRpb24sIGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLCBjYWxsUHJvcGVydGllcy5jaGFubmVsKTtcbiAgICAgICAgLyogVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBlbWl0dGVyIGlzIHVzZWQuIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3RcbiAgICAgICAgICogZW5mb3JjZSB0aGlzIHdpdGggdGhlIHR5cGUgc3lzdGVtLiBXZSBuZWVkIHRvIGNvbnN0cnVjdCB0aGlzIGVtaXR0ZXJcbiAgICAgICAgICogYmVmb3JlIGNhbGxpbmcgdGhlIENhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXIsIGFuZCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGVcbiAgICAgICAgICogY2FsbCBhZnRlciB0aGF0LiAqL1xuICAgICAgICBlbWl0dGVyLmNhbGwgPSBjYWxsO1xuICAgICAgICBsZXQgcmVzcG9uc2VNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgbGV0IHJlY2VpdmVkU3RhdHVzID0gZmFsc2U7XG4gICAgICAgIGxldCBjYWxsZXJTdGFja0Vycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGNhbGwuc3RhcnQoY2FsbFByb3BlcnRpZXMubWV0YWRhdGEsIHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiBtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLlVOSU1QTEVNRU5URUQsICdUb28gbWFueSByZXNwb25zZXMgcmVjZWl2ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVkU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRTdGF0dXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlclN0YWNrID0gZ2V0RXJyb3JTdGFja1N0cmluZyhjYWxsZXJTdGFja0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzLmNhbGxiYWNrKCgwLCBjYWxsXzEuY2FsbEVycm9yRnJvbVN0YXR1cykoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTklNUExFTUVOVEVELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdObyBtZXNzYWdlIHJlY2VpdmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogc3RhdHVzLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2FsbGVyU3RhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzLmNhbGxiYWNrKG51bGwsIHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlclN0YWNrID0gZ2V0RXJyb3JTdGFja1N0cmluZyhjYWxsZXJTdGFja0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2soKDAsIGNhbGxfMS5jYWxsRXJyb3JGcm9tU3RhdHVzKShzdGF0dXMsIGNhbGxlclN0YWNrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIEF2b2lkIHJldGFpbmluZyB0aGUgY2FsbGVyU3RhY2tFcnJvciBvYmplY3QgaW4gdGhlIGNhbGwgY29udGV4dCBvZlxuICAgICAgICAgICAgICAgICAqIHRoZSBzdGF0dXMgZXZlbnQgaGFuZGxlci4gKi9cbiAgICAgICAgICAgICAgICBjYWxsZXJTdGFja0Vycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY2FsbC5zZW5kTWVzc2FnZShhcmd1bWVudCk7XG4gICAgICAgIGNhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgIHJldHVybiBlbWl0dGVyO1xuICAgIH1cbiAgICBtYWtlQ2xpZW50U3RyZWFtUmVxdWVzdChtZXRob2QsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIG1ldGFkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjaGVja2VkQXJndW1lbnRzID0gdGhpcy5jaGVja09wdGlvbmFsVW5hcnlSZXNwb25zZUFyZ3VtZW50cyhtZXRhZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICBjb25zdCBtZXRob2REZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgcGF0aDogbWV0aG9kLFxuICAgICAgICAgICAgcmVxdWVzdFN0cmVhbTogdHJ1ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtOiBmYWxzZSxcbiAgICAgICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IHNlcmlhbGl6ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY2FsbFByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBtZXRhZGF0YTogY2hlY2tlZEFyZ3VtZW50cy5tZXRhZGF0YSxcbiAgICAgICAgICAgIGNhbGw6IG5ldyBjYWxsXzEuQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsKHNlcmlhbGl6ZSksXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzW0NIQU5ORUxfU1lNQk9MXSxcbiAgICAgICAgICAgIG1ldGhvZERlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXG4gICAgICAgICAgICBjYWxsT3B0aW9uczogY2hlY2tlZEFyZ3VtZW50cy5vcHRpb25zLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNoZWNrZWRBcmd1bWVudHMuY2FsbGJhY2ssXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKSB7XG4gICAgICAgICAgICBjYWxsUHJvcGVydGllcyA9IHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0oY2FsbFByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBjYWxsUHJvcGVydGllcy5jYWxsO1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvckFyZ3MgPSB7XG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvcnM6IHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXSxcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzOiB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JzOiAoX2EgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzOiAoX2IgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYWxsID0gKDAsIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5nZXRJbnRlcmNlcHRpbmdDYWxsKShpbnRlcmNlcHRvckFyZ3MsIGNhbGxQcm9wZXJ0aWVzLm1ldGhvZERlZmluaXRpb24sIGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLCBjYWxsUHJvcGVydGllcy5jaGFubmVsKTtcbiAgICAgICAgLyogVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBlbWl0dGVyIGlzIHVzZWQuIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3RcbiAgICAgICAgICogZW5mb3JjZSB0aGlzIHdpdGggdGhlIHR5cGUgc3lzdGVtLiBXZSBuZWVkIHRvIGNvbnN0cnVjdCB0aGlzIGVtaXR0ZXJcbiAgICAgICAgICogYmVmb3JlIGNhbGxpbmcgdGhlIENhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXIsIGFuZCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGVcbiAgICAgICAgICogY2FsbCBhZnRlciB0aGF0LiAqL1xuICAgICAgICBlbWl0dGVyLmNhbGwgPSBjYWxsO1xuICAgICAgICBsZXQgcmVzcG9uc2VNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgbGV0IHJlY2VpdmVkU3RhdHVzID0gZmFsc2U7XG4gICAgICAgIGxldCBjYWxsZXJTdGFja0Vycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGNhbGwuc3RhcnQoY2FsbFByb3BlcnRpZXMubWV0YWRhdGEsIHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiBtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLlVOSU1QTEVNRU5URUQsICdUb28gbWFueSByZXNwb25zZXMgcmVjZWl2ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICBjYWxsLnN0YXJ0UmVhZCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWNlaXZlZFN0YXR1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2soKDAsIGNhbGxfMS5jYWxsRXJyb3JGcm9tU3RhdHVzKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOSU1QTEVNRU5URUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogJ05vIG1lc3NhZ2UgcmVjZWl2ZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBzdGF0dXMubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2sobnVsbCwgcmVzcG9uc2VNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjaygoMCwgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMpKHN0YXR1cywgY2FsbGVyU3RhY2spKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogQXZvaWQgcmV0YWluaW5nIHRoZSBjYWxsZXJTdGFja0Vycm9yIG9iamVjdCBpbiB0aGUgY2FsbCBjb250ZXh0IG9mXG4gICAgICAgICAgICAgICAgICogdGhlIHN0YXR1cyBldmVudCBoYW5kbGVyLiAqL1xuICAgICAgICAgICAgICAgIGNhbGxlclN0YWNrRXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZW1pdHRlcjtcbiAgICB9XG4gICAgY2hlY2tNZXRhZGF0YUFuZE9wdGlvbnMoYXJnMSwgYXJnMikge1xuICAgICAgICBsZXQgbWV0YWRhdGE7XG4gICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhID0gYXJnMTtcbiAgICAgICAgICAgIGlmIChhcmcyKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXJnMSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1ldGFkYXRhLCBvcHRpb25zIH07XG4gICAgfVxuICAgIG1ha2VTZXJ2ZXJTdHJlYW1SZXF1ZXN0KG1ldGhvZCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgYXJndW1lbnQsIG1ldGFkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRBcmd1bWVudHMgPSB0aGlzLmNoZWNrTWV0YWRhdGFBbmRPcHRpb25zKG1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbWV0aG9kRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIHBhdGg6IG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW06IGZhbHNlLFxuICAgICAgICAgICAgcmVzcG9uc2VTdHJlYW06IHRydWUsXG4gICAgICAgICAgICByZXF1ZXN0U2VyaWFsaXplOiBzZXJpYWxpemUsXG4gICAgICAgICAgICByZXNwb25zZURlc2VyaWFsaXplOiBkZXNlcmlhbGl6ZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNhbGxQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgYXJndW1lbnQ6IGFyZ3VtZW50LFxuICAgICAgICAgICAgbWV0YWRhdGE6IGNoZWNrZWRBcmd1bWVudHMubWV0YWRhdGEsXG4gICAgICAgICAgICBjYWxsOiBuZXcgY2FsbF8xLkNsaWVudFJlYWRhYmxlU3RyZWFtSW1wbChkZXNlcmlhbGl6ZSksXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzW0NIQU5ORUxfU1lNQk9MXSxcbiAgICAgICAgICAgIG1ldGhvZERlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXG4gICAgICAgICAgICBjYWxsT3B0aW9uczogY2hlY2tlZEFyZ3VtZW50cy5vcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXSkge1xuICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMgPSB0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKGNhbGxQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJlYW0gPSBjYWxsUHJvcGVydGllcy5jYWxsO1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvckFyZ3MgPSB7XG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvcnM6IHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXSxcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzOiB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JzOiAoX2EgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzOiAoX2IgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYWxsID0gKDAsIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5nZXRJbnRlcmNlcHRpbmdDYWxsKShpbnRlcmNlcHRvckFyZ3MsIGNhbGxQcm9wZXJ0aWVzLm1ldGhvZERlZmluaXRpb24sIGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLCBjYWxsUHJvcGVydGllcy5jaGFubmVsKTtcbiAgICAgICAgLyogVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBlbWl0dGVyIGlzIHVzZWQuIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3RcbiAgICAgICAgICogZW5mb3JjZSB0aGlzIHdpdGggdGhlIHR5cGUgc3lzdGVtLiBXZSBuZWVkIHRvIGNvbnN0cnVjdCB0aGlzIGVtaXR0ZXJcbiAgICAgICAgICogYmVmb3JlIGNhbGxpbmcgdGhlIENhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXIsIGFuZCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGVcbiAgICAgICAgICogY2FsbCBhZnRlciB0aGF0LiAqL1xuICAgICAgICBzdHJlYW0uY2FsbCA9IGNhbGw7XG4gICAgICAgIGxldCByZWNlaXZlZFN0YXR1cyA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FsbGVyU3RhY2tFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBjYWxsLnN0YXJ0KGNhbGxQcm9wZXJ0aWVzLm1ldGFkYXRhLCB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVkU3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZXJTdGFjayA9IGdldEVycm9yU3RhY2tTdHJpbmcoY2FsbGVyU3RhY2tFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsICgwLCBjYWxsXzEuY2FsbEVycm9yRnJvbVN0YXR1cykoc3RhdHVzLCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBBdm9pZCByZXRhaW5pbmcgdGhlIGNhbGxlclN0YWNrRXJyb3Igb2JqZWN0IGluIHRoZSBjYWxsIGNvbnRleHQgb2ZcbiAgICAgICAgICAgICAgICAgKiB0aGUgc3RhdHVzIGV2ZW50IGhhbmRsZXIuICovXG4gICAgICAgICAgICAgICAgY2FsbGVyU3RhY2tFcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY2FsbC5zZW5kTWVzc2FnZShhcmd1bWVudCk7XG4gICAgICAgIGNhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxuICAgIG1ha2VCaWRpU3RyZWFtUmVxdWVzdChtZXRob2QsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIG1ldGFkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRBcmd1bWVudHMgPSB0aGlzLmNoZWNrTWV0YWRhdGFBbmRPcHRpb25zKG1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbWV0aG9kRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIHBhdGg6IG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW06IHRydWUsXG4gICAgICAgICAgICByZXNwb25zZVN0cmVhbTogdHJ1ZSxcbiAgICAgICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IHNlcmlhbGl6ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY2FsbFByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBtZXRhZGF0YTogY2hlY2tlZEFyZ3VtZW50cy5tZXRhZGF0YSxcbiAgICAgICAgICAgIGNhbGw6IG5ldyBjYWxsXzEuQ2xpZW50RHVwbGV4U3RyZWFtSW1wbChzZXJpYWxpemUsIGRlc2VyaWFsaXplKSxcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXNbQ0hBTk5FTF9TWU1CT0xdLFxuICAgICAgICAgICAgbWV0aG9kRGVmaW5pdGlvbjogbWV0aG9kRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGNhbGxPcHRpb25zOiBjaGVja2VkQXJndW1lbnRzLm9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKSB7XG4gICAgICAgICAgICBjYWxsUHJvcGVydGllcyA9IHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0oY2FsbFByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNhbGxQcm9wZXJ0aWVzLmNhbGw7XG4gICAgICAgIGNvbnN0IGludGVyY2VwdG9yQXJncyA9IHtcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yczogdGhpc1tJTlRFUkNFUFRPUl9TWU1CT0xdLFxuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JQcm92aWRlcnM6IHRoaXNbSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MXSxcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvcnM6IChfYSA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JQcm92aWRlcnM6IChfYiA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbGwgPSAoMCwgY2xpZW50X2ludGVyY2VwdG9yc18xLmdldEludGVyY2VwdGluZ0NhbGwpKGludGVyY2VwdG9yQXJncywgY2FsbFByb3BlcnRpZXMubWV0aG9kRGVmaW5pdGlvbiwgY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMsIGNhbGxQcm9wZXJ0aWVzLmNoYW5uZWwpO1xuICAgICAgICAvKiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgdGhlIGVtaXR0ZXIgaXMgdXNlZC4gVW5mb3J0dW5hdGVseSB3ZSBjYW4ndFxuICAgICAgICAgKiBlbmZvcmNlIHRoaXMgd2l0aCB0aGUgdHlwZSBzeXN0ZW0uIFdlIG5lZWQgdG8gY29uc3RydWN0IHRoaXMgZW1pdHRlclxuICAgICAgICAgKiBiZWZvcmUgY2FsbGluZyB0aGUgQ2FsbEludm9jYXRpb25UcmFuc2Zvcm1lciwgYW5kIHdlIG5lZWQgdG8gY3JlYXRlIHRoZVxuICAgICAgICAgKiBjYWxsIGFmdGVyIHRoYXQuICovXG4gICAgICAgIHN0cmVhbS5jYWxsID0gY2FsbDtcbiAgICAgICAgbGV0IHJlY2VpdmVkU3RhdHVzID0gZmFsc2U7XG4gICAgICAgIGxldCBjYWxsZXJTdGFja0Vycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGNhbGwuc3RhcnQoY2FsbFByb3BlcnRpZXMubWV0YWRhdGEsIHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ21ldGFkYXRhJywgbWV0YWRhdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWNlaXZlZFN0YXR1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlICE9PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCAoMCwgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMpKHN0YXR1cywgY2FsbGVyU3RhY2spKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogQXZvaWQgcmV0YWluaW5nIHRoZSBjYWxsZXJTdGFja0Vycm9yIG9iamVjdCBpbiB0aGUgY2FsbCBjb250ZXh0IG9mXG4gICAgICAgICAgICAgICAgICogdGhlIHN0YXR1cyBldmVudCBoYW5kbGVyLiAqL1xuICAgICAgICAgICAgICAgIGNhbGxlclN0YWNrRXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdzdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnQgPSBDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2xpZW50IiwiY2FsbF8xIiwicmVxdWlyZSIsImNoYW5uZWxfMSIsImNvbm5lY3Rpdml0eV9zdGF0ZV8xIiwiY29uc3RhbnRzXzEiLCJtZXRhZGF0YV8xIiwiY2xpZW50X2ludGVyY2VwdG9yc18xIiwiQ0hBTk5FTF9TWU1CT0wiLCJTeW1ib2wiLCJJTlRFUkNFUFRPUl9TWU1CT0wiLCJJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0wiLCJDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MIiwiaXNGdW5jdGlvbiIsImFyZyIsImdldEVycm9yU3RhY2tTdHJpbmciLCJlcnJvciIsIl9hIiwic3RhY2siLCJzcGxpdCIsInNsaWNlIiwiam9pbiIsImNvbnN0cnVjdG9yIiwiYWRkcmVzcyIsImNyZWRlbnRpYWxzIiwib3B0aW9ucyIsIl9iIiwiYXNzaWduIiwiaW50ZXJjZXB0b3JzIiwiaW50ZXJjZXB0b3JfcHJvdmlkZXJzIiwibGVuZ3RoIiwiRXJyb3IiLCJjYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyIiwiY2hhbm5lbE92ZXJyaWRlIiwiY2hhbm5lbEZhY3RvcnlPdmVycmlkZSIsIkNoYW5uZWxJbXBsZW1lbnRhdGlvbiIsImNsb3NlIiwiZ2V0Q2hhbm5lbCIsIndhaXRGb3JSZWFkeSIsImRlYWRsaW5lIiwiY2FsbGJhY2siLCJjaGVja1N0YXRlIiwiZXJyIiwibmV3U3RhdGUiLCJnZXRDb25uZWN0aXZpdHlTdGF0ZSIsImUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIlJFQURZIiwid2F0Y2hDb25uZWN0aXZpdHlTdGF0ZSIsInNldEltbWVkaWF0ZSIsImNoZWNrT3B0aW9uYWxVbmFyeVJlc3BvbnNlQXJndW1lbnRzIiwiYXJnMSIsImFyZzIiLCJhcmczIiwibWV0YWRhdGEiLCJNZXRhZGF0YSIsIm1ha2VVbmFyeVJlcXVlc3QiLCJtZXRob2QiLCJzZXJpYWxpemUiLCJkZXNlcmlhbGl6ZSIsImFyZ3VtZW50IiwiY2hlY2tlZEFyZ3VtZW50cyIsIm1ldGhvZERlZmluaXRpb24iLCJwYXRoIiwicmVxdWVzdFN0cmVhbSIsInJlc3BvbnNlU3RyZWFtIiwicmVxdWVzdFNlcmlhbGl6ZSIsInJlc3BvbnNlRGVzZXJpYWxpemUiLCJjYWxsUHJvcGVydGllcyIsImNhbGwiLCJDbGllbnRVbmFyeUNhbGxJbXBsIiwiY2hhbm5lbCIsImNhbGxPcHRpb25zIiwiZW1pdHRlciIsImludGVyY2VwdG9yQXJncyIsImNsaWVudEludGVyY2VwdG9ycyIsImNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzIiwiY2FsbEludGVyY2VwdG9ycyIsImNhbGxJbnRlcmNlcHRvclByb3ZpZGVycyIsImdldEludGVyY2VwdGluZ0NhbGwiLCJyZXNwb25zZU1lc3NhZ2UiLCJyZWNlaXZlZFN0YXR1cyIsImNhbGxlclN0YWNrRXJyb3IiLCJzdGFydCIsIm9uUmVjZWl2ZU1ldGFkYXRhIiwiZW1pdCIsIm9uUmVjZWl2ZU1lc3NhZ2UiLCJtZXNzYWdlIiwiY2FuY2VsV2l0aFN0YXR1cyIsIlN0YXR1cyIsIlVOSU1QTEVNRU5URUQiLCJvblJlY2VpdmVTdGF0dXMiLCJzdGF0dXMiLCJjb2RlIiwiT0siLCJjYWxsZXJTdGFjayIsImNhbGxFcnJvckZyb21TdGF0dXMiLCJkZXRhaWxzIiwic2VuZE1lc3NhZ2UiLCJoYWxmQ2xvc2UiLCJtYWtlQ2xpZW50U3RyZWFtUmVxdWVzdCIsIkNsaWVudFdyaXRhYmxlU3RyZWFtSW1wbCIsInN0YXJ0UmVhZCIsImNoZWNrTWV0YWRhdGFBbmRPcHRpb25zIiwibWFrZVNlcnZlclN0cmVhbVJlcXVlc3QiLCJDbGllbnRSZWFkYWJsZVN0cmVhbUltcGwiLCJzdHJlYW0iLCJwdXNoIiwibWFrZUJpZGlTdHJlYW1SZXF1ZXN0IiwiQ2xpZW50RHVwbGV4U3RyZWFtSW1wbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js":
/*!************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CompressionAlgorithms = void 0;\nvar CompressionAlgorithms;\n(function(CompressionAlgorithms) {\n    CompressionAlgorithms[CompressionAlgorithms[\"identity\"] = 0] = \"identity\";\n    CompressionAlgorithms[CompressionAlgorithms[\"deflate\"] = 1] = \"deflate\";\n    CompressionAlgorithms[CompressionAlgorithms[\"gzip\"] = 2] = \"gzip\";\n})(CompressionAlgorithms || (exports.CompressionAlgorithms = CompressionAlgorithms = {})); //# sourceMappingURL=compression-algorithms.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tYWxnb3JpdGhtcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNkJBQTZCLEdBQUcsS0FBSztBQUNyQyxJQUFJRTtBQUNILFVBQVVBLHFCQUFxQjtJQUM1QkEscUJBQXFCLENBQUNBLHFCQUFxQixDQUFDLFdBQVcsR0FBRyxFQUFFLEdBQUc7SUFDL0RBLHFCQUFxQixDQUFDQSxxQkFBcUIsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQzlEQSxxQkFBcUIsQ0FBQ0EscUJBQXFCLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztBQUMvRCxHQUFHQSx5QkFBMEJGLENBQUFBLDZCQUE2QixHQUFHRSx3QkFBd0IsQ0FBQyxLQUN0RixrREFBa0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tYWxnb3JpdGhtcy5qcz8yOTI5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIxIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbXByZXNzaW9uQWxnb3JpdGhtcyA9IHZvaWQgMDtcbnZhciBDb21wcmVzc2lvbkFsZ29yaXRobXM7XG4oZnVuY3Rpb24gKENvbXByZXNzaW9uQWxnb3JpdGhtcykge1xuICAgIENvbXByZXNzaW9uQWxnb3JpdGhtc1tDb21wcmVzc2lvbkFsZ29yaXRobXNbXCJpZGVudGl0eVwiXSA9IDBdID0gXCJpZGVudGl0eVwiO1xuICAgIENvbXByZXNzaW9uQWxnb3JpdGhtc1tDb21wcmVzc2lvbkFsZ29yaXRobXNbXCJkZWZsYXRlXCJdID0gMV0gPSBcImRlZmxhdGVcIjtcbiAgICBDb21wcmVzc2lvbkFsZ29yaXRobXNbQ29tcHJlc3Npb25BbGdvcml0aG1zW1wiZ3ppcFwiXSA9IDJdID0gXCJnemlwXCI7XG59KShDb21wcmVzc2lvbkFsZ29yaXRobXMgfHwgKGV4cG9ydHMuQ29tcHJlc3Npb25BbGdvcml0aG1zID0gQ29tcHJlc3Npb25BbGdvcml0aG1zID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXByZXNzaW9uLWFsZ29yaXRobXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ29tcHJlc3Npb25BbGdvcml0aG1zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-filter.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CompressionFilterFactory = exports.CompressionFilter = void 0;\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst isCompressionAlgorithmKey = (key)=>{\n    return typeof key === \"number\" && typeof compression_algorithms_1.CompressionAlgorithms[key] === \"string\";\n};\nclass CompressionHandler {\n    /**\n     * @param message Raw uncompressed message bytes\n     * @param compress Indicates whether the message should be compressed\n     * @return Framed message, compressed if applicable\n     */ async writeMessage(message, compress) {\n        let messageBuffer = message;\n        if (compress) {\n            messageBuffer = await this.compressMessage(messageBuffer);\n        }\n        const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n        output.writeUInt8(compress ? 1 : 0, 0);\n        output.writeUInt32BE(messageBuffer.length, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    /**\n     * @param data Framed message, possibly compressed\n     * @return Uncompressed message\n     */ async readMessage(data) {\n        const compressed = data.readUInt8(0) === 1;\n        let messageBuffer = data.slice(5);\n        if (compressed) {\n            messageBuffer = await this.decompressMessage(messageBuffer);\n        }\n        return messageBuffer;\n    }\n}\nclass IdentityHandler extends CompressionHandler {\n    async compressMessage(message) {\n        return message;\n    }\n    async writeMessage(message, compress) {\n        const output = Buffer.allocUnsafe(message.length + 5);\n        /* With \"identity\" compression, messages should always be marked as\n         * uncompressed */ output.writeUInt8(0, 0);\n        output.writeUInt32BE(message.length, 1);\n        message.copy(output, 5);\n        return output;\n    }\n    decompressMessage(message) {\n        return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n    }\n}\nclass DeflateHandler extends CompressionHandler {\n    constructor(maxRecvMessageLength){\n        super();\n        this.maxRecvMessageLength = maxRecvMessageLength;\n    }\n    compressMessage(message) {\n        return new Promise((resolve, reject)=>{\n            zlib.deflate(message, (err, output)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject)=>{\n            let totalLength = 0;\n            const messageParts = [];\n            const decompresser = zlib.createInflate();\n            decompresser.on(\"data\", (chunk)=>{\n                messageParts.push(chunk);\n                totalLength += chunk.byteLength;\n                if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {\n                    decompresser.destroy();\n                    reject({\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\n                        details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`\n                    });\n                }\n            });\n            decompresser.on(\"end\", ()=>{\n                resolve(Buffer.concat(messageParts));\n            });\n            decompresser.write(message);\n            decompresser.end();\n        });\n    }\n}\nclass GzipHandler extends CompressionHandler {\n    constructor(maxRecvMessageLength){\n        super();\n        this.maxRecvMessageLength = maxRecvMessageLength;\n    }\n    compressMessage(message) {\n        return new Promise((resolve, reject)=>{\n            zlib.gzip(message, (err, output)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject)=>{\n            let totalLength = 0;\n            const messageParts = [];\n            const decompresser = zlib.createGunzip();\n            decompresser.on(\"data\", (chunk)=>{\n                messageParts.push(chunk);\n                totalLength += chunk.byteLength;\n                if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {\n                    decompresser.destroy();\n                    reject({\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\n                        details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`\n                    });\n                }\n            });\n            decompresser.on(\"end\", ()=>{\n                resolve(Buffer.concat(messageParts));\n            });\n            decompresser.write(message);\n            decompresser.end();\n        });\n    }\n}\nclass UnknownHandler extends CompressionHandler {\n    constructor(compressionName){\n        super();\n        this.compressionName = compressionName;\n    }\n    compressMessage(message) {\n        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));\n    }\n    decompressMessage(message) {\n        // This should be unreachable\n        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\n    }\n}\nfunction getCompressionHandler(compressionName, maxReceiveMessageSize) {\n    switch(compressionName){\n        case \"identity\":\n            return new IdentityHandler();\n        case \"deflate\":\n            return new DeflateHandler(maxReceiveMessageSize);\n        case \"gzip\":\n            return new GzipHandler(maxReceiveMessageSize);\n        default:\n            return new UnknownHandler(compressionName);\n    }\n}\nclass CompressionFilter extends filter_1.BaseFilter {\n    constructor(channelOptions, sharedFilterConfig){\n        var _a, _b, _c;\n        super();\n        this.sharedFilterConfig = sharedFilterConfig;\n        this.sendCompression = new IdentityHandler();\n        this.receiveCompression = new IdentityHandler();\n        this.currentCompressionAlgorithm = \"identity\";\n        const compressionAlgorithmKey = channelOptions[\"grpc.default_compression_algorithm\"];\n        this.maxReceiveMessageLength = (_a = channelOptions[\"grpc.max_receive_message_length\"]) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        this.maxSendMessageLength = (_b = channelOptions[\"grpc.max_send_message_length\"]) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n        if (compressionAlgorithmKey !== undefined) {\n            if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {\n                const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];\n                const serverSupportedEncodings = (_c = sharedFilterConfig.serverSupportedEncodingHeader) === null || _c === void 0 ? void 0 : _c.split(\",\");\n                /**\n                 * There are two possible situations here:\n                 * 1) We don't have any info yet from the server about what compression it supports\n                 *    In that case we should just use what the client tells us to use\n                 * 2) We've previously received a response from the server including a grpc-accept-encoding header\n                 *    In that case we only want to use the encoding chosen by the client if the server supports it\n                 */ if (!serverSupportedEncodings || serverSupportedEncodings.includes(clientSelectedEncoding)) {\n                    this.currentCompressionAlgorithm = clientSelectedEncoding;\n                    this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm, -1);\n                }\n            } else {\n                logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);\n            }\n        }\n    }\n    async sendMetadata(metadata) {\n        const headers = await metadata;\n        headers.set(\"grpc-accept-encoding\", \"identity,deflate,gzip\");\n        headers.set(\"accept-encoding\", \"identity\");\n        // No need to send the header if it's \"identity\" -  behavior is identical; save the bandwidth\n        if (this.currentCompressionAlgorithm === \"identity\") {\n            headers.remove(\"grpc-encoding\");\n        } else {\n            headers.set(\"grpc-encoding\", this.currentCompressionAlgorithm);\n        }\n        return headers;\n    }\n    receiveMetadata(metadata) {\n        const receiveEncoding = metadata.get(\"grpc-encoding\");\n        if (receiveEncoding.length > 0) {\n            const encoding = receiveEncoding[0];\n            if (typeof encoding === \"string\") {\n                this.receiveCompression = getCompressionHandler(encoding, this.maxReceiveMessageLength);\n            }\n        }\n        metadata.remove(\"grpc-encoding\");\n        /* Check to see if the compression we're using to send messages is supported by the server\n         * If not, reset the sendCompression filter and have it use the default IdentityHandler */ const serverSupportedEncodingsHeader = metadata.get(\"grpc-accept-encoding\")[0];\n        if (serverSupportedEncodingsHeader) {\n            this.sharedFilterConfig.serverSupportedEncodingHeader = serverSupportedEncodingsHeader;\n            const serverSupportedEncodings = serverSupportedEncodingsHeader.split(\",\");\n            if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {\n                this.sendCompression = new IdentityHandler();\n                this.currentCompressionAlgorithm = \"identity\";\n            }\n        }\n        metadata.remove(\"grpc-accept-encoding\");\n        return metadata;\n    }\n    async sendMessage(message) {\n        var _a;\n        /* This filter is special. The input message is the bare message bytes,\n         * and the output is a framed and possibly compressed message. For this\n         * reason, this filter should be at the bottom of the filter stack */ const resolvedMessage = await message;\n        if (this.maxSendMessageLength !== -1 && resolvedMessage.message.length > this.maxSendMessageLength) {\n            throw {\n                code: constants_1.Status.RESOURCE_EXHAUSTED,\n                details: `Attempted to send message with a size larger than ${this.maxSendMessageLength}`\n            };\n        }\n        let compress;\n        if (this.sendCompression instanceof IdentityHandler) {\n            compress = false;\n        } else {\n            compress = (((_a = resolvedMessage.flags) !== null && _a !== void 0 ? _a : 0) & 2 /* WriteFlags.NoCompress */ ) === 0;\n        }\n        return {\n            message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),\n            flags: resolvedMessage.flags\n        };\n    }\n    async receiveMessage(message) {\n        /* This filter is also special. The input message is framed and possibly\n         * compressed, and the output message is deframed and uncompressed. So\n         * this is another reason that this filter should be at the bottom of the\n         * filter stack. */ return this.receiveCompression.readMessage(await message);\n    }\n}\nexports.CompressionFilter = CompressionFilter;\nclass CompressionFilterFactory {\n    constructor(channel, options){\n        this.options = options;\n        this.sharedFilterConfig = {};\n    }\n    createFilter() {\n        return new CompressionFilter(this.options, this.sharedFilterConfig);\n    }\n}\nexports.CompressionFilterFactory = CompressionFilterFactory; //# sourceMappingURL=compression-filter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tZmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQ0FBZ0MsR0FBR0EseUJBQXlCLEdBQUcsS0FBSztBQUNwRSxNQUFNSSxPQUFPQyxtQkFBT0EsQ0FBQyxrQkFBTTtBQUMzQixNQUFNQywyQkFBMkJELG1CQUFPQSxDQUFDLHdHQUEwQjtBQUNuRSxNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRyxXQUFXSCxtQkFBT0EsQ0FBQyx3RUFBVTtBQUNuQyxNQUFNSSxVQUFVSixtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNSyw0QkFBNEIsQ0FBQ0M7SUFDL0IsT0FBUSxPQUFPQSxRQUFRLFlBQVksT0FBT0wseUJBQXlCTSxxQkFBcUIsQ0FBQ0QsSUFBSSxLQUFLO0FBQ3RHO0FBQ0EsTUFBTUU7SUFDRjs7OztLQUlDLEdBQ0QsTUFBTUMsYUFBYUMsT0FBTyxFQUFFQyxRQUFRLEVBQUU7UUFDbEMsSUFBSUMsZ0JBQWdCRjtRQUNwQixJQUFJQyxVQUFVO1lBQ1ZDLGdCQUFnQixNQUFNLElBQUksQ0FBQ0MsZUFBZSxDQUFDRDtRQUMvQztRQUNBLE1BQU1FLFNBQVNDLE9BQU9DLFdBQVcsQ0FBQ0osY0FBY0ssTUFBTSxHQUFHO1FBQ3pESCxPQUFPSSxVQUFVLENBQUNQLFdBQVcsSUFBSSxHQUFHO1FBQ3BDRyxPQUFPSyxhQUFhLENBQUNQLGNBQWNLLE1BQU0sRUFBRTtRQUMzQ0wsY0FBY1EsSUFBSSxDQUFDTixRQUFRO1FBQzNCLE9BQU9BO0lBQ1g7SUFDQTs7O0tBR0MsR0FDRCxNQUFNTyxZQUFZQyxJQUFJLEVBQUU7UUFDcEIsTUFBTUMsYUFBYUQsS0FBS0UsU0FBUyxDQUFDLE9BQU87UUFDekMsSUFBSVosZ0JBQWdC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RyxPQUFPLEVBQUUsSUFBSSxDQUFDcEMsa0JBQWtCO0lBQ3RFO0FBQ0o7QUFDQW5FLGdDQUFnQyxHQUFHRSwwQkFDbkMsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnljLWhvdXNpbmctYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NvbXByZXNzaW9uLWZpbHRlci5qcz83NWU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbXByZXNzaW9uRmlsdGVyRmFjdG9yeSA9IGV4cG9ydHMuQ29tcHJlc3Npb25GaWx0ZXIgPSB2b2lkIDA7XG5jb25zdCB6bGliID0gcmVxdWlyZShcInpsaWJcIik7XG5jb25zdCBjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEgPSByZXF1aXJlKFwiLi9jb21wcmVzc2lvbi1hbGdvcml0aG1zXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBmaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2ZpbHRlclwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgaXNDb21wcmVzc2lvbkFsZ29yaXRobUtleSA9IChrZXkpID0+IHtcbiAgICByZXR1cm4gKHR5cGVvZiBrZXkgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEuQ29tcHJlc3Npb25BbGdvcml0aG1zW2tleV0gPT09ICdzdHJpbmcnKTtcbn07XG5jbGFzcyBDb21wcmVzc2lvbkhhbmRsZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFJhdyB1bmNvbXByZXNzZWQgbWVzc2FnZSBieXRlc1xuICAgICAqIEBwYXJhbSBjb21wcmVzcyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbWVzc2FnZSBzaG91bGQgYmUgY29tcHJlc3NlZFxuICAgICAqIEByZXR1cm4gRnJhbWVkIG1lc3NhZ2UsIGNvbXByZXNzZWQgaWYgYXBwbGljYWJsZVxuICAgICAqL1xuICAgIGFzeW5jIHdyaXRlTWVzc2FnZShtZXNzYWdlLCBjb21wcmVzcykge1xuICAgICAgICBsZXQgbWVzc2FnZUJ1ZmZlciA9IG1lc3NhZ2U7XG4gICAgICAgIGlmIChjb21wcmVzcykge1xuICAgICAgICAgICAgbWVzc2FnZUJ1ZmZlciA9IGF3YWl0IHRoaXMuY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2VCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShtZXNzYWdlQnVmZmVyLmxlbmd0aCArIDUpO1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50OChjb21wcmVzcyA/IDEgOiAwLCAwKTtcbiAgICAgICAgb3V0cHV0LndyaXRlVUludDMyQkUobWVzc2FnZUJ1ZmZlci5sZW5ndGgsIDEpO1xuICAgICAgICBtZXNzYWdlQnVmZmVyLmNvcHkob3V0cHV0LCA1KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRhdGEgRnJhbWVkIG1lc3NhZ2UsIHBvc3NpYmx5IGNvbXByZXNzZWRcbiAgICAgKiBAcmV0dXJuIFVuY29tcHJlc3NlZCBtZXNzYWdlXG4gICAgICovXG4gICAgYXN5bmMgcmVhZE1lc3NhZ2UoZGF0YSkge1xuICAgICAgICBjb25zdCBjb21wcmVzc2VkID0gZGF0YS5yZWFkVUludDgoMCkgPT09IDE7XG4gICAgICAgIGxldCBtZXNzYWdlQnVmZmVyID0gZGF0YS5zbGljZSg1KTtcbiAgICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VCdWZmZXIgPSBhd2FpdCB0aGlzLmRlY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2VCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlQnVmZmVyO1xuICAgIH1cbn1cbmNsYXNzIElkZW50aXR5SGFuZGxlciBleHRlbmRzIENvbXByZXNzaW9uSGFuZGxlciB7XG4gICAgYXN5bmMgY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGFzeW5jIHdyaXRlTWVzc2FnZShtZXNzYWdlLCBjb21wcmVzcykge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobWVzc2FnZS5sZW5ndGggKyA1KTtcbiAgICAgICAgLyogV2l0aCBcImlkZW50aXR5XCIgY29tcHJlc3Npb24sIG1lc3NhZ2VzIHNob3VsZCBhbHdheXMgYmUgbWFya2VkIGFzXG4gICAgICAgICAqIHVuY29tcHJlc3NlZCAqL1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50OCgwLCAwKTtcbiAgICAgICAgb3V0cHV0LndyaXRlVUludDMyQkUobWVzc2FnZS5sZW5ndGgsIDEpO1xuICAgICAgICBtZXNzYWdlLmNvcHkob3V0cHV0LCA1KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgZGVjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdSZWNlaXZlZCBjb21wcmVzc2VkIG1lc3NhZ2UgYnV0IFwiZ3JwYy1lbmNvZGluZ1wiIGhlYWRlciB3YXMgaWRlbnRpdHknKSk7XG4gICAgfVxufVxuY2xhc3MgRGVmbGF0ZUhhbmRsZXIgZXh0ZW5kcyBDb21wcmVzc2lvbkhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKG1heFJlY3ZNZXNzYWdlTGVuZ3RoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWF4UmVjdk1lc3NhZ2VMZW5ndGggPSBtYXhSZWN2TWVzc2FnZUxlbmd0aDtcbiAgICB9XG4gICAgY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHpsaWIuZGVmbGF0ZShtZXNzYWdlLCAoZXJyLCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgZGVjb21wcmVzc2VyID0gemxpYi5jcmVhdGVJbmZsYXRlKCk7XG4gICAgICAgICAgICBkZWNvbXByZXNzZXIub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlUGFydHMucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgdG90YWxMZW5ndGggKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhSZWN2TWVzc2FnZUxlbmd0aCAhPT0gLTEgJiYgdG90YWxMZW5ndGggPiB0aGlzLm1heFJlY3ZNZXNzYWdlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29tcHJlc3Nlci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVELFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFJlY2VpdmVkIG1lc3NhZ2UgdGhhdCBkZWNvbXByZXNzZXMgdG8gYSBzaXplIGxhcmdlciB0aGFuICR7dGhpcy5tYXhSZWN2TWVzc2FnZUxlbmd0aH1gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVjb21wcmVzc2VyLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShCdWZmZXIuY29uY2F0KG1lc3NhZ2VQYXJ0cykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWNvbXByZXNzZXIud3JpdGUobWVzc2FnZSk7XG4gICAgICAgICAgICBkZWNvbXByZXNzZXIuZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIEd6aXBIYW5kbGVyIGV4dGVuZHMgQ29tcHJlc3Npb25IYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihtYXhSZWN2TWVzc2FnZUxlbmd0aCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1heFJlY3ZNZXNzYWdlTGVuZ3RoID0gbWF4UmVjdk1lc3NhZ2VMZW5ndGg7XG4gICAgfVxuICAgIGNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB6bGliLmd6aXAobWVzc2FnZSwgKGVyciwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCB0b3RhbExlbmd0aCA9IDA7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlUGFydHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGRlY29tcHJlc3NlciA9IHpsaWIuY3JlYXRlR3VuemlwKCk7XG4gICAgICAgICAgICBkZWNvbXByZXNzZXIub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlUGFydHMucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgdG90YWxMZW5ndGggKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhSZWN2TWVzc2FnZUxlbmd0aCAhPT0gLTEgJiYgdG90YWxMZW5ndGggPiB0aGlzLm1heFJlY3ZNZXNzYWdlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29tcHJlc3Nlci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVELFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFJlY2VpdmVkIG1lc3NhZ2UgdGhhdCBkZWNvbXByZXNzZXMgdG8gYSBzaXplIGxhcmdlciB0aGFuICR7dGhpcy5tYXhSZWN2TWVzc2FnZUxlbmd0aH1gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVjb21wcmVzc2VyLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShCdWZmZXIuY29uY2F0KG1lc3NhZ2VQYXJ0cykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWNvbXByZXNzZXIud3JpdGUobWVzc2FnZSk7XG4gICAgICAgICAgICBkZWNvbXByZXNzZXIuZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFVua25vd25IYW5kbGVyIGV4dGVuZHMgQ29tcHJlc3Npb25IYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wcmVzc2lvbk5hbWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2lvbk5hbWUgPSBjb21wcmVzc2lvbk5hbWU7XG4gICAgfVxuICAgIGNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYFJlY2VpdmVkIG1lc3NhZ2UgY29tcHJlc3NlZCB3aXRoIHVuc3VwcG9ydGVkIGNvbXByZXNzaW9uIG1ldGhvZCAke3RoaXMuY29tcHJlc3Npb25OYW1lfWApKTtcbiAgICB9XG4gICAgZGVjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSB1bnJlYWNoYWJsZVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBDb21wcmVzc2lvbiBtZXRob2Qgbm90IHN1cHBvcnRlZDogJHt0aGlzLmNvbXByZXNzaW9uTmFtZX1gKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29tcHJlc3Npb25IYW5kbGVyKGNvbXByZXNzaW9uTmFtZSwgbWF4UmVjZWl2ZU1lc3NhZ2VTaXplKSB7XG4gICAgc3dpdGNoIChjb21wcmVzc2lvbk5hbWUpIHtcbiAgICAgICAgY2FzZSAnaWRlbnRpdHknOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJZGVudGl0eUhhbmRsZXIoKTtcbiAgICAgICAgY2FzZSAnZGVmbGF0ZSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlZmxhdGVIYW5kbGVyKG1heFJlY2VpdmVNZXNzYWdlU2l6ZSk7XG4gICAgICAgIGNhc2UgJ2d6aXAnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHemlwSGFuZGxlcihtYXhSZWNlaXZlTWVzc2FnZVNpemUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmtub3duSGFuZGxlcihjb21wcmVzc2lvbk5hbWUpO1xuICAgIH1cbn1cbmNsYXNzIENvbXByZXNzaW9uRmlsdGVyIGV4dGVuZHMgZmlsdGVyXzEuQmFzZUZpbHRlciB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbE9wdGlvbnMsIHNoYXJlZEZpbHRlckNvbmZpZykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zaGFyZWRGaWx0ZXJDb25maWcgPSBzaGFyZWRGaWx0ZXJDb25maWc7XG4gICAgICAgIHRoaXMuc2VuZENvbXByZXNzaW9uID0gbmV3IElkZW50aXR5SGFuZGxlcigpO1xuICAgICAgICB0aGlzLnJlY2VpdmVDb21wcmVzc2lvbiA9IG5ldyBJZGVudGl0eUhhbmRsZXIoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0gPSAnaWRlbnRpdHknO1xuICAgICAgICBjb25zdCBjb21wcmVzc2lvbkFsZ29yaXRobUtleSA9IGNoYW5uZWxPcHRpb25zWydncnBjLmRlZmF1bHRfY29tcHJlc3Npb25fYWxnb3JpdGhtJ107XG4gICAgICAgIHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VMZW5ndGggPSAoX2EgPSBjaGFubmVsT3B0aW9uc1snZ3JwYy5tYXhfcmVjZWl2ZV9tZXNzYWdlX2xlbmd0aCddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25zdGFudHNfMS5ERUZBVUxUX01BWF9SRUNFSVZFX01FU1NBR0VfTEVOR1RIO1xuICAgICAgICB0aGlzLm1heFNlbmRNZXNzYWdlTGVuZ3RoID0gKF9iID0gY2hhbm5lbE9wdGlvbnNbJ2dycGMubWF4X3NlbmRfbWVzc2FnZV9sZW5ndGgnXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29uc3RhbnRzXzEuREVGQVVMVF9NQVhfU0VORF9NRVNTQUdFX0xFTkdUSDtcbiAgICAgICAgaWYgKGNvbXByZXNzaW9uQWxnb3JpdGhtS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzaW9uQWxnb3JpdGhtS2V5KGNvbXByZXNzaW9uQWxnb3JpdGhtS2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFNlbGVjdGVkRW5jb2RpbmcgPSBjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEuQ29tcHJlc3Npb25BbGdvcml0aG1zW2NvbXByZXNzaW9uQWxnb3JpdGhtS2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3MgPSAoX2MgPSBzaGFyZWRGaWx0ZXJDb25maWcuc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdIZWFkZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZXJlIGFyZSB0d28gcG9zc2libGUgc2l0dWF0aW9ucyBoZXJlOlxuICAgICAgICAgICAgICAgICAqIDEpIFdlIGRvbid0IGhhdmUgYW55IGluZm8geWV0IGZyb20gdGhlIHNlcnZlciBhYm91dCB3aGF0IGNvbXByZXNzaW9uIGl0IHN1cHBvcnRzXG4gICAgICAgICAgICAgICAgICogICAgSW4gdGhhdCBjYXNlIHdlIHNob3VsZCBqdXN0IHVzZSB3aGF0IHRoZSBjbGllbnQgdGVsbHMgdXMgdG8gdXNlXG4gICAgICAgICAgICAgICAgICogMikgV2UndmUgcHJldmlvdXNseSByZWNlaXZlZCBhIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciBpbmNsdWRpbmcgYSBncnBjLWFjY2VwdC1lbmNvZGluZyBoZWFkZXJcbiAgICAgICAgICAgICAgICAgKiAgICBJbiB0aGF0IGNhc2Ugd2Ugb25seSB3YW50IHRvIHVzZSB0aGUgZW5jb2RpbmcgY2hvc2VuIGJ5IHRoZSBjbGllbnQgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyBpdFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICghc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzIHx8XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclN1cHBvcnRlZEVuY29kaW5ncy5pbmNsdWRlcyhjbGllbnRTZWxlY3RlZEVuY29kaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSA9IGNsaWVudFNlbGVjdGVkRW5jb2Rpbmc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZENvbXByZXNzaW9uID0gZ2V0Q29tcHJlc3Npb25IYW5kbGVyKHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtLCAtMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2luZy5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCBgSW52YWxpZCB2YWx1ZSBwcm92aWRlZCBmb3IgZ3JwYy5kZWZhdWx0X2NvbXByZXNzaW9uX2FsZ29yaXRobSBvcHRpb246ICR7Y29tcHJlc3Npb25BbGdvcml0aG1LZXl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2VuZE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCBtZXRhZGF0YTtcbiAgICAgICAgaGVhZGVycy5zZXQoJ2dycGMtYWNjZXB0LWVuY29kaW5nJywgJ2lkZW50aXR5LGRlZmxhdGUsZ3ppcCcpO1xuICAgICAgICBoZWFkZXJzLnNldCgnYWNjZXB0LWVuY29kaW5nJywgJ2lkZW50aXR5Jyk7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gc2VuZCB0aGUgaGVhZGVyIGlmIGl0J3MgXCJpZGVudGl0eVwiIC0gIGJlaGF2aW9yIGlzIGlkZW50aWNhbDsgc2F2ZSB0aGUgYmFuZHdpZHRoXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAgICAgaGVhZGVycy5yZW1vdmUoJ2dycGMtZW5jb2RpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdncnBjLWVuY29kaW5nJywgdGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICByZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgcmVjZWl2ZUVuY29kaW5nID0gbWV0YWRhdGEuZ2V0KCdncnBjLWVuY29kaW5nJyk7XG4gICAgICAgIGlmIChyZWNlaXZlRW5jb2RpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RpbmcgPSByZWNlaXZlRW5jb2RpbmdbMF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVjZWl2ZUNvbXByZXNzaW9uID0gZ2V0Q29tcHJlc3Npb25IYW5kbGVyKGVuY29kaW5nLCB0aGlzLm1heFJlY2VpdmVNZXNzYWdlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoJ2dycGMtZW5jb2RpbmcnKTtcbiAgICAgICAgLyogQ2hlY2sgdG8gc2VlIGlmIHRoZSBjb21wcmVzc2lvbiB3ZSdyZSB1c2luZyB0byBzZW5kIG1lc3NhZ2VzIGlzIHN1cHBvcnRlZCBieSB0aGUgc2VydmVyXG4gICAgICAgICAqIElmIG5vdCwgcmVzZXQgdGhlIHNlbmRDb21wcmVzc2lvbiBmaWx0ZXIgYW5kIGhhdmUgaXQgdXNlIHRoZSBkZWZhdWx0IElkZW50aXR5SGFuZGxlciAqL1xuICAgICAgICBjb25zdCBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3NIZWFkZXIgPSBtZXRhZGF0YS5nZXQoJ2dycGMtYWNjZXB0LWVuY29kaW5nJylbMF07XG4gICAgICAgIGlmIChzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3NIZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkRmlsdGVyQ29uZmlnLnNlcnZlclN1cHBvcnRlZEVuY29kaW5nSGVhZGVyID1cbiAgICAgICAgICAgICAgICBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3NIZWFkZXI7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3MgPSBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3NIZWFkZXIuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIGlmICghc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzLmluY2x1ZGVzKHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZENvbXByZXNzaW9uID0gbmV3IElkZW50aXR5SGFuZGxlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtID0gJ2lkZW50aXR5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoJ2dycGMtYWNjZXB0LWVuY29kaW5nJyk7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8qIFRoaXMgZmlsdGVyIGlzIHNwZWNpYWwuIFRoZSBpbnB1dCBtZXNzYWdlIGlzIHRoZSBiYXJlIG1lc3NhZ2UgYnl0ZXMsXG4gICAgICAgICAqIGFuZCB0aGUgb3V0cHV0IGlzIGEgZnJhbWVkIGFuZCBwb3NzaWJseSBjb21wcmVzc2VkIG1lc3NhZ2UuIEZvciB0aGlzXG4gICAgICAgICAqIHJlYXNvbiwgdGhpcyBmaWx0ZXIgc2hvdWxkIGJlIGF0IHRoZSBib3R0b20gb2YgdGhlIGZpbHRlciBzdGFjayAqL1xuICAgICAgICBjb25zdCByZXNvbHZlZE1lc3NhZ2UgPSBhd2FpdCBtZXNzYWdlO1xuICAgICAgICBpZiAodGhpcy5tYXhTZW5kTWVzc2FnZUxlbmd0aCAhPT0gLTEgJiYgcmVzb2x2ZWRNZXNzYWdlLm1lc3NhZ2UubGVuZ3RoID4gdGhpcy5tYXhTZW5kTWVzc2FnZUxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogYEF0dGVtcHRlZCB0byBzZW5kIG1lc3NhZ2Ugd2l0aCBhIHNpemUgbGFyZ2VyIHRoYW4gJHt0aGlzLm1heFNlbmRNZXNzYWdlTGVuZ3RofWBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbXByZXNzO1xuICAgICAgICBpZiAodGhpcy5zZW5kQ29tcHJlc3Npb24gaW5zdGFuY2VvZiBJZGVudGl0eUhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNvbXByZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb21wcmVzcyA9ICgoKF9hID0gcmVzb2x2ZWRNZXNzYWdlLmZsYWdzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSAmIDIgLyogV3JpdGVGbGFncy5Ob0NvbXByZXNzICovKSA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogYXdhaXQgdGhpcy5zZW5kQ29tcHJlc3Npb24ud3JpdGVNZXNzYWdlKHJlc29sdmVkTWVzc2FnZS5tZXNzYWdlLCBjb21wcmVzcyksXG4gICAgICAgICAgICBmbGFnczogcmVzb2x2ZWRNZXNzYWdlLmZsYWdzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIC8qIFRoaXMgZmlsdGVyIGlzIGFsc28gc3BlY2lhbC4gVGhlIGlucHV0IG1lc3NhZ2UgaXMgZnJhbWVkIGFuZCBwb3NzaWJseVxuICAgICAgICAgKiBjb21wcmVzc2VkLCBhbmQgdGhlIG91dHB1dCBtZXNzYWdlIGlzIGRlZnJhbWVkIGFuZCB1bmNvbXByZXNzZWQuIFNvXG4gICAgICAgICAqIHRoaXMgaXMgYW5vdGhlciByZWFzb24gdGhhdCB0aGlzIGZpbHRlciBzaG91bGQgYmUgYXQgdGhlIGJvdHRvbSBvZiB0aGVcbiAgICAgICAgICogZmlsdGVyIHN0YWNrLiAqL1xuICAgICAgICByZXR1cm4gdGhpcy5yZWNlaXZlQ29tcHJlc3Npb24ucmVhZE1lc3NhZ2UoYXdhaXQgbWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db21wcmVzc2lvbkZpbHRlciA9IENvbXByZXNzaW9uRmlsdGVyO1xuY2xhc3MgQ29tcHJlc3Npb25GaWx0ZXJGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuc2hhcmVkRmlsdGVyQ29uZmlnID0ge307XG4gICAgfVxuICAgIGNyZWF0ZUZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wcmVzc2lvbkZpbHRlcih0aGlzLm9wdGlvbnMsIHRoaXMuc2hhcmVkRmlsdGVyQ29uZmlnKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbXByZXNzaW9uRmlsdGVyRmFjdG9yeSA9IENvbXByZXNzaW9uRmlsdGVyRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXByZXNzaW9uLWZpbHRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDb21wcmVzc2lvbkZpbHRlckZhY3RvcnkiLCJDb21wcmVzc2lvbkZpbHRlciIsInpsaWIiLCJyZXF1aXJlIiwiY29tcHJlc3Npb25fYWxnb3JpdGhtc18xIiwiY29uc3RhbnRzXzEiLCJmaWx0ZXJfMSIsImxvZ2dpbmciLCJpc0NvbXByZXNzaW9uQWxnb3JpdGhtS2V5Iiwia2V5IiwiQ29tcHJlc3Npb25BbGdvcml0aG1zIiwiQ29tcHJlc3Npb25IYW5kbGVyIiwid3JpdGVNZXNzYWdlIiwibWVzc2FnZSIsImNvbXByZXNzIiwibWVzc2FnZUJ1ZmZlciIsImNvbXByZXNzTWVzc2FnZSIsIm91dHB1dCIsIkJ1ZmZlciIsImFsbG9jVW5zYWZlIiwibGVuZ3RoIiwid3JpdGVVSW50OCIsIndyaXRlVUludDMyQkUiLCJjb3B5IiwicmVhZE1lc3NhZ2UiLCJkYXRhIiwiY29tcHJlc3NlZCIsInJlYWRVSW50OCIsInNsaWNlIiwiZGVjb21wcmVzc01lc3NhZ2UiLCJJZGVudGl0eUhhbmRsZXIiLCJQcm9taXNlIiwicmVqZWN0IiwiRXJyb3IiLCJEZWZsYXRlSGFuZGxlciIsImNvbnN0cnVjdG9yIiwibWF4UmVjdk1lc3NhZ2VMZW5ndGgiLCJyZXNvbHZlIiwiZGVmbGF0ZSIsImVyciIsInRvdGFsTGVuZ3RoIiwibWVzc2FnZVBhcnRzIiwiZGVjb21wcmVzc2VyIiwiY3JlYXRlSW5mbGF0ZSIsIm9uIiwiY2h1bmsiLCJwdXNoIiwiYnl0ZUxlbmd0aCIsImRlc3Ryb3kiLCJjb2RlIiwiU3RhdHVzIiwiUkVTT1VSQ0VfRVhIQVVTVEVEIiwiZGV0YWlscyIsImNvbmNhdCIsIndyaXRlIiwiZW5kIiwiR3ppcEhhbmRsZXIiLCJnemlwIiwiY3JlYXRlR3VuemlwIiwiVW5rbm93bkhhbmRsZXIiLCJjb21wcmVzc2lvbk5hbWUiLCJnZXRDb21wcmVzc2lvbkhhbmRsZXIiLCJtYXhSZWNlaXZlTWVzc2FnZVNpemUiLCJCYXNlRmlsdGVyIiwiY2hhbm5lbE9wdGlvbnMiLCJzaGFyZWRGaWx0ZXJDb25maWciLCJfYSIsIl9iIiwiX2MiLCJzZW5kQ29tcHJlc3Npb24iLCJyZWNlaXZlQ29tcHJlc3Npb24iLCJjdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0iLCJjb21wcmVzc2lvbkFsZ29yaXRobUtleSIsIm1heFJlY2VpdmVNZXNzYWdlTGVuZ3RoIiwiREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSCIsIm1heFNlbmRNZXNzYWdlTGVuZ3RoIiwiREVGQVVMVF9NQVhfU0VORF9NRVNTQUdFX0xFTkdUSCIsInVuZGVmaW5lZCIsImNsaWVudFNlbGVjdGVkRW5jb2RpbmciLCJzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3MiLCJzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ0hlYWRlciIsInNwbGl0IiwiaW5jbHVkZXMiLCJsb2ciLCJMb2dWZXJib3NpdHkiLCJFUlJPUiIsInNlbmRNZXRhZGF0YSIsIm1ldGFkYXRhIiwiaGVhZGVycyIsInNldCIsInJlbW92ZSIsInJlY2VpdmVNZXRhZGF0YSIsInJlY2VpdmVFbmNvZGluZyIsImdldCIsImVuY29kaW5nIiwic2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzSGVhZGVyIiwic2VuZE1lc3NhZ2UiLCJyZXNvbHZlZE1lc3NhZ2UiLCJmbGFncyIsInJlY2VpdmVNZXNzYWdlIiwiY2hhbm5lbCIsIm9wdGlvbnMiLCJjcmVhdGVGaWx0ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/connectivity-state.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ConnectivityState = void 0;\nvar ConnectivityState;\n(function(ConnectivityState) {\n    ConnectivityState[ConnectivityState[\"IDLE\"] = 0] = \"IDLE\";\n    ConnectivityState[ConnectivityState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    ConnectivityState[ConnectivityState[\"READY\"] = 2] = \"READY\";\n    ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 3] = \"TRANSIENT_FAILURE\";\n    ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState || (exports.ConnectivityState = ConnectivityState = {})); //# sourceMappingURL=connectivity-state.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29ubmVjdGl2aXR5LXN0YXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx5QkFBeUIsR0FBRyxLQUFLO0FBQ2pDLElBQUlFO0FBQ0gsVUFBVUEsaUJBQWlCO0lBQ3hCQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUNuREEsaUJBQWlCLENBQUNBLGlCQUFpQixDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7SUFDekRBLGlCQUFpQixDQUFDQSxpQkFBaUIsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ3BEQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsb0JBQW9CLEdBQUcsRUFBRSxHQUFHO0lBQ2hFQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsV0FBVyxHQUFHLEVBQUUsR0FBRztBQUMzRCxHQUFHQSxxQkFBc0JGLENBQUFBLHlCQUF5QixHQUFHRSxvQkFBb0IsQ0FBQyxLQUMxRSw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29ubmVjdGl2aXR5LXN0YXRlLmpzPzRlZTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29ubmVjdGl2aXR5U3RhdGUgPSB2b2lkIDA7XG52YXIgQ29ubmVjdGl2aXR5U3RhdGU7XG4oZnVuY3Rpb24gKENvbm5lY3Rpdml0eVN0YXRlKSB7XG4gICAgQ29ubmVjdGl2aXR5U3RhdGVbQ29ubmVjdGl2aXR5U3RhdGVbXCJJRExFXCJdID0gMF0gPSBcIklETEVcIjtcbiAgICBDb25uZWN0aXZpdHlTdGF0ZVtDb25uZWN0aXZpdHlTdGF0ZVtcIkNPTk5FQ1RJTkdcIl0gPSAxXSA9IFwiQ09OTkVDVElOR1wiO1xuICAgIENvbm5lY3Rpdml0eVN0YXRlW0Nvbm5lY3Rpdml0eVN0YXRlW1wiUkVBRFlcIl0gPSAyXSA9IFwiUkVBRFlcIjtcbiAgICBDb25uZWN0aXZpdHlTdGF0ZVtDb25uZWN0aXZpdHlTdGF0ZVtcIlRSQU5TSUVOVF9GQUlMVVJFXCJdID0gM10gPSBcIlRSQU5TSUVOVF9GQUlMVVJFXCI7XG4gICAgQ29ubmVjdGl2aXR5U3RhdGVbQ29ubmVjdGl2aXR5U3RhdGVbXCJTSFVURE9XTlwiXSA9IDRdID0gXCJTSFVURE9XTlwiO1xufSkoQ29ubmVjdGl2aXR5U3RhdGUgfHwgKGV4cG9ydHMuQ29ubmVjdGl2aXR5U3RhdGUgPSBDb25uZWN0aXZpdHlTdGF0ZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aXZpdHktc3RhdGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ29ubmVjdGl2aXR5U3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/constants.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = exports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = exports.Propagate = exports.LogVerbosity = exports.Status = void 0;\nvar Status;\n(function(Status) {\n    Status[Status[\"OK\"] = 0] = \"OK\";\n    Status[Status[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    Status[Status[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    Status[Status[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n    Status[Status[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n    Status[Status[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n    Status[Status[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n    Status[Status[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n    Status[Status[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n    Status[Status[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n    Status[Status[\"ABORTED\"] = 10] = \"ABORTED\";\n    Status[Status[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n    Status[Status[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n    Status[Status[\"INTERNAL\"] = 13] = \"INTERNAL\";\n    Status[Status[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n    Status[Status[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n    Status[Status[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n})(Status || (exports.Status = Status = {}));\nvar LogVerbosity;\n(function(LogVerbosity) {\n    LogVerbosity[LogVerbosity[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogVerbosity[LogVerbosity[\"INFO\"] = 1] = \"INFO\";\n    LogVerbosity[LogVerbosity[\"ERROR\"] = 2] = \"ERROR\";\n    LogVerbosity[LogVerbosity[\"NONE\"] = 3] = \"NONE\";\n})(LogVerbosity || (exports.LogVerbosity = LogVerbosity = {}));\n/**\n * NOTE: This enum is not currently used in any implemented API in this\n * library. It is included only for type parity with the other implementation.\n */ var Propagate;\n(function(Propagate) {\n    Propagate[Propagate[\"DEADLINE\"] = 1] = \"DEADLINE\";\n    Propagate[Propagate[\"CENSUS_STATS_CONTEXT\"] = 2] = \"CENSUS_STATS_CONTEXT\";\n    Propagate[Propagate[\"CENSUS_TRACING_CONTEXT\"] = 4] = \"CENSUS_TRACING_CONTEXT\";\n    Propagate[Propagate[\"CANCELLATION\"] = 8] = \"CANCELLATION\";\n    // https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/propagation_bits.h#L43\n    Propagate[Propagate[\"DEFAULTS\"] = 65535] = \"DEFAULTS\";\n})(Propagate || (exports.Propagate = Propagate = {}));\n// -1 means unlimited\nexports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;\n// 4 MB default\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQ0FBMEMsR0FBR0EsdUNBQXVDLEdBQUdBLGlCQUFpQixHQUFHQSxvQkFBb0IsR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDeEosSUFBSU07QUFDSCxVQUFVQSxNQUFNO0lBQ2JBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLEtBQUssR0FBRyxFQUFFLEdBQUc7SUFDM0JBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLFlBQVksR0FBRyxFQUFFLEdBQUc7SUFDbENBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDaENBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLG1CQUFtQixHQUFHLEVBQUUsR0FBRztJQUN6Q0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsb0JBQW9CLEdBQUcsRUFBRSxHQUFHO0lBQzFDQSxNQUFNLENBQUNBLE1BQU0sQ0FBQyxZQUFZLEdBQUcsRUFBRSxHQUFHO0lBQ2xDQSxNQUFNLENBQUNBLE1BQU0sQ0FBQyxpQkFBaUIsR0FBRyxFQUFFLEdBQUc7SUFDdkNBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLG9CQUFvQixHQUFHLEVBQUUsR0FBRztJQUMxQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMscUJBQXFCLEdBQUcsRUFBRSxHQUFHO0lBQzNDQSxNQUFNLENBQUNBLE1BQU0sQ0FBQyxzQkFBc0IsR0FBRyxFQUFFLEdBQUc7SUFDNUNBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLFVBQVUsR0FBRyxHQUFHLEdBQUc7SUFDakNBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLGVBQWUsR0FBRyxHQUFHLEdBQUc7SUFDdENBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLGdCQUFnQixHQUFHLEdBQUcsR0FBRztJQUN2Q0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsV0FBVyxHQUFHLEdBQUcsR0FBRztJQUNsQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsY0FBYyxHQUFHLEdBQUcsR0FBRztJQUNyQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsWUFBWSxHQUFHLEdBQUcsR0FBRztJQUNuQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsa0JBQWtCLEdBQUcsR0FBRyxHQUFHO0FBQzdDLEdBQUdBLFVBQVdOLENBQUFBLGNBQWMsR0FBR00sU0FBUyxDQUFDO0FBQ3pDLElBQUlEO0FBQ0gsVUFBVUEsWUFBWTtJQUNuQkEsWUFBWSxDQUFDQSxZQUFZLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRztJQUMxQ0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUN6Q0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRztJQUMxQ0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztBQUM3QyxHQUFHQSxnQkFBaUJMLENBQUFBLG9CQUFvQixHQUFHSyxlQUFlLENBQUM7QUFDM0Q7OztDQUdDLEdBQ0QsSUFBSUQ7QUFDSCxVQUFVQSxTQUFTO0lBQ2hCQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxXQUFXLEdBQUcsRUFBRSxHQUFHO0lBQ3ZDQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyx1QkFBdUIsR0FBRyxFQUFFLEdBQUc7SUFDbkRBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLHlCQUF5QixHQUFHLEVBQUUsR0FBRztJQUNyREEsU0FBUyxDQUFDQSxTQUFTLENBQUMsZUFBZSxHQUFHLEVBQUUsR0FBRztJQUMzQyw0RkFBNEY7SUFDNUZBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLFdBQVcsR0FBRyxNQUFNLEdBQUc7QUFDL0MsR0FBR0EsYUFBY0osQ0FBQUEsaUJBQWlCLEdBQUdJLFlBQVksQ0FBQztBQUNsRCxxQkFBcUI7QUFDckJKLHVDQUF1QyxHQUFHLENBQUM7QUFDM0MsZUFBZTtBQUNmQSwwQ0FBMEMsR0FBRyxJQUFJLE9BQU8sTUFDeEQscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnljLWhvdXNpbmctYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NvbnN0YW50cy5qcz8xYzJkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRFRkFVTFRfTUFYX1JFQ0VJVkVfTUVTU0FHRV9MRU5HVEggPSBleHBvcnRzLkRFRkFVTFRfTUFYX1NFTkRfTUVTU0FHRV9MRU5HVEggPSBleHBvcnRzLlByb3BhZ2F0ZSA9IGV4cG9ydHMuTG9nVmVyYm9zaXR5ID0gZXhwb3J0cy5TdGF0dXMgPSB2b2lkIDA7XG52YXIgU3RhdHVzO1xuKGZ1bmN0aW9uIChTdGF0dXMpIHtcbiAgICBTdGF0dXNbU3RhdHVzW1wiT0tcIl0gPSAwXSA9IFwiT0tcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiQ0FOQ0VMTEVEXCJdID0gMV0gPSBcIkNBTkNFTExFRFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJVTktOT1dOXCJdID0gMl0gPSBcIlVOS05PV05cIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiSU5WQUxJRF9BUkdVTUVOVFwiXSA9IDNdID0gXCJJTlZBTElEX0FSR1VNRU5UXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIkRFQURMSU5FX0VYQ0VFREVEXCJdID0gNF0gPSBcIkRFQURMSU5FX0VYQ0VFREVEXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIk5PVF9GT1VORFwiXSA9IDVdID0gXCJOT1RfRk9VTkRcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiQUxSRUFEWV9FWElTVFNcIl0gPSA2XSA9IFwiQUxSRUFEWV9FWElTVFNcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiUEVSTUlTU0lPTl9ERU5JRURcIl0gPSA3XSA9IFwiUEVSTUlTU0lPTl9ERU5JRURcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiUkVTT1VSQ0VfRVhIQVVTVEVEXCJdID0gOF0gPSBcIlJFU09VUkNFX0VYSEFVU1RFRFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJGQUlMRURfUFJFQ09ORElUSU9OXCJdID0gOV0gPSBcIkZBSUxFRF9QUkVDT05ESVRJT05cIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiQUJPUlRFRFwiXSA9IDEwXSA9IFwiQUJPUlRFRFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJPVVRfT0ZfUkFOR0VcIl0gPSAxMV0gPSBcIk9VVF9PRl9SQU5HRVwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJVTklNUExFTUVOVEVEXCJdID0gMTJdID0gXCJVTklNUExFTUVOVEVEXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIklOVEVSTkFMXCJdID0gMTNdID0gXCJJTlRFUk5BTFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJVTkFWQUlMQUJMRVwiXSA9IDE0XSA9IFwiVU5BVkFJTEFCTEVcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiREFUQV9MT1NTXCJdID0gMTVdID0gXCJEQVRBX0xPU1NcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiVU5BVVRIRU5USUNBVEVEXCJdID0gMTZdID0gXCJVTkFVVEhFTlRJQ0FURURcIjtcbn0pKFN0YXR1cyB8fCAoZXhwb3J0cy5TdGF0dXMgPSBTdGF0dXMgPSB7fSkpO1xudmFyIExvZ1ZlcmJvc2l0eTtcbihmdW5jdGlvbiAoTG9nVmVyYm9zaXR5KSB7XG4gICAgTG9nVmVyYm9zaXR5W0xvZ1ZlcmJvc2l0eVtcIkRFQlVHXCJdID0gMF0gPSBcIkRFQlVHXCI7XG4gICAgTG9nVmVyYm9zaXR5W0xvZ1ZlcmJvc2l0eVtcIklORk9cIl0gPSAxXSA9IFwiSU5GT1wiO1xuICAgIExvZ1ZlcmJvc2l0eVtMb2dWZXJib3NpdHlbXCJFUlJPUlwiXSA9IDJdID0gXCJFUlJPUlwiO1xuICAgIExvZ1ZlcmJvc2l0eVtMb2dWZXJib3NpdHlbXCJOT05FXCJdID0gM10gPSBcIk5PTkVcIjtcbn0pKExvZ1ZlcmJvc2l0eSB8fCAoZXhwb3J0cy5Mb2dWZXJib3NpdHkgPSBMb2dWZXJib3NpdHkgPSB7fSkpO1xuLyoqXG4gKiBOT1RFOiBUaGlzIGVudW0gaXMgbm90IGN1cnJlbnRseSB1c2VkIGluIGFueSBpbXBsZW1lbnRlZCBBUEkgaW4gdGhpc1xuICogbGlicmFyeS4gSXQgaXMgaW5jbHVkZWQgb25seSBmb3IgdHlwZSBwYXJpdHkgd2l0aCB0aGUgb3RoZXIgaW1wbGVtZW50YXRpb24uXG4gKi9cbnZhciBQcm9wYWdhdGU7XG4oZnVuY3Rpb24gKFByb3BhZ2F0ZSkge1xuICAgIFByb3BhZ2F0ZVtQcm9wYWdhdGVbXCJERUFETElORVwiXSA9IDFdID0gXCJERUFETElORVwiO1xuICAgIFByb3BhZ2F0ZVtQcm9wYWdhdGVbXCJDRU5TVVNfU1RBVFNfQ09OVEVYVFwiXSA9IDJdID0gXCJDRU5TVVNfU1RBVFNfQ09OVEVYVFwiO1xuICAgIFByb3BhZ2F0ZVtQcm9wYWdhdGVbXCJDRU5TVVNfVFJBQ0lOR19DT05URVhUXCJdID0gNF0gPSBcIkNFTlNVU19UUkFDSU5HX0NPTlRFWFRcIjtcbiAgICBQcm9wYWdhdGVbUHJvcGFnYXRlW1wiQ0FOQ0VMTEFUSU9OXCJdID0gOF0gPSBcIkNBTkNFTExBVElPTlwiO1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMvYmxvYi9tYXN0ZXIvaW5jbHVkZS9ncnBjL2ltcGwvY29kZWdlbi9wcm9wYWdhdGlvbl9iaXRzLmgjTDQzXG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkRFRkFVTFRTXCJdID0gNjU1MzVdID0gXCJERUZBVUxUU1wiO1xufSkoUHJvcGFnYXRlIHx8IChleHBvcnRzLlByb3BhZ2F0ZSA9IFByb3BhZ2F0ZSA9IHt9KSk7XG4vLyAtMSBtZWFucyB1bmxpbWl0ZWRcbmV4cG9ydHMuREVGQVVMVF9NQVhfU0VORF9NRVNTQUdFX0xFTkdUSCA9IC0xO1xuLy8gNCBNQiBkZWZhdWx0XG5leHBvcnRzLkRFRkFVTFRfTUFYX1JFQ0VJVkVfTUVTU0FHRV9MRU5HVEggPSA0ICogMTAyNCAqIDEwMjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSCIsIkRFRkFVTFRfTUFYX1NFTkRfTUVTU0FHRV9MRU5HVEgiLCJQcm9wYWdhdGUiLCJMb2dWZXJib3NpdHkiLCJTdGF0dXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/control-plane-status.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.restrictControlPlaneStatusCode = restrictControlPlaneStatusCode;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst INAPPROPRIATE_CONTROL_PLANE_CODES = [\n    constants_1.Status.OK,\n    constants_1.Status.INVALID_ARGUMENT,\n    constants_1.Status.NOT_FOUND,\n    constants_1.Status.ALREADY_EXISTS,\n    constants_1.Status.FAILED_PRECONDITION,\n    constants_1.Status.ABORTED,\n    constants_1.Status.OUT_OF_RANGE,\n    constants_1.Status.DATA_LOSS\n];\nfunction restrictControlPlaneStatusCode(code, details) {\n    if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {\n        return {\n            code: constants_1.Status.INTERNAL,\n            details: `Invalid status from control plane: ${code} ${constants_1.Status[code]} ${details}`\n        };\n    } else {\n        return {\n            code,\n            details\n        };\n    }\n} //# sourceMappingURL=control-plane-status.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29udHJvbC1wbGFuZS1zdGF0dXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHNDQUFzQyxHQUFHRTtBQUN6QyxNQUFNQyxjQUFjQyxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNQyxvQ0FBb0M7SUFDdENGLFlBQVlHLE1BQU0sQ0FBQ0MsRUFBRTtJQUNyQkosWUFBWUcsTUFBTSxDQUFDRSxnQkFBZ0I7SUFDbkNMLFlBQVlHLE1BQU0sQ0FBQ0csU0FBUztJQUM1Qk4sWUFBWUcsTUFBTSxDQUFDSSxjQUFjO0lBQ2pDUCxZQUFZRyxNQUFNLENBQUNLLG1CQUFtQjtJQUN0Q1IsWUFBWUcsTUFBTSxDQUFDTSxPQUFPO0lBQzFCVCxZQUFZRyxNQUFNLENBQUNPLFlBQVk7SUFDL0JWLFlBQVlHLE1BQU0sQ0FBQ1EsU0FBUztDQUMvQjtBQUNELFNBQVNaLCtCQUErQmEsSUFBSSxFQUFFQyxPQUFPO0lBQ2pELElBQUlYLGtDQUFrQ1ksUUFBUSxDQUFDRixPQUFPO1FBQ2xELE9BQU87WUFDSEEsTUFBTVosWUFBWUcsTUFBTSxDQUFDWSxRQUFRO1lBQ2pDRixTQUFTLENBQUMsbUNBQW1DLEVBQUVELEtBQUssQ0FBQyxFQUFFWixZQUFZRyxNQUFNLENBQUNTLEtBQUssQ0FBQyxDQUFDLEVBQUVDLFFBQVEsQ0FBQztRQUNoRztJQUNKLE9BQ0s7UUFDRCxPQUFPO1lBQUVEO1lBQU1DO1FBQVE7SUFDM0I7QUFDSixFQUNBLGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1ob3VzaW5nLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb250cm9sLXBsYW5lLXN0YXR1cy5qcz83NTQyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZSA9IHJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgSU5BUFBST1BSSUFURV9DT05UUk9MX1BMQU5FX0NPREVTID0gW1xuICAgIGNvbnN0YW50c18xLlN0YXR1cy5PSyxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuSU5WQUxJRF9BUkdVTUVOVCxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgIGNvbnN0YW50c18xLlN0YXR1cy5BTFJFQURZX0VYSVNUUyxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuRkFJTEVEX1BSRUNPTkRJVElPTixcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuQUJPUlRFRCxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuT1VUX09GX1JBTkdFLFxuICAgIGNvbnN0YW50c18xLlN0YXR1cy5EQVRBX0xPU1MsXG5dO1xuZnVuY3Rpb24gcmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlKGNvZGUsIGRldGFpbHMpIHtcbiAgICBpZiAoSU5BUFBST1BSSUFURV9DT05UUk9MX1BMQU5FX0NPREVTLmluY2x1ZGVzKGNvZGUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICBkZXRhaWxzOiBgSW52YWxpZCBzdGF0dXMgZnJvbSBjb250cm9sIHBsYW5lOiAke2NvZGV9ICR7Y29uc3RhbnRzXzEuU3RhdHVzW2NvZGVdfSAke2RldGFpbHN9YCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IGNvZGUsIGRldGFpbHMgfTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250cm9sLXBsYW5lLXN0YXR1cy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUiLCJjb25zdGFudHNfMSIsInJlcXVpcmUiLCJJTkFQUFJPUFJJQVRFX0NPTlRST0xfUExBTkVfQ09ERVMiLCJTdGF0dXMiLCJPSyIsIklOVkFMSURfQVJHVU1FTlQiLCJOT1RfRk9VTkQiLCJBTFJFQURZX0VYSVNUUyIsIkZBSUxFRF9QUkVDT05ESVRJT04iLCJBQk9SVEVEIiwiT1VUX09GX1JBTkdFIiwiREFUQV9MT1NTIiwiY29kZSIsImRldGFpbHMiLCJpbmNsdWRlcyIsIklOVEVSTkFMIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/deadline.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.minDeadline = minDeadline;\nexports.getDeadlineTimeoutString = getDeadlineTimeoutString;\nexports.getRelativeTimeout = getRelativeTimeout;\nexports.deadlineToString = deadlineToString;\nexports.formatDateDifference = formatDateDifference;\nfunction minDeadline(...deadlineList) {\n    let minValue = Infinity;\n    for (const deadline of deadlineList){\n        const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;\n        if (deadlineMsecs < minValue) {\n            minValue = deadlineMsecs;\n        }\n    }\n    return minValue;\n}\nconst units = [\n    [\n        \"m\",\n        1\n    ],\n    [\n        \"S\",\n        1000\n    ],\n    [\n        \"M\",\n        60 * 1000\n    ],\n    [\n        \"H\",\n        60 * 60 * 1000\n    ]\n];\nfunction getDeadlineTimeoutString(deadline) {\n    const now = new Date().getTime();\n    if (deadline instanceof Date) {\n        deadline = deadline.getTime();\n    }\n    const timeoutMs = Math.max(deadline - now, 0);\n    for (const [unit, factor] of units){\n        const amount = timeoutMs / factor;\n        if (amount < 1e8) {\n            return String(Math.ceil(amount)) + unit;\n        }\n    }\n    throw new Error(\"Deadline is too far in the future\");\n}\n/**\n * See https://nodejs.org/api/timers.html#settimeoutcallback-delay-args\n * In particular, \"When delay is larger than 2147483647 or less than 1, the\n * delay will be set to 1. Non-integer delays are truncated to an integer.\"\n * This number of milliseconds is almost 25 days.\n */ const MAX_TIMEOUT_TIME = 2147483647;\n/**\n * Get the timeout value that should be passed to setTimeout now for the timer\n * to end at the deadline. For any deadline before now, the timer should end\n * immediately, represented by a value of 0. For any deadline more than\n * MAX_TIMEOUT_TIME milliseconds in the future, a timer cannot be set that will\n * end at that time, so it is treated as infinitely far in the future.\n * @param deadline\n * @returns\n */ function getRelativeTimeout(deadline) {\n    const deadlineMs = deadline instanceof Date ? deadline.getTime() : deadline;\n    const now = new Date().getTime();\n    const timeout = deadlineMs - now;\n    if (timeout < 0) {\n        return 0;\n    } else if (timeout > MAX_TIMEOUT_TIME) {\n        return Infinity;\n    } else {\n        return timeout;\n    }\n}\nfunction deadlineToString(deadline) {\n    if (deadline instanceof Date) {\n        return deadline.toISOString();\n    } else {\n        const dateDeadline = new Date(deadline);\n        if (Number.isNaN(dateDeadline.getTime())) {\n            return \"\" + deadline;\n        } else {\n            return dateDeadline.toISOString();\n        }\n    }\n}\n/**\n * Calculate the difference between two dates as a number of seconds and format\n * it as a string.\n * @param startDate\n * @param endDate\n * @returns\n */ function formatDateDifference(startDate, endDate) {\n    return ((endDate.getTime() - startDate.getTime()) / 1000).toFixed(3) + \"s\";\n} //# sourceMappingURL=deadline.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZGVhZGxpbmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1CQUFtQixHQUFHRTtBQUN0QkYsZ0NBQWdDLEdBQUdHO0FBQ25DSCwwQkFBMEIsR0FBR0k7QUFDN0JKLHdCQUF3QixHQUFHSztBQUMzQkwsNEJBQTRCLEdBQUdNO0FBQy9CLFNBQVNKLFlBQVksR0FBR0ssWUFBWTtJQUNoQyxJQUFJQyxXQUFXQztJQUNmLEtBQUssTUFBTUMsWUFBWUgsYUFBYztRQUNqQyxNQUFNSSxnQkFBZ0JELG9CQUFvQkUsT0FBT0YsU0FBU0csT0FBTyxLQUFLSDtRQUN0RSxJQUFJQyxnQkFBZ0JILFVBQVU7WUFDMUJBLFdBQVdHO1FBQ2Y7SUFDSjtJQUNBLE9BQU9IO0FBQ1g7QUFDQSxNQUFNTSxRQUFRO0lBQ1Y7UUFBQztRQUFLO0tBQUU7SUFDUjtRQUFDO1FBQUs7S0FBSztJQUNYO1FBQUM7UUFBSyxLQUFLO0tBQUs7SUFDaEI7UUFBQztRQUFLLEtBQUssS0FBSztLQUFLO0NBQ3hCO0FBQ0QsU0FBU1gseUJBQXlCTyxRQUFRO0lBQ3RDLE1BQU1LLE1BQU0sSUFBSUgsT0FBT0MsT0FBTztJQUM5QixJQUFJSCxvQkFBb0JFLE1BQU07UUFDMUJGLFdBQVdBLFNBQVNHLE9BQU87SUFDL0I7SUFDQSxNQUFNRyxZQUFZQyxLQUFLQyxHQUFHLENBQUNSLFdBQVdLLEtBQUs7SUFDM0MsS0FBSyxNQUFNLENBQUNJLE1BQU1DLE9BQU8sSUFBSU4sTUFBTztRQUNoQyxNQUFNTyxTQUFTTCxZQUFZSTtRQUMzQixJQUFJQyxTQUFTLEtBQUs7WUFDZCxPQUFPQyxPQUFPTCxLQUFLTSxJQUFJLENBQUNGLFdBQVdGO1FBQ3ZDO0lBQ0o7SUFDQSxNQUFNLElBQUlLLE1BQU07QUFDcEI7QUFDQTs7Ozs7Q0FLQyxHQUNELE1BQU1DLG1CQUFtQjtBQUN6Qjs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNyQixtQkFBbUJNLFFBQVE7SUFDaEMsTUFBTWdCLGFBQWFoQixvQkFBb0JFLE9BQU9GLFNBQVNHLE9BQU8sS0FBS0g7SUFDbkUsTUFBTUssTUFBTSxJQUFJSCxPQUFPQyxPQUFPO0lBQzlCLE1BQU1jLFVBQVVELGFBQWFYO0lBQzdCLElBQUlZLFVBQVUsR0FBRztRQUNiLE9BQU87SUFDWCxPQUNLLElBQUlBLFVBQVVGLGtCQUFrQjtRQUNqQyxPQUFPaEI7SUFDWCxPQUNLO1FBQ0QsT0FBT2tCO0lBQ1g7QUFDSjtBQUNBLFNBQVN0QixpQkFBaUJLLFFBQVE7SUFDOUIsSUFBSUEsb0JBQW9CRSxNQUFNO1FBQzFCLE9BQU9GLFNBQVNrQixXQUFXO0lBQy9CLE9BQ0s7UUFDRCxNQUFNQyxlQUFlLElBQUlqQixLQUFLRjtRQUM5QixJQUFJb0IsT0FBT0MsS0FBSyxDQUFDRixhQUFhaEIsT0FBTyxLQUFLO1lBQ3RDLE9BQU8sS0FBS0g7UUFDaEIsT0FDSztZQUNELE9BQU9tQixhQUFhRCxXQUFXO1FBQ25DO0lBQ0o7QUFDSjtBQUNBOzs7Ozs7Q0FNQyxHQUNELFNBQVN0QixxQkFBcUIwQixTQUFTLEVBQUVDLE9BQU87SUFDNUMsT0FBTyxDQUFDLENBQUNBLFFBQVFwQixPQUFPLEtBQUttQixVQUFVbkIsT0FBTyxFQUFDLElBQUssSUFBRyxFQUFHcUIsT0FBTyxDQUFDLEtBQUs7QUFDM0UsRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZGVhZGxpbmUuanM/ZGVjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5taW5EZWFkbGluZSA9IG1pbkRlYWRsaW5lO1xuZXhwb3J0cy5nZXREZWFkbGluZVRpbWVvdXRTdHJpbmcgPSBnZXREZWFkbGluZVRpbWVvdXRTdHJpbmc7XG5leHBvcnRzLmdldFJlbGF0aXZlVGltZW91dCA9IGdldFJlbGF0aXZlVGltZW91dDtcbmV4cG9ydHMuZGVhZGxpbmVUb1N0cmluZyA9IGRlYWRsaW5lVG9TdHJpbmc7XG5leHBvcnRzLmZvcm1hdERhdGVEaWZmZXJlbmNlID0gZm9ybWF0RGF0ZURpZmZlcmVuY2U7XG5mdW5jdGlvbiBtaW5EZWFkbGluZSguLi5kZWFkbGluZUxpc3QpIHtcbiAgICBsZXQgbWluVmFsdWUgPSBJbmZpbml0eTtcbiAgICBmb3IgKGNvbnN0IGRlYWRsaW5lIG9mIGRlYWRsaW5lTGlzdCkge1xuICAgICAgICBjb25zdCBkZWFkbGluZU1zZWNzID0gZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlID8gZGVhZGxpbmUuZ2V0VGltZSgpIDogZGVhZGxpbmU7XG4gICAgICAgIGlmIChkZWFkbGluZU1zZWNzIDwgbWluVmFsdWUpIHtcbiAgICAgICAgICAgIG1pblZhbHVlID0gZGVhZGxpbmVNc2VjcztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWluVmFsdWU7XG59XG5jb25zdCB1bml0cyA9IFtcbiAgICBbJ20nLCAxXSxcbiAgICBbJ1MnLCAxMDAwXSxcbiAgICBbJ00nLCA2MCAqIDEwMDBdLFxuICAgIFsnSCcsIDYwICogNjAgKiAxMDAwXSxcbl07XG5mdW5jdGlvbiBnZXREZWFkbGluZVRpbWVvdXRTdHJpbmcoZGVhZGxpbmUpIHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBpZiAoZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIGRlYWRsaW5lID0gZGVhZGxpbmUuZ2V0VGltZSgpO1xuICAgIH1cbiAgICBjb25zdCB0aW1lb3V0TXMgPSBNYXRoLm1heChkZWFkbGluZSAtIG5vdywgMCk7XG4gICAgZm9yIChjb25zdCBbdW5pdCwgZmFjdG9yXSBvZiB1bml0cykge1xuICAgICAgICBjb25zdCBhbW91bnQgPSB0aW1lb3V0TXMgLyBmYWN0b3I7XG4gICAgICAgIGlmIChhbW91bnQgPCAxZTgpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoTWF0aC5jZWlsKGFtb3VudCkpICsgdW5pdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlYWRsaW5lIGlzIHRvbyBmYXIgaW4gdGhlIGZ1dHVyZScpO1xufVxuLyoqXG4gKiBTZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90aW1lcnMuaHRtbCNzZXR0aW1lb3V0Y2FsbGJhY2stZGVsYXktYXJnc1xuICogSW4gcGFydGljdWxhciwgXCJXaGVuIGRlbGF5IGlzIGxhcmdlciB0aGFuIDIxNDc0ODM2NDcgb3IgbGVzcyB0aGFuIDEsIHRoZVxuICogZGVsYXkgd2lsbCBiZSBzZXQgdG8gMS4gTm9uLWludGVnZXIgZGVsYXlzIGFyZSB0cnVuY2F0ZWQgdG8gYW4gaW50ZWdlci5cIlxuICogVGhpcyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGlzIGFsbW9zdCAyNSBkYXlzLlxuICovXG5jb25zdCBNQVhfVElNRU9VVF9USU1FID0gMjE0NzQ4MzY0Nztcbi8qKlxuICogR2V0IHRoZSB0aW1lb3V0IHZhbHVlIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCB0byBzZXRUaW1lb3V0IG5vdyBmb3IgdGhlIHRpbWVyXG4gKiB0byBlbmQgYXQgdGhlIGRlYWRsaW5lLiBGb3IgYW55IGRlYWRsaW5lIGJlZm9yZSBub3csIHRoZSB0aW1lciBzaG91bGQgZW5kXG4gKiBpbW1lZGlhdGVseSwgcmVwcmVzZW50ZWQgYnkgYSB2YWx1ZSBvZiAwLiBGb3IgYW55IGRlYWRsaW5lIG1vcmUgdGhhblxuICogTUFYX1RJTUVPVVRfVElNRSBtaWxsaXNlY29uZHMgaW4gdGhlIGZ1dHVyZSwgYSB0aW1lciBjYW5ub3QgYmUgc2V0IHRoYXQgd2lsbFxuICogZW5kIGF0IHRoYXQgdGltZSwgc28gaXQgaXMgdHJlYXRlZCBhcyBpbmZpbml0ZWx5IGZhciBpbiB0aGUgZnV0dXJlLlxuICogQHBhcmFtIGRlYWRsaW5lXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVRpbWVvdXQoZGVhZGxpbmUpIHtcbiAgICBjb25zdCBkZWFkbGluZU1zID0gZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlID8gZGVhZGxpbmUuZ2V0VGltZSgpIDogZGVhZGxpbmU7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgY29uc3QgdGltZW91dCA9IGRlYWRsaW5lTXMgLSBub3c7XG4gICAgaWYgKHRpbWVvdXQgPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aW1lb3V0ID4gTUFYX1RJTUVPVVRfVElNRSkge1xuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdGltZW91dDtcbiAgICB9XG59XG5mdW5jdGlvbiBkZWFkbGluZVRvU3RyaW5nKGRlYWRsaW5lKSB7XG4gICAgaWYgKGRlYWRsaW5lIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gZGVhZGxpbmUudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGRhdGVEZWFkbGluZSA9IG5ldyBEYXRlKGRlYWRsaW5lKTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihkYXRlRGVhZGxpbmUuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgZGVhZGxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZURlYWRsaW5lLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBkYXRlcyBhcyBhIG51bWJlciBvZiBzZWNvbmRzIGFuZCBmb3JtYXRcbiAqIGl0IGFzIGEgc3RyaW5nLlxuICogQHBhcmFtIHN0YXJ0RGF0ZVxuICogQHBhcmFtIGVuZERhdGVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdERhdGVEaWZmZXJlbmNlKHN0YXJ0RGF0ZSwgZW5kRGF0ZSkge1xuICAgIHJldHVybiAoKGVuZERhdGUuZ2V0VGltZSgpIC0gc3RhcnREYXRlLmdldFRpbWUoKSkgLyAxMDAwKS50b0ZpeGVkKDMpICsgJ3MnO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVhZGxpbmUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibWluRGVhZGxpbmUiLCJnZXREZWFkbGluZVRpbWVvdXRTdHJpbmciLCJnZXRSZWxhdGl2ZVRpbWVvdXQiLCJkZWFkbGluZVRvU3RyaW5nIiwiZm9ybWF0RGF0ZURpZmZlcmVuY2UiLCJkZWFkbGluZUxpc3QiLCJtaW5WYWx1ZSIsIkluZmluaXR5IiwiZGVhZGxpbmUiLCJkZWFkbGluZU1zZWNzIiwiRGF0ZSIsImdldFRpbWUiLCJ1bml0cyIsIm5vdyIsInRpbWVvdXRNcyIsIk1hdGgiLCJtYXgiLCJ1bml0IiwiZmFjdG9yIiwiYW1vdW50IiwiU3RyaW5nIiwiY2VpbCIsIkVycm9yIiwiTUFYX1RJTUVPVVRfVElNRSIsImRlYWRsaW5lTXMiLCJ0aW1lb3V0IiwidG9JU09TdHJpbmciLCJkYXRlRGVhZGxpbmUiLCJOdW1iZXIiLCJpc05hTiIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJ0b0ZpeGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/duration.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/duration.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.msToDuration = msToDuration;\nexports.durationToMs = durationToMs;\nexports.isDuration = isDuration;\nexports.parseDuration = parseDuration;\nfunction msToDuration(millis) {\n    return {\n        seconds: millis / 1000 | 0,\n        nanos: millis % 1000 * 1000000 | 0\n    };\n}\nfunction durationToMs(duration) {\n    return duration.seconds * 1000 + duration.nanos / 1000000 | 0;\n}\nfunction isDuration(value) {\n    return typeof value.seconds === \"number\" && typeof value.nanos === \"number\";\n}\nconst durationRegex = /^(\\d+)(?:\\.(\\d+))?s$/;\nfunction parseDuration(value) {\n    const match = value.match(durationRegex);\n    if (!match) {\n        return null;\n    }\n    return {\n        seconds: Number.parseInt(match[1], 10),\n        nanos: match[2] ? Number.parseInt(match[2].padEnd(9, \"0\"), 10) : 0\n    };\n} //# sourceMappingURL=duration.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZHVyYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHRTtBQUN2QkYsb0JBQW9CLEdBQUdHO0FBQ3ZCSCxrQkFBa0IsR0FBR0k7QUFDckJKLHFCQUFxQixHQUFHSztBQUN4QixTQUFTSCxhQUFhSSxNQUFNO0lBQ3hCLE9BQU87UUFDSEMsU0FBUyxTQUFVLE9BQVE7UUFDM0JDLE9BQU8sU0FBVyxPQUFRLFVBQVc7SUFDekM7QUFDSjtBQUNBLFNBQVNMLGFBQWFNLFFBQVE7SUFDMUIsT0FBTyxTQUFVRixPQUFPLEdBQUcsT0FBT0UsU0FBU0QsS0FBSyxHQUFHLFVBQVc7QUFDbEU7QUFDQSxTQUFTSixXQUFXSCxLQUFLO0lBQ3JCLE9BQU8sT0FBT0EsTUFBTU0sT0FBTyxLQUFLLFlBQVksT0FBT04sTUFBTU8sS0FBSyxLQUFLO0FBQ3ZFO0FBQ0EsTUFBTUUsZ0JBQWdCO0FBQ3RCLFNBQVNMLGNBQWNKLEtBQUs7SUFDeEIsTUFBTVUsUUFBUVYsTUFBTVUsS0FBSyxDQUFDRDtJQUMxQixJQUFJLENBQUNDLE9BQU87UUFDUixPQUFPO0lBQ1g7SUFDQSxPQUFPO1FBQ0hKLFNBQVNLLE9BQU9DLFFBQVEsQ0FBQ0YsS0FBSyxDQUFDLEVBQUUsRUFBRTtRQUNuQ0gsT0FBT0csS0FBSyxDQUFDLEVBQUUsR0FBR0MsT0FBT0MsUUFBUSxDQUFDRixLQUFLLENBQUMsRUFBRSxDQUFDRyxNQUFNLENBQUMsR0FBRyxNQUFNLE1BQU07SUFDckU7QUFDSixFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1ob3VzaW5nLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9kdXJhdGlvbi5qcz9kMTEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1zVG9EdXJhdGlvbiA9IG1zVG9EdXJhdGlvbjtcbmV4cG9ydHMuZHVyYXRpb25Ub01zID0gZHVyYXRpb25Ub01zO1xuZXhwb3J0cy5pc0R1cmF0aW9uID0gaXNEdXJhdGlvbjtcbmV4cG9ydHMucGFyc2VEdXJhdGlvbiA9IHBhcnNlRHVyYXRpb247XG5mdW5jdGlvbiBtc1RvRHVyYXRpb24obWlsbGlzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2Vjb25kczogKG1pbGxpcyAvIDEwMDApIHwgMCxcbiAgICAgICAgbmFub3M6ICgobWlsbGlzICUgMTAwMCkgKiAxMDAwMDAwKSB8IDAsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGR1cmF0aW9uVG9NcyhkdXJhdGlvbikge1xuICAgIHJldHVybiAoZHVyYXRpb24uc2Vjb25kcyAqIDEwMDAgKyBkdXJhdGlvbi5uYW5vcyAvIDEwMDAwMDApIHwgMDtcbn1cbmZ1bmN0aW9uIGlzRHVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlLnNlY29uZHMgPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZS5uYW5vcyA9PT0gJ251bWJlcic7XG59XG5jb25zdCBkdXJhdGlvblJlZ2V4ID0gL14oXFxkKykoPzpcXC4oXFxkKykpP3MkLztcbmZ1bmN0aW9uIHBhcnNlRHVyYXRpb24odmFsdWUpIHtcbiAgICBjb25zdCBtYXRjaCA9IHZhbHVlLm1hdGNoKGR1cmF0aW9uUmVnZXgpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNlY29uZHM6IE51bWJlci5wYXJzZUludChtYXRjaFsxXSwgMTApLFxuICAgICAgICBuYW5vczogbWF0Y2hbMl0gPyBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMl0ucGFkRW5kKDksICcwJyksIDEwKSA6IDBcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHVyYXRpb24uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibXNUb0R1cmF0aW9uIiwiZHVyYXRpb25Ub01zIiwiaXNEdXJhdGlvbiIsInBhcnNlRHVyYXRpb24iLCJtaWxsaXMiLCJzZWNvbmRzIiwibmFub3MiLCJkdXJhdGlvbiIsImR1cmF0aW9uUmVnZXgiLCJtYXRjaCIsIk51bWJlciIsInBhcnNlSW50IiwicGFkRW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/duration.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/environment.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/environment.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2024 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ var _a;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.GRPC_NODE_USE_ALTERNATIVE_RESOLVER = void 0;\nexports.GRPC_NODE_USE_ALTERNATIVE_RESOLVER = ((_a = process.env.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) !== null && _a !== void 0 ? _a : \"false\") === \"true\"; //# sourceMappingURL=environment.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZW52aXJvbm1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxJQUFJQTtBQUNKQyw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMENBQTBDLEdBQUcsS0FBSztBQUNsREEsMENBQTBDLEdBQUcsQ0FBQyxDQUFDSCxLQUFLTSxRQUFRQyxHQUFHLENBQUNGLGtDQUFrQyxNQUFNLFFBQVFMLE9BQU8sS0FBSyxJQUFJQSxLQUFLLE9BQU0sTUFBTyxRQUNsSix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZW52aXJvbm1lbnQuanM/OGU4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyNCBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5HUlBDX05PREVfVVNFX0FMVEVSTkFUSVZFX1JFU09MVkVSID0gdm9pZCAwO1xuZXhwb3J0cy5HUlBDX05PREVfVVNFX0FMVEVSTkFUSVZFX1JFU09MVkVSID0gKChfYSA9IHByb2Nlc3MuZW52LkdSUENfTk9ERV9VU0VfQUxURVJOQVRJVkVfUkVTT0xWRVIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdmYWxzZScpID09PSAndHJ1ZSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnZpcm9ubWVudC5qcy5tYXAiXSwibmFtZXMiOlsiX2EiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkdSUENfTk9ERV9VU0VfQUxURVJOQVRJVkVfUkVTT0xWRVIiLCJwcm9jZXNzIiwiZW52Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/environment.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/error.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/error.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getErrorMessage = getErrorMessage;\nexports.getErrorCode = getErrorCode;\nfunction getErrorMessage(error) {\n    if (error instanceof Error) {\n        return error.message;\n    } else {\n        return String(error);\n    }\n}\nfunction getErrorCode(error) {\n    if (typeof error === \"object\" && error !== null && \"code\" in error && typeof error.code === \"number\") {\n        return error.code;\n    } else {\n        return null;\n    }\n} //# sourceMappingURL=error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHVCQUF1QixHQUFHRTtBQUMxQkYsb0JBQW9CLEdBQUdHO0FBQ3ZCLFNBQVNELGdCQUFnQkUsS0FBSztJQUMxQixJQUFJQSxpQkFBaUJDLE9BQU87UUFDeEIsT0FBT0QsTUFBTUUsT0FBTztJQUN4QixPQUNLO1FBQ0QsT0FBT0MsT0FBT0g7SUFDbEI7QUFDSjtBQUNBLFNBQVNELGFBQWFDLEtBQUs7SUFDdkIsSUFBSSxPQUFPQSxVQUFVLFlBQ2pCQSxVQUFVLFFBQ1YsVUFBVUEsU0FDVixPQUFPQSxNQUFNSSxJQUFJLEtBQUssVUFBVTtRQUNoQyxPQUFPSixNQUFNSSxJQUFJO0lBQ3JCLE9BQ0s7UUFDRCxPQUFPO0lBQ1g7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1ob3VzaW5nLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9lcnJvci5qcz9lYzk0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEVycm9yTWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZTtcbmV4cG9ydHMuZ2V0RXJyb3JDb2RlID0gZ2V0RXJyb3JDb2RlO1xuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGVycm9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRFcnJvckNvZGUoZXJyb3IpIHtcbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBlcnJvciAhPT0gbnVsbCAmJlxuICAgICAgICAnY29kZScgaW4gZXJyb3IgJiZcbiAgICAgICAgdHlwZW9mIGVycm9yLmNvZGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBlcnJvci5jb2RlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3IuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0RXJyb3JNZXNzYWdlIiwiZ2V0RXJyb3JDb2RlIiwiZXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJTdHJpbmciLCJjb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/experimental.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/experimental.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX = exports.createCertificateProviderChannelCredentials = exports.FileWatcherCertificateProvider = exports.createCertificateProviderServerCredentials = exports.createServerCredentialsWithInterceptors = exports.BaseSubchannelWrapper = exports.registerAdminService = exports.FilterStackFactory = exports.BaseFilter = exports.PickResultType = exports.QueuePicker = exports.UnavailablePicker = exports.ChildLoadBalancerHandler = exports.EndpointMap = exports.endpointHasAddress = exports.endpointToString = exports.subchannelAddressToString = exports.LeafLoadBalancer = exports.isLoadBalancerNameRegistered = exports.parseLoadBalancingConfig = exports.selectLbConfigFromList = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = exports.BackoffTimeout = exports.parseDuration = exports.durationToMs = exports.splitHostPort = exports.uriToString = exports.createResolver = exports.registerResolver = exports.log = exports.trace = void 0;\nvar logging_1 = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nObject.defineProperty(exports, \"trace\", ({\n    enumerable: true,\n    get: function() {\n        return logging_1.trace;\n    }\n}));\nObject.defineProperty(exports, \"log\", ({\n    enumerable: true,\n    get: function() {\n        return logging_1.log;\n    }\n}));\nvar resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nObject.defineProperty(exports, \"registerResolver\", ({\n    enumerable: true,\n    get: function() {\n        return resolver_1.registerResolver;\n    }\n}));\nObject.defineProperty(exports, \"createResolver\", ({\n    enumerable: true,\n    get: function() {\n        return resolver_1.createResolver;\n    }\n}));\nvar uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nObject.defineProperty(exports, \"uriToString\", ({\n    enumerable: true,\n    get: function() {\n        return uri_parser_1.uriToString;\n    }\n}));\nObject.defineProperty(exports, \"splitHostPort\", ({\n    enumerable: true,\n    get: function() {\n        return uri_parser_1.splitHostPort;\n    }\n}));\nvar duration_1 = __webpack_require__(/*! ./duration */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\nObject.defineProperty(exports, \"durationToMs\", ({\n    enumerable: true,\n    get: function() {\n        return duration_1.durationToMs;\n    }\n}));\nObject.defineProperty(exports, \"parseDuration\", ({\n    enumerable: true,\n    get: function() {\n        return duration_1.parseDuration;\n    }\n}));\nvar backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nObject.defineProperty(exports, \"BackoffTimeout\", ({\n    enumerable: true,\n    get: function() {\n        return backoff_timeout_1.BackoffTimeout;\n    }\n}));\nvar load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nObject.defineProperty(exports, \"createChildChannelControlHelper\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_1.createChildChannelControlHelper;\n    }\n}));\nObject.defineProperty(exports, \"registerLoadBalancerType\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_1.registerLoadBalancerType;\n    }\n}));\nObject.defineProperty(exports, \"selectLbConfigFromList\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_1.selectLbConfigFromList;\n    }\n}));\nObject.defineProperty(exports, \"parseLoadBalancingConfig\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_1.parseLoadBalancingConfig;\n    }\n}));\nObject.defineProperty(exports, \"isLoadBalancerNameRegistered\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_1.isLoadBalancerNameRegistered;\n    }\n}));\nvar load_balancer_pick_first_1 = __webpack_require__(/*! ./load-balancer-pick-first */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\");\nObject.defineProperty(exports, \"LeafLoadBalancer\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_pick_first_1.LeafLoadBalancer;\n    }\n}));\nvar subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nObject.defineProperty(exports, \"subchannelAddressToString\", ({\n    enumerable: true,\n    get: function() {\n        return subchannel_address_1.subchannelAddressToString;\n    }\n}));\nObject.defineProperty(exports, \"endpointToString\", ({\n    enumerable: true,\n    get: function() {\n        return subchannel_address_1.endpointToString;\n    }\n}));\nObject.defineProperty(exports, \"endpointHasAddress\", ({\n    enumerable: true,\n    get: function() {\n        return subchannel_address_1.endpointHasAddress;\n    }\n}));\nObject.defineProperty(exports, \"EndpointMap\", ({\n    enumerable: true,\n    get: function() {\n        return subchannel_address_1.EndpointMap;\n    }\n}));\nvar load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nObject.defineProperty(exports, \"ChildLoadBalancerHandler\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_child_handler_1.ChildLoadBalancerHandler;\n    }\n}));\nvar picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nObject.defineProperty(exports, \"UnavailablePicker\", ({\n    enumerable: true,\n    get: function() {\n        return picker_1.UnavailablePicker;\n    }\n}));\nObject.defineProperty(exports, \"QueuePicker\", ({\n    enumerable: true,\n    get: function() {\n        return picker_1.QueuePicker;\n    }\n}));\nObject.defineProperty(exports, \"PickResultType\", ({\n    enumerable: true,\n    get: function() {\n        return picker_1.PickResultType;\n    }\n}));\nvar filter_1 = __webpack_require__(/*! ./filter */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nObject.defineProperty(exports, \"BaseFilter\", ({\n    enumerable: true,\n    get: function() {\n        return filter_1.BaseFilter;\n    }\n}));\nvar filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\nObject.defineProperty(exports, \"FilterStackFactory\", ({\n    enumerable: true,\n    get: function() {\n        return filter_stack_1.FilterStackFactory;\n    }\n}));\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nObject.defineProperty(exports, \"registerAdminService\", ({\n    enumerable: true,\n    get: function() {\n        return admin_1.registerAdminService;\n    }\n}));\nvar subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\nObject.defineProperty(exports, \"BaseSubchannelWrapper\", ({\n    enumerable: true,\n    get: function() {\n        return subchannel_interface_1.BaseSubchannelWrapper;\n    }\n}));\nvar server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\nObject.defineProperty(exports, \"createServerCredentialsWithInterceptors\", ({\n    enumerable: true,\n    get: function() {\n        return server_credentials_1.createServerCredentialsWithInterceptors;\n    }\n}));\nObject.defineProperty(exports, \"createCertificateProviderServerCredentials\", ({\n    enumerable: true,\n    get: function() {\n        return server_credentials_1.createCertificateProviderServerCredentials;\n    }\n}));\nvar certificate_provider_1 = __webpack_require__(/*! ./certificate-provider */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/certificate-provider.js\");\nObject.defineProperty(exports, \"FileWatcherCertificateProvider\", ({\n    enumerable: true,\n    get: function() {\n        return certificate_provider_1.FileWatcherCertificateProvider;\n    }\n}));\nvar channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nObject.defineProperty(exports, \"createCertificateProviderChannelCredentials\", ({\n    enumerable: true,\n    get: function() {\n        return channel_credentials_1.createCertificateProviderChannelCredentials;\n    }\n}));\nvar internal_channel_1 = __webpack_require__(/*! ./internal-channel */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js\");\nObject.defineProperty(exports, \"SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX\", ({\n    enumerable: true,\n    get: function() {\n        return internal_channel_1.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX;\n    }\n})); //# sourceMappingURL=experimental.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZXhwZXJpbWVudGFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQ0FBMEMsR0FBR0EsbURBQW1ELEdBQUdBLHNDQUFzQyxHQUFHQSxrREFBa0QsR0FBR0EsK0NBQStDLEdBQUdBLDZCQUE2QixHQUFHQSw0QkFBNEIsR0FBR0EsMEJBQTBCLEdBQUdBLGtCQUFrQixHQUFHQSxzQkFBc0IsR0FBR0EsbUJBQW1CLEdBQUdBLHlCQUF5QixHQUFHQSxnQ0FBZ0MsR0FBR0EsbUJBQW1CLEdBQUdBLDBCQUEwQixHQUFHQSx3QkFBd0IsR0FBR0EsaUNBQWlDLEdBQUdBLHdCQUF3QixHQUFHQSxvQ0FBb0MsR0FBR0EsZ0NBQWdDLEdBQUdBLDhCQUE4QixHQUFHQSxnQ0FBZ0MsR0FBR0EsdUNBQXVDLEdBQUdBLHNCQUFzQixHQUFHQSxxQkFBcUIsR0FBR0Esb0JBQW9CLEdBQUdBLHFCQUFxQixHQUFHQSxtQkFBbUIsR0FBR0Esc0JBQXNCLEdBQUdBLHdCQUF3QixHQUFHQSxXQUFXLEdBQUdBLGFBQWEsR0FBRyxLQUFLO0FBQ3ArQixJQUFJa0MsWUFBWUMsbUJBQU9BLENBQUMsMEVBQVc7QUFDbkNyQyx5Q0FBd0M7SUFBRXNDLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9ILFVBQVVELEtBQUs7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMzR25DLHVDQUFzQztJQUFFc0MsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsVUFBVUYsR0FBRztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3ZHLElBQUlNLGFBQWFILG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3JDckMsb0RBQW1EO0lBQUVzQyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPQyxXQUFXUCxnQkFBZ0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNsSWpDLGtEQUFpRDtJQUFFc0Ms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RXNDLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9lLHVCQUF1QmhELDhCQUE4QjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzFLLElBQUlpRCx3QkFBd0JsQixtQkFBT0EsQ0FBQyxrR0FBdUI7QUFDM0RyQywrRUFBOEU7SUFBRXNDLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9nQixzQkFBc0JsRCwyQ0FBMkM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNuTSxJQUFJbUQscUJBQXFCbkIsbUJBQU9BLENBQUMsNEZBQW9CO0FBQ3JEckMsc0VBQXFFO0lBQUVzQyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPaUIsbUJBQW1CcEQsa0NBQWtDO0lBQUU7QUFBRSxDQUFDLEVBQUMsRUFDOUssd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnljLWhvdXNpbmctYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2V4cGVyaW1lbnRhbC5qcz80YWQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TVUJDSEFOTkVMX0FSR1NfRVhDTFVERV9LRVlfUFJFRklYID0gZXhwb3J0cy5jcmVhdGVDZXJ0aWZpY2F0ZVByb3ZpZGVyQ2hhbm5lbENyZWRlbnRpYWxzID0gZXhwb3J0cy5GaWxlV2F0Y2hlckNlcnRpZmljYXRlUHJvdmlkZXIgPSBleHBvcnRzLmNyZWF0ZUNlcnRpZmljYXRlUHJvdmlkZXJTZXJ2ZXJDcmVkZW50aWFscyA9IGV4cG9ydHMuY3JlYXRlU2VydmVyQ3JlZGVudGlhbHNXaXRoSW50ZXJjZXB0b3JzID0gZXhwb3J0cy5CYXNlU3ViY2hhbm5lbFdyYXBwZXIgPSBleHBvcnRzLnJlZ2lzdGVyQWRtaW5TZXJ2aWNlID0gZXhwb3J0cy5GaWx0ZXJTdGFja0ZhY3RvcnkgPSBleHBvcnRzLkJhc2VGaWx0ZXIgPSBleHBvcnRzLlBpY2tSZXN1bHRUeXBlID0gZXhwb3J0cy5RdWV1ZVBpY2tlciA9IGV4cG9ydHMuVW5hdmFpbGFibGVQaWNrZXIgPSBleHBvcnRzLkNoaWxkTG9hZEJhbGFuY2VySGFuZGxlciA9IGV4cG9ydHMuRW5kcG9pbnRNYXAgPSBleHBvcnRzLmVuZHBvaW50SGFzQWRkcmVzcyA9IGV4cG9ydHMuZW5kcG9pbnRUb1N0cmluZyA9IGV4cG9ydHMuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyA9IGV4cG9ydHMuTGVhZkxvYWRCYWxhbmNlciA9IGV4cG9ydHMuaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZCA9IGV4cG9ydHMucGFyc2VMb2FkQmFsYW5jaW5nQ29uZmlnID0gZXhwb3J0cy5zZWxlY3RMYkNvbmZpZ0Zyb21MaXN0ID0gZXhwb3J0cy5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGUgPSBleHBvcnRzLmNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIgPSBleHBvcnRzLkJhY2tvZmZUaW1lb3V0ID0gZXhwb3J0cy5wYXJzZUR1cmF0aW9uID0gZXhwb3J0cy5kdXJhdGlvblRvTXMgPSBleHBvcnRzLnNwbGl0SG9zdFBvcnQgPSBleHBvcnRzLnVyaVRvU3RyaW5nID0gZXhwb3J0cy5jcmVhdGVSZXNvbHZlciA9IGV4cG9ydHMucmVnaXN0ZXJSZXNvbHZlciA9IGV4cG9ydHMubG9nID0gZXhwb3J0cy50cmFjZSA9IHZvaWQgMDtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidHJhY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvZ2dpbmdfMS50cmFjZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9nZ2luZ18xLmxvZzsgfSB9KTtcbnZhciByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWdpc3RlclJlc29sdmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVSZXNvbHZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZXJfMS5jcmVhdGVSZXNvbHZlcjsgfSB9KTtcbnZhciB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXJpVG9TdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNwbGl0SG9zdFBvcnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0OyB9IH0pO1xudmFyIGR1cmF0aW9uXzEgPSByZXF1aXJlKFwiLi9kdXJhdGlvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImR1cmF0aW9uVG9Nc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHVyYXRpb25fMS5kdXJhdGlvblRvTXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZUR1cmF0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkdXJhdGlvbl8xLnBhcnNlRHVyYXRpb247IH0gfSk7XG52YXIgYmFja29mZl90aW1lb3V0XzEgPSByZXF1aXJlKFwiLi9iYWNrb2ZmLXRpbWVvdXRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYWNrb2ZmVGltZW91dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFja29mZl90aW1lb3V0XzEuQmFja29mZlRpbWVvdXQ7IH0gfSk7XG52YXIgbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvYWRfYmFsYW5jZXJfMS5jcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyXzEucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VsZWN0TGJDb25maWdGcm9tTGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl8xLnNlbGVjdExiQ29uZmlnRnJvbUxpc3Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZUxvYWRCYWxhbmNpbmdDb25maWdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvYWRfYmFsYW5jZXJfMS5wYXJzZUxvYWRCYWxhbmNpbmdDb25maWc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0xvYWRCYWxhbmNlck5hbWVSZWdpc3RlcmVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyXzEuaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZDsgfSB9KTtcbnZhciBsb2FkX2JhbGFuY2VyX3BpY2tfZmlyc3RfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItcGljay1maXJzdFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxlYWZMb2FkQmFsYW5jZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvYWRfYmFsYW5jZXJfcGlja19maXJzdF8xLkxlYWZMb2FkQmFsYW5jZXI7IH0gfSk7XG52YXIgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5kcG9pbnRUb1N0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3ViY2hhbm5lbF9hZGRyZXNzXzEuZW5kcG9pbnRUb1N0cmluZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuZHBvaW50SGFzQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3ViY2hhbm5lbF9hZGRyZXNzXzEuZW5kcG9pbnRIYXNBZGRyZXNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRW5kcG9pbnRNYXBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YmNoYW5uZWxfYWRkcmVzc18xLkVuZHBvaW50TWFwOyB9IH0pO1xudmFyIGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMS5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXI7IH0gfSk7XG52YXIgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVbmF2YWlsYWJsZVBpY2tlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJRdWV1ZVBpY2tlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGlja2VyXzEuUXVldWVQaWNrZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQaWNrUmVzdWx0VHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGlja2VyXzEuUGlja1Jlc3VsdFR5cGU7IH0gfSk7XG52YXIgZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9maWx0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlRmlsdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJfMS5CYXNlRmlsdGVyOyB9IH0pO1xudmFyIGZpbHRlcl9zdGFja18xID0gcmVxdWlyZShcIi4vZmlsdGVyLXN0YWNrXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmlsdGVyU3RhY2tGYWN0b3J5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJfc3RhY2tfMS5GaWx0ZXJTdGFja0ZhY3Rvcnk7IH0gfSk7XG52YXIgYWRtaW5fMSA9IHJlcXVpcmUoXCIuL2FkbWluXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVnaXN0ZXJBZG1pblNlcnZpY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkbWluXzEucmVnaXN0ZXJBZG1pblNlcnZpY2U7IH0gfSk7XG52YXIgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtaW50ZXJmYWNlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFzZVN1YmNoYW5uZWxXcmFwcGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJjaGFubmVsX2ludGVyZmFjZV8xLkJhc2VTdWJjaGFubmVsV3JhcHBlcjsgfSB9KTtcbnZhciBzZXJ2ZXJfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL3NlcnZlci1jcmVkZW50aWFsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVNlcnZlckNyZWRlbnRpYWxzV2l0aEludGVyY2VwdG9yc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmVyX2NyZWRlbnRpYWxzXzEuY3JlYXRlU2VydmVyQ3JlZGVudGlhbHNXaXRoSW50ZXJjZXB0b3JzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlQ2VydGlmaWNhdGVQcm92aWRlclNlcnZlckNyZWRlbnRpYWxzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJ2ZXJfY3JlZGVudGlhbHNfMS5jcmVhdGVDZXJ0aWZpY2F0ZVByb3ZpZGVyU2VydmVyQ3JlZGVudGlhbHM7IH0gfSk7XG52YXIgY2VydGlmaWNhdGVfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL2NlcnRpZmljYXRlLXByb3ZpZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmlsZVdhdGNoZXJDZXJ0aWZpY2F0ZVByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjZXJ0aWZpY2F0ZV9wcm92aWRlcl8xLkZpbGVXYXRjaGVyQ2VydGlmaWNhdGVQcm92aWRlcjsgfSB9KTtcbnZhciBjaGFubmVsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsLWNyZWRlbnRpYWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlQ2VydGlmaWNhdGVQcm92aWRlckNoYW5uZWxDcmVkZW50aWFsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hhbm5lbF9jcmVkZW50aWFsc18xLmNyZWF0ZUNlcnRpZmljYXRlUHJvdmlkZXJDaGFubmVsQ3JlZGVudGlhbHM7IH0gfSk7XG52YXIgaW50ZXJuYWxfY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwtY2hhbm5lbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNVQkNIQU5ORUxfQVJHU19FWENMVURFX0tFWV9QUkVGSVhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsX2NoYW5uZWxfMS5TVUJDSEFOTkVMX0FSR1NfRVhDTFVERV9LRVlfUFJFRklYOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhwZXJpbWVudGFsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNVQkNIQU5ORUxfQVJHU19FWENMVURFX0tFWV9QUkVGSVgiLCJjcmVhdGVDZXJ0aWZpY2F0ZVByb3ZpZGVyQ2hhbm5lbENyZWRlbnRpYWxzIiwiRmlsZVdhdGNoZXJDZXJ0aWZpY2F0ZVByb3ZpZGVyIiwiY3JlYXRlQ2VydGlmaWNhdGVQcm92aWRlclNlcnZlckNyZWRlbnRpYWxzIiwiY3JlYXRlU2VydmVyQ3JlZGVudGlhbHNXaXRoSW50ZXJjZXB0b3JzIiwiQmFzZVN1YmNoYW5uZWxXcmFwcGVyIiwicmVnaXN0ZXJBZG1pblNlcnZpY2UiLCJGaWx0ZXJTdGFja0ZhY3RvcnkiLCJCYXNlRmlsdGVyIiwiUGlja1Jlc3VsdFR5cGUiLCJRdWV1ZVBpY2tlciIsIlVuYXZhaWxhYmxlUGlja2VyIiwiQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyIiwiRW5kcG9pbnRNYXAiLCJlbmRwb2ludEhhc0FkZHJlc3MiLCJlbmRwb2ludFRvU3RyaW5nIiwic3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyIsIkxlYWZMb2FkQmFsYW5jZXIiLCJpc0xvYWRCYWxhbmNlck5hbWVSZWdpc3RlcmVkIiwicGFyc2VMb2FkQmFsYW5jaW5nQ29uZmlnIiwic2VsZWN0TGJDb25maWdGcm9tTGlzdCIsInJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSIsImNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIiLCJCYWNrb2ZmVGltZW91dCIsInBhcnNlRHVyYXRpb24iLCJkdXJhdGlvblRvTXMiLCJzcGxpdEhvc3RQb3J0IiwidXJpVG9TdHJpbmciLCJjcmVhdGVSZXNvbHZlciIsInJlZ2lzdGVyUmVzb2x2ZXIiLCJsb2ciLCJ0cmFjZSIsImxvZ2dpbmdfMSIsInJlcXVpcmUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwicmVzb2x2ZXJfMSIsInVyaV9wYXJzZXJfMSIsImR1cmF0aW9uXzEiLCJiYWNrb2ZmX3RpbWVvdXRfMSIsImxvYWRfYmFsYW5jZXJfMSIsImxvYWRfYmFsYW5jZXJfcGlja19maXJzdF8xIiwic3ViY2hhbm5lbF9hZGRyZXNzXzEiLCJsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMSIsInBpY2tlcl8xIiwiZmlsdGVyXzEiLCJmaWx0ZXJfc3RhY2tfMSIsImFkbWluXzEiLCJzdWJjaGFubmVsX2ludGVyZmFjZV8xIiwic2VydmVyX2NyZWRlbnRpYWxzXzEiLCJjZXJ0aWZpY2F0ZV9wcm92aWRlcl8xIiwiY2hhbm5lbF9jcmVkZW50aWFsc18xIiwiaW50ZXJuYWxfY2hhbm5lbF8xIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/experimental.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter-stack.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FilterStackFactory = exports.FilterStack = void 0;\nclass FilterStack {\n    constructor(filters){\n        this.filters = filters;\n    }\n    sendMetadata(metadata) {\n        let result = metadata;\n        for(let i = 0; i < this.filters.length; i++){\n            result = this.filters[i].sendMetadata(result);\n        }\n        return result;\n    }\n    receiveMetadata(metadata) {\n        let result = metadata;\n        for(let i = this.filters.length - 1; i >= 0; i--){\n            result = this.filters[i].receiveMetadata(result);\n        }\n        return result;\n    }\n    sendMessage(message) {\n        let result = message;\n        for(let i = 0; i < this.filters.length; i++){\n            result = this.filters[i].sendMessage(result);\n        }\n        return result;\n    }\n    receiveMessage(message) {\n        let result = message;\n        for(let i = this.filters.length - 1; i >= 0; i--){\n            result = this.filters[i].receiveMessage(result);\n        }\n        return result;\n    }\n    receiveTrailers(status) {\n        let result = status;\n        for(let i = this.filters.length - 1; i >= 0; i--){\n            result = this.filters[i].receiveTrailers(result);\n        }\n        return result;\n    }\n    push(filters) {\n        this.filters.unshift(...filters);\n    }\n    getFilters() {\n        return this.filters;\n    }\n}\nexports.FilterStack = FilterStack;\nclass FilterStackFactory {\n    constructor(factories){\n        this.factories = factories;\n    }\n    push(filterFactories) {\n        this.factories.unshift(...filterFactories);\n    }\n    clone() {\n        return new FilterStackFactory([\n            ...this.factories\n        ]);\n    }\n    createFilter() {\n        return new FilterStack(this.factories.map((factory)=>factory.createFilter()));\n    }\n}\nexports.FilterStackFactory = FilterStackFactory; //# sourceMappingURL=filter-stack.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLXN0YWNrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQkFBMEIsR0FBR0EsbUJBQW1CLEdBQUcsS0FBSztBQUN4RCxNQUFNRztJQUNGQyxZQUFZQyxPQUFPLENBQUU7UUFDakIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ25CO0lBQ0FDLGFBQWFDLFFBQVEsRUFBRTtRQUNuQixJQUFJQyxTQUFTRDtRQUNiLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ0osT0FBTyxDQUFDSyxNQUFNLEVBQUVELElBQUs7WUFDMUNELFNBQVMsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEVBQUUsQ0FBQ0gsWUFBWSxDQUFDRTtRQUMxQztRQUNBLE9BQU9BO0lBQ1g7SUFDQUcsZ0JBQWdCSixRQUFRLEVBQUU7UUFDdEIsSUFBSUMsU0FBU0Q7UUFDYixJQUFLLElBQUlFLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLE1BQU0sR0FBRyxHQUFHRCxLQUFLLEdBQUdBLElBQUs7WUFDL0NELFNBQVMsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEVBQUUsQ0FBQ0UsZUFBZSxDQUFDSDtRQUM3QztRQUNBLE9BQU9BO0lBQ1g7SUFDQUksWUFBWUMsT0FBTyxFQUFFO1FBQ2pCLElBQUlMLFNBQVNLO1FBQ2IsSUFBSyxJQUFJSixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLE1BQU0sRUFBRUQsSUFBSztZQUMxQ0QsU0FBUyxJQUFJLENBQUNILE9BQU8sQ0FBQ0ksRUFBRSxDQUFDRyxXQUFXLENBQUNKO1FBQ3pDO1FBQ0EsT0FBT0E7SUFDWDtJQUNBTSxlQUFlRCxPQUFPLEVBQUU7UUFDcEIsSUFBSUwsU0FBU0s7UUFDYixJQUFLLElBQUlKLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLE1BQU0sR0FBRyxHQUFHRCxLQUFLLEdBQUdBLElBQUs7WUFDL0NELFNBQVMsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEVBQUUsQ0FBQ0ssY0FBYyxDQUFDTjtRQUM1QztRQUNBLE9BQU9BO0lBQ1g7SUFDQU8sZ0JBQWdCQyxNQUFNLEVBQUU7UUFDcEIsSUFBSVIsU0FBU1E7UUFDYixJQUFLLElBQUlQLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLE1BQU0sR0FBRyxHQUFHRCxLQUFLLEdBQUdBLElBQUs7WUFDL0NELFNBQVMsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEVBQUUsQ0FBQ00sZUFBZSxDQUFDUDtRQUM3QztRQUNBLE9BQU9BO0lBQ1g7SUFDQVMsS0FBS1osT0FBTyxFQUFFO1FBQ1YsSUFBSSxDQUFDQSxPQUFPLENBQUNhLE9BQU8sSUFBSWI7SUFDNUI7SUFDQWMsYUFBYTtRQUNULE9BQU8sSUFBSSxDQUFDZCxPQUFPO0lBQ3ZCO0FBQ0o7QUFDQUwsbUJBQW1CLEdBQUdHO0FBQ3RCLE1BQU1EO0lBQ0ZFLFlBQVlnQixTQUFTLENBQUU7UUFDbkIsSUFBSSxDQUFDQSxTQUFTLEdBQUdBO0lBQ3JCO0lBQ0FILEtBQUtJLGVBQWUsRUFBRTtRQUNsQixJQUFJLENBQUNELFNBQVMsQ0FBQ0YsT0FBTyxJQUFJRztJQUM5QjtJQUNBQyxRQUFRO1FBQ0osT0FBTyxJQUFJcEIsbUJBQW1CO2VBQUksSUFBSSxDQUFDa0IsU0FBUztTQUFDO0lBQ3JEO0lBQ0FHLGVBQWU7UUFDWCxPQUFPLElBQUlwQixZQUFZLElBQUksQ0FBQ2lCLFNBQVMsQ0FBQ0ksR0FBRyxDQUFDQyxDQUFBQSxVQUFXQSxRQUFRRixZQUFZO0lBQzdFO0FBQ0o7QUFDQXZCLDBCQUEwQixHQUFHRSxvQkFDN0Isd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnljLWhvdXNpbmctYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2ZpbHRlci1zdGFjay5qcz83NTMwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZpbHRlclN0YWNrRmFjdG9yeSA9IGV4cG9ydHMuRmlsdGVyU3RhY2sgPSB2b2lkIDA7XG5jbGFzcyBGaWx0ZXJTdGFjayB7XG4gICAgY29uc3RydWN0b3IoZmlsdGVycykge1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgIH1cbiAgICBzZW5kTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG1ldGFkYXRhO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXJzW2ldLnNlbmRNZXRhZGF0YShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbWV0YWRhdGE7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZpbHRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyc1tpXS5yZWNlaXZlTWV0YWRhdGEocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBtZXNzYWdlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXJzW2ldLnNlbmRNZXNzYWdlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbWVzc2FnZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZmlsdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXJzW2ldLnJlY2VpdmVNZXNzYWdlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVjZWl2ZVRyYWlsZXJzKHN0YXR1cykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc3RhdHVzO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmZpbHRlcnNbaV0ucmVjZWl2ZVRyYWlsZXJzKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcHVzaChmaWx0ZXJzKSB7XG4gICAgICAgIHRoaXMuZmlsdGVycy51bnNoaWZ0KC4uLmZpbHRlcnMpO1xuICAgIH1cbiAgICBnZXRGaWx0ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJzO1xuICAgIH1cbn1cbmV4cG9ydHMuRmlsdGVyU3RhY2sgPSBGaWx0ZXJTdGFjaztcbmNsYXNzIEZpbHRlclN0YWNrRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IoZmFjdG9yaWVzKSB7XG4gICAgICAgIHRoaXMuZmFjdG9yaWVzID0gZmFjdG9yaWVzO1xuICAgIH1cbiAgICBwdXNoKGZpbHRlckZhY3Rvcmllcykge1xuICAgICAgICB0aGlzLmZhY3Rvcmllcy51bnNoaWZ0KC4uLmZpbHRlckZhY3Rvcmllcyk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEZpbHRlclN0YWNrRmFjdG9yeShbLi4udGhpcy5mYWN0b3JpZXNdKTtcbiAgICB9XG4gICAgY3JlYXRlRmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IEZpbHRlclN0YWNrKHRoaXMuZmFjdG9yaWVzLm1hcChmYWN0b3J5ID0+IGZhY3RvcnkuY3JlYXRlRmlsdGVyKCkpKTtcbiAgICB9XG59XG5leHBvcnRzLkZpbHRlclN0YWNrRmFjdG9yeSA9IEZpbHRlclN0YWNrRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlci1zdGFjay5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJGaWx0ZXJTdGFja0ZhY3RvcnkiLCJGaWx0ZXJTdGFjayIsImNvbnN0cnVjdG9yIiwiZmlsdGVycyIsInNlbmRNZXRhZGF0YSIsIm1ldGFkYXRhIiwicmVzdWx0IiwiaSIsImxlbmd0aCIsInJlY2VpdmVNZXRhZGF0YSIsInNlbmRNZXNzYWdlIiwibWVzc2FnZSIsInJlY2VpdmVNZXNzYWdlIiwicmVjZWl2ZVRyYWlsZXJzIiwic3RhdHVzIiwicHVzaCIsInVuc2hpZnQiLCJnZXRGaWx0ZXJzIiwiZmFjdG9yaWVzIiwiZmlsdGVyRmFjdG9yaWVzIiwiY2xvbmUiLCJjcmVhdGVGaWx0ZXIiLCJtYXAiLCJmYWN0b3J5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/filter.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BaseFilter = void 0;\nclass BaseFilter {\n    async sendMetadata(metadata) {\n        return metadata;\n    }\n    receiveMetadata(metadata) {\n        return metadata;\n    }\n    async sendMessage(message) {\n        return message;\n    }\n    async receiveMessage(message) {\n        return message;\n    }\n    receiveTrailers(status) {\n        return status;\n    }\n}\nexports.BaseFilter = BaseFilter; //# sourceMappingURL=filter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBa0IsR0FBRyxLQUFLO0FBQzFCLE1BQU1FO0lBQ0YsTUFBTUMsYUFBYUMsUUFBUSxFQUFFO1FBQ3pCLE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCRCxRQUFRLEVBQUU7UUFDdEIsT0FBT0E7SUFDWDtJQUNBLE1BQU1FLFlBQVlDLE9BQU8sRUFBRTtRQUN2QixPQUFPQTtJQUNYO0lBQ0EsTUFBTUMsZUFBZUQsT0FBTyxFQUFFO1FBQzFCLE9BQU9BO0lBQ1g7SUFDQUUsZ0JBQWdCQyxNQUFNLEVBQUU7UUFDcEIsT0FBT0E7SUFDWDtBQUNKO0FBQ0FWLGtCQUFrQixHQUFHRSxZQUNyQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLmpzPzBmMzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZUZpbHRlciA9IHZvaWQgMDtcbmNsYXNzIEJhc2VGaWx0ZXIge1xuICAgIGFzeW5jIHNlbmRNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgfVxuICAgIHJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIHJlY2VpdmVUcmFpbGVycyhzdGF0dXMpIHtcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG59XG5leHBvcnRzLkJhc2VGaWx0ZXIgPSBCYXNlRmlsdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkJhc2VGaWx0ZXIiLCJzZW5kTWV0YWRhdGEiLCJtZXRhZGF0YSIsInJlY2VpdmVNZXRhZGF0YSIsInNlbmRNZXNzYWdlIiwibWVzc2FnZSIsInJlY2VpdmVNZXNzYWdlIiwicmVjZWl2ZVRyYWlsZXJzIiwic3RhdHVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/filter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/http_proxy.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.parseCIDR = parseCIDR;\nexports.mapProxyName = mapProxyName;\nexports.getProxiedConnection = getProxiedConnection;\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst resolver_dns_1 = __webpack_require__(/*! ./resolver-dns */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\");\nconst TRACER_NAME = \"proxy\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nfunction getProxyInfo() {\n    let proxyEnv = \"\";\n    let envVar = \"\";\n    /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n     * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n     * fallback behavior can be removed if there's a demand for it.\n     */ if (process.env.grpc_proxy) {\n        envVar = \"grpc_proxy\";\n        proxyEnv = process.env.grpc_proxy;\n    } else if (process.env.https_proxy) {\n        envVar = \"https_proxy\";\n        proxyEnv = process.env.https_proxy;\n    } else if (process.env.http_proxy) {\n        envVar = \"http_proxy\";\n        proxyEnv = process.env.http_proxy;\n    } else {\n        return {};\n    }\n    let proxyUrl;\n    try {\n        proxyUrl = new url_1.URL(proxyEnv);\n    } catch (e) {\n        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n        return {};\n    }\n    if (proxyUrl.protocol !== \"http:\") {\n        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\n        return {};\n    }\n    let userCred = null;\n    if (proxyUrl.username) {\n        if (proxyUrl.password) {\n            (0, logging_1.log)(constants_1.LogVerbosity.INFO, \"userinfo found in proxy URI\");\n            userCred = decodeURIComponent(`${proxyUrl.username}:${proxyUrl.password}`);\n        } else {\n            userCred = proxyUrl.username;\n        }\n    }\n    const hostname = proxyUrl.hostname;\n    let port = proxyUrl.port;\n    /* The proxy URL uses the scheme \"http:\", which has a default port number of\n     * 80. We need to set that explicitly here if it is omitted because otherwise\n     * it will use gRPC's default port 443. */ if (port === \"\") {\n        port = \"80\";\n    }\n    const result = {\n        address: `${hostname}:${port}`\n    };\n    if (userCred) {\n        result.creds = userCred;\n    }\n    trace(\"Proxy server \" + result.address + \" set by environment variable \" + envVar);\n    return result;\n}\nfunction getNoProxyHostList() {\n    /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */ let noProxyStr = process.env.no_grpc_proxy;\n    let envVar = \"no_grpc_proxy\";\n    if (!noProxyStr) {\n        noProxyStr = process.env.no_proxy;\n        envVar = \"no_proxy\";\n    }\n    if (noProxyStr) {\n        trace(\"No proxy server list set by environment variable \" + envVar);\n        return noProxyStr.split(\",\");\n    } else {\n        return [];\n    }\n}\n/*\n * The groups correspond to CIDR parts as follows:\n * 1. ip\n * 2. prefixLength\n */ function parseCIDR(cidrString) {\n    const splitRange = cidrString.split(\"/\");\n    if (splitRange.length !== 2) {\n        return null;\n    }\n    const prefixLength = parseInt(splitRange[1], 10);\n    if (!(0, net_1.isIPv4)(splitRange[0]) || Number.isNaN(prefixLength) || prefixLength < 0 || prefixLength > 32) {\n        return null;\n    }\n    return {\n        ip: ipToInt(splitRange[0]),\n        prefixLength: prefixLength\n    };\n}\nfunction ipToInt(ip) {\n    return ip.split(\".\").reduce((acc, octet)=>(acc << 8) + parseInt(octet, 10), 0);\n}\nfunction isIpInCIDR(cidr, serverHost) {\n    const ip = cidr.ip;\n    const mask = -1 << 32 - cidr.prefixLength;\n    const hostIP = ipToInt(serverHost);\n    return (hostIP & mask) === (ip & mask);\n}\nfunction hostMatchesNoProxyList(serverHost) {\n    for (const host of getNoProxyHostList()){\n        const parsedCIDR = parseCIDR(host);\n        // host is a CIDR and serverHost is an IP address\n        if ((0, net_1.isIPv4)(serverHost) && parsedCIDR && isIpInCIDR(parsedCIDR, serverHost)) {\n            return true;\n        } else if (serverHost.endsWith(host)) {\n            // host is a single IP or a domain name suffix\n            return true;\n        }\n    }\n    return false;\n}\nfunction mapProxyName(target, options) {\n    var _a;\n    const noProxyResult = {\n        target: target,\n        extraOptions: {}\n    };\n    if (((_a = options[\"grpc.enable_http_proxy\"]) !== null && _a !== void 0 ? _a : 1) === 0) {\n        return noProxyResult;\n    }\n    if (target.scheme === \"unix\") {\n        return noProxyResult;\n    }\n    const proxyInfo = getProxyInfo();\n    if (!proxyInfo.address) {\n        return noProxyResult;\n    }\n    const hostPort = (0, uri_parser_1.splitHostPort)(target.path);\n    if (!hostPort) {\n        return noProxyResult;\n    }\n    const serverHost = hostPort.host;\n    if (hostMatchesNoProxyList(serverHost)) {\n        trace(\"Not using proxy for target in no_proxy list: \" + (0, uri_parser_1.uriToString)(target));\n        return noProxyResult;\n    }\n    const extraOptions = {\n        \"grpc.http_connect_target\": (0, uri_parser_1.uriToString)(target)\n    };\n    if (proxyInfo.creds) {\n        extraOptions[\"grpc.http_connect_creds\"] = proxyInfo.creds;\n    }\n    return {\n        target: {\n            scheme: \"dns\",\n            path: proxyInfo.address\n        },\n        extraOptions: extraOptions\n    };\n}\nfunction getProxiedConnection(address, channelOptions) {\n    var _a;\n    if (!(\"grpc.http_connect_target\" in channelOptions)) {\n        return Promise.resolve(null);\n    }\n    const realTarget = channelOptions[\"grpc.http_connect_target\"];\n    const parsedTarget = (0, uri_parser_1.parseUri)(realTarget);\n    if (parsedTarget === null) {\n        return Promise.resolve(null);\n    }\n    const splitHostPost = (0, uri_parser_1.splitHostPort)(parsedTarget.path);\n    if (splitHostPost === null) {\n        return Promise.resolve(null);\n    }\n    const hostPort = `${splitHostPost.host}:${(_a = splitHostPost.port) !== null && _a !== void 0 ? _a : resolver_dns_1.DEFAULT_PORT}`;\n    const options = {\n        method: \"CONNECT\",\n        path: hostPort\n    };\n    const headers = {\n        Host: hostPort\n    };\n    // Connect to the subchannel address as a proxy\n    if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {\n        options.host = address.host;\n        options.port = address.port;\n    } else {\n        options.socketPath = address.path;\n    }\n    if (\"grpc.http_connect_creds\" in channelOptions) {\n        headers[\"Proxy-Authorization\"] = \"Basic \" + Buffer.from(channelOptions[\"grpc.http_connect_creds\"]).toString(\"base64\");\n    }\n    options.headers = headers;\n    const proxyAddressString = (0, subchannel_address_1.subchannelAddressToString)(address);\n    trace(\"Using proxy \" + proxyAddressString + \" to connect to \" + options.path);\n    return new Promise((resolve, reject)=>{\n        const request = http.request(options);\n        request.once(\"connect\", (res, socket, head)=>{\n            request.removeAllListeners();\n            socket.removeAllListeners();\n            if (res.statusCode === 200) {\n                trace(\"Successfully connected to \" + options.path + \" through proxy \" + proxyAddressString);\n                // The HTTP client may have already read a few bytes of the proxied\n                // connection. If that's the case, put them back into the socket.\n                // See https://github.com/grpc/grpc-node/issues/2744.\n                if (head.length > 0) {\n                    socket.unshift(head);\n                }\n                trace(\"Successfully established a plaintext connection to \" + options.path + \" through proxy \" + proxyAddressString);\n                resolve(socket);\n            } else {\n                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, \"Failed to connect to \" + options.path + \" through proxy \" + proxyAddressString + \" with status \" + res.statusCode);\n                reject();\n            }\n        });\n        request.once(\"error\", (err)=>{\n            request.removeAllListeners();\n            (0, logging_1.log)(constants_1.LogVerbosity.ERROR, \"Failed to connect to proxy \" + proxyAddressString + \" with error \" + err.message);\n            reject();\n        });\n        request.end();\n    });\n} //# sourceMappingURL=http_proxy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaHR0cF9wcm94eS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUdFO0FBQ3BCRixvQkFBb0IsR0FBR0c7QUFDdkJILDRCQUE0QixHQUFHSTtBQUMvQixNQUFNQyxZQUFZQyxtQkFBT0EsQ0FBQywwRUFBVztBQUNyQyxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRSxRQUFRRixtQkFBT0EsQ0FBQyxnQkFBSztBQUMzQixNQUFNRyxPQUFPSCxtQkFBT0EsQ0FBQyxrQkFBTTtBQUMzQixNQUFNSSxVQUFVSixtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNSyx1QkFBdUJMLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNTSxlQUFlTixtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNTyxRQUFRUCxtQkFBT0EsQ0FBQyxnQkFBSztBQUMzQixNQUFNUSxpQkFBaUJSLG1CQUFPQSxDQUFDLG9GQUFnQjtBQUMvQyxNQUFNUyxjQUFjO0FBQ3BCLFNBQVNDLE1BQU1DLElBQUk7SUFDZlAsUUFBUU0sS0FBSyxDQUFDVCxZQUFZVyxZQUFZLENBQUNDLEtBQUssRUFBRUosYUFBYUU7QUFDL0Q7QUFDQSxTQUFTRztJQUNMLElBQUlDLFdBQVc7SUFDZixJQUFJQyxTQUFTO0lBQ2I7OztLQUdDLEdBQ0QsSUFBSUMsUUFBUUMsR0FBRyxDQUFDQyxVQUFVLEVBQUU7UUFDeEJILFNBQVM7UUFDVEQsV0FBV0UsUUFBUUMsR0FBRyxDQUFDQyxVQUFVO0lBQ3JDLE9BQ0ssSUFBSUYsUUFBUUMsR0FBRyxDQUFDRSxXQUFXLEVBQUU7UUFDOUJKLFNBQVM7UUFDVEQsV0FBV0UsUUFBUUMsR0FBRyxDQUFDRSxXQUFXO0lBQ3RDLE9BQ0ssSUFBSUgs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SUksVUFBVTtnQkFDbEJQO1lBQ0o7UUFDSjtRQUNBQyxRQUFRQyxJQUFJLENBQUMsU0FBU08sQ0FBQUE7WUFDbEJSLFFBQVFLLGtCQUFrQjtZQUN6QixJQUFHckcsVUFBVTBCLEdBQUcsRUFBRXhCLFlBQVlXLFlBQVksQ0FBQ2MsS0FBSyxFQUFFLGdDQUMvQ2tFLHFCQUNBLGlCQUNBVyxJQUFJQyxPQUFPO1lBQ2ZWO1FBQ0o7UUFDQUMsUUFBUVUsR0FBRztJQUNmO0FBQ0osRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaHR0cF9wcm94eS5qcz8yOGUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlQ0lEUiA9IHBhcnNlQ0lEUjtcbmV4cG9ydHMubWFwUHJveHlOYW1lID0gbWFwUHJveHlOYW1lO1xuZXhwb3J0cy5nZXRQcm94aWVkQ29ubmVjdGlvbiA9IGdldFByb3hpZWRDb25uZWN0aW9uO1xuY29uc3QgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCByZXNvbHZlcl9kbnNfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyLWRuc1wiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3Byb3h5JztcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xufVxuZnVuY3Rpb24gZ2V0UHJveHlJbmZvKCkge1xuICAgIGxldCBwcm94eUVudiA9ICcnO1xuICAgIGxldCBlbnZWYXIgPSAnJztcbiAgICAvKiBQcmVmZXIgdXNpbmcgJ2dycGNfcHJveHknLiBGYWxsYmFjayBvbiAnaHR0cF9wcm94eScgaWYgaXQgaXMgbm90IHNldC5cbiAgICAgKiBBbHNvIHByZWZlciB1c2luZyAnaHR0cHNfcHJveHknIHdpdGggZmFsbGJhY2sgb24gJ2h0dHBfcHJveHknLiBUaGVcbiAgICAgKiBmYWxsYmFjayBiZWhhdmlvciBjYW4gYmUgcmVtb3ZlZCBpZiB0aGVyZSdzIGEgZGVtYW5kIGZvciBpdC5cbiAgICAgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuZ3JwY19wcm94eSkge1xuICAgICAgICBlbnZWYXIgPSAnZ3JwY19wcm94eSc7XG4gICAgICAgIHByb3h5RW52ID0gcHJvY2Vzcy5lbnYuZ3JwY19wcm94eTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuaHR0cHNfcHJveHkpIHtcbiAgICAgICAgZW52VmFyID0gJ2h0dHBzX3Byb3h5JztcbiAgICAgICAgcHJveHlFbnYgPSBwcm9jZXNzLmVudi5odHRwc19wcm94eTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuaHR0cF9wcm94eSkge1xuICAgICAgICBlbnZWYXIgPSAnaHR0cF9wcm94eSc7XG4gICAgICAgIHByb3h5RW52ID0gcHJvY2Vzcy5lbnYuaHR0cF9wcm94eTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgbGV0IHByb3h5VXJsO1xuICAgIHRyeSB7XG4gICAgICAgIHByb3h5VXJsID0gbmV3IHVybF8xLlVSTChwcm94eUVudik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgICgwLCBsb2dnaW5nXzEubG9nKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGBjYW5ub3QgcGFyc2UgdmFsdWUgb2YgXCIke2VudlZhcn1cIiBlbnYgdmFyYCk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKHByb3h5VXJsLnByb3RvY29sICE9PSAnaHR0cDonKSB7XG4gICAgICAgICgwLCBsb2dnaW5nXzEubG9nKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGBcIiR7cHJveHlVcmwucHJvdG9jb2x9XCIgc2NoZW1lIG5vdCBzdXBwb3J0ZWQgaW4gcHJveHkgVVJJYCk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgbGV0IHVzZXJDcmVkID0gbnVsbDtcbiAgICBpZiAocHJveHlVcmwudXNlcm5hbWUpIHtcbiAgICAgICAgaWYgKHByb3h5VXJsLnBhc3N3b3JkKSB7XG4gICAgICAgICAgICAoMCwgbG9nZ2luZ18xLmxvZykoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LklORk8sICd1c2VyaW5mbyBmb3VuZCBpbiBwcm94eSBVUkknKTtcbiAgICAgICAgICAgIHVzZXJDcmVkID0gZGVjb2RlVVJJQ29tcG9uZW50KGAke3Byb3h5VXJsLnVzZXJuYW1lfToke3Byb3h5VXJsLnBhc3N3b3JkfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXNlckNyZWQgPSBwcm94eVVybC51c2VybmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBob3N0bmFtZSA9IHByb3h5VXJsLmhvc3RuYW1lO1xuICAgIGxldCBwb3J0ID0gcHJveHlVcmwucG9ydDtcbiAgICAvKiBUaGUgcHJveHkgVVJMIHVzZXMgdGhlIHNjaGVtZSBcImh0dHA6XCIsIHdoaWNoIGhhcyBhIGRlZmF1bHQgcG9ydCBudW1iZXIgb2ZcbiAgICAgKiA4MC4gV2UgbmVlZCB0byBzZXQgdGhhdCBleHBsaWNpdGx5IGhlcmUgaWYgaXQgaXMgb21pdHRlZCBiZWNhdXNlIG90aGVyd2lzZVxuICAgICAqIGl0IHdpbGwgdXNlIGdSUEMncyBkZWZhdWx0IHBvcnQgNDQzLiAqL1xuICAgIGlmIChwb3J0ID09PSAnJykge1xuICAgICAgICBwb3J0ID0gJzgwJztcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBhZGRyZXNzOiBgJHtob3N0bmFtZX06JHtwb3J0fWAsXG4gICAgfTtcbiAgICBpZiAodXNlckNyZWQpIHtcbiAgICAgICAgcmVzdWx0LmNyZWRzID0gdXNlckNyZWQ7XG4gICAgfVxuICAgIHRyYWNlKCdQcm94eSBzZXJ2ZXIgJyArIHJlc3VsdC5hZGRyZXNzICsgJyBzZXQgYnkgZW52aXJvbm1lbnQgdmFyaWFibGUgJyArIGVudlZhcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldE5vUHJveHlIb3N0TGlzdCgpIHtcbiAgICAvKiBQcmVmZXIgdXNpbmcgJ25vX2dycGNfcHJveHknLiBGYWxsYmFjayBvbiAnbm9fcHJveHknIGlmIGl0IGlzIG5vdCBzZXQuICovXG4gICAgbGV0IG5vUHJveHlTdHIgPSBwcm9jZXNzLmVudi5ub19ncnBjX3Byb3h5O1xuICAgIGxldCBlbnZWYXIgPSAnbm9fZ3JwY19wcm94eSc7XG4gICAgaWYgKCFub1Byb3h5U3RyKSB7XG4gICAgICAgIG5vUHJveHlTdHIgPSBwcm9jZXNzLmVudi5ub19wcm94eTtcbiAgICAgICAgZW52VmFyID0gJ25vX3Byb3h5JztcbiAgICB9XG4gICAgaWYgKG5vUHJveHlTdHIpIHtcbiAgICAgICAgdHJhY2UoJ05vIHByb3h5IHNlcnZlciBsaXN0IHNldCBieSBlbnZpcm9ubWVudCB2YXJpYWJsZSAnICsgZW52VmFyKTtcbiAgICAgICAgcmV0dXJuIG5vUHJveHlTdHIuc3BsaXQoJywnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG4vKlxuICogVGhlIGdyb3VwcyBjb3JyZXNwb25kIHRvIENJRFIgcGFydHMgYXMgZm9sbG93czpcbiAqIDEuIGlwXG4gKiAyLiBwcmVmaXhMZW5ndGhcbiAqL1xuZnVuY3Rpb24gcGFyc2VDSURSKGNpZHJTdHJpbmcpIHtcbiAgICBjb25zdCBzcGxpdFJhbmdlID0gY2lkclN0cmluZy5zcGxpdCgnLycpO1xuICAgIGlmIChzcGxpdFJhbmdlLmxlbmd0aCAhPT0gMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcHJlZml4TGVuZ3RoID0gcGFyc2VJbnQoc3BsaXRSYW5nZVsxXSwgMTApO1xuICAgIGlmICghKDAsIG5ldF8xLmlzSVB2NCkoc3BsaXRSYW5nZVswXSkgfHwgTnVtYmVyLmlzTmFOKHByZWZpeExlbmd0aCkgfHwgcHJlZml4TGVuZ3RoIDwgMCB8fCBwcmVmaXhMZW5ndGggPiAzMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXA6IGlwVG9JbnQoc3BsaXRSYW5nZVswXSksXG4gICAgICAgIHByZWZpeExlbmd0aDogcHJlZml4TGVuZ3RoXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlwVG9JbnQoaXApIHtcbiAgICByZXR1cm4gaXAuc3BsaXQoXCIuXCIpLnJlZHVjZSgoYWNjLCBvY3RldCkgPT4gKGFjYyA8PCA4KSArIHBhcnNlSW50KG9jdGV0LCAxMCksIDApO1xufVxuZnVuY3Rpb24gaXNJcEluQ0lEUihjaWRyLCBzZXJ2ZXJIb3N0KSB7XG4gICAgY29uc3QgaXAgPSBjaWRyLmlwO1xuICAgIGNvbnN0IG1hc2sgPSAtMSA8PCAoMzIgLSBjaWRyLnByZWZpeExlbmd0aCk7XG4gICAgY29uc3QgaG9zdElQID0gaXBUb0ludChzZXJ2ZXJIb3N0KTtcbiAgICByZXR1cm4gKGhvc3RJUCAmIG1hc2spID09PSAoaXAgJiBtYXNrKTtcbn1cbmZ1bmN0aW9uIGhvc3RNYXRjaGVzTm9Qcm94eUxpc3Qoc2VydmVySG9zdCkge1xuICAgIGZvciAoY29uc3QgaG9zdCBvZiBnZXROb1Byb3h5SG9zdExpc3QoKSkge1xuICAgICAgICBjb25zdCBwYXJzZWRDSURSID0gcGFyc2VDSURSKGhvc3QpO1xuICAgICAgICAvLyBob3N0IGlzIGEgQ0lEUiBhbmQgc2VydmVySG9zdCBpcyBhbiBJUCBhZGRyZXNzXG4gICAgICAgIGlmICgoMCwgbmV0XzEuaXNJUHY0KShzZXJ2ZXJIb3N0KSAmJiBwYXJzZWRDSURSICYmIGlzSXBJbkNJRFIocGFyc2VkQ0lEUiwgc2VydmVySG9zdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlcnZlckhvc3QuZW5kc1dpdGgoaG9zdCkpIHtcbiAgICAgICAgICAgIC8vIGhvc3QgaXMgYSBzaW5nbGUgSVAgb3IgYSBkb21haW4gbmFtZSBzdWZmaXhcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1hcFByb3h5TmFtZSh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgbm9Qcm94eVJlc3VsdCA9IHtcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgIGV4dHJhT3B0aW9uczoge30sXG4gICAgfTtcbiAgICBpZiAoKChfYSA9IG9wdGlvbnNbJ2dycGMuZW5hYmxlX2h0dHBfcHJveHknXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5vUHJveHlSZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0YXJnZXQuc2NoZW1lID09PSAndW5peCcpIHtcbiAgICAgICAgcmV0dXJuIG5vUHJveHlSZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHByb3h5SW5mbyA9IGdldFByb3h5SW5mbygpO1xuICAgIGlmICghcHJveHlJbmZvLmFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG5vUHJveHlSZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGhvc3RQb3J0ID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KSh0YXJnZXQucGF0aCk7XG4gICAgaWYgKCFob3N0UG9ydCkge1xuICAgICAgICByZXR1cm4gbm9Qcm94eVJlc3VsdDtcbiAgICB9XG4gICAgY29uc3Qgc2VydmVySG9zdCA9IGhvc3RQb3J0Lmhvc3Q7XG4gICAgaWYgKGhvc3RNYXRjaGVzTm9Qcm94eUxpc3Qoc2VydmVySG9zdCkpIHtcbiAgICAgICAgdHJhY2UoJ05vdCB1c2luZyBwcm94eSBmb3IgdGFyZ2V0IGluIG5vX3Byb3h5IGxpc3Q6ICcgKyAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0YXJnZXQpKTtcbiAgICAgICAgcmV0dXJuIG5vUHJveHlSZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGV4dHJhT3B0aW9ucyA9IHtcbiAgICAgICAgJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCc6ICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCksXG4gICAgfTtcbiAgICBpZiAocHJveHlJbmZvLmNyZWRzKSB7XG4gICAgICAgIGV4dHJhT3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfY3JlZHMnXSA9IHByb3h5SW5mby5jcmVkcztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICBzY2hlbWU6ICdkbnMnLFxuICAgICAgICAgICAgcGF0aDogcHJveHlJbmZvLmFkZHJlc3MsXG4gICAgICAgIH0sXG4gICAgICAgIGV4dHJhT3B0aW9uczogZXh0cmFPcHRpb25zLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRQcm94aWVkQ29ubmVjdGlvbihhZGRyZXNzLCBjaGFubmVsT3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoISgnZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0JyBpbiBjaGFubmVsT3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gICAgY29uc3QgcmVhbFRhcmdldCA9IGNoYW5uZWxPcHRpb25zWydncnBjLmh0dHBfY29ubmVjdF90YXJnZXQnXTtcbiAgICBjb25zdCBwYXJzZWRUYXJnZXQgPSAoMCwgdXJpX3BhcnNlcl8xLnBhcnNlVXJpKShyZWFsVGFyZ2V0KTtcbiAgICBpZiAocGFyc2VkVGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgfVxuICAgIGNvbnN0IHNwbGl0SG9zdFBvc3QgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHBhcnNlZFRhcmdldC5wYXRoKTtcbiAgICBpZiAoc3BsaXRIb3N0UG9zdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgICBjb25zdCBob3N0UG9ydCA9IGAke3NwbGl0SG9zdFBvc3QuaG9zdH06JHsoX2EgPSBzcGxpdEhvc3RQb3N0LnBvcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJlc29sdmVyX2Ruc18xLkRFRkFVTFRfUE9SVH1gO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogJ0NPTk5FQ1QnLFxuICAgICAgICBwYXRoOiBob3N0UG9ydCxcbiAgICB9O1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgIEhvc3Q6IGhvc3RQb3J0LFxuICAgIH07XG4gICAgLy8gQ29ubmVjdCB0byB0aGUgc3ViY2hhbm5lbCBhZGRyZXNzIGFzIGEgcHJveHlcbiAgICBpZiAoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLmlzVGNwU3ViY2hhbm5lbEFkZHJlc3MpKGFkZHJlc3MpKSB7XG4gICAgICAgIG9wdGlvbnMuaG9zdCA9IGFkZHJlc3MuaG9zdDtcbiAgICAgICAgb3B0aW9ucy5wb3J0ID0gYWRkcmVzcy5wb3J0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5zb2NrZXRQYXRoID0gYWRkcmVzcy5wYXRoO1xuICAgIH1cbiAgICBpZiAoJ2dycGMuaHR0cF9jb25uZWN0X2NyZWRzJyBpbiBjaGFubmVsT3B0aW9ucykge1xuICAgICAgICBoZWFkZXJzWydQcm94eS1BdXRob3JpemF0aW9uJ10gPVxuICAgICAgICAgICAgJ0Jhc2ljICcgK1xuICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKGNoYW5uZWxPcHRpb25zWydncnBjLmh0dHBfY29ubmVjdF9jcmVkcyddKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICAgIG9wdGlvbnMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgY29uc3QgcHJveHlBZGRyZXNzU3RyaW5nID0gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGFkZHJlc3MpO1xuICAgIHRyYWNlKCdVc2luZyBwcm94eSAnICsgcHJveHlBZGRyZXNzU3RyaW5nICsgJyB0byBjb25uZWN0IHRvICcgKyBvcHRpb25zLnBhdGgpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBodHRwLnJlcXVlc3Qob3B0aW9ucyk7XG4gICAgICAgIHJlcXVlc3Qub25jZSgnY29ubmVjdCcsIChyZXMsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ1N1Y2Nlc3NmdWxseSBjb25uZWN0ZWQgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGF0aCArXG4gICAgICAgICAgICAgICAgICAgICcgdGhyb3VnaCBwcm94eSAnICtcbiAgICAgICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgSFRUUCBjbGllbnQgbWF5IGhhdmUgYWxyZWFkeSByZWFkIGEgZmV3IGJ5dGVzIG9mIHRoZSBwcm94aWVkXG4gICAgICAgICAgICAgICAgLy8gY29ubmVjdGlvbi4gSWYgdGhhdCdzIHRoZSBjYXNlLCBwdXQgdGhlbSBiYWNrIGludG8gdGhlIHNvY2tldC5cbiAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy1ub2RlL2lzc3Vlcy8yNzQ0LlxuICAgICAgICAgICAgICAgIGlmIChoZWFkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnVuc2hpZnQoaGVhZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYWNlKCdTdWNjZXNzZnVsbHkgZXN0YWJsaXNoZWQgYSBwbGFpbnRleHQgY29ubmVjdGlvbiB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXRoICtcbiAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgICAgICBwcm94eUFkZHJlc3NTdHJpbmcpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoc29ja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICgwLCBsb2dnaW5nXzEubG9nKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsICdGYWlsZWQgdG8gY29ubmVjdCB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXRoICtcbiAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgICAgICBwcm94eUFkZHJlc3NTdHJpbmcgK1xuICAgICAgICAgICAgICAgICAgICAnIHdpdGggc3RhdHVzICcgK1xuICAgICAgICAgICAgICAgICAgICByZXMuc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0Lm9uY2UoJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAoMCwgbG9nZ2luZ18xLmxvZykoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCAnRmFpbGVkIHRvIGNvbm5lY3QgdG8gcHJveHkgJyArXG4gICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICAgICAnIHdpdGggZXJyb3IgJyArXG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0LmVuZCgpO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHR0cF9wcm94eS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwYXJzZUNJRFIiLCJtYXBQcm94eU5hbWUiLCJnZXRQcm94aWVkQ29ubmVjdGlvbiIsImxvZ2dpbmdfMSIsInJlcXVpcmUiLCJjb25zdGFudHNfMSIsIm5ldF8xIiwiaHR0cCIsImxvZ2dpbmciLCJzdWJjaGFubmVsX2FkZHJlc3NfMSIsInVyaV9wYXJzZXJfMSIsInVybF8xIiwicmVzb2x2ZXJfZG5zXzEiLCJUUkFDRVJfTkFNRSIsInRyYWNlIiwidGV4dCIsIkxvZ1ZlcmJvc2l0eSIsIkRFQlVHIiwiZ2V0UHJveHlJbmZvIiwicHJveHlFbnYiLCJlbnZWYXIiLCJwcm9jZXNzIiwiZW52IiwiZ3JwY19wcm94eSIsImh0dHBzX3Byb3h5IiwiaHR0cF9wcm94eSIsInByb3h5VXJsIiwiVVJMIiwiZSIsImxvZyIsIkVSUk9SIiwicHJvdG9jb2wiLCJ1c2VyQ3JlZCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJJTkZPIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiaG9zdG5hbWUiLCJwb3J0IiwicmVzdWx0IiwiYWRkcmVzcyIsImNyZWRzIiwiZ2V0Tm9Qcm94eUhvc3RMaXN0Iiwibm9Qcm94eVN0ciIsIm5vX2dycGNfcHJveHkiLCJub19wcm94eSIsInNwbGl0IiwiY2lkclN0cmluZyIsInNwbGl0UmFuZ2UiLCJsZW5ndGgiLCJwcmVmaXhMZW5ndGgiLCJwYXJzZUludCIsImlzSVB2NCIsIk51bWJlciIsImlzTmFOIiwiaXAiLCJpcFRvSW50IiwicmVkdWNlIiwiYWNjIiwib2N0ZXQiLCJpc0lwSW5DSURSIiwiY2lkciIsInNlcnZlckhvc3QiLCJtYXNrIiwiaG9zdElQIiwiaG9zdE1hdGNoZXNOb1Byb3h5TGlzdCIsImhvc3QiLCJwYXJzZWRDSURSIiwiZW5kc1dpdGgiLCJ0YXJnZXQiLCJvcHRpb25zIiwiX2EiLCJub1Byb3h5UmVzdWx0IiwiZXh0cmFPcHRpb25zIiwic2NoZW1lIiwicHJveHlJbmZvIiwiaG9zdFBvcnQiLCJzcGxpdEhvc3RQb3J0IiwicGF0aCIsInVyaVRvU3RyaW5nIiwiY2hhbm5lbE9wdGlvbnMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlYWxUYXJnZXQiLCJwYXJzZWRUYXJnZXQiLCJwYXJzZVVyaSIsInNwbGl0SG9zdFBvc3QiLCJERUZBVUxUX1BPUlQiLCJtZXRob2QiLCJoZWFkZXJzIiwiSG9zdCIsImlzVGNwU3ViY2hhbm5lbEFkZHJlc3MiLCJzb2NrZXRQYXRoIiwiQnVmZmVyIiwiZnJvbSIsInRvU3RyaW5nIiwicHJveHlBZGRyZXNzU3RyaW5nIiwic3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyIsInJlamVjdCIsInJlcXVlc3QiLCJvbmNlIiwicmVzIiwic29ja2V0IiwiaGVhZCIsInJlbW92ZUFsbExpc3RlbmVycyIsInN0YXR1c0NvZGUiLCJ1bnNoaWZ0IiwiZXJyIiwibWVzc2FnZSIsImVuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.experimental = exports.ServerInterceptingCall = exports.ResponderBuilder = exports.ServerListenerBuilder = exports.addAdminServicesToServer = exports.getChannelzHandlers = exports.getChannelzServiceDefinition = exports.InterceptorConfigurationError = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.StatusBuilder = exports.getClientChannel = exports.ServerCredentials = exports.Server = exports.setLogVerbosity = exports.setLogger = exports.load = exports.loadObject = exports.CallCredentials = exports.ChannelCredentials = exports.waitForClientReady = exports.closeClient = exports.Channel = exports.makeGenericClientConstructor = exports.makeClientConstructor = exports.loadPackageDefinition = exports.Client = exports.compressionAlgorithms = exports.propagate = exports.connectivityState = exports.status = exports.logVerbosity = exports.Metadata = exports.credentials = void 0;\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\nObject.defineProperty(exports, \"CallCredentials\", ({\n    enumerable: true,\n    get: function() {\n        return call_credentials_1.CallCredentials;\n    }\n}));\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\nObject.defineProperty(exports, \"Channel\", ({\n    enumerable: true,\n    get: function() {\n        return channel_1.ChannelImplementation;\n    }\n}));\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\nObject.defineProperty(exports, \"compressionAlgorithms\", ({\n    enumerable: true,\n    get: function() {\n        return compression_algorithms_1.CompressionAlgorithms;\n    }\n}));\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nObject.defineProperty(exports, \"connectivityState\", ({\n    enumerable: true,\n    get: function() {\n        return connectivity_state_1.ConnectivityState;\n    }\n}));\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nObject.defineProperty(exports, \"ChannelCredentials\", ({\n    enumerable: true,\n    get: function() {\n        return channel_credentials_1.ChannelCredentials;\n    }\n}));\nconst client_1 = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/client.js\");\nObject.defineProperty(exports, \"Client\", ({\n    enumerable: true,\n    get: function() {\n        return client_1.Client;\n    }\n}));\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nObject.defineProperty(exports, \"logVerbosity\", ({\n    enumerable: true,\n    get: function() {\n        return constants_1.LogVerbosity;\n    }\n}));\nObject.defineProperty(exports, \"status\", ({\n    enumerable: true,\n    get: function() {\n        return constants_1.Status;\n    }\n}));\nObject.defineProperty(exports, \"propagate\", ({\n    enumerable: true,\n    get: function() {\n        return constants_1.Propagate;\n    }\n}));\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\nObject.defineProperty(exports, \"loadPackageDefinition\", ({\n    enumerable: true,\n    get: function() {\n        return make_client_1.loadPackageDefinition;\n    }\n}));\nObject.defineProperty(exports, \"makeClientConstructor\", ({\n    enumerable: true,\n    get: function() {\n        return make_client_1.makeClientConstructor;\n    }\n}));\nObject.defineProperty(exports, \"makeGenericClientConstructor\", ({\n    enumerable: true,\n    get: function() {\n        return make_client_1.makeClientConstructor;\n    }\n}));\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nObject.defineProperty(exports, \"Metadata\", ({\n    enumerable: true,\n    get: function() {\n        return metadata_1.Metadata;\n    }\n}));\nconst server_1 = __webpack_require__(/*! ./server */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server.js\");\nObject.defineProperty(exports, \"Server\", ({\n    enumerable: true,\n    get: function() {\n        return server_1.Server;\n    }\n}));\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\nObject.defineProperty(exports, \"ServerCredentials\", ({\n    enumerable: true,\n    get: function() {\n        return server_credentials_1.ServerCredentials;\n    }\n}));\nconst status_builder_1 = __webpack_require__(/*! ./status-builder */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\");\nObject.defineProperty(exports, \"StatusBuilder\", ({\n    enumerable: true,\n    get: function() {\n        return status_builder_1.StatusBuilder;\n    }\n}));\n/**** Client Credentials ****/ // Using assign only copies enumerable properties, which is what we want\nexports.credentials = {\n    /**\n     * Combine a ChannelCredentials with any number of CallCredentials into a\n     * single ChannelCredentials object.\n     * @param channelCredentials The ChannelCredentials object.\n     * @param callCredentials Any number of CallCredentials objects.\n     * @return The resulting ChannelCredentials object.\n     */ combineChannelCredentials: (channelCredentials, ...callCredentials)=>{\n        return callCredentials.reduce((acc, other)=>acc.compose(other), channelCredentials);\n    },\n    /**\n     * Combine any number of CallCredentials into a single CallCredentials\n     * object.\n     * @param first The first CallCredentials object.\n     * @param additional Any number of additional CallCredentials objects.\n     * @return The resulting CallCredentials object.\n     */ combineCallCredentials: (first, ...additional)=>{\n        return additional.reduce((acc, other)=>acc.compose(other), first);\n    },\n    // from channel-credentials.ts\n    createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,\n    createSsl: channel_credentials_1.ChannelCredentials.createSsl,\n    createFromSecureContext: channel_credentials_1.ChannelCredentials.createFromSecureContext,\n    // from call-credentials.ts\n    createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,\n    createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,\n    createEmpty: call_credentials_1.CallCredentials.createEmpty\n};\n/**\n * Close a Client object.\n * @param client The client to close.\n */ const closeClient = (client)=>client.close();\nexports.closeClient = closeClient;\nconst waitForClientReady = (client, deadline, callback)=>client.waitForReady(deadline, callback);\nexports.waitForClientReady = waitForClientReady;\n/* eslint-enable @typescript-eslint/no-explicit-any */ /**** Unimplemented function stubs ****/ /* eslint-disable @typescript-eslint/no-explicit-any */ const loadObject = (value, options)=>{\n    throw new Error(\"Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead\");\n};\nexports.loadObject = loadObject;\nconst load = (filename, format, options)=>{\n    throw new Error(\"Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead\");\n};\nexports.load = load;\nconst setLogger = (logger)=>{\n    logging.setLogger(logger);\n};\nexports.setLogger = setLogger;\nconst setLogVerbosity = (verbosity)=>{\n    logging.setLoggerVerbosity(verbosity);\n};\nexports.setLogVerbosity = setLogVerbosity;\nconst getClientChannel = (client)=>{\n    return client_1.Client.prototype.getChannel.call(client);\n};\nexports.getClientChannel = getClientChannel;\nvar client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\nObject.defineProperty(exports, \"ListenerBuilder\", ({\n    enumerable: true,\n    get: function() {\n        return client_interceptors_1.ListenerBuilder;\n    }\n}));\nObject.defineProperty(exports, \"RequesterBuilder\", ({\n    enumerable: true,\n    get: function() {\n        return client_interceptors_1.RequesterBuilder;\n    }\n}));\nObject.defineProperty(exports, \"InterceptingCall\", ({\n    enumerable: true,\n    get: function() {\n        return client_interceptors_1.InterceptingCall;\n    }\n}));\nObject.defineProperty(exports, \"InterceptorConfigurationError\", ({\n    enumerable: true,\n    get: function() {\n        return client_interceptors_1.InterceptorConfigurationError;\n    }\n}));\nvar channelz_1 = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nObject.defineProperty(exports, \"getChannelzServiceDefinition\", ({\n    enumerable: true,\n    get: function() {\n        return channelz_1.getChannelzServiceDefinition;\n    }\n}));\nObject.defineProperty(exports, \"getChannelzHandlers\", ({\n    enumerable: true,\n    get: function() {\n        return channelz_1.getChannelzHandlers;\n    }\n}));\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nObject.defineProperty(exports, \"addAdminServicesToServer\", ({\n    enumerable: true,\n    get: function() {\n        return admin_1.addAdminServicesToServer;\n    }\n}));\nvar server_interceptors_1 = __webpack_require__(/*! ./server-interceptors */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server-interceptors.js\");\nObject.defineProperty(exports, \"ServerListenerBuilder\", ({\n    enumerable: true,\n    get: function() {\n        return server_interceptors_1.ServerListenerBuilder;\n    }\n}));\nObject.defineProperty(exports, \"ResponderBuilder\", ({\n    enumerable: true,\n    get: function() {\n        return server_interceptors_1.ResponderBuilder;\n    }\n}));\nObject.defineProperty(exports, \"ServerInterceptingCall\", ({\n    enumerable: true,\n    get: function() {\n        return server_interceptors_1.ServerInterceptingCall;\n    }\n}));\nconst experimental = __webpack_require__(/*! ./experimental */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\nexports.experimental = experimental;\nconst resolver_dns = __webpack_require__(/*! ./resolver-dns */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\");\nconst resolver_uds = __webpack_require__(/*! ./resolver-uds */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\");\nconst resolver_ip = __webpack_require__(/*! ./resolver-ip */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\");\nconst load_balancer_pick_first = __webpack_require__(/*! ./load-balancer-pick-first */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\");\nconst load_balancer_round_robin = __webpack_require__(/*! ./load-balancer-round-robin */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\");\nconst load_balancer_outlier_detection = __webpack_require__(/*! ./load-balancer-outlier-detection */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\");\nconst channelz = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\n(()=>{\n    resolver_dns.setup();\n    resolver_uds.setup();\n    resolver_ip.setup();\n    load_balancer_pick_first.setup();\n    load_balancer_round_robin.setup();\n    load_balancer_outlier_detection.setup();\n    channelz.setup();\n})(); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHQSw4QkFBOEIsR0FBR0Esd0JBQXdCLEdBQUdBLDZCQUE2QixHQUFHQSxnQ0FBZ0MsR0FBR0EsMkJBQTJCLEdBQUdBLG9DQUFvQyxHQUFHQSxxQ0FBcUMsR0FBR0Esd0JBQXdCLEdBQUdBLHdCQUF3QixHQUFHQSx1QkFBdUIsR0FBR0EscUJBQXFCLEdBQUdBLHdCQUF3QixHQUFHQSx5QkFBeUIsR0FBR0EsY0FBYyxHQUFHQSx1QkFBdUIsR0FBR0EsaUJBQWlCLEdBQUdBLFlBQVksR0FBR0Esa0JBQWtCLEdBQUdBLHVCQUF1QixHQUFHQSwwQkFBMEIsR0FBR0EsMEJBQTBCLEdBQUdBLG1CQUFtQixHQUFHQSxlQUFlLEdBQUdBLG9DQUFvQyxHQUFHQSw2QkFBNkIsR0FBR0EsNkJBQTZCLEdBQUdBLGNBQWMsR0FBR0EsNkJBQTZCLEdBQUdBLGlCQUFpQixHQUFHQSx5QkFBeUIsR0FBR0EsY0FBYyxHQUFHQSxvQkFBb0IsR0FBR0EsZ0JBQWdCLEdBQUdBLG1CQUFtQixHQUFHLEtBQUs7QUFDLzVCLE1BQU1xQyxxQkFBcUJDLG1CQUFPQSxDQUFDLDRGQUFvQjtBQUN2RHhDLG1EQUFrRDtJQUFFeUMsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsbUJBQW1CaEIsZUFBZTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3hJLE1BQU1vQixZQUFZSCxtQkFBT0EsQ0FBQywwRUFBVztBQUNyQ3hDLDJDQUEwQztJQUFFeUMsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0MsVUFBVUMscUJBQXFCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDN0gsTUFBTUMsMkJBQTJCTCxtQkFBT0EsQ0FBQyx3R0FBMEI7QUFDbkV4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REFBbUQ7SUFBRXlDLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9xRCxzQkFBc0J6RixnQkFBZ0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM3SU4sMERBQXlEO0lBQUV5QyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPcUQsc0JBQXNCMUYsc0JBQXNCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDekosTUFBTUQsZUFBZW9DLG1CQUFPQSxDQUFDLG9GQUFnQjtBQUM3Q3RDLG9CQUFvQixHQUFHRTtBQUN2QixNQUFNNEYsZUFBZXhELG1CQUFPQSxDQUFDLG9GQUFnQjtBQUM3QyxNQUFNeUQsZUFBZXpELG1CQUFPQSxDQUFDLG9GQUFnQjtBQUM3QyxNQUFNMEQsY0FBYzFELG1CQUFPQSxDQUFDLGtGQUFlO0FBQzNDLE1BQU0yRCwyQkFBMkIzRCxtQkFBT0EsQ0FBQyw0R0FBNEI7QUFDckUsTUFBTTRELDRCQUE0QjVELG1CQUFPQSxDQUFDLDhHQUE2QjtBQUN2RSxNQUFNNkQsa0NBQWtDN0QsbUJBQU9BLENBQUMsMEhBQW1DO0FBQ25GLE1BQU04RCxXQUFXOUQsbUJBQU9BLENBQUMsNEVBQVk7QUFDcEM7SUFDR3dELGFBQWFPLEtBQUs7SUFDbEJOLGFBQWFNLEtBQUs7SUFDbEJMLFlBQVlLLEtBQUs7SUFDakJKLHlCQUF5QkksS0FBSztJQUM5QkgsMEJBQTBCRyxLQUFLO0lBQy9CRixnQ0FBZ0NFLEtBQUs7SUFDckNELFNBQVNDLEtBQUs7QUFDbEIsTUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW5kZXguanM/Mzk1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHBlcmltZW50YWwgPSBleHBvcnRzLlNlcnZlckludGVyY2VwdGluZ0NhbGwgPSBleHBvcnRzLlJlc3BvbmRlckJ1aWxkZXIgPSBleHBvcnRzLlNlcnZlckxpc3RlbmVyQnVpbGRlciA9IGV4cG9ydHMuYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyID0gZXhwb3J0cy5nZXRDaGFubmVsekhhbmRsZXJzID0gZXhwb3J0cy5nZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uID0gZXhwb3J0cy5JbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvciA9IGV4cG9ydHMuSW50ZXJjZXB0aW5nQ2FsbCA9IGV4cG9ydHMuUmVxdWVzdGVyQnVpbGRlciA9IGV4cG9ydHMuTGlzdGVuZXJCdWlsZGVyID0gZXhwb3J0cy5TdGF0dXNCdWlsZGVyID0gZXhwb3J0cy5nZXRDbGllbnRDaGFubmVsID0gZXhwb3J0cy5TZXJ2ZXJDcmVkZW50aWFscyA9IGV4cG9ydHMuU2VydmVyID0gZXhwb3J0cy5zZXRMb2dWZXJib3NpdHkgPSBleHBvcnRzLnNldExvZ2dlciA9IGV4cG9ydHMubG9hZCA9IGV4cG9ydHMubG9hZE9iamVjdCA9IGV4cG9ydHMuQ2FsbENyZWRlbnRpYWxzID0gZXhwb3J0cy5DaGFubmVsQ3JlZGVudGlhbHMgPSBleHBvcnRzLndhaXRGb3JDbGllbnRSZWFkeSA9IGV4cG9ydHMuY2xvc2VDbGllbnQgPSBleHBvcnRzLkNoYW5uZWwgPSBleHBvcnRzLm1ha2VHZW5lcmljQ2xpZW50Q29uc3RydWN0b3IgPSBleHBvcnRzLm1ha2VDbGllbnRDb25zdHJ1Y3RvciA9IGV4cG9ydHMubG9hZFBhY2thZ2VEZWZpbml0aW9uID0gZXhwb3J0cy5DbGllbnQgPSBleHBvcnRzLmNvbXByZXNzaW9uQWxnb3JpdGhtcyA9IGV4cG9ydHMucHJvcGFnYXRlID0gZXhwb3J0cy5jb25uZWN0aXZpdHlTdGF0ZSA9IGV4cG9ydHMuc3RhdHVzID0gZXhwb3J0cy5sb2dWZXJib3NpdHkgPSBleHBvcnRzLk1ldGFkYXRhID0gZXhwb3J0cy5jcmVkZW50aWFscyA9IHZvaWQgMDtcbmNvbnN0IGNhbGxfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL2NhbGwtY3JlZGVudGlhbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYWxsQ3JlZGVudGlhbHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxfY3JlZGVudGlhbHNfMS5DYWxsQ3JlZGVudGlhbHM7IH0gfSk7XG5jb25zdCBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2hhbm5lbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hhbm5lbF8xLkNoYW5uZWxJbXBsZW1lbnRhdGlvbjsgfSB9KTtcbmNvbnN0IGNvbXByZXNzaW9uX2FsZ29yaXRobXNfMSA9IHJlcXVpcmUoXCIuL2NvbXByZXNzaW9uLWFsZ29yaXRobXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb21wcmVzc2lvbkFsZ29yaXRobXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXByZXNzaW9uX2FsZ29yaXRobXNfMS5Db21wcmVzc2lvbkFsZ29yaXRobXM7IH0gfSk7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbm5lY3Rpdml0eVN0YXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZTsgfSB9KTtcbmNvbnN0IGNoYW5uZWxfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWwtY3JlZGVudGlhbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDaGFubmVsQ3JlZGVudGlhbHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHM7IH0gfSk7XG5jb25zdCBjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xpZW50XzEuQ2xpZW50OyB9IH0pO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsb2dWZXJib3NpdHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0YXR1c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRzXzEuU3RhdHVzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicHJvcGFnYXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudHNfMS5Qcm9wYWdhdGU7IH0gfSk7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IG1ha2VfY2xpZW50XzEgPSByZXF1aXJlKFwiLi9tYWtlLWNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvYWRQYWNrYWdlRGVmaW5pdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFrZV9jbGllbnRfMS5sb2FkUGFja2FnZURlZmluaXRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlQ2xpZW50Q29uc3RydWN0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VfY2xpZW50XzEubWFrZUNsaWVudENvbnN0cnVjdG9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFrZUdlbmVyaWNDbGllbnRDb25zdHJ1Y3RvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFrZV9jbGllbnRfMS5tYWtlQ2xpZW50Q29uc3RydWN0b3I7IH0gfSk7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXRhZGF0YVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWV0YWRhdGFfMS5NZXRhZGF0YTsgfSB9KTtcbmNvbnN0IHNlcnZlcl8xID0gcmVxdWlyZShcIi4vc2VydmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VydmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJ2ZXJfMS5TZXJ2ZXI7IH0gfSk7XG5jb25zdCBzZXJ2ZXJfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL3NlcnZlci1jcmVkZW50aWFsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlcnZlckNyZWRlbnRpYWxzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJ2ZXJfY3JlZGVudGlhbHNfMS5TZXJ2ZXJDcmVkZW50aWFsczsgfSB9KTtcbmNvbnN0IHN0YXR1c19idWlsZGVyXzEgPSByZXF1aXJlKFwiLi9zdGF0dXMtYnVpbGRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0YXR1c0J1aWxkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0YXR1c19idWlsZGVyXzEuU3RhdHVzQnVpbGRlcjsgfSB9KTtcbi8qKioqIENsaWVudCBDcmVkZW50aWFscyAqKioqL1xuLy8gVXNpbmcgYXNzaWduIG9ubHkgY29waWVzIGVudW1lcmFibGUgcHJvcGVydGllcywgd2hpY2ggaXMgd2hhdCB3ZSB3YW50XG5leHBvcnRzLmNyZWRlbnRpYWxzID0ge1xuICAgIC8qKlxuICAgICAqIENvbWJpbmUgYSBDaGFubmVsQ3JlZGVudGlhbHMgd2l0aCBhbnkgbnVtYmVyIG9mIENhbGxDcmVkZW50aWFscyBpbnRvIGFcbiAgICAgKiBzaW5nbGUgQ2hhbm5lbENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gY2hhbm5lbENyZWRlbnRpYWxzIFRoZSBDaGFubmVsQ3JlZGVudGlhbHMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBjYWxsQ3JlZGVudGlhbHMgQW55IG51bWJlciBvZiBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXN1bHRpbmcgQ2hhbm5lbENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb21iaW5lQ2hhbm5lbENyZWRlbnRpYWxzOiAoY2hhbm5lbENyZWRlbnRpYWxzLCAuLi5jYWxsQ3JlZGVudGlhbHMpID0+IHtcbiAgICAgICAgcmV0dXJuIGNhbGxDcmVkZW50aWFscy5yZWR1Y2UoKGFjYywgb3RoZXIpID0+IGFjYy5jb21wb3NlKG90aGVyKSwgY2hhbm5lbENyZWRlbnRpYWxzKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENvbWJpbmUgYW55IG51bWJlciBvZiBDYWxsQ3JlZGVudGlhbHMgaW50byBhIHNpbmdsZSBDYWxsQ3JlZGVudGlhbHNcbiAgICAgKiBvYmplY3QuXG4gICAgICogQHBhcmFtIGZpcnN0IFRoZSBmaXJzdCBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsIEFueSBudW1iZXIgb2YgYWRkaXRpb25hbCBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXN1bHRpbmcgQ2FsbENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb21iaW5lQ2FsbENyZWRlbnRpYWxzOiAoZmlyc3QsIC4uLmFkZGl0aW9uYWwpID0+IHtcbiAgICAgICAgcmV0dXJuIGFkZGl0aW9uYWwucmVkdWNlKChhY2MsIG90aGVyKSA9PiBhY2MuY29tcG9zZShvdGhlciksIGZpcnN0KTtcbiAgICB9LFxuICAgIC8vIGZyb20gY2hhbm5lbC1jcmVkZW50aWFscy50c1xuICAgIGNyZWF0ZUluc2VjdXJlOiBjaGFubmVsX2NyZWRlbnRpYWxzXzEuQ2hhbm5lbENyZWRlbnRpYWxzLmNyZWF0ZUluc2VjdXJlLFxuICAgIGNyZWF0ZVNzbDogY2hhbm5lbF9jcmVkZW50aWFsc18xLkNoYW5uZWxDcmVkZW50aWFscy5jcmVhdGVTc2wsXG4gICAgY3JlYXRlRnJvbVNlY3VyZUNvbnRleHQ6IGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHMuY3JlYXRlRnJvbVNlY3VyZUNvbnRleHQsXG4gICAgLy8gZnJvbSBjYWxsLWNyZWRlbnRpYWxzLnRzXG4gICAgY3JlYXRlRnJvbU1ldGFkYXRhR2VuZXJhdG9yOiBjYWxsX2NyZWRlbnRpYWxzXzEuQ2FsbENyZWRlbnRpYWxzLmNyZWF0ZUZyb21NZXRhZGF0YUdlbmVyYXRvcixcbiAgICBjcmVhdGVGcm9tR29vZ2xlQ3JlZGVudGlhbDogY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVGcm9tR29vZ2xlQ3JlZGVudGlhbCxcbiAgICBjcmVhdGVFbXB0eTogY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVFbXB0eSxcbn07XG4vKipcbiAqIENsb3NlIGEgQ2xpZW50IG9iamVjdC5cbiAqIEBwYXJhbSBjbGllbnQgVGhlIGNsaWVudCB0byBjbG9zZS5cbiAqL1xuY29uc3QgY2xvc2VDbGllbnQgPSAoY2xpZW50KSA9PiBjbGllbnQuY2xvc2UoKTtcbmV4cG9ydHMuY2xvc2VDbGllbnQgPSBjbG9zZUNsaWVudDtcbmNvbnN0IHdhaXRGb3JDbGllbnRSZWFkeSA9IChjbGllbnQsIGRlYWRsaW5lLCBjYWxsYmFjaykgPT4gY2xpZW50LndhaXRGb3JSZWFkeShkZWFkbGluZSwgY2FsbGJhY2spO1xuZXhwb3J0cy53YWl0Rm9yQ2xpZW50UmVhZHkgPSB3YWl0Rm9yQ2xpZW50UmVhZHk7XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKioqIFVuaW1wbGVtZW50ZWQgZnVuY3Rpb24gc3R1YnMgKioqKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmNvbnN0IGxvYWRPYmplY3QgPSAodmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdmFpbGFibGUgaW4gdGhpcyBsaWJyYXJ5LiBVc2UgQGdycGMvcHJvdG8tbG9hZGVyIGFuZCBsb2FkUGFja2FnZURlZmluaXRpb24gaW5zdGVhZCcpO1xufTtcbmV4cG9ydHMubG9hZE9iamVjdCA9IGxvYWRPYmplY3Q7XG5jb25zdCBsb2FkID0gKGZpbGVuYW1lLCBmb3JtYXQsIG9wdGlvbnMpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdmFpbGFibGUgaW4gdGhpcyBsaWJyYXJ5LiBVc2UgQGdycGMvcHJvdG8tbG9hZGVyIGFuZCBsb2FkUGFja2FnZURlZmluaXRpb24gaW5zdGVhZCcpO1xufTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5jb25zdCBzZXRMb2dnZXIgPSAobG9nZ2VyKSA9PiB7XG4gICAgbG9nZ2luZy5zZXRMb2dnZXIobG9nZ2VyKTtcbn07XG5leHBvcnRzLnNldExvZ2dlciA9IHNldExvZ2dlcjtcbmNvbnN0IHNldExvZ1ZlcmJvc2l0eSA9ICh2ZXJib3NpdHkpID0+IHtcbiAgICBsb2dnaW5nLnNldExvZ2dlclZlcmJvc2l0eSh2ZXJib3NpdHkpO1xufTtcbmV4cG9ydHMuc2V0TG9nVmVyYm9zaXR5ID0gc2V0TG9nVmVyYm9zaXR5O1xuY29uc3QgZ2V0Q2xpZW50Q2hhbm5lbCA9IChjbGllbnQpID0+IHtcbiAgICByZXR1cm4gY2xpZW50XzEuQ2xpZW50LnByb3RvdHlwZS5nZXRDaGFubmVsLmNhbGwoY2xpZW50KTtcbn07XG5leHBvcnRzLmdldENsaWVudENoYW5uZWwgPSBnZXRDbGllbnRDaGFubmVsO1xudmFyIGNsaWVudF9pbnRlcmNlcHRvcnNfMSA9IHJlcXVpcmUoXCIuL2NsaWVudC1pbnRlcmNlcHRvcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMaXN0ZW5lckJ1aWxkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5MaXN0ZW5lckJ1aWxkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0ZXJCdWlsZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfaW50ZXJjZXB0b3JzXzEuUmVxdWVzdGVyQnVpbGRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludGVyY2VwdGluZ0NhbGxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5JbnRlcmNlcHRpbmdDYWxsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5JbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcjsgfSB9KTtcbnZhciBjaGFubmVsel8xID0gcmVxdWlyZShcIi4vY2hhbm5lbHpcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFubmVsel8xLmdldENoYW5uZWx6U2VydmljZURlZmluaXRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRDaGFubmVsekhhbmRsZXJzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFubmVsel8xLmdldENoYW5uZWx6SGFuZGxlcnM7IH0gfSk7XG52YXIgYWRtaW5fMSA9IHJlcXVpcmUoXCIuL2FkbWluXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhZG1pbl8xLmFkZEFkbWluU2VydmljZXNUb1NlcnZlcjsgfSB9KTtcbnZhciBzZXJ2ZXJfaW50ZXJjZXB0b3JzXzEgPSByZXF1aXJlKFwiLi9zZXJ2ZXItaW50ZXJjZXB0b3JzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VydmVyTGlzdGVuZXJCdWlsZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJ2ZXJfaW50ZXJjZXB0b3JzXzEuU2VydmVyTGlzdGVuZXJCdWlsZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVzcG9uZGVyQnVpbGRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmVyX2ludGVyY2VwdG9yc18xLlJlc3BvbmRlckJ1aWxkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXJ2ZXJJbnRlcmNlcHRpbmdDYWxsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJ2ZXJfaW50ZXJjZXB0b3JzXzEuU2VydmVySW50ZXJjZXB0aW5nQ2FsbDsgfSB9KTtcbmNvbnN0IGV4cGVyaW1lbnRhbCA9IHJlcXVpcmUoXCIuL2V4cGVyaW1lbnRhbFwiKTtcbmV4cG9ydHMuZXhwZXJpbWVudGFsID0gZXhwZXJpbWVudGFsO1xuY29uc3QgcmVzb2x2ZXJfZG5zID0gcmVxdWlyZShcIi4vcmVzb2x2ZXItZG5zXCIpO1xuY29uc3QgcmVzb2x2ZXJfdWRzID0gcmVxdWlyZShcIi4vcmVzb2x2ZXItdWRzXCIpO1xuY29uc3QgcmVzb2x2ZXJfaXAgPSByZXF1aXJlKFwiLi9yZXNvbHZlci1pcFwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfcGlja19maXJzdCA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItcGljay1maXJzdFwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfcm91bmRfcm9iaW4gPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLXJvdW5kLXJvYmluXCIpO1xuY29uc3QgbG9hZF9iYWxhbmNlcl9vdXRsaWVyX2RldGVjdGlvbiA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItb3V0bGllci1kZXRlY3Rpb25cIik7XG5jb25zdCBjaGFubmVseiA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xuKCgpID0+IHtcbiAgICByZXNvbHZlcl9kbnMuc2V0dXAoKTtcbiAgICByZXNvbHZlcl91ZHMuc2V0dXAoKTtcbiAgICByZXNvbHZlcl9pcC5zZXR1cCgpO1xuICAgIGxvYWRfYmFsYW5jZXJfcGlja19maXJzdC5zZXR1cCgpO1xuICAgIGxvYWRfYmFsYW5jZXJfcm91bmRfcm9iaW4uc2V0dXAoKTtcbiAgICBsb2FkX2JhbGFuY2VyX291dGxpZXJfZGV0ZWN0aW9uLnNldHVwKCk7XG4gICAgY2hhbm5lbHouc2V0dXAoKTtcbn0pKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJleHBlcmltZW50YWwiLCJTZXJ2ZXJJbnRlcmNlcHRpbmdDYWxsIiwiUmVzcG9uZGVyQnVpbGRlciIsIlNlcnZlckxpc3RlbmVyQnVpbGRlciIsImFkZEFkbWluU2VydmljZXNUb1NlcnZlciIsImdldENoYW5uZWx6SGFuZGxlcnMiLCJnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uIiwiSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IiLCJJbnRlcmNlcHRpbmdDYWxsIiwiUmVxdWVzdGVyQnVpbGRlciIsIkxpc3RlbmVyQnVpbGRlciIsIlN0YXR1c0J1aWxkZXIiLCJnZXRDbGllbnRDaGFubmVsIiwiU2VydmVyQ3JlZGVudGlhbHMiLCJTZXJ2ZXIiLCJzZXRMb2dWZXJib3NpdHkiLCJzZXRMb2dnZXIiLCJsb2FkIiwibG9hZE9iamVjdCIsIkNhbGxDcmVkZW50aWFscyIsIkNoYW5uZWxDcmVkZW50aWFscyIsIndhaXRGb3JDbGllbnRSZWFkeSIsImNsb3NlQ2xpZW50IiwiQ2hhbm5lbCIsIm1ha2VHZW5lcmljQ2xpZW50Q29uc3RydWN0b3IiLCJtYWtlQ2xpZW50Q29uc3RydWN0b3IiLCJsb2FkUGFja2FnZURlZmluaXRpb24iLCJDbGllbnQiLCJjb21wcmVzc2lvbkFsZ29yaXRobXMiLCJwcm9wYWdhdGUiLCJjb25uZWN0aXZpdHlTdGF0ZSIsInN0YXR1cyIsImxvZ1ZlcmJvc2l0eSIsIk1ldGFkYXRhIiwiY3JlZGVudGlhbHMiLCJjYWxsX2NyZWRlbnRpYWxzXzEiLCJyZXF1aXJlIiwiZW51bWVyYWJsZSIsImdldCIsImNoYW5uZWxfMSIsIkNoYW5uZWxJbXBsZW1lbnRhdGlvbiIsImNvbXByZXNzaW9uX2FsZ29yaXRobXNfMSIsIkNvbXByZXNzaW9uQWxnb3JpdGhtcyIsImNvbm5lY3Rpdml0eV9zdGF0ZV8xIiwiQ29ubmVjdGl2aXR5U3RhdGUiLCJjaGFubmVsX2NyZWRlbnRpYWxzXzEiLCJjbGllbnRfMSIsImNvbnN0YW50c18xIiwiTG9nVmVyYm9zaXR5IiwiU3RhdHVzIiwiUHJvcGFnYXRlIiwibG9nZ2luZyIsIm1ha2VfY2xpZW50XzEiLCJtZXRhZGF0YV8xIiwic2VydmVyXzEiLCJzZXJ2ZXJfY3JlZGVudGlhbHNfMSIsInN0YXR1c19idWlsZGVyXzEiLCJjb21iaW5lQ2hhbm5lbENyZWRlbnRpYWxzIiwiY2hhbm5lbENyZWRlbnRpYWxzIiwiY2FsbENyZWRlbnRpYWxzIiwicmVkdWNlIiwiYWNjIiwib3RoZXIiLCJjb21wb3NlIiwiY29tYmluZUNhbGxDcmVkZW50aWFscyIsImZpcnN0IiwiYWRkaXRpb25hbCIsImNyZWF0ZUluc2VjdXJlIiwiY3JlYXRlU3NsIiwiY3JlYXRlRnJvbVNlY3VyZUNvbnRleHQiLCJjcmVhdGVGcm9tTWV0YWRhdGFHZW5lcmF0b3IiLCJjcmVhdGVGcm9tR29vZ2xlQ3JlZGVudGlhbCIsImNyZWF0ZUVtcHR5IiwiY2xpZW50IiwiY2xvc2UiLCJkZWFkbGluZSIsImNhbGxiYWNrIiwid2FpdEZvclJlYWR5Iiwib3B0aW9ucyIsIkVycm9yIiwiZmlsZW5hbWUiLCJmb3JtYXQiLCJsb2dnZXIiLCJ2ZXJib3NpdHkiLCJzZXRMb2dnZXJWZXJib3NpdHkiLCJwcm90b3R5cGUiLCJnZXRDaGFubmVsIiwiY2FsbCIsImNsaWVudF9pbnRlcmNlcHRvcnNfMSIsImNoYW5uZWx6XzEiLCJhZG1pbl8xIiwic2VydmVyX2ludGVyY2VwdG9yc18xIiwicmVzb2x2ZXJfZG5zIiwicmVzb2x2ZXJfdWRzIiwicmVzb2x2ZXJfaXAiLCJsb2FkX2JhbGFuY2VyX3BpY2tfZmlyc3QiLCJsb2FkX2JhbGFuY2VyX3JvdW5kX3JvYmluIiwibG9hZF9iYWxhbmNlcl9vdXRsaWVyX2RldGVjdGlvbiIsImNoYW5uZWx6Iiwic2V0dXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js":
/*!******************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/internal-channel.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InternalChannel = exports.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX = void 0;\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nconst resolving_load_balancer_1 = __webpack_require__(/*! ./resolving-load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\");\nconst subchannel_pool_1 = __webpack_require__(/*! ./subchannel-pool */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\nconst compression_filter_1 = __webpack_require__(/*! ./compression-filter */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst load_balancing_call_1 = __webpack_require__(/*! ./load-balancing-call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js\");\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\nconst resolving_call_1 = __webpack_require__(/*! ./resolving-call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js\");\nconst call_number_1 = __webpack_require__(/*! ./call-number */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-number.js\");\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\nconst retrying_call_1 = __webpack_require__(/*! ./retrying-call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js\");\nconst subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */ const MAX_TIMEOUT_TIME = 2147483647;\nconst MIN_IDLE_TIMEOUT_MS = 1000;\n// 30 minutes\nconst DEFAULT_IDLE_TIMEOUT_MS = 30 * 60 * 1000;\nconst RETRY_THROTTLER_MAP = new Map();\nconst DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24; // 16 MB\nconst DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20; // 1 MB\nclass ChannelSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n    constructor(childSubchannel, channel){\n        super(childSubchannel);\n        this.channel = channel;\n        this.refCount = 0;\n        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime)=>{\n            channel.throttleKeepalive(keepaliveTime);\n        };\n    }\n    ref() {\n        if (this.refCount === 0) {\n            this.child.addConnectivityStateListener(this.subchannelStateListener);\n            this.channel.addWrappedSubchannel(this);\n        }\n        this.child.ref();\n        this.refCount += 1;\n    }\n    unref() {\n        this.child.unref();\n        this.refCount -= 1;\n        if (this.refCount <= 0) {\n            this.child.removeConnectivityStateListener(this.subchannelStateListener);\n            this.channel.removeWrappedSubchannel(this);\n        }\n    }\n}\nclass ShutdownPicker {\n    pick(pickArgs) {\n        return {\n            pickResultType: picker_1.PickResultType.DROP,\n            status: {\n                code: constants_1.Status.UNAVAILABLE,\n                details: \"Channel closed before call started\",\n                metadata: new metadata_1.Metadata()\n            },\n            subchannel: null,\n            onCallStarted: null,\n            onCallEnded: null\n        };\n    }\n}\nexports.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX = \"grpc.internal.no_subchannel\";\nclass ChannelzInfoTracker {\n    constructor(target){\n        this.target = target;\n        this.trace = new channelz_1.ChannelzTrace();\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.state = connectivity_state_1.ConnectivityState.IDLE;\n    }\n    getChannelzInfoCallback() {\n        return ()=>{\n            return {\n                target: this.target,\n                state: this.state,\n                trace: this.trace,\n                callTracker: this.callTracker,\n                children: this.childrenTracker.getChildLists()\n            };\n        };\n    }\n}\nclass InternalChannel {\n    constructor(target, credentials, options){\n        var _a, _b, _c, _d, _e, _f;\n        this.credentials = credentials;\n        this.options = options;\n        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n        this.currentPicker = new picker_1.UnavailablePicker();\n        /**\n         * Calls queued up to get a call config. Should only be populated before the\n         * first time the resolver returns a result, which includes the ConfigSelector.\n         */ this.configSelectionQueue = [];\n        this.pickQueue = [];\n        this.connectivityStateWatchers = [];\n        /**\n         * This timer does not do anything on its own. Its purpose is to hold the\n         * event loop open while there are any pending calls for the channel that\n         * have not yet been assigned to specific subchannels. In other words,\n         * the invariant is that callRefTimer is reffed if and only if pickQueue\n         * is non-empty. In addition, the timer is null while the state is IDLE or\n         * SHUTDOWN and there are no pending calls.\n         */ this.callRefTimer = null;\n        this.configSelector = null;\n        /**\n         * This is the error from the name resolver if it failed most recently. It\n         * is only used to end calls that start while there is no config selector\n         * and the name resolver is in backoff, so it should be nulled if\n         * configSelector becomes set or the channel state becomes anything other\n         * than TRANSIENT_FAILURE.\n         */ this.currentResolutionError = null;\n        this.wrappedSubchannels = new Set();\n        this.callCount = 0;\n        this.idleTimer = null;\n        // Channelz info\n        this.channelzEnabled = true;\n        /**\n         * Randomly generated ID to be passed to the config selector, for use by\n         * ring_hash in xDS. An integer distributed approximately uniformly between\n         * 0 and MAX_SAFE_INTEGER.\n         */ this.randomChannelId = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);\n        if (typeof target !== \"string\") {\n            throw new TypeError(\"Channel target must be a string\");\n        }\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n            throw new TypeError(\"Channel credentials must be a ChannelCredentials object\");\n        }\n        if (options) {\n            if (typeof options !== \"object\") {\n                throw new TypeError(\"Channel options must be an object\");\n            }\n        }\n        this.channelzInfoTracker = new ChannelzInfoTracker(target);\n        const originalTargetUri = (0, uri_parser_1.parseUri)(target);\n        if (originalTargetUri === null) {\n            throw new Error(`Could not parse target name \"${target}\"`);\n        }\n        /* This ensures that the target has a scheme that is registered with the\n         * resolver */ const defaultSchemeMapResult = (0, resolver_1.mapUriDefaultScheme)(originalTargetUri);\n        if (defaultSchemeMapResult === null) {\n            throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n        }\n        if (this.options[\"grpc.enable_channelz\"] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzRef = (0, channelz_1.registerChannelzChannel)(target, this.channelzInfoTracker.getChannelzInfoCallback(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzInfoTracker.trace.addTrace(\"CT_INFO\", \"Channel created\");\n        }\n        if (this.options[\"grpc.default_authority\"]) {\n            this.defaultAuthority = this.options[\"grpc.default_authority\"];\n        } else {\n            this.defaultAuthority = (0, resolver_1.getDefaultAuthority)(defaultSchemeMapResult);\n        }\n        const proxyMapResult = (0, http_proxy_1.mapProxyName)(defaultSchemeMapResult, options);\n        this.target = proxyMapResult.target;\n        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n         * the grpc.use_local_subchannel_pool channel option means. */ this.subchannelPool = (0, subchannel_pool_1.getSubchannelPool)(((_a = options[\"grpc.use_local_subchannel_pool\"]) !== null && _a !== void 0 ? _a : 0) === 0);\n        this.retryBufferTracker = new retrying_call_1.MessageBufferTracker((_b = options[\"grpc.retry_buffer_size\"]) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_BUFFER_SIZE_BYTES, (_c = options[\"grpc.per_rpc_retry_buffer_size\"]) !== null && _c !== void 0 ? _c : DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES);\n        this.keepaliveTime = (_d = options[\"grpc.keepalive_time_ms\"]) !== null && _d !== void 0 ? _d : -1;\n        this.idleTimeoutMs = Math.max((_e = options[\"grpc.client_idle_timeout_ms\"]) !== null && _e !== void 0 ? _e : DEFAULT_IDLE_TIMEOUT_MS, MIN_IDLE_TIMEOUT_MS);\n        const channelControlHelper = {\n            createSubchannel: (subchannelAddress, subchannelArgs)=>{\n                const finalSubchannelArgs = {};\n                for (const [key, value] of Object.entries(subchannelArgs)){\n                    if (!key.startsWith(exports.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX)) {\n                        finalSubchannelArgs[key] = value;\n                    }\n                }\n                const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, finalSubchannelArgs, this.credentials);\n                subchannel.throttleKeepalive(this.keepaliveTime);\n                if (this.channelzEnabled) {\n                    this.channelzInfoTracker.trace.addTrace(\"CT_INFO\", \"Created subchannel or used existing subchannel\", subchannel.getChannelzRef());\n                }\n                const wrappedSubchannel = new ChannelSubchannelWrapper(subchannel, this);\n                return wrappedSubchannel;\n            },\n            updateState: (connectivityState, picker)=>{\n                this.currentPicker = picker;\n                const queueCopy = this.pickQueue.slice();\n                this.pickQueue = [];\n                if (queueCopy.length > 0) {\n                    this.callRefTimerUnref();\n                }\n                for (const call of queueCopy){\n                    call.doPick();\n                }\n                this.updateState(connectivityState);\n            },\n            requestReresolution: ()=>{\n                // This should never be called.\n                throw new Error(\"Resolving load balancer should never call requestReresolution\");\n            },\n            addChannelzChild: (child)=>{\n                if (this.channelzEnabled) {\n                    this.channelzInfoTracker.childrenTracker.refChild(child);\n                }\n            },\n            removeChannelzChild: (child)=>{\n                if (this.channelzEnabled) {\n                    this.channelzInfoTracker.childrenTracker.unrefChild(child);\n                }\n            }\n        };\n        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, (serviceConfig, configSelector)=>{\n            var _a;\n            if (serviceConfig.retryThrottling) {\n                RETRY_THROTTLER_MAP.set(this.getTarget(), new retrying_call_1.RetryThrottler(serviceConfig.retryThrottling.maxTokens, serviceConfig.retryThrottling.tokenRatio, RETRY_THROTTLER_MAP.get(this.getTarget())));\n            } else {\n                RETRY_THROTTLER_MAP.delete(this.getTarget());\n            }\n            if (this.channelzEnabled) {\n                this.channelzInfoTracker.trace.addTrace(\"CT_INFO\", \"Address resolution succeeded\");\n            }\n            (_a = this.configSelector) === null || _a === void 0 ? void 0 : _a.unref();\n            this.configSelector = configSelector;\n            this.currentResolutionError = null;\n            /* We process the queue asynchronously to ensure that the corresponding\n             * load balancer update has completed. */ process.nextTick(()=>{\n                const localQueue = this.configSelectionQueue;\n                this.configSelectionQueue = [];\n                if (localQueue.length > 0) {\n                    this.callRefTimerUnref();\n                }\n                for (const call of localQueue){\n                    call.getConfig();\n                }\n            });\n        }, (status)=>{\n            if (this.channelzEnabled) {\n                this.channelzInfoTracker.trace.addTrace(\"CT_WARNING\", \"Address resolution failed with code \" + status.code + ' and details \"' + status.details + '\"');\n            }\n            if (this.configSelectionQueue.length > 0) {\n                this.trace(\"Name resolution failed with calls queued for config selection\");\n            }\n            if (this.configSelector === null) {\n                this.currentResolutionError = Object.assign(Object.assign({}, (0, control_plane_status_1.restrictControlPlaneStatusCode)(status.code, status.details)), {\n                    metadata: status.metadata\n                });\n            }\n            const localQueue = this.configSelectionQueue;\n            this.configSelectionQueue = [];\n            if (localQueue.length > 0) {\n                this.callRefTimerUnref();\n            }\n            for (const call of localQueue){\n                call.reportResolverError(status);\n            }\n        });\n        this.filterStackFactory = new filter_stack_1.FilterStackFactory([\n            new compression_filter_1.CompressionFilterFactory(this, this.options)\n        ]);\n        this.trace(\"Channel constructed with options \" + JSON.stringify(options, undefined, 2));\n        const error = new Error();\n        if ((0, logging_1.isTracerEnabled)(\"channel_stacktrace\")) {\n            (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, \"channel_stacktrace\", \"(\" + this.channelzRef.id + \") \" + \"Channel constructed \\n\" + ((_f = error.stack) === null || _f === void 0 ? void 0 : _f.substring(error.stack.indexOf(\"\\n\") + 1)));\n        }\n        this.lastActivityTimestamp = new Date();\n    }\n    trace(text, verbosityOverride) {\n        (0, logging_1.trace)(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, \"channel\", \"(\" + this.channelzRef.id + \") \" + (0, uri_parser_1.uriToString)(this.target) + \" \" + text);\n    }\n    callRefTimerRef() {\n        var _a, _b, _c, _d;\n        if (!this.callRefTimer) {\n            this.callRefTimer = setInterval(()=>{}, MAX_TIMEOUT_TIME);\n        }\n        // If the hasRef function does not exist, always run the code\n        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n            this.trace(\"callRefTimer.ref | configSelectionQueue.length=\" + this.configSelectionQueue.length + \" pickQueue.length=\" + this.pickQueue.length);\n            (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n        }\n    }\n    callRefTimerUnref() {\n        var _a, _b, _c;\n        // If the timer or the hasRef function does not exist, always run the code\n        if (!((_a = this.callRefTimer) === null || _a === void 0 ? void 0 : _a.hasRef) || this.callRefTimer.hasRef()) {\n            this.trace(\"callRefTimer.unref | configSelectionQueue.length=\" + this.configSelectionQueue.length + \" pickQueue.length=\" + this.pickQueue.length);\n            (_c = (_b = this.callRefTimer) === null || _b === void 0 ? void 0 : _b.unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n        }\n    }\n    removeConnectivityStateWatcher(watcherObject) {\n        const watcherIndex = this.connectivityStateWatchers.findIndex((value)=>value === watcherObject);\n        if (watcherIndex >= 0) {\n            this.connectivityStateWatchers.splice(watcherIndex, 1);\n        }\n    }\n    updateState(newState) {\n        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, \"connectivity_state\", \"(\" + this.channelzRef.id + \") \" + (0, uri_parser_1.uriToString)(this.target) + \" \" + connectivity_state_1.ConnectivityState[this.connectivityState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        if (this.channelzEnabled) {\n            this.channelzInfoTracker.trace.addTrace(\"CT_INFO\", \"Connectivity state change to \" + connectivity_state_1.ConnectivityState[newState]);\n        }\n        this.connectivityState = newState;\n        this.channelzInfoTracker.state = newState;\n        const watchersCopy = this.connectivityStateWatchers.slice();\n        for (const watcherObject of watchersCopy){\n            if (newState !== watcherObject.currentState) {\n                if (watcherObject.timer) {\n                    clearTimeout(watcherObject.timer);\n                }\n                this.removeConnectivityStateWatcher(watcherObject);\n                watcherObject.callback();\n            }\n        }\n        if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n            this.currentResolutionError = null;\n        }\n    }\n    throttleKeepalive(newKeepaliveTime) {\n        if (newKeepaliveTime > this.keepaliveTime) {\n            this.keepaliveTime = newKeepaliveTime;\n            for (const wrappedSubchannel of this.wrappedSubchannels){\n                wrappedSubchannel.throttleKeepalive(newKeepaliveTime);\n            }\n        }\n    }\n    addWrappedSubchannel(wrappedSubchannel) {\n        this.wrappedSubchannels.add(wrappedSubchannel);\n    }\n    removeWrappedSubchannel(wrappedSubchannel) {\n        this.wrappedSubchannels.delete(wrappedSubchannel);\n    }\n    doPick(metadata, extraPickInfo) {\n        return this.currentPicker.pick({\n            metadata: metadata,\n            extraPickInfo: extraPickInfo\n        });\n    }\n    queueCallForPick(call) {\n        this.pickQueue.push(call);\n        this.callRefTimerRef();\n    }\n    getConfig(method, metadata) {\n        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            this.resolvingLoadBalancer.exitIdle();\n        }\n        if (this.configSelector) {\n            return {\n                type: \"SUCCESS\",\n                config: this.configSelector.invoke(method, metadata, this.randomChannelId)\n            };\n        } else {\n            if (this.currentResolutionError) {\n                return {\n                    type: \"ERROR\",\n                    error: this.currentResolutionError\n                };\n            } else {\n                return {\n                    type: \"NONE\"\n                };\n            }\n        }\n    }\n    queueCallForConfig(call) {\n        this.configSelectionQueue.push(call);\n        this.callRefTimerRef();\n    }\n    enterIdle() {\n        this.resolvingLoadBalancer.destroy();\n        this.updateState(connectivity_state_1.ConnectivityState.IDLE);\n        this.currentPicker = new picker_1.QueuePicker(this.resolvingLoadBalancer);\n        if (this.idleTimer) {\n            clearTimeout(this.idleTimer);\n            this.idleTimer = null;\n        }\n        if (this.callRefTimer) {\n            clearInterval(this.callRefTimer);\n            this.callRefTimer = null;\n        }\n    }\n    startIdleTimeout(timeoutMs) {\n        var _a, _b;\n        this.idleTimer = setTimeout(()=>{\n            if (this.callCount > 0) {\n                /* If there is currently a call, the channel will not go idle for a\n                 * period of at least idleTimeoutMs, so check again after that time.\n                 */ this.startIdleTimeout(this.idleTimeoutMs);\n                return;\n            }\n            const now = new Date();\n            const timeSinceLastActivity = now.valueOf() - this.lastActivityTimestamp.valueOf();\n            if (timeSinceLastActivity >= this.idleTimeoutMs) {\n                this.trace(\"Idle timer triggered after \" + this.idleTimeoutMs + \"ms of inactivity\");\n                this.enterIdle();\n            } else {\n                /* Whenever the timer fires with the latest activity being too recent,\n                 * set the timer again for the time when the time since the last\n                 * activity is equal to the timeout. This should result in the timer\n                 * firing no more than once every idleTimeoutMs/2 on average. */ this.startIdleTimeout(this.idleTimeoutMs - timeSinceLastActivity);\n            }\n        }, timeoutMs);\n        (_b = (_a = this.idleTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    maybeStartIdleTimer() {\n        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN && !this.idleTimer) {\n            this.startIdleTimeout(this.idleTimeoutMs);\n        }\n    }\n    onCallStart() {\n        if (this.channelzEnabled) {\n            this.channelzInfoTracker.callTracker.addCallStarted();\n        }\n        this.callCount += 1;\n    }\n    onCallEnd(status) {\n        if (this.channelzEnabled) {\n            if (status.code === constants_1.Status.OK) {\n                this.channelzInfoTracker.callTracker.addCallSucceeded();\n            } else {\n                this.channelzInfoTracker.callTracker.addCallFailed();\n            }\n        }\n        this.callCount -= 1;\n        this.lastActivityTimestamp = new Date();\n        this.maybeStartIdleTimer();\n    }\n    createLoadBalancingCall(callConfig, method, host, credentials, deadline) {\n        const callNumber = (0, call_number_1.getNextCallNumber)();\n        this.trace(\"createLoadBalancingCall [\" + callNumber + '] method=\"' + method + '\"');\n        return new load_balancing_call_1.LoadBalancingCall(this, callConfig, method, host, credentials, deadline, callNumber);\n    }\n    createRetryingCall(callConfig, method, host, credentials, deadline) {\n        const callNumber = (0, call_number_1.getNextCallNumber)();\n        this.trace(\"createRetryingCall [\" + callNumber + '] method=\"' + method + '\"');\n        return new retrying_call_1.RetryingCall(this, callConfig, method, host, credentials, deadline, callNumber, this.retryBufferTracker, RETRY_THROTTLER_MAP.get(this.getTarget()));\n    }\n    createResolvingCall(method, deadline, host, parentCall, propagateFlags) {\n        const callNumber = (0, call_number_1.getNextCallNumber)();\n        this.trace(\"createResolvingCall [\" + callNumber + '] method=\"' + method + '\", deadline=' + (0, deadline_1.deadlineToString)(deadline));\n        const finalOptions = {\n            deadline: deadline,\n            flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n            host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n            parentCall: parentCall\n        };\n        const call = new resolving_call_1.ResolvingCall(this, method, finalOptions, this.filterStackFactory.clone(), callNumber);\n        this.onCallStart();\n        call.addStatusWatcher((status)=>{\n            this.onCallEnd(status);\n        });\n        return call;\n    }\n    close() {\n        var _a;\n        this.resolvingLoadBalancer.destroy();\n        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);\n        this.currentPicker = new ShutdownPicker();\n        for (const call of this.configSelectionQueue){\n            call.cancelWithStatus(constants_1.Status.UNAVAILABLE, \"Channel closed before call started\");\n        }\n        this.configSelectionQueue = [];\n        for (const call of this.pickQueue){\n            call.cancelWithStatus(constants_1.Status.UNAVAILABLE, \"Channel closed before call started\");\n        }\n        this.pickQueue = [];\n        if (this.callRefTimer) {\n            clearInterval(this.callRefTimer);\n        }\n        if (this.idleTimer) {\n            clearTimeout(this.idleTimer);\n        }\n        if (this.channelzEnabled) {\n            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n        }\n        this.subchannelPool.unrefUnusedSubchannels();\n        (_a = this.configSelector) === null || _a === void 0 ? void 0 : _a.unref();\n        this.configSelector = null;\n    }\n    getTarget() {\n        return (0, uri_parser_1.uriToString)(this.target);\n    }\n    getConnectivityState(tryToConnect) {\n        const connectivityState = this.connectivityState;\n        if (tryToConnect) {\n            this.resolvingLoadBalancer.exitIdle();\n            this.lastActivityTimestamp = new Date();\n            this.maybeStartIdleTimer();\n        }\n        return connectivityState;\n    }\n    watchConnectivityState(currentState, deadline, callback) {\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            throw new Error(\"Channel has been shut down\");\n        }\n        let timer = null;\n        if (deadline !== Infinity) {\n            const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n            const now = new Date();\n            if (deadline === -Infinity || deadlineDate <= now) {\n                process.nextTick(callback, new Error(\"Deadline passed without connectivity state change\"));\n                return;\n            }\n            timer = setTimeout(()=>{\n                this.removeConnectivityStateWatcher(watcherObject);\n                callback(new Error(\"Deadline passed without connectivity state change\"));\n            }, deadlineDate.getTime() - now.getTime());\n        }\n        const watcherObject = {\n            currentState,\n            callback,\n            timer\n        };\n        this.connectivityStateWatchers.push(watcherObject);\n    }\n    /**\n     * Get the channelz reference object for this channel. The returned value is\n     * garbage if channelz is disabled for this channel.\n     * @returns\n     */ getChannelzRef() {\n        return this.channelzRef;\n    }\n    createCall(method, deadline, host, parentCall, propagateFlags) {\n        if (typeof method !== \"string\") {\n            throw new TypeError(\"Channel#createCall: method must be a string\");\n        }\n        if (!(typeof deadline === \"number\" || deadline instanceof Date)) {\n            throw new TypeError(\"Channel#createCall: deadline must be a number or Date\");\n        }\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            throw new Error(\"Channel has been shut down\");\n        }\n        return this.createResolvingCall(method, deadline, host, parentCall, propagateFlags);\n    }\n    getOptions() {\n        return this.options;\n    }\n}\nexports.InternalChannel = InternalChannel; //# sourceMappingURL=internal-channel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW50ZXJuYWwtY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUJBQXVCLEdBQUdBLDBDQUEwQyxHQUFHLEtBQUs7QUFDNUUsTUFBTUksd0JBQXdCQyxtQkFBT0EsQ0FBQyxrR0FBdUI7QUFDN0QsTUFBTUMsNEJBQTRCRCxtQkFBT0EsQ0FBQywwR0FBMkI7QUFDckUsTUFBTUUsb0JBQW9CRixtQkFBT0EsQ0FBQywwRkFBbUI7QUFDckQsTUFBTUcsV0FBV0gsbUJBQU9BLENBQUMsd0VBQVU7QUFDbkMsTUFBTUksYUFBYUosbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUssY0FBY0wsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTU0saUJBQWlCTixtQkFBT0EsQ0FBQyxvRkFBZ0I7QUFDL0MsTUFBTU8sdUJBQXVCUCxtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTVEsYUFBYVIsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTVMsWUFBWVQsbUJBQU9BLENBQUMsMEVBQVc7QUFDckMsTUFBTVUsZUFBZVYsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTVcsZUFBZVgsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTVksdUJBQXVCWixtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTWEsYUFBYWIsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTWMsd0JBQXdCZCxtQkFBT0EsQ0FBQyxrR0FBdUI7QUFDN0QsTUFBTWUsYUFBYWYsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTWdCLG1CQUFtQmhCLG1CQUFPQSxDQUFDLHdGQUFrQjtBQUNuRCxNQUFNaUIsZ0JBQWdCakIsbUJBQU9BLENBQUMsa0ZBQWU7QUFDN0MsTUFBTWtCLHlCQUF5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QUVELElBQUksRUFBRVEsVUFBVSxFQUFFQyxjQUFjLEVBQUU7UUFDM0QsSUFBSSxPQUFPbkMsV0FBVyxVQUFVO1lBQzVCLE1BQU0sSUFBSXRHLFVBQVU7UUFDeEI7UUFDQSxJQUFJLENBQUUsUUFBT2lJLGFBQWEsWUFBWUEsb0JBQW9CbEQsSUFBRyxHQUFJO1lBQzdELE1BQU0sSUFBSS9FLFVBQVU7UUFDeEI7UUFDQSxJQUFJLElBQUksQ0FBQ3BCLGlCQUFpQixLQUFLeEUscUJBQXFCMkQsaUJBQWlCLENBQUN3SSxRQUFRLEVBQUU7WUFDNUUsTUFBTSxJQUFJbEcsTUFBTTtRQUNwQjtRQUNBLE9BQU8sSUFBSSxDQUFDa0ksbUJBQW1CLENBQUNqQyxRQUFRMkIsVUFBVUQsTUFBTVEsWUFBWUM7SUFDeEU7SUFDQW9CLGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQ3hMLE9BQU87SUFDdkI7QUFDSjtBQUNBbEYsdUJBQXVCLEdBQUdFLGlCQUMxQiw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW50ZXJuYWwtY2hhbm5lbC5qcz8zNGQ3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkludGVybmFsQ2hhbm5lbCA9IGV4cG9ydHMuU1VCQ0hBTk5FTF9BUkdTX0VYQ0xVREVfS0VZX1BSRUZJWCA9IHZvaWQgMDtcbmNvbnN0IGNoYW5uZWxfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWwtY3JlZGVudGlhbHNcIik7XG5jb25zdCByZXNvbHZpbmdfbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2aW5nLWxvYWQtYmFsYW5jZXJcIik7XG5jb25zdCBzdWJjaGFubmVsX3Bvb2xfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtcG9vbFwiKTtcbmNvbnN0IHBpY2tlcl8xID0gcmVxdWlyZShcIi4vcGlja2VyXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBmaWx0ZXJfc3RhY2tfMSA9IHJlcXVpcmUoXCIuL2ZpbHRlci1zdGFja1wiKTtcbmNvbnN0IGNvbXByZXNzaW9uX2ZpbHRlcl8xID0gcmVxdWlyZShcIi4vY29tcHJlc3Npb24tZmlsdGVyXCIpO1xuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xuY29uc3QgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGh0dHBfcHJveHlfMSA9IHJlcXVpcmUoXCIuL2h0dHBfcHJveHlcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBjaGFubmVsel8xID0gcmVxdWlyZShcIi4vY2hhbm5lbHpcIik7XG5jb25zdCBsb2FkX2JhbGFuY2luZ19jYWxsXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2luZy1jYWxsXCIpO1xuY29uc3QgZGVhZGxpbmVfMSA9IHJlcXVpcmUoXCIuL2RlYWRsaW5lXCIpO1xuY29uc3QgcmVzb2x2aW5nX2NhbGxfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmluZy1jYWxsXCIpO1xuY29uc3QgY2FsbF9udW1iZXJfMSA9IHJlcXVpcmUoXCIuL2NhbGwtbnVtYmVyXCIpO1xuY29uc3QgY29udHJvbF9wbGFuZV9zdGF0dXNfMSA9IHJlcXVpcmUoXCIuL2NvbnRyb2wtcGxhbmUtc3RhdHVzXCIpO1xuY29uc3QgcmV0cnlpbmdfY2FsbF8xID0gcmVxdWlyZShcIi4vcmV0cnlpbmctY2FsbFwiKTtcbmNvbnN0IHN1YmNoYW5uZWxfaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWludGVyZmFjZVwiKTtcbi8qKlxuICogU2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdGltZXJzLmh0bWwjdGltZXJzX3NldGludGVydmFsX2NhbGxiYWNrX2RlbGF5X2FyZ3NcbiAqL1xuY29uc3QgTUFYX1RJTUVPVVRfVElNRSA9IDIxNDc0ODM2NDc7XG5jb25zdCBNSU5fSURMRV9USU1FT1VUX01TID0gMTAwMDtcbi8vIDMwIG1pbnV0ZXNcbmNvbnN0IERFRkFVTFRfSURMRV9USU1FT1VUX01TID0gMzAgKiA2MCAqIDEwMDA7XG5jb25zdCBSRVRSWV9USFJPVFRMRVJfTUFQID0gbmV3IE1hcCgpO1xuY29uc3QgREVGQVVMVF9SRVRSWV9CVUZGRVJfU0laRV9CWVRFUyA9IDEgPDwgMjQ7IC8vIDE2IE1CXG5jb25zdCBERUZBVUxUX1BFUl9SUENfUkVUUllfQlVGRkVSX1NJWkVfQllURVMgPSAxIDw8IDIwOyAvLyAxIE1CXG5jbGFzcyBDaGFubmVsU3ViY2hhbm5lbFdyYXBwZXIgZXh0ZW5kcyBzdWJjaGFubmVsX2ludGVyZmFjZV8xLkJhc2VTdWJjaGFubmVsV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRTdWJjaGFubmVsLCBjaGFubmVsKSB7XG4gICAgICAgIHN1cGVyKGNoaWxkU3ViY2hhbm5lbCk7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMucmVmQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyID0gKHN1YmNoYW5uZWwsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlLCBrZWVwYWxpdmVUaW1lKSA9PiB7XG4gICAgICAgICAgICBjaGFubmVsLnRocm90dGxlS2VlcGFsaXZlKGtlZXBhbGl2ZVRpbWUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWYoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZkNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkLmFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwuYWRkV3JhcHBlZFN1YmNoYW5uZWwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGlsZC5yZWYoKTtcbiAgICAgICAgdGhpcy5yZWZDb3VudCArPSAxO1xuICAgIH1cbiAgICB1bnJlZigpIHtcbiAgICAgICAgdGhpcy5jaGlsZC51bnJlZigpO1xuICAgICAgICB0aGlzLnJlZkNvdW50IC09IDE7XG4gICAgICAgIGlmICh0aGlzLnJlZkNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGQucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5yZW1vdmVXcmFwcGVkU3ViY2hhbm5lbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNodXRkb3duUGlja2VyIHtcbiAgICBwaWNrKHBpY2tBcmdzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwaWNrUmVzdWx0VHlwZTogcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuRFJPUCxcbiAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiAnQ2hhbm5lbCBjbG9zZWQgYmVmb3JlIGNhbGwgc3RhcnRlZCcsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWJjaGFubmVsOiBudWxsLFxuICAgICAgICAgICAgb25DYWxsU3RhcnRlZDogbnVsbCxcbiAgICAgICAgICAgIG9uQ2FsbEVuZGVkOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5TVUJDSEFOTkVMX0FSR1NfRVhDTFVERV9LRVlfUFJFRklYID0gJ2dycGMuaW50ZXJuYWwubm9fc3ViY2hhbm5lbCc7XG5jbGFzcyBDaGFubmVsekluZm9UcmFja2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMudHJhY2UgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVselRyYWNlKCk7XG4gICAgICAgIHRoaXMuY2FsbFRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyKCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXIoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgfVxuICAgIGdldENoYW5uZWx6SW5mb0NhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMudGFyZ2V0LFxuICAgICAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgICAgIHRyYWNlOiB0aGlzLnRyYWNlLFxuICAgICAgICAgICAgICAgIGNhbGxUcmFja2VyOiB0aGlzLmNhbGxUcmFja2VyLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiB0aGlzLmNoaWxkcmVuVHJhY2tlci5nZXRDaGlsZExpc3RzKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxufVxuY2xhc3MgSW50ZXJuYWxDaGFubmVsIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGNyZWRlbnRpYWxzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICB0aGlzLmN1cnJlbnRQaWNrZXIgPSBuZXcgcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxzIHF1ZXVlZCB1cCB0byBnZXQgYSBjYWxsIGNvbmZpZy4gU2hvdWxkIG9ubHkgYmUgcG9wdWxhdGVkIGJlZm9yZSB0aGVcbiAgICAgICAgICogZmlyc3QgdGltZSB0aGUgcmVzb2x2ZXIgcmV0dXJucyBhIHJlc3VsdCwgd2hpY2ggaW5jbHVkZXMgdGhlIENvbmZpZ1NlbGVjdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLnBpY2tRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgdGltZXIgZG9lcyBub3QgZG8gYW55dGhpbmcgb24gaXRzIG93bi4gSXRzIHB1cnBvc2UgaXMgdG8gaG9sZCB0aGVcbiAgICAgICAgICogZXZlbnQgbG9vcCBvcGVuIHdoaWxlIHRoZXJlIGFyZSBhbnkgcGVuZGluZyBjYWxscyBmb3IgdGhlIGNoYW5uZWwgdGhhdFxuICAgICAgICAgKiBoYXZlIG5vdCB5ZXQgYmVlbiBhc3NpZ25lZCB0byBzcGVjaWZpYyBzdWJjaGFubmVscy4gSW4gb3RoZXIgd29yZHMsXG4gICAgICAgICAqIHRoZSBpbnZhcmlhbnQgaXMgdGhhdCBjYWxsUmVmVGltZXIgaXMgcmVmZmVkIGlmIGFuZCBvbmx5IGlmIHBpY2tRdWV1ZVxuICAgICAgICAgKiBpcyBub24tZW1wdHkuIEluIGFkZGl0aW9uLCB0aGUgdGltZXIgaXMgbnVsbCB3aGlsZSB0aGUgc3RhdGUgaXMgSURMRSBvclxuICAgICAgICAgKiBTSFVURE9XTiBhbmQgdGhlcmUgYXJlIG5vIHBlbmRpbmcgY2FsbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbGxSZWZUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuY29uZmlnU2VsZWN0b3IgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyB0aGUgZXJyb3IgZnJvbSB0aGUgbmFtZSByZXNvbHZlciBpZiBpdCBmYWlsZWQgbW9zdCByZWNlbnRseS4gSXRcbiAgICAgICAgICogaXMgb25seSB1c2VkIHRvIGVuZCBjYWxscyB0aGF0IHN0YXJ0IHdoaWxlIHRoZXJlIGlzIG5vIGNvbmZpZyBzZWxlY3RvclxuICAgICAgICAgKiBhbmQgdGhlIG5hbWUgcmVzb2x2ZXIgaXMgaW4gYmFja29mZiwgc28gaXQgc2hvdWxkIGJlIG51bGxlZCBpZlxuICAgICAgICAgKiBjb25maWdTZWxlY3RvciBiZWNvbWVzIHNldCBvciB0aGUgY2hhbm5lbCBzdGF0ZSBiZWNvbWVzIGFueXRoaW5nIG90aGVyXG4gICAgICAgICAqIHRoYW4gVFJBTlNJRU5UX0ZBSUxVUkUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uRXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLndyYXBwZWRTdWJjaGFubmVscyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5jYWxsQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmlkbGVUaW1lciA9IG51bGw7XG4gICAgICAgIC8vIENoYW5uZWx6IGluZm9cbiAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmFuZG9tbHkgZ2VuZXJhdGVkIElEIHRvIGJlIHBhc3NlZCB0byB0aGUgY29uZmlnIHNlbGVjdG9yLCBmb3IgdXNlIGJ5XG4gICAgICAgICAqIHJpbmdfaGFzaCBpbiB4RFMuIEFuIGludGVnZXIgZGlzdHJpYnV0ZWQgYXBwcm94aW1hdGVseSB1bmlmb3JtbHkgYmV0d2VlblxuICAgICAgICAgKiAwIGFuZCBNQVhfU0FGRV9JTlRFR0VSLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYW5kb21DaGFubmVsSWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCB0YXJnZXQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGNyZWRlbnRpYWxzIGluc3RhbmNlb2YgY2hhbm5lbF9jcmVkZW50aWFsc18xLkNoYW5uZWxDcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwgY3JlZGVudGlhbHMgbXVzdCBiZSBhIENoYW5uZWxDcmVkZW50aWFscyBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwgb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbm5lbHpJbmZvVHJhY2tlciA9IG5ldyBDaGFubmVsekluZm9UcmFja2VyKHRhcmdldCk7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsVGFyZ2V0VXJpID0gKDAsIHVyaV9wYXJzZXJfMS5wYXJzZVVyaSkodGFyZ2V0KTtcbiAgICAgICAgaWYgKG9yaWdpbmFsVGFyZ2V0VXJpID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSB0YXJnZXQgbmFtZSBcIiR7dGFyZ2V0fVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHRhcmdldCBoYXMgYSBzY2hlbWUgdGhhdCBpcyByZWdpc3RlcmVkIHdpdGggdGhlXG4gICAgICAgICAqIHJlc29sdmVyICovXG4gICAgICAgIGNvbnN0IGRlZmF1bHRTY2hlbWVNYXBSZXN1bHQgPSAoMCwgcmVzb2x2ZXJfMS5tYXBVcmlEZWZhdWx0U2NoZW1lKShvcmlnaW5hbFRhcmdldFVyaSk7XG4gICAgICAgIGlmIChkZWZhdWx0U2NoZW1lTWFwUmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgZGVmYXVsdCBzY2hlbWUgZm9yIHRhcmdldCBuYW1lIFwiJHt0YXJnZXR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zWydncnBjLmVuYWJsZV9jaGFubmVseiddID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbm5lbHpSZWYgPSAoMCwgY2hhbm5lbHpfMS5yZWdpc3RlckNoYW5uZWx6Q2hhbm5lbCkodGFyZ2V0LCB0aGlzLmNoYW5uZWx6SW5mb1RyYWNrZXIuZ2V0Q2hhbm5lbHpJbmZvQ2FsbGJhY2soKSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpJbmZvVHJhY2tlci50cmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDaGFubmVsIGNyZWF0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zWydncnBjLmRlZmF1bHRfYXV0aG9yaXR5J10pIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdEF1dGhvcml0eSA9IHRoaXMub3B0aW9uc1snZ3JwYy5kZWZhdWx0X2F1dGhvcml0eSddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0QXV0aG9yaXR5ID0gKDAsIHJlc29sdmVyXzEuZ2V0RGVmYXVsdEF1dGhvcml0eSkoZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJveHlNYXBSZXN1bHQgPSAoMCwgaHR0cF9wcm94eV8xLm1hcFByb3h5TmFtZSkoZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gcHJveHlNYXBSZXN1bHQudGFyZ2V0O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIHByb3h5TWFwUmVzdWx0LmV4dHJhT3B0aW9ucyk7XG4gICAgICAgIC8qIFRoZSBnbG9iYWwgYm9vbGVhbiBwYXJhbWV0ZXIgdG8gZ2V0U3ViY2hhbm5lbFBvb2wgaGFzIHRoZSBpbnZlcnNlIG1lYW5pbmcgdG8gd2hhdFxuICAgICAgICAgKiB0aGUgZ3JwYy51c2VfbG9jYWxfc3ViY2hhbm5lbF9wb29sIGNoYW5uZWwgb3B0aW9uIG1lYW5zLiAqL1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxQb29sID0gKDAsIHN1YmNoYW5uZWxfcG9vbF8xLmdldFN1YmNoYW5uZWxQb29sKSgoKF9hID0gb3B0aW9uc1snZ3JwYy51c2VfbG9jYWxfc3ViY2hhbm5lbF9wb29sJ10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApID09PSAwKTtcbiAgICAgICAgdGhpcy5yZXRyeUJ1ZmZlclRyYWNrZXIgPSBuZXcgcmV0cnlpbmdfY2FsbF8xLk1lc3NhZ2VCdWZmZXJUcmFja2VyKChfYiA9IG9wdGlvbnNbJ2dycGMucmV0cnlfYnVmZmVyX3NpemUnXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogREVGQVVMVF9SRVRSWV9CVUZGRVJfU0laRV9CWVRFUywgKF9jID0gb3B0aW9uc1snZ3JwYy5wZXJfcnBjX3JldHJ5X2J1ZmZlcl9zaXplJ10pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IERFRkFVTFRfUEVSX1JQQ19SRVRSWV9CVUZGRVJfU0laRV9CWVRFUyk7XG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZSA9IChfZCA9IG9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnXSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogLTE7XG4gICAgICAgIHRoaXMuaWRsZVRpbWVvdXRNcyA9IE1hdGgubWF4KChfZSA9IG9wdGlvbnNbJ2dycGMuY2xpZW50X2lkbGVfdGltZW91dF9tcyddKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBERUZBVUxUX0lETEVfVElNRU9VVF9NUywgTUlOX0lETEVfVElNRU9VVF9NUyk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxDb250cm9sSGVscGVyID0ge1xuICAgICAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsU3ViY2hhbm5lbEFyZ3MgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzdWJjaGFubmVsQXJncykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXkuc3RhcnRzV2l0aChleHBvcnRzLlNVQkNIQU5ORUxfQVJHU19FWENMVURFX0tFWV9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFN1YmNoYW5uZWxBcmdzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsID0gdGhpcy5zdWJjaGFubmVsUG9vbC5nZXRPckNyZWF0ZVN1YmNoYW5uZWwodGhpcy50YXJnZXQsIHN1YmNoYW5uZWxBZGRyZXNzLCBmaW5hbFN1YmNoYW5uZWxBcmdzLCB0aGlzLmNyZWRlbnRpYWxzKTtcbiAgICAgICAgICAgICAgICBzdWJjaGFubmVsLnRocm90dGxlS2VlcGFsaXZlKHRoaXMua2VlcGFsaXZlVGltZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpJbmZvVHJhY2tlci50cmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDcmVhdGVkIHN1YmNoYW5uZWwgb3IgdXNlZCBleGlzdGluZyBzdWJjaGFubmVsJywgc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgd3JhcHBlZFN1YmNoYW5uZWwgPSBuZXcgQ2hhbm5lbFN1YmNoYW5uZWxXcmFwcGVyKHN1YmNoYW5uZWwsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkU3ViY2hhbm5lbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVTdGF0ZTogKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQaWNrZXIgPSBwaWNrZXI7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVldWVDb3B5ID0gdGhpcy5waWNrUXVldWUuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZUNvcHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclVucmVmKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiBxdWV1ZUNvcHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5kb1BpY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWVzdFJlcmVzb2x1dGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGJlIGNhbGxlZC5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc29sdmluZyBsb2FkIGJhbGFuY2VyIHNob3VsZCBuZXZlciBjYWxsIHJlcXVlc3RSZXJlc29sdXRpb24nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRDaGFubmVsekNoaWxkOiAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsekluZm9UcmFja2VyLmNoaWxkcmVuVHJhY2tlci5yZWZDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZUNoYW5uZWx6Q2hpbGQ6IChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6SW5mb1RyYWNrZXIuY2hpbGRyZW5UcmFja2VyLnVucmVmQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVzb2x2aW5nTG9hZEJhbGFuY2VyID0gbmV3IHJlc29sdmluZ19sb2FkX2JhbGFuY2VyXzEuUmVzb2x2aW5nTG9hZEJhbGFuY2VyKHRoaXMudGFyZ2V0LCBjaGFubmVsQ29udHJvbEhlbHBlciwgb3B0aW9ucywgKHNlcnZpY2VDb25maWcsIGNvbmZpZ1NlbGVjdG9yKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoc2VydmljZUNvbmZpZy5yZXRyeVRocm90dGxpbmcpIHtcbiAgICAgICAgICAgICAgICBSRVRSWV9USFJPVFRMRVJfTUFQLnNldCh0aGlzLmdldFRhcmdldCgpLCBuZXcgcmV0cnlpbmdfY2FsbF8xLlJldHJ5VGhyb3R0bGVyKHNlcnZpY2VDb25maWcucmV0cnlUaHJvdHRsaW5nLm1heFRva2Vucywgc2VydmljZUNvbmZpZy5yZXRyeVRocm90dGxpbmcudG9rZW5SYXRpbywgUkVUUllfVEhST1RUTEVSX01BUC5nZXQodGhpcy5nZXRUYXJnZXQoKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIFJFVFJZX1RIUk9UVExFUl9NQVAuZGVsZXRlKHRoaXMuZ2V0VGFyZ2V0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsekluZm9UcmFja2VyLnRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0FkZHJlc3MgcmVzb2x1dGlvbiBzdWNjZWVkZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYSA9IHRoaXMuY29uZmlnU2VsZWN0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bnJlZigpO1xuICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3RvciA9IGNvbmZpZ1NlbGVjdG9yO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIC8qIFdlIHByb2Nlc3MgdGhlIHF1ZXVlIGFzeW5jaHJvbm91c2x5IHRvIGVuc3VyZSB0aGF0IHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICAgICAgICAgKiBsb2FkIGJhbGFuY2VyIHVwZGF0ZSBoYXMgY29tcGxldGVkLiAqL1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxRdWV1ZSA9IHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsUmVmVGltZXJVbnJlZigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgbG9jYWxRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsLmdldENvbmZpZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBzdGF0dXMgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsekluZm9UcmFja2VyLnRyYWNlLmFkZFRyYWNlKCdDVF9XQVJOSU5HJywgJ0FkZHJlc3MgcmVzb2x1dGlvbiBmYWlsZWQgd2l0aCBjb2RlICcgK1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuY29kZSArXG4gICAgICAgICAgICAgICAgICAgICcgYW5kIGRldGFpbHMgXCInICtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRldGFpbHMgK1xuICAgICAgICAgICAgICAgICAgICAnXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdOYW1lIHJlc29sdXRpb24gZmFpbGVkIHdpdGggY2FsbHMgcXVldWVkIGZvciBjb25maWcgc2VsZWN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWdTZWxlY3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKDAsIGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEucmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlKShzdGF0dXMuY29kZSwgc3RhdHVzLmRldGFpbHMpKSwgeyBtZXRhZGF0YTogc3RhdHVzLm1ldGFkYXRhIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxRdWV1ZSA9IHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWU7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlID0gW107XG4gICAgICAgICAgICBpZiAobG9jYWxRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsUmVmVGltZXJVbnJlZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIGxvY2FsUXVldWUpIHtcbiAgICAgICAgICAgICAgICBjYWxsLnJlcG9ydFJlc29sdmVyRXJyb3Ioc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2tGYWN0b3J5ID0gbmV3IGZpbHRlcl9zdGFja18xLkZpbHRlclN0YWNrRmFjdG9yeShbXG4gICAgICAgICAgICBuZXcgY29tcHJlc3Npb25fZmlsdGVyXzEuQ29tcHJlc3Npb25GaWx0ZXJGYWN0b3J5KHRoaXMsIHRoaXMub3B0aW9ucyksXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLnRyYWNlKCdDaGFubmVsIGNvbnN0cnVjdGVkIHdpdGggb3B0aW9ucyAnICtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMsIHVuZGVmaW5lZCwgMikpO1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBpZiAoKDAsIGxvZ2dpbmdfMS5pc1RyYWNlckVuYWJsZWQpKCdjaGFubmVsX3N0YWNrdHJhY2UnKSkge1xuICAgICAgICAgICAgKDAsIGxvZ2dpbmdfMS50cmFjZSkoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAnY2hhbm5lbF9zdGFja3RyYWNlJywgJygnICtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmLmlkICtcbiAgICAgICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgICAgICAnQ2hhbm5lbCBjb25zdHJ1Y3RlZCBcXG4nICtcbiAgICAgICAgICAgICAgICAoKF9mID0gZXJyb3Iuc3RhY2spID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5zdWJzdHJpbmcoZXJyb3Iuc3RhY2suaW5kZXhPZignXFxuJykgKyAxKSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdEFjdGl2aXR5VGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgdHJhY2UodGV4dCwgdmVyYm9zaXR5T3ZlcnJpZGUpIHtcbiAgICAgICAgKDAsIGxvZ2dpbmdfMS50cmFjZSkodmVyYm9zaXR5T3ZlcnJpZGUgIT09IG51bGwgJiYgdmVyYm9zaXR5T3ZlcnJpZGUgIT09IHZvaWQgMCA/IHZlcmJvc2l0eU92ZXJyaWRlIDogY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAnY2hhbm5lbCcsICcoJyArIHRoaXMuY2hhbm5lbHpSZWYuaWQgKyAnKSAnICsgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpICsgJyAnICsgdGV4dCk7XG4gICAgfVxuICAgIGNhbGxSZWZUaW1lclJlZigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBpZiAoIXRoaXMuY2FsbFJlZlRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxSZWZUaW1lciA9IHNldEludGVydmFsKCgpID0+IHsgfSwgTUFYX1RJTUVPVVRfVElNRSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGhhc1JlZiBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdCwgYWx3YXlzIHJ1biB0aGUgY29kZVxuICAgICAgICBpZiAoISgoX2IgPSAoX2EgPSB0aGlzLmNhbGxSZWZUaW1lcikuaGFzUmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdjYWxsUmVmVGltZXIucmVmIHwgY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoPScgK1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAnIHBpY2tRdWV1ZS5sZW5ndGg9JyArXG4gICAgICAgICAgICAgICAgdGhpcy5waWNrUXVldWUubGVuZ3RoKTtcbiAgICAgICAgICAgIChfZCA9IChfYyA9IHRoaXMuY2FsbFJlZlRpbWVyKS5yZWYpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxsUmVmVGltZXJVbnJlZigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIC8vIElmIHRoZSB0aW1lciBvciB0aGUgaGFzUmVmIGZ1bmN0aW9uIGRvZXMgbm90IGV4aXN0LCBhbHdheXMgcnVuIHRoZSBjb2RlXG4gICAgICAgIGlmICghKChfYSA9IHRoaXMuY2FsbFJlZlRpbWVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFzUmVmKSB8fCB0aGlzLmNhbGxSZWZUaW1lci5oYXNSZWYoKSkge1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnY2FsbFJlZlRpbWVyLnVucmVmIHwgY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoPScgK1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAnIHBpY2tRdWV1ZS5sZW5ndGg9JyArXG4gICAgICAgICAgICAgICAgdGhpcy5waWNrUXVldWUubGVuZ3RoKTtcbiAgICAgICAgICAgIChfYyA9IChfYiA9IHRoaXMuY2FsbFJlZlRpbWVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudW5yZWYpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVDb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXIod2F0Y2hlck9iamVjdCkge1xuICAgICAgICBjb25zdCB3YXRjaGVySW5kZXggPSB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcnMuZmluZEluZGV4KHZhbHVlID0+IHZhbHVlID09PSB3YXRjaGVyT2JqZWN0KTtcbiAgICAgICAgaWYgKHdhdGNoZXJJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcnMuc3BsaWNlKHdhdGNoZXJJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlU3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgKDAsIGxvZ2dpbmdfMS50cmFjZSkoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAnY29ubmVjdGl2aXR5X3N0YXRlJywgJygnICtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xuICAgICAgICAgICAgJykgJyArXG4gICAgICAgICAgICAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCkgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3RoaXMuY29ubmVjdGl2aXR5U3RhdGVdICtcbiAgICAgICAgICAgICcgLT4gJyArXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpJbmZvVHJhY2tlci50cmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDb25uZWN0aXZpdHkgc3RhdGUgY2hhbmdlIHRvICcgKyBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgdGhpcy5jaGFubmVsekluZm9UcmFja2VyLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIGNvbnN0IHdhdGNoZXJzQ29weSA9IHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5zbGljZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IHdhdGNoZXJPYmplY3Qgb2Ygd2F0Y2hlcnNDb3B5KSB7XG4gICAgICAgICAgICBpZiAobmV3U3RhdGUgIT09IHdhdGNoZXJPYmplY3QuY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdhdGNoZXJPYmplY3QudGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHdhdGNoZXJPYmplY3QudGltZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcih3YXRjaGVyT2JqZWN0KTtcbiAgICAgICAgICAgICAgICB3YXRjaGVyT2JqZWN0LmNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1N0YXRlICE9PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdHRsZUtlZXBhbGl2ZShuZXdLZWVwYWxpdmVUaW1lKSB7XG4gICAgICAgIGlmIChuZXdLZWVwYWxpdmVUaW1lID4gdGhpcy5rZWVwYWxpdmVUaW1lKSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWUgPSBuZXdLZWVwYWxpdmVUaW1lO1xuICAgICAgICAgICAgZm9yIChjb25zdCB3cmFwcGVkU3ViY2hhbm5lbCBvZiB0aGlzLndyYXBwZWRTdWJjaGFubmVscykge1xuICAgICAgICAgICAgICAgIHdyYXBwZWRTdWJjaGFubmVsLnRocm90dGxlS2VlcGFsaXZlKG5ld0tlZXBhbGl2ZVRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFdyYXBwZWRTdWJjaGFubmVsKHdyYXBwZWRTdWJjaGFubmVsKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZFN1YmNoYW5uZWxzLmFkZCh3cmFwcGVkU3ViY2hhbm5lbCk7XG4gICAgfVxuICAgIHJlbW92ZVdyYXBwZWRTdWJjaGFubmVsKHdyYXBwZWRTdWJjaGFubmVsKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZFN1YmNoYW5uZWxzLmRlbGV0ZSh3cmFwcGVkU3ViY2hhbm5lbCk7XG4gICAgfVxuICAgIGRvUGljayhtZXRhZGF0YSwgZXh0cmFQaWNrSW5mbykge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50UGlja2VyLnBpY2soe1xuICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhLFxuICAgICAgICAgICAgZXh0cmFQaWNrSW5mbzogZXh0cmFQaWNrSW5mbyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHF1ZXVlQ2FsbEZvclBpY2soY2FsbCkge1xuICAgICAgICB0aGlzLnBpY2tRdWV1ZS5wdXNoKGNhbGwpO1xuICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclJlZigpO1xuICAgIH1cbiAgICBnZXRDb25maWcobWV0aG9kLCBtZXRhZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aXZpdHlTdGF0ZSAhPT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV04pIHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2aW5nTG9hZEJhbGFuY2VyLmV4aXRJZGxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1NVQ0NFU1MnLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWdTZWxlY3Rvci5pbnZva2UobWV0aG9kLCBtZXRhZGF0YSwgdGhpcy5yYW5kb21DaGFubmVsSWQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRSZXNvbHV0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRVJST1InLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogdGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTk9ORScsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZUNhbGxGb3JDb25maWcoY2FsbCkge1xuICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlLnB1c2goY2FsbCk7XG4gICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyUmVmKCk7XG4gICAgfVxuICAgIGVudGVySWRsZSgpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpO1xuICAgICAgICB0aGlzLmN1cnJlbnRQaWNrZXIgPSBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIpO1xuICAgICAgICBpZiAodGhpcy5pZGxlVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmlkbGVUaW1lcik7XG4gICAgICAgICAgICB0aGlzLmlkbGVUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FsbFJlZlRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY2FsbFJlZlRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydElkbGVUaW1lb3V0KHRpbWVvdXRNcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmlkbGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FsbENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIC8qIElmIHRoZXJlIGlzIGN1cnJlbnRseSBhIGNhbGwsIHRoZSBjaGFubmVsIHdpbGwgbm90IGdvIGlkbGUgZm9yIGFcbiAgICAgICAgICAgICAgICAgKiBwZXJpb2Qgb2YgYXQgbGVhc3QgaWRsZVRpbWVvdXRNcywgc28gY2hlY2sgYWdhaW4gYWZ0ZXIgdGhhdCB0aW1lLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRJZGxlVGltZW91dCh0aGlzLmlkbGVUaW1lb3V0TXMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBjb25zdCB0aW1lU2luY2VMYXN0QWN0aXZpdHkgPSBub3cudmFsdWVPZigpIC0gdGhpcy5sYXN0QWN0aXZpdHlUaW1lc3RhbXAudmFsdWVPZigpO1xuICAgICAgICAgICAgaWYgKHRpbWVTaW5jZUxhc3RBY3Rpdml0eSA+PSB0aGlzLmlkbGVUaW1lb3V0TXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdJZGxlIHRpbWVyIHRyaWdnZXJlZCBhZnRlciAnICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pZGxlVGltZW91dE1zICtcbiAgICAgICAgICAgICAgICAgICAgJ21zIG9mIGluYWN0aXZpdHknKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVudGVySWRsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogV2hlbmV2ZXIgdGhlIHRpbWVyIGZpcmVzIHdpdGggdGhlIGxhdGVzdCBhY3Rpdml0eSBiZWluZyB0b28gcmVjZW50LFxuICAgICAgICAgICAgICAgICAqIHNldCB0aGUgdGltZXIgYWdhaW4gZm9yIHRoZSB0aW1lIHdoZW4gdGhlIHRpbWUgc2luY2UgdGhlIGxhc3RcbiAgICAgICAgICAgICAgICAgKiBhY3Rpdml0eSBpcyBlcXVhbCB0byB0aGUgdGltZW91dC4gVGhpcyBzaG91bGQgcmVzdWx0IGluIHRoZSB0aW1lclxuICAgICAgICAgICAgICAgICAqIGZpcmluZyBubyBtb3JlIHRoYW4gb25jZSBldmVyeSBpZGxlVGltZW91dE1zLzIgb24gYXZlcmFnZS4gKi9cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0SWRsZVRpbWVvdXQodGhpcy5pZGxlVGltZW91dE1zIC0gdGltZVNpbmNlTGFzdEFjdGl2aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGltZW91dE1zKTtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5pZGxlVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgfVxuICAgIG1heWJlU3RhcnRJZGxlVGltZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpdml0eVN0YXRlICE9PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5TSFVURE9XTiAmJlxuICAgICAgICAgICAgIXRoaXMuaWRsZVRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0SWRsZVRpbWVvdXQodGhpcy5pZGxlVGltZW91dE1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkNhbGxTdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6SW5mb1RyYWNrZXIuY2FsbFRyYWNrZXIuYWRkQ2FsbFN0YXJ0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxDb3VudCArPSAxO1xuICAgIH1cbiAgICBvbkNhbGxFbmQoc3RhdHVzKSB7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6SW5mb1RyYWNrZXIuY2FsbFRyYWNrZXIuYWRkQ2FsbFN1Y2NlZWRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsekluZm9UcmFja2VyLmNhbGxUcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxDb3VudCAtPSAxO1xuICAgICAgICB0aGlzLmxhc3RBY3Rpdml0eVRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMubWF5YmVTdGFydElkbGVUaW1lcigpO1xuICAgIH1cbiAgICBjcmVhdGVMb2FkQmFsYW5jaW5nQ2FsbChjYWxsQ29uZmlnLCBtZXRob2QsIGhvc3QsIGNyZWRlbnRpYWxzLCBkZWFkbGluZSkge1xuICAgICAgICBjb25zdCBjYWxsTnVtYmVyID0gKDAsIGNhbGxfbnVtYmVyXzEuZ2V0TmV4dENhbGxOdW1iZXIpKCk7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NyZWF0ZUxvYWRCYWxhbmNpbmdDYWxsIFsnICsgY2FsbE51bWJlciArICddIG1ldGhvZD1cIicgKyBtZXRob2QgKyAnXCInKTtcbiAgICAgICAgcmV0dXJuIG5ldyBsb2FkX2JhbGFuY2luZ19jYWxsXzEuTG9hZEJhbGFuY2luZ0NhbGwodGhpcywgY2FsbENvbmZpZywgbWV0aG9kLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUsIGNhbGxOdW1iZXIpO1xuICAgIH1cbiAgICBjcmVhdGVSZXRyeWluZ0NhbGwoY2FsbENvbmZpZywgbWV0aG9kLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUpIHtcbiAgICAgICAgY29uc3QgY2FsbE51bWJlciA9ICgwLCBjYWxsX251bWJlcl8xLmdldE5leHRDYWxsTnVtYmVyKSgpO1xuICAgICAgICB0aGlzLnRyYWNlKCdjcmVhdGVSZXRyeWluZ0NhbGwgWycgKyBjYWxsTnVtYmVyICsgJ10gbWV0aG9kPVwiJyArIG1ldGhvZCArICdcIicpO1xuICAgICAgICByZXR1cm4gbmV3IHJldHJ5aW5nX2NhbGxfMS5SZXRyeWluZ0NhbGwodGhpcywgY2FsbENvbmZpZywgbWV0aG9kLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUsIGNhbGxOdW1iZXIsIHRoaXMucmV0cnlCdWZmZXJUcmFja2VyLCBSRVRSWV9USFJPVFRMRVJfTUFQLmdldCh0aGlzLmdldFRhcmdldCgpKSk7XG4gICAgfVxuICAgIGNyZWF0ZVJlc29sdmluZ0NhbGwobWV0aG9kLCBkZWFkbGluZSwgaG9zdCwgcGFyZW50Q2FsbCwgcHJvcGFnYXRlRmxhZ3MpIHtcbiAgICAgICAgY29uc3QgY2FsbE51bWJlciA9ICgwLCBjYWxsX251bWJlcl8xLmdldE5leHRDYWxsTnVtYmVyKSgpO1xuICAgICAgICB0aGlzLnRyYWNlKCdjcmVhdGVSZXNvbHZpbmdDYWxsIFsnICtcbiAgICAgICAgICAgIGNhbGxOdW1iZXIgK1xuICAgICAgICAgICAgJ10gbWV0aG9kPVwiJyArXG4gICAgICAgICAgICBtZXRob2QgK1xuICAgICAgICAgICAgJ1wiLCBkZWFkbGluZT0nICtcbiAgICAgICAgICAgICgwLCBkZWFkbGluZV8xLmRlYWRsaW5lVG9TdHJpbmcpKGRlYWRsaW5lKSk7XG4gICAgICAgIGNvbnN0IGZpbmFsT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGRlYWRsaW5lOiBkZWFkbGluZSxcbiAgICAgICAgICAgIGZsYWdzOiBwcm9wYWdhdGVGbGFncyAhPT0gbnVsbCAmJiBwcm9wYWdhdGVGbGFncyAhPT0gdm9pZCAwID8gcHJvcGFnYXRlRmxhZ3MgOiBjb25zdGFudHNfMS5Qcm9wYWdhdGUuREVGQVVMVFMsXG4gICAgICAgICAgICBob3N0OiBob3N0ICE9PSBudWxsICYmIGhvc3QgIT09IHZvaWQgMCA/IGhvc3QgOiB0aGlzLmRlZmF1bHRBdXRob3JpdHksXG4gICAgICAgICAgICBwYXJlbnRDYWxsOiBwYXJlbnRDYWxsLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYWxsID0gbmV3IHJlc29sdmluZ19jYWxsXzEuUmVzb2x2aW5nQ2FsbCh0aGlzLCBtZXRob2QsIGZpbmFsT3B0aW9ucywgdGhpcy5maWx0ZXJTdGFja0ZhY3RvcnkuY2xvbmUoKSwgY2FsbE51bWJlcik7XG4gICAgICAgIHRoaXMub25DYWxsU3RhcnQoKTtcbiAgICAgICAgY2FsbC5hZGRTdGF0dXNXYXRjaGVyKHN0YXR1cyA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uQ2FsbEVuZChzdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMucmVzb2x2aW5nTG9hZEJhbGFuY2VyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5TSFVURE9XTik7XG4gICAgICAgIHRoaXMuY3VycmVudFBpY2tlciA9IG5ldyBTaHV0ZG93blBpY2tlcigpO1xuICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZSkge1xuICAgICAgICAgICAgY2FsbC5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSwgJ0NoYW5uZWwgY2xvc2VkIGJlZm9yZSBjYWxsIHN0YXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlID0gW107XG4gICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiB0aGlzLnBpY2tRdWV1ZSkge1xuICAgICAgICAgICAgY2FsbC5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSwgJ0NoYW5uZWwgY2xvc2VkIGJlZm9yZSBjYWxsIHN0YXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBpY2tRdWV1ZSA9IFtdO1xuICAgICAgICBpZiAodGhpcy5jYWxsUmVmVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jYWxsUmVmVGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlkbGVUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaWRsZVRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikodGhpcy5jaGFubmVselJlZik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJjaGFubmVsUG9vbC51bnJlZlVudXNlZFN1YmNoYW5uZWxzKCk7XG4gICAgICAgIChfYSA9IHRoaXMuY29uZmlnU2VsZWN0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bnJlZigpO1xuICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdG9yID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpO1xuICAgIH1cbiAgICBnZXRDb25uZWN0aXZpdHlTdGF0ZSh0cnlUb0Nvbm5lY3QpIHtcbiAgICAgICAgY29uc3QgY29ubmVjdGl2aXR5U3RhdGUgPSB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlO1xuICAgICAgICBpZiAodHJ5VG9Db25uZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmluZ0xvYWRCYWxhbmNlci5leGl0SWRsZSgpO1xuICAgICAgICAgICAgdGhpcy5sYXN0QWN0aXZpdHlUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0SWRsZVRpbWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpdml0eVN0YXRlO1xuICAgIH1cbiAgICB3YXRjaENvbm5lY3Rpdml0eVN0YXRlKGN1cnJlbnRTdGF0ZSwgZGVhZGxpbmUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5TSFVURE9XTikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGFubmVsIGhhcyBiZWVuIHNodXQgZG93bicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgICAgIGlmIChkZWFkbGluZSAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlYWRsaW5lRGF0ZSA9IGRlYWRsaW5lIGluc3RhbmNlb2YgRGF0ZSA/IGRlYWRsaW5lIDogbmV3IERhdGUoZGVhZGxpbmUpO1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGlmIChkZWFkbGluZSA9PT0gLUluZmluaXR5IHx8IGRlYWRsaW5lRGF0ZSA8PSBub3cpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBuZXcgRXJyb3IoJ0RlYWRsaW5lIHBhc3NlZCB3aXRob3V0IGNvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2UnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcih3YXRjaGVyT2JqZWN0KTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0RlYWRsaW5lIHBhc3NlZCB3aXRob3V0IGNvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2UnKSk7XG4gICAgICAgICAgICB9LCBkZWFkbGluZURhdGUuZ2V0VGltZSgpIC0gbm93LmdldFRpbWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2F0Y2hlck9iamVjdCA9IHtcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSxcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgdGltZXIsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5wdXNoKHdhdGNoZXJPYmplY3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNoYW5uZWx6IHJlZmVyZW5jZSBvYmplY3QgZm9yIHRoaXMgY2hhbm5lbC4gVGhlIHJldHVybmVkIHZhbHVlIGlzXG4gICAgICogZ2FyYmFnZSBpZiBjaGFubmVseiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjaGFubmVsLlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZ2V0Q2hhbm5lbHpSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWx6UmVmO1xuICAgIH1cbiAgICBjcmVhdGVDYWxsKG1ldGhvZCwgZGVhZGxpbmUsIGhvc3QsIHBhcmVudENhbGwsIHByb3BhZ2F0ZUZsYWdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCNjcmVhdGVDYWxsOiBtZXRob2QgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHR5cGVvZiBkZWFkbGluZSA9PT0gJ251bWJlcicgfHwgZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCNjcmVhdGVDYWxsOiBkZWFkbGluZSBtdXN0IGJlIGEgbnVtYmVyIG9yIERhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV04pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hhbm5lbCBoYXMgYmVlbiBzaHV0IGRvd24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVSZXNvbHZpbmdDYWxsKG1ldGhvZCwgZGVhZGxpbmUsIGhvc3QsIHBhcmVudENhbGwsIHByb3BhZ2F0ZUZsYWdzKTtcbiAgICB9XG4gICAgZ2V0T3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkludGVybmFsQ2hhbm5lbCA9IEludGVybmFsQ2hhbm5lbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVybmFsLWNoYW5uZWwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSW50ZXJuYWxDaGFubmVsIiwiU1VCQ0hBTk5FTF9BUkdTX0VYQ0xVREVfS0VZX1BSRUZJWCIsImNoYW5uZWxfY3JlZGVudGlhbHNfMSIsInJlcXVpcmUiLCJyZXNvbHZpbmdfbG9hZF9iYWxhbmNlcl8xIiwic3ViY2hhbm5lbF9wb29sXzEiLCJwaWNrZXJfMSIsIm1ldGFkYXRhXzEiLCJjb25zdGFudHNfMSIsImZpbHRlcl9zdGFja18xIiwiY29tcHJlc3Npb25fZmlsdGVyXzEiLCJyZXNvbHZlcl8xIiwibG9nZ2luZ18xIiwiaHR0cF9wcm94eV8xIiwidXJpX3BhcnNlcl8xIiwiY29ubmVjdGl2aXR5X3N0YXRlXzEiLCJjaGFubmVsel8xIiwibG9hZF9iYWxhbmNpbmdfY2FsbF8xIiwiZGVhZGxpbmVfMSIsInJlc29sdmluZ19jYWxsXzEiLCJjYWxsX251bWJlcl8xIiwiY29udHJvbF9wbGFuZV9zdGF0dXNfMSIsInJldHJ5aW5nX2NhbGxfMSIsInN1YmNoYW5uZWxfaW50ZXJmYWNlXzEiLCJNQVhfVElNRU9VVF9USU1FIiwiTUlOX0lETEVfVElNRU9VVF9NUyIsIkRFRkFVTFRfSURMRV9USU1FT1VUX01TIiwiUkVUUllfVEhST1RUTEVSX01BUCIsIk1hcCIsIkRFRkFVTFRfUkVUUllfQlVGRkVSX1NJWkVfQllURVMiLCJERUZBVUxUX1BFUl9SUENfUkVUUllfQlVGRkVSX1NJWkVfQllURVMiLCJDaGFubmVsU3ViY2hhbm5lbFdyYXBwZXIiLCJCYXNlU3ViY2hhbm5lbFdyYXBwZXIiLCJjb25zdHJ1Y3RvciIsImNoaWxkU3ViY2hhbm5lbCIsImNoYW5uZWwiLCJyZWZDb3VudCIsInN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyIiwic3ViY2hhbm5lbCIsInByZXZpb3VzU3RhdGUiLCJuZXdTdGF0ZSIsImtlZXBhbGl2ZVRpbWUiLCJ0aHJvdHRsZUtlZXBhbGl2ZSIsInJlZiIsImNoaWxkIiwiYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lciIsImFkZFdyYXBwZWRTdWJjaGFubmVsIiwidW5yZWYiLCJyZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyIiwicmVtb3ZlV3JhcHBlZFN1YmNoYW5uZWwiLCJTaHV0ZG93blBpY2tlciIsInBpY2siLCJwaWNrQXJncyIsInBpY2tSZXN1bHRUeXBlIiwiUGlja1Jlc3VsdFR5cGUiLCJEUk9QIiwic3RhdHVzIiwiY29kZSIsIlN0YXR1cyIsIlVOQVZBSUxBQkxFIiwiZGV0YWlscyIsIm1ldGFkYXRhIiwiTWV0YWRhdGEiLCJvbkNhbGxTdGFydGVkIiwib25DYWxsRW5kZWQiLCJDaGFubmVsekluZm9UcmFja2VyIiwidGFyZ2V0IiwidHJhY2UiLCJDaGFubmVselRyYWNlIiwiY2FsbFRyYWNrZXIiLCJDaGFubmVsekNhbGxUcmFja2VyIiwiY2hpbGRyZW5UcmFja2VyIiwiQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXIiLCJzdGF0ZSIsIkNvbm5lY3Rpdml0eVN0YXRlIiwiSURMRSIsImdldENoYW5uZWx6SW5mb0NhbGxiYWNrIiwiY2hpbGRyZW4iLCJnZXRDaGlsZExpc3RzIiwiY3JlZGVudGlhbHMiLCJvcHRpb25zIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiY29ubmVjdGl2aXR5U3RhdGUiLCJjdXJyZW50UGlja2VyIiwiVW5hdmFpbGFibGVQaWNrZXIiLCJjb25maWdTZWxlY3Rpb25RdWV1ZSIsInBpY2tRdWV1ZSIsImNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcnMiLCJjYWxsUmVmVGltZXIiLCJjb25maWdTZWxlY3RvciIsImN1cnJlbnRSZXNvbHV0aW9uRXJyb3IiLCJ3cmFwcGVkU3ViY2hhbm5lbHMiLCJTZXQiLCJjYWxsQ291bnQiLCJpZGxlVGltZXIiLCJjaGFubmVsekVuYWJsZWQiLCJyYW5kb21DaGFubmVsSWQiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiVHlwZUVycm9yIiwiQ2hhbm5lbENyZWRlbnRpYWxzIiwiY2hhbm5lbHpJbmZvVHJhY2tlciIsIm9yaWdpbmFsVGFyZ2V0VXJpIiwicGFyc2VVcmkiLCJFcnJvciIsImRlZmF1bHRTY2hlbWVNYXBSZXN1bHQiLCJtYXBVcmlEZWZhdWx0U2NoZW1lIiwiY2hhbm5lbHpSZWYiLCJyZWdpc3RlckNoYW5uZWx6Q2hhbm5lbCIsImFkZFRyYWNlIiwiZGVmYXVsdEF1dGhvcml0eSIsImdldERlZmF1bHRBdXRob3JpdHkiLCJwcm94eU1hcFJlc3VsdCIsIm1hcFByb3h5TmFtZSIsImFzc2lnbiIsImV4dHJhT3B0aW9ucyIsInN1YmNoYW5uZWxQb29sIiwiZ2V0U3ViY2hhbm5lbFBvb2wiLCJyZXRyeUJ1ZmZlclRyYWNrZXIiLCJNZXNzYWdlQnVmZmVyVHJhY2tlciIsImlkbGVUaW1lb3V0TXMiLCJtYXgiLCJjaGFubmVsQ29udHJvbEhlbHBlciIsImNyZWF0ZVN1YmNoYW5uZWwiLCJzdWJjaGFubmVsQWRkcmVzcyIsInN1YmNoYW5uZWxBcmdzIiwiZmluYWxTdWJjaGFubmVsQXJncyIsImtleSIsImVudHJpZXMiLCJzdGFydHNXaXRoIiwiZ2V0T3JDcmVhdGVTdWJjaGFubmVsIiwiZ2V0Q2hhbm5lbHpSZWYiLCJ3cmFwcGVkU3ViY2hhbm5lbCIsInVwZGF0ZVN0YXRlIiwicGlja2VyIiwicXVldWVDb3B5Iiwic2xpY2UiLCJsZW5ndGgiLCJjYWxsUmVmVGltZXJVbnJlZiIsImNhbGwiLCJkb1BpY2siLCJyZXF1ZXN0UmVyZXNvbHV0aW9uIiwiYWRkQ2hhbm5lbHpDaGlsZCIsInJlZkNoaWxkIiwicmVtb3ZlQ2hhbm5lbHpDaGlsZCIsInVucmVmQ2hpbGQiLCJyZXNvbHZpbmdMb2FkQmFsYW5jZXIiLCJSZXNvbHZpbmdMb2FkQmFsYW5jZXIiLCJzZXJ2aWNlQ29uZmlnIiwicmV0cnlUaHJvdHRsaW5nIiwic2V0IiwiZ2V0VGFyZ2V0IiwiUmV0cnlUaHJvdHRsZXIiLCJtYXhUb2tlbnMiLCJ0b2tlblJhdGlvIiwiZ2V0IiwiZGVsZXRlIiwicHJvY2VzcyIsIm5leHRUaWNrIiwibG9jYWxRdWV1ZSIsImdldENvbmZpZyIsInJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZSIsInJlcG9ydFJlc29sdmVyRXJyb3IiLCJmaWx0ZXJTdGFja0ZhY3RvcnkiLCJGaWx0ZXJTdGFja0ZhY3RvcnkiLCJDb21wcmVzc2lvbkZpbHRlckZhY3RvcnkiLCJKU09OIiwic3RyaW5naWZ5IiwidW5kZWZpbmVkIiwiZXJyb3IiLCJpc1RyYWNlckVuYWJsZWQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsImlkIiwic3RhY2siLCJzdWJzdHJpbmciLCJpbmRleE9mIiwibGFzdEFjdGl2aXR5VGltZXN0YW1wIiwiRGF0ZSIsInRleHQiLCJ2ZXJib3NpdHlPdmVycmlkZSIsInVyaVRvU3RyaW5nIiwiY2FsbFJlZlRpbWVyUmVmIiwic2V0SW50ZXJ2YWwiLCJoYXNSZWYiLCJyZW1vdmVDb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXIiLCJ3YXRjaGVyT2JqZWN0Iiwid2F0Y2hlckluZGV4IiwiZmluZEluZGV4Iiwic3BsaWNlIiwid2F0Y2hlcnNDb3B5IiwiY3VycmVudFN0YXRlIiwidGltZXIiLCJjbGVhclRpbWVvdXQiLCJjYWxsYmFjayIsIlRSQU5TSUVOVF9GQUlMVVJFIiwibmV3S2VlcGFsaXZlVGltZSIsImFkZCIsImV4dHJhUGlja0luZm8iLCJxdWV1ZUNhbGxGb3JQaWNrIiwicHVzaCIsIm1ldGhvZCIsIlNIVVRET1dOIiwiZXhpdElkbGUiLCJ0eXBlIiwiY29uZmlnIiwiaW52b2tlIiwicXVldWVDYWxsRm9yQ29uZmlnIiwiZW50ZXJJZGxlIiwiZGVzdHJveSIsIlF1ZXVlUGlja2VyIiwiY2xlYXJJbnRlcnZhbCIsInN0YXJ0SWRsZVRpbWVvdXQiLCJ0aW1lb3V0TXMiLCJzZXRUaW1lb3V0Iiwibm93IiwidGltZVNpbmNlTGFzdEFjdGl2aXR5IiwidmFsdWVPZiIsIm1heWJlU3RhcnRJZGxlVGltZXIiLCJvbkNhbGxTdGFydCIsImFkZENhbGxTdGFydGVkIiwib25DYWxsRW5kIiwiT0siLCJhZGRDYWxsU3VjY2VlZGVkIiwiYWRkQ2FsbEZhaWxlZCIsImNyZWF0ZUxvYWRCYWxhbmNpbmdDYWxsIiwiY2FsbENvbmZpZyIsImhvc3QiLCJkZWFkbGluZSIsImNhbGxOdW1iZXIiLCJnZXROZXh0Q2FsbE51bWJlciIsIkxvYWRCYWxhbmNpbmdDYWxsIiwiY3JlYXRlUmV0cnlpbmdDYWxsIiwiUmV0cnlpbmdDYWxsIiwiY3JlYXRlUmVzb2x2aW5nQ2FsbCIsInBhcmVudENhbGwiLCJwcm9wYWdhdGVGbGFncyIsImRlYWRsaW5lVG9TdHJpbmciLCJmaW5hbE9wdGlvbnMiLCJmbGFncyIsIlByb3BhZ2F0ZSIsIkRFRkFVTFRTIiwiUmVzb2x2aW5nQ2FsbCIsImNsb25lIiwiYWRkU3RhdHVzV2F0Y2hlciIsImNsb3NlIiwiY2FuY2VsV2l0aFN0YXR1cyIsInVucmVnaXN0ZXJDaGFubmVselJlZiIsInVucmVmVW51c2VkU3ViY2hhbm5lbHMiLCJnZXRDb25uZWN0aXZpdHlTdGF0ZSIsInRyeVRvQ29ubmVjdCIsIndhdGNoQ29ubmVjdGl2aXR5U3RhdGUiLCJJbmZpbml0eSIsImRlYWRsaW5lRGF0ZSIsImdldFRpbWUiLCJjcmVhdGVDYWxsIiwiZ2V0T3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ChildLoadBalancerHandler = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst TYPE_NAME = \"child_load_balancer_helper\";\nclass ChildLoadBalancerHandler {\n    constructor(channelControlHelper){\n        this.channelControlHelper = channelControlHelper;\n        this.currentChild = null;\n        this.pendingChild = null;\n        this.latestConfig = null;\n        this.ChildPolicyHelper = class {\n            constructor(parent){\n                this.parent = parent;\n                this.child = null;\n            }\n            createSubchannel(subchannelAddress, subchannelArgs) {\n                return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n            }\n            updateState(connectivityState, picker, errorMessage) {\n                var _a;\n                if (this.calledByPendingChild()) {\n                    if (connectivityState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                        return;\n                    }\n                    (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();\n                    this.parent.currentChild = this.parent.pendingChild;\n                    this.parent.pendingChild = null;\n                } else if (!this.calledByCurrentChild()) {\n                    return;\n                }\n                this.parent.channelControlHelper.updateState(connectivityState, picker, errorMessage);\n            }\n            requestReresolution() {\n                var _a;\n                const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;\n                if (this.child === latestChild) {\n                    this.parent.channelControlHelper.requestReresolution();\n                }\n            }\n            setChild(newChild) {\n                this.child = newChild;\n            }\n            addChannelzChild(child) {\n                this.parent.channelControlHelper.addChannelzChild(child);\n            }\n            removeChannelzChild(child) {\n                this.parent.channelControlHelper.removeChannelzChild(child);\n            }\n            calledByPendingChild() {\n                return this.child === this.parent.pendingChild;\n            }\n            calledByCurrentChild() {\n                return this.child === this.parent.currentChild;\n            }\n        };\n    }\n    configUpdateRequiresNewPolicyInstance(oldConfig, newConfig) {\n        return oldConfig.getLoadBalancerName() !== newConfig.getLoadBalancerName();\n    }\n    /**\n     * Prerequisites: lbConfig !== null and lbConfig.name is registered\n     * @param endpointList\n     * @param lbConfig\n     * @param attributes\n     */ updateAddressList(endpointList, lbConfig, options) {\n        let childToUpdate;\n        if (this.currentChild === null || this.latestConfig === null || this.configUpdateRequiresNewPolicyInstance(this.latestConfig, lbConfig)) {\n            const newHelper = new this.ChildPolicyHelper(this);\n            const newChild = (0, load_balancer_1.createLoadBalancer)(lbConfig, newHelper);\n            newHelper.setChild(newChild);\n            if (this.currentChild === null) {\n                this.currentChild = newChild;\n                childToUpdate = this.currentChild;\n            } else {\n                if (this.pendingChild) {\n                    this.pendingChild.destroy();\n                }\n                this.pendingChild = newChild;\n                childToUpdate = this.pendingChild;\n            }\n        } else {\n            if (this.pendingChild === null) {\n                childToUpdate = this.currentChild;\n            } else {\n                childToUpdate = this.pendingChild;\n            }\n        }\n        this.latestConfig = lbConfig;\n        childToUpdate.updateAddressList(endpointList, lbConfig, options);\n    }\n    exitIdle() {\n        if (this.currentChild) {\n            this.currentChild.exitIdle();\n            if (this.pendingChild) {\n                this.pendingChild.exitIdle();\n            }\n        }\n    }\n    resetBackoff() {\n        if (this.currentChild) {\n            this.currentChild.resetBackoff();\n            if (this.pendingChild) {\n                this.pendingChild.resetBackoff();\n            }\n        }\n    }\n    destroy() {\n        /* Note: state updates are only propagated from the child balancer if that\n         * object is equal to this.currentChild or this.pendingChild. Since this\n         * function sets both of those to null, no further state updates will\n         * occur after this function returns. */ if (this.currentChild) {\n            this.currentChild.destroy();\n            this.currentChild = null;\n        }\n        if (this.pendingChild) {\n            this.pendingChild.destroy();\n            this.pendingChild = null;\n        }\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.ChildLoadBalancerHandler = ChildLoadBalancerHandler; //# sourceMappingURL=load-balancer-child-handler.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQ0FBZ0MsR0FBRyxLQUFLO0FBQ3hDLE1BQU1HLGtCQUFrQkMsbUJBQU9BLENBQUMsc0ZBQWlCO0FBQ2pELE1BQU1DLHVCQUF1QkQsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1FLFlBQVk7QUFDbEIsTUFBTUo7SUFDRkssWUFBWUMsb0JBQW9CLENBQUU7UUFDOUIsSUFBSSxDQUFDQSxvQkFBb0IsR0FBR0E7UUFDNUIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztZQUNyQkwsWUFBWU0sTUFBTSxDQUFFO2dCQUNoQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7Z0JBQ2QsSUFBSSxDQUFDQyxLQUFLLEdBQUc7WUFDakI7WUFDQUMsaUJBQWlCQyxpQkFBaUIsRUFBRUMsY0FBYyxFQUFFO2dCQUNoRCxPQUFPLElBQUksQ0FBQ0osTUFBTSxDQUFDTCxvQkFBb0IsQ0FBQ08sZ0JBQWdCLENBQUNDLG1CQUFtQkM7WUFDaEY7WUFDQUMsWUFBWUMsaUJBQWlCLEVBQUVDLE1BQU0sRUFBRUMsWUFBWSxFQUFFO2dCQUNqRCxJQUFJQztnQkFDSixJQUFJLElBQUksQ0FBQ0Msb0JBQW9CLElBQUk7b0JBQzdCLElBQUlKLHNCQUFzQmQscUJBQXFCbUIsaUJBQWlCLENBQUNDLFVBQVUsRUFBRTt3QkFDekU7b0JBQ0o7b0JBQ0NILENBQUFBLEtBQUssSUFBSSxDQUFDVCxNQUFNLENBQUNKLFlBQVksTUFBTSxRQUFRYSxPQUFPLEtBQUssSUFBSSxL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cEMsWUFBWSxFQUFFO1lBQ25CLElBQUksQ0FBQ0EsWUFBWSxDQUFDb0MsUUFBUTtZQUMxQixJQUFJLElBQUksQ0FBQ25DLFlBQVksRUFBRTtnQkFDbkIsSUFBSSxDQUFDQSxZQUFZLENBQUNtQyxRQUFRO1lBQzlCO1FBQ0o7SUFDSjtJQUNBQyxlQUFlO1FBQ1gsSUFBSSxJQUFJLENBQUNyQyxZQUFZLEVBQUU7WUFDbkIsSUFBSSxDQUFDQSxZQUFZLENBQUNxQyxZQUFZO1lBQzlCLElBQUksSUFBSSxDQUFDcEMsWUFBWSxFQUFFO2dCQUNuQixJQUFJLENBQUNBLFlBQVksQ0FBQ29DLFlBQVk7WUFDbEM7UUFDSjtJQUNKO0lBQ0FwQixVQUFVO1FBQ047Ozs4Q0FHc0MsR0FDdEMsSUFBSSxJQUFJLENBQUNqQixZQUFZLEVBQUU7WUFDbkIsSUFBSSxDQUFDQSxZQUFZLENBQUNpQixPQUFPO1lBQ3pCLElBQUksQ0FBQ2pCLFlBQVksR0FBRztRQUN4QjtRQUNBLElBQUksSUFBSSxDQUFDQyxZQUFZLEVBQUU7WUFDbkIsSUFBSSxDQUFDQSxZQUFZLENBQUNnQixPQUFPO1lBQ3pCLElBQUksQ0FBQ2hCLFlBQVksR0FBRztRQUN4QjtJQUNKO0lBQ0FxQyxjQUFjO1FBQ1YsT0FBT3pDO0lBQ1g7QUFDSjtBQUNBTixnQ0FBZ0MsR0FBR0UsMEJBQ25DLHVEQUF1RCIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1ob3VzaW5nLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLWNoaWxkLWhhbmRsZXIuanM/N2UxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBUWVBFX05BTUUgPSAnY2hpbGRfbG9hZF9iYWxhbmNlcl9oZWxwZXInO1xuY2xhc3MgQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsQ29udHJvbEhlbHBlcikge1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyID0gY2hhbm5lbENvbnRyb2xIZWxwZXI7XG4gICAgICAgIHRoaXMuY3VycmVudENoaWxkID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdENvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMuQ2hpbGRQb2xpY3lIZWxwZXIgPSBjbGFzcyB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNyZWF0ZVN1YmNoYW5uZWwoc3ViY2hhbm5lbEFkZHJlc3MsIHN1YmNoYW5uZWxBcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNoYW5uZWxDb250cm9sSGVscGVyLmNyZWF0ZVN1YmNoYW5uZWwoc3ViY2hhbm5lbEFkZHJlc3MsIHN1YmNoYW5uZWxBcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIsIGVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYWxsZWRCeVBlbmRpbmdDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMucGFyZW50LmN1cnJlbnRDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY3VycmVudENoaWxkID0gdGhpcy5wYXJlbnQucGVuZGluZ0NoaWxkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5wZW5kaW5nQ2hpbGQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jYWxsZWRCeUN1cnJlbnRDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hhbm5lbENvbnRyb2xIZWxwZXIudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlciwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3RSZXJlc29sdXRpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhdGVzdENoaWxkID0gKF9hID0gdGhpcy5wYXJlbnQucGVuZGluZ0NoaWxkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnBhcmVudC5jdXJyZW50Q2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGQgPT09IGxhdGVzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoYW5uZWxDb250cm9sSGVscGVyLnJlcXVlc3RSZXJlc29sdXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDaGlsZChuZXdDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQgPSBuZXdDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZENoYW5uZWx6Q2hpbGQoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW92ZUNoYW5uZWx6Q2hpbGQoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxlZEJ5UGVuZGluZ0NoaWxkKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkID09PSB0aGlzLnBhcmVudC5wZW5kaW5nQ2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsZWRCeUN1cnJlbnRDaGlsZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZCA9PT0gdGhpcy5wYXJlbnQuY3VycmVudENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25maWdVcGRhdGVSZXF1aXJlc05ld1BvbGljeUluc3RhbmNlKG9sZENvbmZpZywgbmV3Q29uZmlnKSB7XG4gICAgICAgIHJldHVybiBvbGRDb25maWcuZ2V0TG9hZEJhbGFuY2VyTmFtZSgpICE9PSBuZXdDb25maWcuZ2V0TG9hZEJhbGFuY2VyTmFtZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVyZXF1aXNpdGVzOiBsYkNvbmZpZyAhPT0gbnVsbCBhbmQgbGJDb25maWcubmFtZSBpcyByZWdpc3RlcmVkXG4gICAgICogQHBhcmFtIGVuZHBvaW50TGlzdFxuICAgICAqIEBwYXJhbSBsYkNvbmZpZ1xuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgdXBkYXRlQWRkcmVzc0xpc3QoZW5kcG9pbnRMaXN0LCBsYkNvbmZpZywgb3B0aW9ucykge1xuICAgICAgICBsZXQgY2hpbGRUb1VwZGF0ZTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENoaWxkID09PSBudWxsIHx8XG4gICAgICAgICAgICB0aGlzLmxhdGVzdENvbmZpZyA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgdGhpcy5jb25maWdVcGRhdGVSZXF1aXJlc05ld1BvbGljeUluc3RhbmNlKHRoaXMubGF0ZXN0Q29uZmlnLCBsYkNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0hlbHBlciA9IG5ldyB0aGlzLkNoaWxkUG9saWN5SGVscGVyKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSAoMCwgbG9hZF9iYWxhbmNlcl8xLmNyZWF0ZUxvYWRCYWxhbmNlcikobGJDb25maWcsIG5ld0hlbHBlcik7XG4gICAgICAgICAgICBuZXdIZWxwZXIuc2V0Q2hpbGQobmV3Q2hpbGQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudENoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQgPSBuZXdDaGlsZDtcbiAgICAgICAgICAgICAgICBjaGlsZFRvVXBkYXRlID0gdGhpcy5jdXJyZW50Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGQuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZCA9IG5ld0NoaWxkO1xuICAgICAgICAgICAgICAgIGNoaWxkVG9VcGRhdGUgPSB0aGlzLnBlbmRpbmdDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdDaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoaWxkVG9VcGRhdGUgPSB0aGlzLmN1cnJlbnRDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkVG9VcGRhdGUgPSB0aGlzLnBlbmRpbmdDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhdGVzdENvbmZpZyA9IGxiQ29uZmlnO1xuICAgICAgICBjaGlsZFRvVXBkYXRlLnVwZGF0ZUFkZHJlc3NMaXN0KGVuZHBvaW50TGlzdCwgbGJDb25maWcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBleGl0SWRsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZC5leGl0SWRsZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGQuZXhpdElkbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQucmVzZXRCYWNrb2ZmKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZC5yZXNldEJhY2tvZmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAvKiBOb3RlOiBzdGF0ZSB1cGRhdGVzIGFyZSBvbmx5IHByb3BhZ2F0ZWQgZnJvbSB0aGUgY2hpbGQgYmFsYW5jZXIgaWYgdGhhdFxuICAgICAgICAgKiBvYmplY3QgaXMgZXF1YWwgdG8gdGhpcy5jdXJyZW50Q2hpbGQgb3IgdGhpcy5wZW5kaW5nQ2hpbGQuIFNpbmNlIHRoaXNcbiAgICAgICAgICogZnVuY3Rpb24gc2V0cyBib3RoIG9mIHRob3NlIHRvIG51bGwsIG5vIGZ1cnRoZXIgc3RhdGUgdXBkYXRlcyB3aWxsXG4gICAgICAgICAqIG9jY3VyIGFmdGVyIHRoaXMgZnVuY3Rpb24gcmV0dXJucy4gKi9cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxufVxuZXhwb3J0cy5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXIgPSBDaGlsZExvYWRCYWxhbmNlckhhbmRsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLWNoaWxkLWhhbmRsZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyIiwibG9hZF9iYWxhbmNlcl8xIiwicmVxdWlyZSIsImNvbm5lY3Rpdml0eV9zdGF0ZV8xIiwiVFlQRV9OQU1FIiwiY29uc3RydWN0b3IiLCJjaGFubmVsQ29udHJvbEhlbHBlciIsImN1cnJlbnRDaGlsZCIsInBlbmRpbmdDaGlsZCIsImxhdGVzdENvbmZpZyIsIkNoaWxkUG9saWN5SGVscGVyIiwicGFyZW50IiwiY2hpbGQiLCJjcmVhdGVTdWJjaGFubmVsIiwic3ViY2hhbm5lbEFkZHJlc3MiLCJzdWJjaGFubmVsQXJncyIsInVwZGF0ZVN0YXRlIiwiY29ubmVjdGl2aXR5U3RhdGUiLCJwaWNrZXIiLCJlcnJvck1lc3NhZ2UiLCJfYSIsImNhbGxlZEJ5UGVuZGluZ0NoaWxkIiwiQ29ubmVjdGl2aXR5U3RhdGUiLCJDT05ORUNUSU5HIiwiZGVzdHJveSIsImNhbGxlZEJ5Q3VycmVudENoaWxkIiwicmVxdWVzdFJlcmVzb2x1dGlvbiIsImxhdGVzdENoaWxkIiwic2V0Q2hpbGQiLCJuZXdDaGlsZCIsImFkZENoYW5uZWx6Q2hpbGQiLCJyZW1vdmVDaGFubmVsekNoaWxkIiwiY29uZmlnVXBkYXRlUmVxdWlyZXNOZXdQb2xpY3lJbnN0YW5jZSIsIm9sZENvbmZpZyIsIm5ld0NvbmZpZyIsImdldExvYWRCYWxhbmNlck5hbWUiLCJ1cGRhdGVBZGRyZXNzTGlzdCIsImVuZHBvaW50TGlzdCIsImxiQ29uZmlnIiwib3B0aW9ucyIsImNoaWxkVG9VcGRhdGUiLCJuZXdIZWxwZXIiLCJjcmVhdGVMb2FkQmFsYW5jZXIiLCJleGl0SWRsZSIsInJlc2V0QmFja29mZiIsImdldFR5cGVOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ var _a;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.OutlierDetectionLoadBalancer = exports.OutlierDetectionLoadBalancingConfig = void 0;\nexports.setup = setup;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst duration_1 = __webpack_require__(/*! ./duration */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\nconst experimental_1 = __webpack_require__(/*! ./experimental */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = \"outlier_detection\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = \"outlier_detection\";\nconst OUTLIER_DETECTION_ENABLED = ((_a = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a !== void 0 ? _a : \"true\") === \"true\";\nconst defaultSuccessRateEjectionConfig = {\n    stdev_factor: 1900,\n    enforcement_percentage: 100,\n    minimum_hosts: 5,\n    request_volume: 100\n};\nconst defaultFailurePercentageEjectionConfig = {\n    threshold: 85,\n    enforcement_percentage: 100,\n    minimum_hosts: 5,\n    request_volume: 50\n};\nfunction validateFieldType(obj, fieldName, expectedType, objectName) {\n    if (fieldName in obj && obj[fieldName] !== undefined && typeof obj[fieldName] !== expectedType) {\n        const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n        throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);\n    }\n}\nfunction validatePositiveDuration(obj, fieldName, objectName) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    if (fieldName in obj && obj[fieldName] !== undefined) {\n        if (!(0, duration_1.isDuration)(obj[fieldName])) {\n            throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);\n        }\n        if (!(obj[fieldName].seconds >= 0 && obj[fieldName].seconds <= 315576000000 && obj[fieldName].nanos >= 0 && obj[fieldName].nanos <= 999999999)) {\n            throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);\n        }\n    }\n}\nfunction validatePercentage(obj, fieldName, objectName) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    validateFieldType(obj, fieldName, \"number\", objectName);\n    if (fieldName in obj && obj[fieldName] !== undefined && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {\n        throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);\n    }\n}\nclass OutlierDetectionLoadBalancingConfig {\n    constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy){\n        this.childPolicy = childPolicy;\n        if (childPolicy.getLoadBalancerName() === \"pick_first\") {\n            throw new Error(\"outlier_detection LB policy cannot have a pick_first child policy\");\n        }\n        this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 10000;\n        this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 30000;\n        this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 300000;\n        this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;\n        this.successRateEjection = successRateEjection ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;\n        this.failurePercentageEjection = failurePercentageEjection ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;\n    }\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    toJsonObject() {\n        var _a, _b;\n        return {\n            outlier_detection: {\n                interval: (0, duration_1.msToDuration)(this.intervalMs),\n                base_ejection_time: (0, duration_1.msToDuration)(this.baseEjectionTimeMs),\n                max_ejection_time: (0, duration_1.msToDuration)(this.maxEjectionTimeMs),\n                max_ejection_percent: this.maxEjectionPercent,\n                success_rate_ejection: (_a = this.successRateEjection) !== null && _a !== void 0 ? _a : undefined,\n                failure_percentage_ejection: (_b = this.failurePercentageEjection) !== null && _b !== void 0 ? _b : undefined,\n                child_policy: [\n                    this.childPolicy.toJsonObject()\n                ]\n            }\n        };\n    }\n    getIntervalMs() {\n        return this.intervalMs;\n    }\n    getBaseEjectionTimeMs() {\n        return this.baseEjectionTimeMs;\n    }\n    getMaxEjectionTimeMs() {\n        return this.maxEjectionTimeMs;\n    }\n    getMaxEjectionPercent() {\n        return this.maxEjectionPercent;\n    }\n    getSuccessRateEjectionConfig() {\n        return this.successRateEjection;\n    }\n    getFailurePercentageEjectionConfig() {\n        return this.failurePercentageEjection;\n    }\n    getChildPolicy() {\n        return this.childPolicy;\n    }\n    static createFromJson(obj) {\n        var _a;\n        validatePositiveDuration(obj, \"interval\");\n        validatePositiveDuration(obj, \"base_ejection_time\");\n        validatePositiveDuration(obj, \"max_ejection_time\");\n        validatePercentage(obj, \"max_ejection_percent\");\n        if (\"success_rate_ejection\" in obj && obj.success_rate_ejection !== undefined) {\n            if (typeof obj.success_rate_ejection !== \"object\") {\n                throw new Error(\"outlier detection config success_rate_ejection must be an object\");\n            }\n            validateFieldType(obj.success_rate_ejection, \"stdev_factor\", \"number\", \"success_rate_ejection\");\n            validatePercentage(obj.success_rate_ejection, \"enforcement_percentage\", \"success_rate_ejection\");\n            validateFieldType(obj.success_rate_ejection, \"minimum_hosts\", \"number\", \"success_rate_ejection\");\n            validateFieldType(obj.success_rate_ejection, \"request_volume\", \"number\", \"success_rate_ejection\");\n        }\n        if (\"failure_percentage_ejection\" in obj && obj.failure_percentage_ejection !== undefined) {\n            if (typeof obj.failure_percentage_ejection !== \"object\") {\n                throw new Error(\"outlier detection config failure_percentage_ejection must be an object\");\n            }\n            validatePercentage(obj.failure_percentage_ejection, \"threshold\", \"failure_percentage_ejection\");\n            validatePercentage(obj.failure_percentage_ejection, \"enforcement_percentage\", \"failure_percentage_ejection\");\n            validateFieldType(obj.failure_percentage_ejection, \"minimum_hosts\", \"number\", \"failure_percentage_ejection\");\n            validateFieldType(obj.failure_percentage_ejection, \"request_volume\", \"number\", \"failure_percentage_ejection\");\n        }\n        if (!(\"child_policy\" in obj) || !Array.isArray(obj.child_policy)) {\n            throw new Error(\"outlier detection config child_policy must be an array\");\n        }\n        const childPolicy = (0, load_balancer_1.selectLbConfigFromList)(obj.child_policy);\n        if (!childPolicy) {\n            throw new Error(\"outlier detection config child_policy: no valid recognized policy found\");\n        }\n        return new OutlierDetectionLoadBalancingConfig(obj.interval ? (0, duration_1.durationToMs)(obj.interval) : null, obj.base_ejection_time ? (0, duration_1.durationToMs)(obj.base_ejection_time) : null, obj.max_ejection_time ? (0, duration_1.durationToMs)(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== void 0 ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, childPolicy);\n    }\n}\nexports.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;\nclass OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n    constructor(childSubchannel, mapEntry){\n        super(childSubchannel);\n        this.mapEntry = mapEntry;\n        this.refCount = 0;\n    }\n    ref() {\n        this.child.ref();\n        this.refCount += 1;\n    }\n    unref() {\n        this.child.unref();\n        this.refCount -= 1;\n        if (this.refCount <= 0) {\n            if (this.mapEntry) {\n                const index = this.mapEntry.subchannelWrappers.indexOf(this);\n                if (index >= 0) {\n                    this.mapEntry.subchannelWrappers.splice(index, 1);\n                }\n            }\n        }\n    }\n    eject() {\n        this.setHealthy(false);\n    }\n    uneject() {\n        this.setHealthy(true);\n    }\n    getMapEntry() {\n        return this.mapEntry;\n    }\n    getWrappedSubchannel() {\n        return this.child;\n    }\n}\nfunction createEmptyBucket() {\n    return {\n        success: 0,\n        failure: 0\n    };\n}\nclass CallCounter {\n    constructor(){\n        this.activeBucket = createEmptyBucket();\n        this.inactiveBucket = createEmptyBucket();\n    }\n    addSuccess() {\n        this.activeBucket.success += 1;\n    }\n    addFailure() {\n        this.activeBucket.failure += 1;\n    }\n    switchBuckets() {\n        this.inactiveBucket = this.activeBucket;\n        this.activeBucket = createEmptyBucket();\n    }\n    getLastSuccesses() {\n        return this.inactiveBucket.success;\n    }\n    getLastFailures() {\n        return this.inactiveBucket.failure;\n    }\n}\nclass OutlierDetectionPicker {\n    constructor(wrappedPicker, countCalls){\n        this.wrappedPicker = wrappedPicker;\n        this.countCalls = countCalls;\n    }\n    pick(pickArgs) {\n        const wrappedPick = this.wrappedPicker.pick(pickArgs);\n        if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {\n            const subchannelWrapper = wrappedPick.subchannel;\n            const mapEntry = subchannelWrapper.getMapEntry();\n            if (mapEntry) {\n                let onCallEnded = wrappedPick.onCallEnded;\n                if (this.countCalls) {\n                    onCallEnded = (statusCode)=>{\n                        var _a;\n                        if (statusCode === constants_1.Status.OK) {\n                            mapEntry.counter.addSuccess();\n                        } else {\n                            mapEntry.counter.addFailure();\n                        }\n                        (_a = wrappedPick.onCallEnded) === null || _a === void 0 ? void 0 : _a.call(wrappedPick, statusCode);\n                    };\n                }\n                return Object.assign(Object.assign({}, wrappedPick), {\n                    subchannel: subchannelWrapper.getWrappedSubchannel(),\n                    onCallEnded: onCallEnded\n                });\n            } else {\n                return Object.assign(Object.assign({}, wrappedPick), {\n                    subchannel: subchannelWrapper.getWrappedSubchannel()\n                });\n            }\n        } else {\n            return wrappedPick;\n        }\n    }\n}\nclass OutlierDetectionLoadBalancer {\n    constructor(channelControlHelper){\n        this.entryMap = new subchannel_address_1.EndpointMap();\n        this.latestConfig = null;\n        this.timerStartTime = null;\n        this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler((0, experimental_1.createChildChannelControlHelper)(channelControlHelper, {\n            createSubchannel: (subchannelAddress, subchannelArgs)=>{\n                const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n                const mapEntry = this.entryMap.getForSubchannelAddress(subchannelAddress);\n                const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);\n                if ((mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.currentEjectionTimestamp) !== null) {\n                    // If the address is ejected, propagate that to the new subchannel wrapper\n                    subchannelWrapper.eject();\n                }\n                mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);\n                return subchannelWrapper;\n            },\n            updateState: (connectivityState, picker, errorMessage)=>{\n                if (connectivityState === connectivity_state_1.ConnectivityState.READY) {\n                    channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()), errorMessage);\n                } else {\n                    channelControlHelper.updateState(connectivityState, picker, errorMessage);\n                }\n            }\n        }));\n        this.ejectionTimer = setInterval(()=>{}, 0);\n        clearInterval(this.ejectionTimer);\n    }\n    isCountingEnabled() {\n        return this.latestConfig !== null && (this.latestConfig.getSuccessRateEjectionConfig() !== null || this.latestConfig.getFailurePercentageEjectionConfig() !== null);\n    }\n    getCurrentEjectionPercent() {\n        let ejectionCount = 0;\n        for (const mapEntry of this.entryMap.values()){\n            if (mapEntry.currentEjectionTimestamp !== null) {\n                ejectionCount += 1;\n            }\n        }\n        return ejectionCount * 100 / this.entryMap.size;\n    }\n    runSuccessRateCheck(ejectionTimestamp) {\n        if (!this.latestConfig) {\n            return;\n        }\n        const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();\n        if (!successRateConfig) {\n            return;\n        }\n        trace(\"Running success rate check\");\n        // Step 1\n        const targetRequestVolume = successRateConfig.request_volume;\n        let addresesWithTargetVolume = 0;\n        const successRates = [];\n        for (const [endpoint, mapEntry] of this.entryMap.entries()){\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            trace(\"Stats for \" + (0, subchannel_address_1.endpointToString)(endpoint) + \": successes=\" + successes + \" failures=\" + failures + \" targetRequestVolume=\" + targetRequestVolume);\n            if (successes + failures >= targetRequestVolume) {\n                addresesWithTargetVolume += 1;\n                successRates.push(successes / (successes + failures));\n            }\n        }\n        trace(\"Found \" + addresesWithTargetVolume + \" success rate candidates; currentEjectionPercent=\" + this.getCurrentEjectionPercent() + \" successRates=[\" + successRates + \"]\");\n        if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {\n            return;\n        }\n        // Step 2\n        const successRateMean = successRates.reduce((a, b)=>a + b) / successRates.length;\n        let successRateDeviationSum = 0;\n        for (const rate of successRates){\n            const deviation = rate - successRateMean;\n            successRateDeviationSum += deviation * deviation;\n        }\n        const successRateVariance = successRateDeviationSum / successRates.length;\n        const successRateStdev = Math.sqrt(successRateVariance);\n        const ejectionThreshold = successRateMean - successRateStdev * (successRateConfig.stdev_factor / 1000);\n        trace(\"stdev=\" + successRateStdev + \" ejectionThreshold=\" + ejectionThreshold);\n        // Step 3\n        for (const [address, mapEntry] of this.entryMap.entries()){\n            // Step 3.i\n            if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {\n                break;\n            }\n            // Step 3.ii\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures < targetRequestVolume) {\n                continue;\n            }\n            // Step 3.iii\n            const successRate = successes / (successes + failures);\n            trace(\"Checking candidate \" + address + \" successRate=\" + successRate);\n            if (successRate < ejectionThreshold) {\n                const randomNumber = Math.random() * 100;\n                trace(\"Candidate \" + address + \" randomNumber=\" + randomNumber + \" enforcement_percentage=\" + successRateConfig.enforcement_percentage);\n                if (randomNumber < successRateConfig.enforcement_percentage) {\n                    trace(\"Ejecting candidate \" + address);\n                    this.eject(mapEntry, ejectionTimestamp);\n                }\n            }\n        }\n    }\n    runFailurePercentageCheck(ejectionTimestamp) {\n        if (!this.latestConfig) {\n            return;\n        }\n        const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();\n        if (!failurePercentageConfig) {\n            return;\n        }\n        trace(\"Running failure percentage check. threshold=\" + failurePercentageConfig.threshold + \" request volume threshold=\" + failurePercentageConfig.request_volume);\n        // Step 1\n        let addressesWithTargetVolume = 0;\n        for (const mapEntry of this.entryMap.values()){\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures >= failurePercentageConfig.request_volume) {\n                addressesWithTargetVolume += 1;\n            }\n        }\n        if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {\n            return;\n        }\n        // Step 2\n        for (const [address, mapEntry] of this.entryMap.entries()){\n            // Step 2.i\n            if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {\n                break;\n            }\n            // Step 2.ii\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            trace(\"Candidate successes=\" + successes + \" failures=\" + failures);\n            if (successes + failures < failurePercentageConfig.request_volume) {\n                continue;\n            }\n            // Step 2.iii\n            const failurePercentage = failures * 100 / (failures + successes);\n            if (failurePercentage > failurePercentageConfig.threshold) {\n                const randomNumber = Math.random() * 100;\n                trace(\"Candidate \" + address + \" randomNumber=\" + randomNumber + \" enforcement_percentage=\" + failurePercentageConfig.enforcement_percentage);\n                if (randomNumber < failurePercentageConfig.enforcement_percentage) {\n                    trace(\"Ejecting candidate \" + address);\n                    this.eject(mapEntry, ejectionTimestamp);\n                }\n            }\n        }\n    }\n    eject(mapEntry, ejectionTimestamp) {\n        mapEntry.currentEjectionTimestamp = new Date();\n        mapEntry.ejectionTimeMultiplier += 1;\n        for (const subchannelWrapper of mapEntry.subchannelWrappers){\n            subchannelWrapper.eject();\n        }\n    }\n    uneject(mapEntry) {\n        mapEntry.currentEjectionTimestamp = null;\n        for (const subchannelWrapper of mapEntry.subchannelWrappers){\n            subchannelWrapper.uneject();\n        }\n    }\n    switchAllBuckets() {\n        for (const mapEntry of this.entryMap.values()){\n            mapEntry.counter.switchBuckets();\n        }\n    }\n    startTimer(delayMs) {\n        var _a, _b;\n        this.ejectionTimer = setTimeout(()=>this.runChecks(), delayMs);\n        (_b = (_a = this.ejectionTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    runChecks() {\n        const ejectionTimestamp = new Date();\n        trace(\"Ejection timer running\");\n        this.switchAllBuckets();\n        if (!this.latestConfig) {\n            return;\n        }\n        this.timerStartTime = ejectionTimestamp;\n        this.startTimer(this.latestConfig.getIntervalMs());\n        this.runSuccessRateCheck(ejectionTimestamp);\n        this.runFailurePercentageCheck(ejectionTimestamp);\n        for (const [address, mapEntry] of this.entryMap.entries()){\n            if (mapEntry.currentEjectionTimestamp === null) {\n                if (mapEntry.ejectionTimeMultiplier > 0) {\n                    mapEntry.ejectionTimeMultiplier -= 1;\n                }\n            } else {\n                const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();\n                const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();\n                const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());\n                returnTime.setMilliseconds(returnTime.getMilliseconds() + Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));\n                if (returnTime < new Date()) {\n                    trace(\"Unejecting \" + address);\n                    this.uneject(mapEntry);\n                }\n            }\n        }\n    }\n    updateAddressList(endpointList, lbConfig, options) {\n        if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {\n            return;\n        }\n        trace(\"Received update with config: \" + JSON.stringify(lbConfig.toJsonObject(), undefined, 2));\n        for (const endpoint of endpointList){\n            if (!this.entryMap.has(endpoint)) {\n                trace(\"Adding map entry for \" + (0, subchannel_address_1.endpointToString)(endpoint));\n                this.entryMap.set(endpoint, {\n                    counter: new CallCounter(),\n                    currentEjectionTimestamp: null,\n                    ejectionTimeMultiplier: 0,\n                    subchannelWrappers: []\n                });\n            }\n        }\n        this.entryMap.deleteMissing(endpointList);\n        const childPolicy = lbConfig.getChildPolicy();\n        this.childBalancer.updateAddressList(endpointList, childPolicy, options);\n        if (lbConfig.getSuccessRateEjectionConfig() || lbConfig.getFailurePercentageEjectionConfig()) {\n            if (this.timerStartTime) {\n                trace(\"Previous timer existed. Replacing timer\");\n                clearTimeout(this.ejectionTimer);\n                const remainingDelay = lbConfig.getIntervalMs() - (new Date().getTime() - this.timerStartTime.getTime());\n                this.startTimer(remainingDelay);\n            } else {\n                trace(\"Starting new timer\");\n                this.timerStartTime = new Date();\n                this.startTimer(lbConfig.getIntervalMs());\n                this.switchAllBuckets();\n            }\n        } else {\n            trace(\"Counting disabled. Cancelling timer.\");\n            this.timerStartTime = null;\n            clearTimeout(this.ejectionTimer);\n            for (const mapEntry of this.entryMap.values()){\n                this.uneject(mapEntry);\n                mapEntry.ejectionTimeMultiplier = 0;\n            }\n        }\n        this.latestConfig = lbConfig;\n    }\n    exitIdle() {\n        this.childBalancer.exitIdle();\n    }\n    resetBackoff() {\n        this.childBalancer.resetBackoff();\n    }\n    destroy() {\n        clearTimeout(this.ejectionTimer);\n        this.childBalancer.destroy();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;\nfunction setup() {\n    if (OUTLIER_DETECTION_ENABLED) {\n        (0, experimental_1.registerLoadBalancerType)(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);\n    }\n} //# sourceMappingURL=load-balancer-outlier-detection.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1vdXRsaWVyLWRldGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELElBQUlBO0FBQ0pDLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQ0FBb0MsR0FBR0EsMkNBQTJDLEdBQUcsS0FBSztBQUMxRkEsYUFBYSxHQUFHSTtBQUNoQixNQUFNQyx1QkFBdUJDLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNRyxpQkFBaUJILG1CQUFPQSxDQUFDLG9GQUFnQjtBQUMvQyxNQUFNSSxrQkFBa0JKLG1CQUFPQSxDQUFDLHNGQUFpQjtBQUNqRCxNQUFNSyxnQ0FBZ0NMLG1CQUFPQSxDQUFDLGtIQUErQjtBQUM3RSxNQUFNTSxXQUFXTixtQkFBT0EsQ0FBQyx3RUFBVTtBQUNuQyxNQUFNTyx1QkFBdUJQLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNUSx5QkFBeUJSLG1CQUFPQSxDQUFDLG9HQUF3QjtBQUMvRCxNQUFNUyxVQUFVVCxtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNVSxjQUFjO0FBQ3BCLFNBQVNDLE1BQU1DLElBQUk7SUFDZkgsUUFBUUUsS0FBSyxDQUFDVixZQUFZWSxZQUFZLENBQUNDLEtBQUssRUFBRUosYUFBYUU7QUFDL0Q7QUFDQSxNQUFNRyxZQUFZO0FBQ2xCLE1BQU1DLDRCQUE0QixDQUFDLENBQUN6QixLQUFLMEIsUUFBUUMsR0FBRyxDQUFDQywwQ0FBMEMsTUFBTSxRQUFRNUIsT0FBTyxLQUFLLElBQUlBLEtBQUssTUFBSyxNQUFPO0FBQzlJLE1BQU02QixtQ0FBbUM7SUFDckNDLGNBQWM7SUFDZEMsd0JBQXdCO0lBQ3hC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LElBQUlrQiwyQkFBMkI7UUFDMUIsSUFBR2IsZUFBZTRNLHdCQUF3QixFQUFFaE0sV0FBV25CLDhCQUE4QkM7SUFDMUY7QUFDSixFQUNBLDJEQUEyRCIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1ob3VzaW5nLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLW91dGxpZXItZGV0ZWN0aW9uLmpzPzAwNmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciA9IGV4cG9ydHMuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcgPSB2b2lkIDA7XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZHVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL2R1cmF0aW9uXCIpO1xuY29uc3QgZXhwZXJpbWVudGFsXzEgPSByZXF1aXJlKFwiLi9leHBlcmltZW50YWxcIik7XG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xuY29uc3QgbG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLWNoaWxkLWhhbmRsZXJcIik7XG5jb25zdCBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtaW50ZXJmYWNlXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdvdXRsaWVyX2RldGVjdGlvbic7XG5mdW5jdGlvbiB0cmFjZSh0ZXh0KSB7XG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcbn1cbmNvbnN0IFRZUEVfTkFNRSA9ICdvdXRsaWVyX2RldGVjdGlvbic7XG5jb25zdCBPVVRMSUVSX0RFVEVDVElPTl9FTkFCTEVEID0gKChfYSA9IHByb2Nlc3MuZW52LkdSUENfRVhQRVJJTUVOVEFMX0VOQUJMRV9PVVRMSUVSX0RFVEVDVElPTikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ3RydWUnKSA9PT0gJ3RydWUnO1xuY29uc3QgZGVmYXVsdFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcgPSB7XG4gICAgc3RkZXZfZmFjdG9yOiAxOTAwLFxuICAgIGVuZm9yY2VtZW50X3BlcmNlbnRhZ2U6IDEwMCxcbiAgICBtaW5pbXVtX2hvc3RzOiA1LFxuICAgIHJlcXVlc3Rfdm9sdW1lOiAxMDAsXG59O1xuY29uc3QgZGVmYXVsdEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcgPSB7XG4gICAgdGhyZXNob2xkOiA4NSxcbiAgICBlbmZvcmNlbWVudF9wZXJjZW50YWdlOiAxMDAsXG4gICAgbWluaW11bV9ob3N0czogNSxcbiAgICByZXF1ZXN0X3ZvbHVtZTogNTAsXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVGaWVsZFR5cGUob2JqLCBmaWVsZE5hbWUsIGV4cGVjdGVkVHlwZSwgb2JqZWN0TmFtZSkge1xuICAgIGlmIChmaWVsZE5hbWUgaW4gb2JqICYmXG4gICAgICAgIG9ialtmaWVsZE5hbWVdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9ialtmaWVsZE5hbWVdICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgY29uc3QgZnVsbEZpZWxkTmFtZSA9IG9iamVjdE5hbWUgPyBgJHtvYmplY3ROYW1lfS4ke2ZpZWxkTmFtZX1gIDogZmllbGROYW1lO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyAke2Z1bGxGaWVsZE5hbWV9IHBhcnNlIGVycm9yOiBleHBlY3RlZCAke2V4cGVjdGVkVHlwZX0sIGdvdCAke3R5cGVvZiBvYmpbZmllbGROYW1lXX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBvc2l0aXZlRHVyYXRpb24ob2JqLCBmaWVsZE5hbWUsIG9iamVjdE5hbWUpIHtcbiAgICBjb25zdCBmdWxsRmllbGROYW1lID0gb2JqZWN0TmFtZSA/IGAke29iamVjdE5hbWV9LiR7ZmllbGROYW1lfWAgOiBmaWVsZE5hbWU7XG4gICAgaWYgKGZpZWxkTmFtZSBpbiBvYmogJiYgb2JqW2ZpZWxkTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoISgwLCBkdXJhdGlvbl8xLmlzRHVyYXRpb24pKG9ialtmaWVsZE5hbWVdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvdXRsaWVyIGRldGVjdGlvbiBjb25maWcgJHtmdWxsRmllbGROYW1lfSBwYXJzZSBlcnJvcjogZXhwZWN0ZWQgRHVyYXRpb24sIGdvdCAke3R5cGVvZiBvYmpbZmllbGROYW1lXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShvYmpbZmllbGROYW1lXS5zZWNvbmRzID49IDAgJiZcbiAgICAgICAgICAgIG9ialtmaWVsZE5hbWVdLnNlY29uZHMgPD0gMzE1NTc2MDAwMDAwICYmXG4gICAgICAgICAgICBvYmpbZmllbGROYW1lXS5uYW5vcyA+PSAwICYmXG4gICAgICAgICAgICBvYmpbZmllbGROYW1lXS5uYW5vcyA8PSA5OTk5OTk5OTkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyAke2Z1bGxGaWVsZE5hbWV9IHBhcnNlIGVycm9yOiB2YWx1ZXMgb3V0IG9mIHJhbmdlIGZvciBub24tbmVnYXRpdmUgRHVhcmF0aW9uYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLCBmaWVsZE5hbWUsIG9iamVjdE5hbWUpIHtcbiAgICBjb25zdCBmdWxsRmllbGROYW1lID0gb2JqZWN0TmFtZSA/IGAke29iamVjdE5hbWV9LiR7ZmllbGROYW1lfWAgOiBmaWVsZE5hbWU7XG4gICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLCBmaWVsZE5hbWUsICdudW1iZXInLCBvYmplY3ROYW1lKTtcbiAgICBpZiAoZmllbGROYW1lIGluIG9iaiAmJlxuICAgICAgICBvYmpbZmllbGROYW1lXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICEob2JqW2ZpZWxkTmFtZV0gPj0gMCAmJiBvYmpbZmllbGROYW1lXSA8PSAxMDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgb3V0bGllciBkZXRlY3Rpb24gY29uZmlnICR7ZnVsbEZpZWxkTmFtZX0gcGFyc2UgZXJyb3I6IHZhbHVlIG91dCBvZiByYW5nZSBmb3IgcGVyY2VudGFnZSAoMC0xMDApYCk7XG4gICAgfVxufVxuY2xhc3MgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcge1xuICAgIGNvbnN0cnVjdG9yKGludGVydmFsTXMsIGJhc2VFamVjdGlvblRpbWVNcywgbWF4RWplY3Rpb25UaW1lTXMsIG1heEVqZWN0aW9uUGVyY2VudCwgc3VjY2Vzc1JhdGVFamVjdGlvbiwgZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbiwgY2hpbGRQb2xpY3kpIHtcbiAgICAgICAgdGhpcy5jaGlsZFBvbGljeSA9IGNoaWxkUG9saWN5O1xuICAgICAgICBpZiAoY2hpbGRQb2xpY3kuZ2V0TG9hZEJhbGFuY2VyTmFtZSgpID09PSAncGlja19maXJzdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0bGllcl9kZXRlY3Rpb24gTEIgcG9saWN5IGNhbm5vdCBoYXZlIGEgcGlja19maXJzdCBjaGlsZCBwb2xpY3knKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVydmFsTXMgPSBpbnRlcnZhbE1zICE9PSBudWxsICYmIGludGVydmFsTXMgIT09IHZvaWQgMCA/IGludGVydmFsTXMgOiAxMDAwMDtcbiAgICAgICAgdGhpcy5iYXNlRWplY3Rpb25UaW1lTXMgPSBiYXNlRWplY3Rpb25UaW1lTXMgIT09IG51bGwgJiYgYmFzZUVqZWN0aW9uVGltZU1zICE9PSB2b2lkIDAgPyBiYXNlRWplY3Rpb25UaW1lTXMgOiAzMDAwMDtcbiAgICAgICAgdGhpcy5tYXhFamVjdGlvblRpbWVNcyA9IG1heEVqZWN0aW9uVGltZU1zICE9PSBudWxsICYmIG1heEVqZWN0aW9uVGltZU1zICE9PSB2b2lkIDAgPyBtYXhFamVjdGlvblRpbWVNcyA6IDMwMDAwMDtcbiAgICAgICAgdGhpcy5tYXhFamVjdGlvblBlcmNlbnQgPSBtYXhFamVjdGlvblBlcmNlbnQgIT09IG51bGwgJiYgbWF4RWplY3Rpb25QZXJjZW50ICE9PSB2b2lkIDAgPyBtYXhFamVjdGlvblBlcmNlbnQgOiAxMDtcbiAgICAgICAgdGhpcy5zdWNjZXNzUmF0ZUVqZWN0aW9uID0gc3VjY2Vzc1JhdGVFamVjdGlvblxuICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKSwgc3VjY2Vzc1JhdGVFamVjdGlvbikgOiBudWxsO1xuICAgICAgICB0aGlzLmZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb24gPSBmYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uXG4gICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcpLCBmYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uKSA6IG51bGw7XG4gICAgfVxuICAgIGdldExvYWRCYWxhbmNlck5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxuICAgIHRvSnNvbk9iamVjdCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG91dGxpZXJfZGV0ZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWw6ICgwLCBkdXJhdGlvbl8xLm1zVG9EdXJhdGlvbikodGhpcy5pbnRlcnZhbE1zKSxcbiAgICAgICAgICAgICAgICBiYXNlX2VqZWN0aW9uX3RpbWU6ICgwLCBkdXJhdGlvbl8xLm1zVG9EdXJhdGlvbikodGhpcy5iYXNlRWplY3Rpb25UaW1lTXMpLFxuICAgICAgICAgICAgICAgIG1heF9lamVjdGlvbl90aW1lOiAoMCwgZHVyYXRpb25fMS5tc1RvRHVyYXRpb24pKHRoaXMubWF4RWplY3Rpb25UaW1lTXMpLFxuICAgICAgICAgICAgICAgIG1heF9lamVjdGlvbl9wZXJjZW50OiB0aGlzLm1heEVqZWN0aW9uUGVyY2VudCxcbiAgICAgICAgICAgICAgICBzdWNjZXNzX3JhdGVfZWplY3Rpb246IChfYSA9IHRoaXMuc3VjY2Vzc1JhdGVFamVjdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbjogKF9iID0gdGhpcy5mYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgY2hpbGRfcG9saWN5OiBbdGhpcy5jaGlsZFBvbGljeS50b0pzb25PYmplY3QoKV0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRJbnRlcnZhbE1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnZhbE1zO1xuICAgIH1cbiAgICBnZXRCYXNlRWplY3Rpb25UaW1lTXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VFamVjdGlvblRpbWVNcztcbiAgICB9XG4gICAgZ2V0TWF4RWplY3Rpb25UaW1lTXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heEVqZWN0aW9uVGltZU1zO1xuICAgIH1cbiAgICBnZXRNYXhFamVjdGlvblBlcmNlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heEVqZWN0aW9uUGVyY2VudDtcbiAgICB9XG4gICAgZ2V0U3VjY2Vzc1JhdGVFamVjdGlvbkNvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VjY2Vzc1JhdGVFamVjdGlvbjtcbiAgICB9XG4gICAgZ2V0RmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbkNvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbjtcbiAgICB9XG4gICAgZ2V0Q2hpbGRQb2xpY3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkUG9saWN5O1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRnJvbUpzb24ob2JqKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFsaWRhdGVQb3NpdGl2ZUR1cmF0aW9uKG9iaiwgJ2ludGVydmFsJyk7XG4gICAgICAgIHZhbGlkYXRlUG9zaXRpdmVEdXJhdGlvbihvYmosICdiYXNlX2VqZWN0aW9uX3RpbWUnKTtcbiAgICAgICAgdmFsaWRhdGVQb3NpdGl2ZUR1cmF0aW9uKG9iaiwgJ21heF9lamVjdGlvbl90aW1lJyk7XG4gICAgICAgIHZhbGlkYXRlUGVyY2VudGFnZShvYmosICdtYXhfZWplY3Rpb25fcGVyY2VudCcpO1xuICAgICAgICBpZiAoJ3N1Y2Nlc3NfcmF0ZV9lamVjdGlvbicgaW4gb2JqICYmXG4gICAgICAgICAgICBvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqLnN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyBzdWNjZXNzX3JhdGVfZWplY3Rpb24gbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkYXRlRmllbGRUeXBlKG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24sICdzdGRldl9mYWN0b3InLCAnbnVtYmVyJywgJ3N1Y2Nlc3NfcmF0ZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVQZXJjZW50YWdlKG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24sICdlbmZvcmNlbWVudF9wZXJjZW50YWdlJywgJ3N1Y2Nlc3NfcmF0ZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLnN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiwgJ21pbmltdW1faG9zdHMnLCAnbnVtYmVyJywgJ3N1Y2Nlc3NfcmF0ZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLnN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiwgJ3JlcXVlc3Rfdm9sdW1lJywgJ251bWJlcicsICdzdWNjZXNzX3JhdGVfZWplY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicgaW4gb2JqICYmXG4gICAgICAgICAgICBvYmouZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyBmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24gbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkYXRlUGVyY2VudGFnZShvYmouZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uLCAndGhyZXNob2xkJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVQZXJjZW50YWdlKG9iai5mYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24sICdlbmZvcmNlbWVudF9wZXJjZW50YWdlJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiwgJ21pbmltdW1faG9zdHMnLCAnbnVtYmVyJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiwgJ3JlcXVlc3Rfdm9sdW1lJywgJ251bWJlcicsICdmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgnY2hpbGRfcG9saWN5JyBpbiBvYmopIHx8ICFBcnJheS5pc0FycmF5KG9iai5jaGlsZF9wb2xpY3kpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyBjaGlsZF9wb2xpY3kgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkUG9saWN5ID0gKDAsIGxvYWRfYmFsYW5jZXJfMS5zZWxlY3RMYkNvbmZpZ0Zyb21MaXN0KShvYmouY2hpbGRfcG9saWN5KTtcbiAgICAgICAgaWYgKCFjaGlsZFBvbGljeSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRsaWVyIGRldGVjdGlvbiBjb25maWcgY2hpbGRfcG9saWN5OiBubyB2YWxpZCByZWNvZ25pemVkIHBvbGljeSBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcob2JqLmludGVydmFsID8gKDAsIGR1cmF0aW9uXzEuZHVyYXRpb25Ub01zKShvYmouaW50ZXJ2YWwpIDogbnVsbCwgb2JqLmJhc2VfZWplY3Rpb25fdGltZSA/ICgwLCBkdXJhdGlvbl8xLmR1cmF0aW9uVG9Ncykob2JqLmJhc2VfZWplY3Rpb25fdGltZSkgOiBudWxsLCBvYmoubWF4X2VqZWN0aW9uX3RpbWUgPyAoMCwgZHVyYXRpb25fMS5kdXJhdGlvblRvTXMpKG9iai5tYXhfZWplY3Rpb25fdGltZSkgOiBudWxsLCAoX2EgPSBvYmoubWF4X2VqZWN0aW9uX3BlcmNlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwsIG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24sIG9iai5mYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24sIGNoaWxkUG9saWN5KTtcbiAgICB9XG59XG5leHBvcnRzLk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnID0gT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWc7XG5jbGFzcyBPdXRsaWVyRGV0ZWN0aW9uU3ViY2hhbm5lbFdyYXBwZXIgZXh0ZW5kcyBzdWJjaGFubmVsX2ludGVyZmFjZV8xLkJhc2VTdWJjaGFubmVsV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRTdWJjaGFubmVsLCBtYXBFbnRyeSkge1xuICAgICAgICBzdXBlcihjaGlsZFN1YmNoYW5uZWwpO1xuICAgICAgICB0aGlzLm1hcEVudHJ5ID0gbWFwRW50cnk7XG4gICAgICAgIHRoaXMucmVmQ291bnQgPSAwO1xuICAgIH1cbiAgICByZWYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQucmVmKCk7XG4gICAgICAgIHRoaXMucmVmQ291bnQgKz0gMTtcbiAgICB9XG4gICAgdW5yZWYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQudW5yZWYoKTtcbiAgICAgICAgdGhpcy5yZWZDb3VudCAtPSAxO1xuICAgICAgICBpZiAodGhpcy5yZWZDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXBFbnRyeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tYXBFbnRyeS5zdWJjaGFubmVsV3JhcHBlcnMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlamVjdCgpIHtcbiAgICAgICAgdGhpcy5zZXRIZWFsdGh5KGZhbHNlKTtcbiAgICB9XG4gICAgdW5lamVjdCgpIHtcbiAgICAgICAgdGhpcy5zZXRIZWFsdGh5KHRydWUpO1xuICAgIH1cbiAgICBnZXRNYXBFbnRyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwRW50cnk7XG4gICAgfVxuICAgIGdldFdyYXBwZWRTdWJjaGFubmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZDtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFbXB0eUJ1Y2tldCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiAwLFxuICAgICAgICBmYWlsdXJlOiAwLFxuICAgIH07XG59XG5jbGFzcyBDYWxsQ291bnRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQnVja2V0ID0gY3JlYXRlRW1wdHlCdWNrZXQoKTtcbiAgICAgICAgdGhpcy5pbmFjdGl2ZUJ1Y2tldCA9IGNyZWF0ZUVtcHR5QnVja2V0KCk7XG4gICAgfVxuICAgIGFkZFN1Y2Nlc3MoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQnVja2V0LnN1Y2Nlc3MgKz0gMTtcbiAgICB9XG4gICAgYWRkRmFpbHVyZSgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVCdWNrZXQuZmFpbHVyZSArPSAxO1xuICAgIH1cbiAgICBzd2l0Y2hCdWNrZXRzKCkge1xuICAgICAgICB0aGlzLmluYWN0aXZlQnVja2V0ID0gdGhpcy5hY3RpdmVCdWNrZXQ7XG4gICAgICAgIHRoaXMuYWN0aXZlQnVja2V0ID0gY3JlYXRlRW1wdHlCdWNrZXQoKTtcbiAgICB9XG4gICAgZ2V0TGFzdFN1Y2Nlc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5hY3RpdmVCdWNrZXQuc3VjY2VzcztcbiAgICB9XG4gICAgZ2V0TGFzdEZhaWx1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmFjdGl2ZUJ1Y2tldC5mYWlsdXJlO1xuICAgIH1cbn1cbmNsYXNzIE91dGxpZXJEZXRlY3Rpb25QaWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKHdyYXBwZWRQaWNrZXIsIGNvdW50Q2FsbHMpIHtcbiAgICAgICAgdGhpcy53cmFwcGVkUGlja2VyID0gd3JhcHBlZFBpY2tlcjtcbiAgICAgICAgdGhpcy5jb3VudENhbGxzID0gY291bnRDYWxscztcbiAgICB9XG4gICAgcGljayhwaWNrQXJncykge1xuICAgICAgICBjb25zdCB3cmFwcGVkUGljayA9IHRoaXMud3JhcHBlZFBpY2tlci5waWNrKHBpY2tBcmdzKTtcbiAgICAgICAgaWYgKHdyYXBwZWRQaWNrLnBpY2tSZXN1bHRUeXBlID09PSBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5DT01QTEVURSkge1xuICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgPSB3cmFwcGVkUGljay5zdWJjaGFubmVsO1xuICAgICAgICAgICAgY29uc3QgbWFwRW50cnkgPSBzdWJjaGFubmVsV3JhcHBlci5nZXRNYXBFbnRyeSgpO1xuICAgICAgICAgICAgaWYgKG1hcEVudHJ5KSB7XG4gICAgICAgICAgICAgICAgbGV0IG9uQ2FsbEVuZGVkID0gd3JhcHBlZFBpY2sub25DYWxsRW5kZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY291bnRDYWxscykge1xuICAgICAgICAgICAgICAgICAgICBvbkNhbGxFbmRlZCA9IHN0YXR1c0NvZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcEVudHJ5LmNvdW50ZXIuYWRkU3VjY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwRW50cnkuY291bnRlci5hZGRGYWlsdXJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSB3cmFwcGVkUGljay5vbkNhbGxFbmRlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwod3JhcHBlZFBpY2ssIHN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3cmFwcGVkUGljayksIHsgc3ViY2hhbm5lbDogc3ViY2hhbm5lbFdyYXBwZXIuZ2V0V3JhcHBlZFN1YmNoYW5uZWwoKSwgb25DYWxsRW5kZWQ6IG9uQ2FsbEVuZGVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd3JhcHBlZFBpY2spLCB7IHN1YmNoYW5uZWw6IHN1YmNoYW5uZWxXcmFwcGVyLmdldFdyYXBwZWRTdWJjaGFubmVsKCkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlZFBpY2s7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2VyIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsQ29udHJvbEhlbHBlcikge1xuICAgICAgICB0aGlzLmVudHJ5TWFwID0gbmV3IHN1YmNoYW5uZWxfYWRkcmVzc18xLkVuZHBvaW50TWFwKCk7XG4gICAgICAgIHRoaXMubGF0ZXN0Q29uZmlnID0gbnVsbDtcbiAgICAgICAgdGhpcy50aW1lclN0YXJ0VGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlciA9IG5ldyBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMS5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXIoKDAsIGV4cGVyaW1lbnRhbF8xLmNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIpKGNoYW5uZWxDb250cm9sSGVscGVyLCB7XG4gICAgICAgICAgICBjcmVhdGVTdWJjaGFubmVsOiAoc3ViY2hhbm5lbEFkZHJlc3MsIHN1YmNoYW5uZWxBcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdWJjaGFubmVsID0gY2hhbm5lbENvbnRyb2xIZWxwZXIuY3JlYXRlU3ViY2hhbm5lbChzdWJjaGFubmVsQWRkcmVzcywgc3ViY2hhbm5lbEFyZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcEVudHJ5ID0gdGhpcy5lbnRyeU1hcC5nZXRGb3JTdWJjaGFubmVsQWRkcmVzcyhzdWJjaGFubmVsQWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgPSBuZXcgT3V0bGllckRldGVjdGlvblN1YmNoYW5uZWxXcmFwcGVyKG9yaWdpbmFsU3ViY2hhbm5lbCwgbWFwRW50cnkpO1xuICAgICAgICAgICAgICAgIGlmICgobWFwRW50cnkgPT09IG51bGwgfHwgbWFwRW50cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFkZHJlc3MgaXMgZWplY3RlZCwgcHJvcGFnYXRlIHRoYXQgdG8gdGhlIG5ldyBzdWJjaGFubmVsIHdyYXBwZXJcbiAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFdyYXBwZXIuZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFwRW50cnkgPT09IG51bGwgfHwgbWFwRW50cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycy5wdXNoKHN1YmNoYW5uZWxXcmFwcGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ViY2hhbm5lbFdyYXBwZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlU3RhdGU6IChjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGl2aXR5U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBuZXcgT3V0bGllckRldGVjdGlvblBpY2tlcihwaWNrZXIsIHRoaXMuaXNDb3VudGluZ0VuYWJsZWQoKSksIGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5lamVjdGlvblRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmVqZWN0aW9uVGltZXIpO1xuICAgIH1cbiAgICBpc0NvdW50aW5nRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxhdGVzdENvbmZpZyAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgKHRoaXMubGF0ZXN0Q29uZmlnLmdldFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcoKSAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q29uZmlnLmdldEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcoKSAhPT0gbnVsbCkpO1xuICAgIH1cbiAgICBnZXRDdXJyZW50RWplY3Rpb25QZXJjZW50KCkge1xuICAgICAgICBsZXQgZWplY3Rpb25Db3VudCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgbWFwRW50cnkgb2YgdGhpcy5lbnRyeU1hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVqZWN0aW9uQ291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGVqZWN0aW9uQ291bnQgKiAxMDApIC8gdGhpcy5lbnRyeU1hcC5zaXplO1xuICAgIH1cbiAgICBydW5TdWNjZXNzUmF0ZUNoZWNrKGVqZWN0aW9uVGltZXN0YW1wKSB7XG4gICAgICAgIGlmICghdGhpcy5sYXRlc3RDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZUNvbmZpZyA9IHRoaXMubGF0ZXN0Q29uZmlnLmdldFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcoKTtcbiAgICAgICAgaWYgKCFzdWNjZXNzUmF0ZUNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlKCdSdW5uaW5nIHN1Y2Nlc3MgcmF0ZSBjaGVjaycpO1xuICAgICAgICAvLyBTdGVwIDFcbiAgICAgICAgY29uc3QgdGFyZ2V0UmVxdWVzdFZvbHVtZSA9IHN1Y2Nlc3NSYXRlQ29uZmlnLnJlcXVlc3Rfdm9sdW1lO1xuICAgICAgICBsZXQgYWRkcmVzZXNXaXRoVGFyZ2V0Vm9sdW1lID0gMDtcbiAgICAgICAgY29uc3Qgc3VjY2Vzc1JhdGVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW2VuZHBvaW50LCBtYXBFbnRyeV0gb2YgdGhpcy5lbnRyeU1hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdFN1Y2Nlc3NlcygpO1xuICAgICAgICAgICAgY29uc3QgZmFpbHVyZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RGYWlsdXJlcygpO1xuICAgICAgICAgICAgdHJhY2UoJ1N0YXRzIGZvciAnICtcbiAgICAgICAgICAgICAgICAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuZW5kcG9pbnRUb1N0cmluZykoZW5kcG9pbnQpICtcbiAgICAgICAgICAgICAgICAnOiBzdWNjZXNzZXM9JyArXG4gICAgICAgICAgICAgICAgc3VjY2Vzc2VzICtcbiAgICAgICAgICAgICAgICAnIGZhaWx1cmVzPScgK1xuICAgICAgICAgICAgICAgIGZhaWx1cmVzICtcbiAgICAgICAgICAgICAgICAnIHRhcmdldFJlcXVlc3RWb2x1bWU9JyArXG4gICAgICAgICAgICAgICAgdGFyZ2V0UmVxdWVzdFZvbHVtZSk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgZmFpbHVyZXMgPj0gdGFyZ2V0UmVxdWVzdFZvbHVtZSkge1xuICAgICAgICAgICAgICAgIGFkZHJlc2VzV2l0aFRhcmdldFZvbHVtZSArPSAxO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NSYXRlcy5wdXNoKHN1Y2Nlc3NlcyAvIChzdWNjZXNzZXMgKyBmYWlsdXJlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyYWNlKCdGb3VuZCAnICtcbiAgICAgICAgICAgIGFkZHJlc2VzV2l0aFRhcmdldFZvbHVtZSArXG4gICAgICAgICAgICAnIHN1Y2Nlc3MgcmF0ZSBjYW5kaWRhdGVzOyBjdXJyZW50RWplY3Rpb25QZXJjZW50PScgK1xuICAgICAgICAgICAgdGhpcy5nZXRDdXJyZW50RWplY3Rpb25QZXJjZW50KCkgK1xuICAgICAgICAgICAgJyBzdWNjZXNzUmF0ZXM9WycgK1xuICAgICAgICAgICAgc3VjY2Vzc1JhdGVzICtcbiAgICAgICAgICAgICddJyk7XG4gICAgICAgIGlmIChhZGRyZXNlc1dpdGhUYXJnZXRWb2x1bWUgPCBzdWNjZXNzUmF0ZUNvbmZpZy5taW5pbXVtX2hvc3RzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RlcCAyXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlTWVhbiA9IHN1Y2Nlc3NSYXRlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKSAvIHN1Y2Nlc3NSYXRlcy5sZW5ndGg7XG4gICAgICAgIGxldCBzdWNjZXNzUmF0ZURldmlhdGlvblN1bSA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgcmF0ZSBvZiBzdWNjZXNzUmF0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRldmlhdGlvbiA9IHJhdGUgLSBzdWNjZXNzUmF0ZU1lYW47XG4gICAgICAgICAgICBzdWNjZXNzUmF0ZURldmlhdGlvblN1bSArPSBkZXZpYXRpb24gKiBkZXZpYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VjY2Vzc1JhdGVWYXJpYW5jZSA9IHN1Y2Nlc3NSYXRlRGV2aWF0aW9uU3VtIC8gc3VjY2Vzc1JhdGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc3VjY2Vzc1JhdGVTdGRldiA9IE1hdGguc3FydChzdWNjZXNzUmF0ZVZhcmlhbmNlKTtcbiAgICAgICAgY29uc3QgZWplY3Rpb25UaHJlc2hvbGQgPSBzdWNjZXNzUmF0ZU1lYW4gLVxuICAgICAgICAgICAgc3VjY2Vzc1JhdGVTdGRldiAqIChzdWNjZXNzUmF0ZUNvbmZpZy5zdGRldl9mYWN0b3IgLyAxMDAwKTtcbiAgICAgICAgdHJhY2UoJ3N0ZGV2PScgKyBzdWNjZXNzUmF0ZVN0ZGV2ICsgJyBlamVjdGlvblRocmVzaG9sZD0nICsgZWplY3Rpb25UaHJlc2hvbGQpO1xuICAgICAgICAvLyBTdGVwIDNcbiAgICAgICAgZm9yIChjb25zdCBbYWRkcmVzcywgbWFwRW50cnldIG9mIHRoaXMuZW50cnlNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICAvLyBTdGVwIDMuaVxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCgpID49XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RDb25maWcuZ2V0TWF4RWplY3Rpb25QZXJjZW50KCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0ZXAgMy5paVxuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc2VzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0U3VjY2Vzc2VzKCk7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdEZhaWx1cmVzKCk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgZmFpbHVyZXMgPCB0YXJnZXRSZXF1ZXN0Vm9sdW1lKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGVwIDMuaWlpXG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZSA9IHN1Y2Nlc3NlcyAvIChzdWNjZXNzZXMgKyBmYWlsdXJlcyk7XG4gICAgICAgICAgICB0cmFjZSgnQ2hlY2tpbmcgY2FuZGlkYXRlICcgKyBhZGRyZXNzICsgJyBzdWNjZXNzUmF0ZT0nICsgc3VjY2Vzc1JhdGUpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NSYXRlIDwgZWplY3Rpb25UaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5kb21OdW1iZXIgPSBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgICAgICAgICAgIHRyYWNlKCdDYW5kaWRhdGUgJyArXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgK1xuICAgICAgICAgICAgICAgICAgICAnIHJhbmRvbU51bWJlcj0nICtcbiAgICAgICAgICAgICAgICAgICAgcmFuZG9tTnVtYmVyICtcbiAgICAgICAgICAgICAgICAgICAgJyBlbmZvcmNlbWVudF9wZXJjZW50YWdlPScgK1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzUmF0ZUNvbmZpZy5lbmZvcmNlbWVudF9wZXJjZW50YWdlKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZG9tTnVtYmVyIDwgc3VjY2Vzc1JhdGVDb25maWcuZW5mb3JjZW1lbnRfcGVyY2VudGFnZSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgnRWplY3RpbmcgY2FuZGlkYXRlICcgKyBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lamVjdChtYXBFbnRyeSwgZWplY3Rpb25UaW1lc3RhbXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5GYWlsdXJlUGVyY2VudGFnZUNoZWNrKGVqZWN0aW9uVGltZXN0YW1wKSB7XG4gICAgICAgIGlmICghdGhpcy5sYXRlc3RDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZyA9IHRoaXMubGF0ZXN0Q29uZmlnLmdldEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcoKTtcbiAgICAgICAgaWYgKCFmYWlsdXJlUGVyY2VudGFnZUNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlKCdSdW5uaW5nIGZhaWx1cmUgcGVyY2VudGFnZSBjaGVjay4gdGhyZXNob2xkPScgK1xuICAgICAgICAgICAgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcudGhyZXNob2xkICtcbiAgICAgICAgICAgICcgcmVxdWVzdCB2b2x1bWUgdGhyZXNob2xkPScgK1xuICAgICAgICAgICAgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcucmVxdWVzdF92b2x1bWUpO1xuICAgICAgICAvLyBTdGVwIDFcbiAgICAgICAgbGV0IGFkZHJlc3Nlc1dpdGhUYXJnZXRWb2x1bWUgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IG1hcEVudHJ5IG9mIHRoaXMuZW50cnlNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdFN1Y2Nlc3NlcygpO1xuICAgICAgICAgICAgY29uc3QgZmFpbHVyZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RGYWlsdXJlcygpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyArIGZhaWx1cmVzID49IGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLnJlcXVlc3Rfdm9sdW1lKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzV2l0aFRhcmdldFZvbHVtZSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRyZXNzZXNXaXRoVGFyZ2V0Vm9sdW1lIDwgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcubWluaW11bV9ob3N0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0ZXAgMlxuICAgICAgICBmb3IgKGNvbnN0IFthZGRyZXNzLCBtYXBFbnRyeV0gb2YgdGhpcy5lbnRyeU1hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIC8vIFN0ZXAgMi5pXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRDdXJyZW50RWplY3Rpb25QZXJjZW50KCkgPj1cbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdENvbmZpZy5nZXRNYXhFamVjdGlvblBlcmNlbnQoKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RlcCAyLmlpXG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RTdWNjZXNzZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0RmFpbHVyZXMoKTtcbiAgICAgICAgICAgIHRyYWNlKCdDYW5kaWRhdGUgc3VjY2Vzc2VzPScgKyBzdWNjZXNzZXMgKyAnIGZhaWx1cmVzPScgKyBmYWlsdXJlcyk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgZmFpbHVyZXMgPCBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5yZXF1ZXN0X3ZvbHVtZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RlcCAyLmlpaVxuICAgICAgICAgICAgY29uc3QgZmFpbHVyZVBlcmNlbnRhZ2UgPSAoZmFpbHVyZXMgKiAxMDApIC8gKGZhaWx1cmVzICsgc3VjY2Vzc2VzKTtcbiAgICAgICAgICAgIGlmIChmYWlsdXJlUGVyY2VudGFnZSA+IGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmRvbU51bWJlciA9IE1hdGgucmFuZG9tKCkgKiAxMDA7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ0NhbmRpZGF0ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyArXG4gICAgICAgICAgICAgICAgICAgICcgcmFuZG9tTnVtYmVyPScgK1xuICAgICAgICAgICAgICAgICAgICByYW5kb21OdW1iZXIgK1xuICAgICAgICAgICAgICAgICAgICAnIGVuZm9yY2VtZW50X3BlcmNlbnRhZ2U9JyArXG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLmVuZm9yY2VtZW50X3BlcmNlbnRhZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5kb21OdW1iZXIgPCBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5lbmZvcmNlbWVudF9wZXJjZW50YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdFamVjdGluZyBjYW5kaWRhdGUgJyArIGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVqZWN0KG1hcEVudHJ5LCBlamVjdGlvblRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVqZWN0KG1hcEVudHJ5LCBlamVjdGlvblRpbWVzdGFtcCkge1xuICAgICAgICBtYXBFbnRyeS5jdXJyZW50RWplY3Rpb25UaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBtYXBFbnRyeS5lamVjdGlvblRpbWVNdWx0aXBsaWVyICs9IDE7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgb2YgbWFwRW50cnkuc3ViY2hhbm5lbFdyYXBwZXJzKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsV3JhcHBlci5lamVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuZWplY3QobWFwRW50cnkpIHtcbiAgICAgICAgbWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBzdWJjaGFubmVsV3JhcHBlciBvZiBtYXBFbnRyeS5zdWJjaGFubmVsV3JhcHBlcnMpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWxXcmFwcGVyLnVuZWplY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2hBbGxCdWNrZXRzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IG1hcEVudHJ5IG9mIHRoaXMuZW50cnlNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIG1hcEVudHJ5LmNvdW50ZXIuc3dpdGNoQnVja2V0cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0VGltZXIoZGVsYXlNcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmVqZWN0aW9uVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMucnVuQ2hlY2tzKCksIGRlbGF5TXMpO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmVqZWN0aW9uVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgfVxuICAgIHJ1bkNoZWNrcygpIHtcbiAgICAgICAgY29uc3QgZWplY3Rpb25UaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0cmFjZSgnRWplY3Rpb24gdGltZXIgcnVubmluZycpO1xuICAgICAgICB0aGlzLnN3aXRjaEFsbEJ1Y2tldHMoKTtcbiAgICAgICAgaWYgKCF0aGlzLmxhdGVzdENvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltZXJTdGFydFRpbWUgPSBlamVjdGlvblRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5zdGFydFRpbWVyKHRoaXMubGF0ZXN0Q29uZmlnLmdldEludGVydmFsTXMoKSk7XG4gICAgICAgIHRoaXMucnVuU3VjY2Vzc1JhdGVDaGVjayhlamVjdGlvblRpbWVzdGFtcCk7XG4gICAgICAgIHRoaXMucnVuRmFpbHVyZVBlcmNlbnRhZ2VDaGVjayhlamVjdGlvblRpbWVzdGFtcCk7XG4gICAgICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIG1hcEVudHJ5XSBvZiB0aGlzLmVudHJ5TWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXBFbnRyeS5lamVjdGlvblRpbWVNdWx0aXBsaWVyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBtYXBFbnRyeS5lamVjdGlvblRpbWVNdWx0aXBsaWVyIC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUVqZWN0aW9uVGltZU1zID0gdGhpcy5sYXRlc3RDb25maWcuZ2V0QmFzZUVqZWN0aW9uVGltZU1zKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4RWplY3Rpb25UaW1lTXMgPSB0aGlzLmxhdGVzdENvbmZpZy5nZXRNYXhFamVjdGlvblRpbWVNcygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldHVyblRpbWUgPSBuZXcgRGF0ZShtYXBFbnRyeS5jdXJyZW50RWplY3Rpb25UaW1lc3RhbXAuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm5UaW1lLnNldE1pbGxpc2Vjb25kcyhyZXR1cm5UaW1lLmdldE1pbGxpc2Vjb25kcygpICtcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oYmFzZUVqZWN0aW9uVGltZU1zICogbWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciwgTWF0aC5tYXgoYmFzZUVqZWN0aW9uVGltZU1zLCBtYXhFamVjdGlvblRpbWVNcykpKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuVGltZSA8IG5ldyBEYXRlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ1VuZWplY3RpbmcgJyArIGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuZWplY3QobWFwRW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVBZGRyZXNzTGlzdChlbmRwb2ludExpc3QsIGxiQ29uZmlnLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghKGxiQ29uZmlnIGluc3RhbmNlb2YgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2UoJ1JlY2VpdmVkIHVwZGF0ZSB3aXRoIGNvbmZpZzogJyArIEpTT04uc3RyaW5naWZ5KGxiQ29uZmlnLnRvSnNvbk9iamVjdCgpLCB1bmRlZmluZWQsIDIpKTtcbiAgICAgICAgZm9yIChjb25zdCBlbmRwb2ludCBvZiBlbmRwb2ludExpc3QpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5lbnRyeU1hcC5oYXMoZW5kcG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ0FkZGluZyBtYXAgZW50cnkgZm9yICcgKyAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuZW5kcG9pbnRUb1N0cmluZykoZW5kcG9pbnQpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVudHJ5TWFwLnNldChlbmRwb2ludCwge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyOiBuZXcgQ2FsbENvdW50ZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEVqZWN0aW9uVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBlamVjdGlvblRpbWVNdWx0aXBsaWVyOiAwLFxuICAgICAgICAgICAgICAgICAgICBzdWJjaGFubmVsV3JhcHBlcnM6IFtdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW50cnlNYXAuZGVsZXRlTWlzc2luZyhlbmRwb2ludExpc3QpO1xuICAgICAgICBjb25zdCBjaGlsZFBvbGljeSA9IGxiQ29uZmlnLmdldENoaWxkUG9saWN5KCk7XG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlci51cGRhdGVBZGRyZXNzTGlzdChlbmRwb2ludExpc3QsIGNoaWxkUG9saWN5LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGxiQ29uZmlnLmdldFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcoKSB8fFxuICAgICAgICAgICAgbGJDb25maWcuZ2V0RmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbkNvbmZpZygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50aW1lclN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIHRyYWNlKCdQcmV2aW91cyB0aW1lciBleGlzdGVkLiBSZXBsYWNpbmcgdGltZXInKTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5lamVjdGlvblRpbWVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmdEZWxheSA9IGxiQ29uZmlnLmdldEludGVydmFsTXMoKSAtXG4gICAgICAgICAgICAgICAgICAgIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMudGltZXJTdGFydFRpbWUuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0VGltZXIocmVtYWluaW5nRGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ1N0YXJ0aW5nIG5ldyB0aW1lcicpO1xuICAgICAgICAgICAgICAgIHRoaXMudGltZXJTdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lcihsYkNvbmZpZy5nZXRJbnRlcnZhbE1zKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3dpdGNoQWxsQnVja2V0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJhY2UoJ0NvdW50aW5nIGRpc2FibGVkLiBDYW5jZWxsaW5nIHRpbWVyLicpO1xuICAgICAgICAgICAgdGhpcy50aW1lclN0YXJ0VGltZSA9IG51bGw7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5lamVjdGlvblRpbWVyKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWFwRW50cnkgb2YgdGhpcy5lbnRyeU1hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5lamVjdChtYXBFbnRyeSk7XG4gICAgICAgICAgICAgICAgbWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXRlc3RDb25maWcgPSBsYkNvbmZpZztcbiAgICB9XG4gICAgZXhpdElkbGUoKSB7XG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlci5leGl0SWRsZSgpO1xuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlci5yZXNldEJhY2tvZmYoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZWplY3Rpb25UaW1lcik7XG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGdldFR5cGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xuICAgIH1cbn1cbmV4cG9ydHMuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciA9IE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jZXI7XG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgICBpZiAoT1VUTElFUl9ERVRFQ1RJT05fRU5BQkxFRCkge1xuICAgICAgICAoMCwgZXhwZXJpbWVudGFsXzEucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlKShUWVBFX05BTUUsIE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jZXIsIE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLW91dGxpZXItZGV0ZWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJfYSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciIsIk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnIiwic2V0dXAiLCJjb25uZWN0aXZpdHlfc3RhdGVfMSIsInJlcXVpcmUiLCJjb25zdGFudHNfMSIsImR1cmF0aW9uXzEiLCJleHBlcmltZW50YWxfMSIsImxvYWRfYmFsYW5jZXJfMSIsImxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xIiwicGlja2VyXzEiLCJzdWJjaGFubmVsX2FkZHJlc3NfMSIsInN1YmNoYW5uZWxfaW50ZXJmYWNlXzEiLCJsb2dnaW5nIiwiVFJBQ0VSX05BTUUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIlRZUEVfTkFNRSIsIk9VVExJRVJfREVURUNUSU9OX0VOQUJMRUQiLCJwcm9jZXNzIiwiZW52IiwiR1JQQ19FWFBFUklNRU5UQUxfRU5BQkxFX09VVExJRVJfREVURUNUSU9OIiwiZGVmYXVsdFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWciLCJzdGRldl9mYWN0b3IiLCJlbmZvcmNlbWVudF9wZXJjZW50YWdlIiwibWluaW11bV9ob3N0cyIsInJlcXVlc3Rfdm9sdW1lIiwiZGVmYXVsdEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWciLCJ0aHJlc2hvbGQiLCJ2YWxpZGF0ZUZpZWxkVHlwZSIsIm9iaiIsImZpZWxkTmFtZSIsImV4cGVjdGVkVHlwZSIsIm9iamVjdE5hbWUiLCJ1bmRlZmluZWQiLCJmdWxsRmllbGROYW1lIiwiRXJyb3IiLCJ2YWxpZGF0ZVBvc2l0aXZlRHVyYXRpb24iLCJpc0R1cmF0aW9uIiwic2Vjb25kcyIsIm5hbm9zIiwidmFsaWRhdGVQZXJjZW50YWdlIiwiY29uc3RydWN0b3IiLCJpbnRlcnZhbE1zIiwiYmFzZUVqZWN0aW9uVGltZU1zIiwibWF4RWplY3Rpb25UaW1lTXMiLCJtYXhFamVjdGlvblBlcmNlbnQiLCJzdWNjZXNzUmF0ZUVqZWN0aW9uIiwiZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbiIsImNoaWxkUG9saWN5IiwiZ2V0TG9hZEJhbGFuY2VyTmFtZSIsImFzc2lnbiIsInRvSnNvbk9iamVjdCIsIl9iIiwib3V0bGllcl9kZXRlY3Rpb24iLCJpbnRlcnZhbCIsIm1zVG9EdXJhdGlvbiIsImJhc2VfZWplY3Rpb25fdGltZSIsIm1heF9lamVjdGlvbl90aW1lIiwibWF4X2VqZWN0aW9uX3BlcmNlbnQiLCJzdWNjZXNzX3JhdGVfZWplY3Rpb24iLCJmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24iLCJjaGlsZF9wb2xpY3kiLCJnZXRJbnRlcnZhbE1zIiwiZ2V0QmFzZUVqZWN0aW9uVGltZU1zIiwiZ2V0TWF4RWplY3Rpb25UaW1lTXMiLCJnZXRNYXhFamVjdGlvblBlcmNlbnQiLCJnZXRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnIiwiZ2V0RmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbkNvbmZpZyIsImdldENoaWxkUG9saWN5IiwiY3JlYXRlRnJvbUpzb24iLCJBcnJheSIsImlzQXJyYXkiLCJzZWxlY3RMYkNvbmZpZ0Zyb21MaXN0IiwiZHVyYXRpb25Ub01zIiwiT3V0bGllckRldGVjdGlvblN1YmNoYW5uZWxXcmFwcGVyIiwiQmFzZVN1YmNoYW5uZWxXcmFwcGVyIiwiY2hpbGRTdWJjaGFubmVsIiwibWFwRW50cnkiLCJyZWZDb3VudCIsInJlZiIsImNoaWxkIiwidW5yZWYiLCJpbmRleCIsInN1YmNoYW5uZWxXcmFwcGVycyIsImluZGV4T2YiLCJzcGxpY2UiLCJlamVjdCIsInNldEhlYWx0aHkiLCJ1bmVqZWN0IiwiZ2V0TWFwRW50cnkiLCJnZXRXcmFwcGVkU3ViY2hhbm5lbCIsImNyZWF0ZUVtcHR5QnVja2V0Iiwic3VjY2VzcyIsImZhaWx1cmUiLCJDYWxsQ291bnRlciIsImFjdGl2ZUJ1Y2tldCIsImluYWN0aXZlQnVja2V0IiwiYWRkU3VjY2VzcyIsImFkZEZhaWx1cmUiLCJzd2l0Y2hCdWNrZXRzIiwiZ2V0TGFzdFN1Y2Nlc3NlcyIsImdldExhc3RGYWlsdXJlcyIsIk91dGxpZXJEZXRlY3Rpb25QaWNrZXIiLCJ3cmFwcGVkUGlja2VyIiwiY291bnRDYWxscyIsInBpY2siLCJwaWNrQXJncyIsIndyYXBwZWRQaWNrIiwicGlja1Jlc3VsdFR5cGUiLCJQaWNrUmVzdWx0VHlwZSIsIkNPTVBMRVRFIiwic3ViY2hhbm5lbFdyYXBwZXIiLCJzdWJjaGFubmVsIiwib25DYWxsRW5kZWQiLCJzdGF0dXNDb2RlIiwiU3RhdHVzIiwiT0siLCJjb3VudGVyIiwiY2FsbCIsImNoYW5uZWxDb250cm9sSGVscGVyIiwiZW50cnlNYXAiLCJFbmRwb2ludE1hcCIsImxhdGVzdENvbmZpZyIsInRpbWVyU3RhcnRUaW1lIiwiY2hpbGRCYWxhbmNlciIsIkNoaWxkTG9hZEJhbGFuY2VySGFuZGxlciIsImNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIiLCJjcmVhdGVTdWJjaGFubmVsIiwic3ViY2hhbm5lbEFkZHJlc3MiLCJzdWJjaGFubmVsQXJncyIsIm9yaWdpbmFsU3ViY2hhbm5lbCIsImdldEZvclN1YmNoYW5uZWxBZGRyZXNzIiwiY3VycmVudEVqZWN0aW9uVGltZXN0YW1wIiwicHVzaCIsInVwZGF0ZVN0YXRlIiwiY29ubmVjdGl2aXR5U3RhdGUiLCJwaWNrZXIiLCJlcnJvck1lc3NhZ2UiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIlJFQURZIiwiaXNDb3VudGluZ0VuYWJsZWQiLCJlamVjdGlvblRpbWVyIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCIsImVqZWN0aW9uQ291bnQiLCJ2YWx1ZXMiLCJzaXplIiwicnVuU3VjY2Vzc1JhdGVDaGVjayIsImVqZWN0aW9uVGltZXN0YW1wIiwic3VjY2Vzc1JhdGVDb25maWciLCJ0YXJnZXRSZXF1ZXN0Vm9sdW1lIiwiYWRkcmVzZXNXaXRoVGFyZ2V0Vm9sdW1lIiwic3VjY2Vzc1JhdGVzIiwiZW5kcG9pbnQiLCJlbnRyaWVzIiwic3VjY2Vzc2VzIiwiZmFpbHVyZXMiLCJlbmRwb2ludFRvU3RyaW5nIiwic3VjY2Vzc1JhdGVNZWFuIiwicmVkdWNlIiwiYSIsImIiLCJsZW5ndGgiLCJzdWNjZXNzUmF0ZURldmlhdGlvblN1bSIsInJhdGUiLCJkZXZpYXRpb24iLCJzdWNjZXNzUmF0ZVZhcmlhbmNlIiwic3VjY2Vzc1JhdGVTdGRldiIsIk1hdGgiLCJzcXJ0IiwiZWplY3Rpb25UaHJlc2hvbGQiLCJhZGRyZXNzIiwic3VjY2Vzc1JhdGUiLCJyYW5kb21OdW1iZXIiLCJyYW5kb20iLCJydW5GYWlsdXJlUGVyY2VudGFnZUNoZWNrIiwiZmFpbHVyZVBlcmNlbnRhZ2VDb25maWciLCJhZGRyZXNzZXNXaXRoVGFyZ2V0Vm9sdW1lIiwiZmFpbHVyZVBlcmNlbnRhZ2UiLCJEYXRlIiwiZWplY3Rpb25UaW1lTXVsdGlwbGllciIsInN3aXRjaEFsbEJ1Y2tldHMiLCJzdGFydFRpbWVyIiwiZGVsYXlNcyIsInNldFRpbWVvdXQiLCJydW5DaGVja3MiLCJyZXR1cm5UaW1lIiwiZ2V0VGltZSIsInNldE1pbGxpc2Vjb25kcyIsImdldE1pbGxpc2Vjb25kcyIsIm1pbiIsIm1heCIsInVwZGF0ZUFkZHJlc3NMaXN0IiwiZW5kcG9pbnRMaXN0IiwibGJDb25maWciLCJvcHRpb25zIiwiSlNPTiIsInN0cmluZ2lmeSIsImhhcyIsInNldCIsImRlbGV0ZU1pc3NpbmciLCJjbGVhclRpbWVvdXQiLCJyZW1haW5pbmdEZWxheSIsImV4aXRJZGxlIiwicmVzZXRCYWNrb2ZmIiwiZGVzdHJveSIsImdldFR5cGVOYW1lIiwicmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LeafLoadBalancer = exports.PickFirstLoadBalancer = exports.PickFirstLoadBalancingConfig = void 0;\nexports.shuffled = shuffled;\nexports.setup = setup;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst subchannel_address_2 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst TRACER_NAME = \"pick_first\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = \"pick_first\";\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */ const CONNECTION_DELAY_INTERVAL_MS = 250;\nclass PickFirstLoadBalancingConfig {\n    constructor(shuffleAddressList){\n        this.shuffleAddressList = shuffleAddressList;\n    }\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    toJsonObject() {\n        return {\n            [TYPE_NAME]: {\n                shuffleAddressList: this.shuffleAddressList\n            }\n        };\n    }\n    getShuffleAddressList() {\n        return this.shuffleAddressList;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static createFromJson(obj) {\n        if (\"shuffleAddressList\" in obj && !(typeof obj.shuffleAddressList === \"boolean\")) {\n            throw new Error(\"pick_first config field shuffleAddressList must be a boolean if provided\");\n        }\n        return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);\n    }\n}\nexports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */ class PickFirstPicker {\n    constructor(subchannel){\n        this.subchannel = subchannel;\n    }\n    pick(pickArgs) {\n        return {\n            pickResultType: picker_1.PickResultType.COMPLETE,\n            subchannel: this.subchannel,\n            status: null,\n            onCallStarted: null,\n            onCallEnded: null\n        };\n    }\n}\n/**\n * Return a new array with the elements of the input array in a random order\n * @param list The input array\n * @returns A shuffled array of the elements of list\n */ function shuffled(list) {\n    const result = list.slice();\n    for(let i = result.length - 1; i > 1; i--){\n        const j = Math.floor(Math.random() * (i + 1));\n        const temp = result[i];\n        result[i] = result[j];\n        result[j] = temp;\n    }\n    return result;\n}\n/**\n * Interleave addresses in addressList by family in accordance with RFC-8304 section 4\n * @param addressList\n * @returns\n */ function interleaveAddressFamilies(addressList) {\n    if (addressList.length === 0) {\n        return [];\n    }\n    const result = [];\n    const ipv6Addresses = [];\n    const ipv4Addresses = [];\n    const ipv6First = (0, subchannel_address_2.isTcpSubchannelAddress)(addressList[0]) && (0, net_1.isIPv6)(addressList[0].host);\n    for (const address of addressList){\n        if ((0, subchannel_address_2.isTcpSubchannelAddress)(address) && (0, net_1.isIPv6)(address.host)) {\n            ipv6Addresses.push(address);\n        } else {\n            ipv4Addresses.push(address);\n        }\n    }\n    const firstList = ipv6First ? ipv6Addresses : ipv4Addresses;\n    const secondList = ipv6First ? ipv4Addresses : ipv6Addresses;\n    for(let i = 0; i < Math.max(firstList.length, secondList.length); i++){\n        if (i < firstList.length) {\n            result.push(firstList[i]);\n        }\n        if (i < secondList.length) {\n            result.push(secondList[i]);\n        }\n    }\n    return result;\n}\nconst REPORT_HEALTH_STATUS_OPTION_NAME = \"grpc-node.internal.pick-first.report_health_status\";\nclass PickFirstLoadBalancer {\n    /**\n     * Load balancer that attempts to connect to each backend in the address list\n     * in order, and picks the first one that connects, using it for every\n     * request.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     */ constructor(channelControlHelper){\n        this.channelControlHelper = channelControlHelper;\n        /**\n         * The list of subchannels this load balancer is currently attempting to\n         * connect to.\n         */ this.children = [];\n        /**\n         * The current connectivity state of the load balancer.\n         */ this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The index within the `subchannels` array of the subchannel with the most\n         * recently started connection attempt.\n         */ this.currentSubchannelIndex = 0;\n        /**\n         * The currently picked subchannel used for making calls. Populated if\n         * and only if the load balancer's current state is READY. In that case,\n         * the subchannel's current state is also READY.\n         */ this.currentPick = null;\n        /**\n         * Listener callback attached to each subchannel in the `subchannels` list\n         * while establishing a connection.\n         */ this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage)=>{\n            this.onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage);\n        };\n        this.pickedSubchannelHealthListener = ()=>this.calculateAndReportNewState();\n        /**\n         * The LB policy enters sticky TRANSIENT_FAILURE mode when all\n         * subchannels have failed to connect at least once, and it stays in that\n         * mode until a connection attempt is successful. While in sticky TF mode,\n         * the LB policy continuously attempts to connect to all of its subchannels.\n         */ this.stickyTransientFailureMode = false;\n        this.reportHealthStatus = false;\n        /**\n         * The most recent error reported by any subchannel as it transitioned to\n         * TRANSIENT_FAILURE.\n         */ this.lastError = null;\n        this.latestAddressList = null;\n        this.latestOptions = {};\n        this.connectionDelayTimeout = setTimeout(()=>{}, 0);\n        clearTimeout(this.connectionDelayTimeout);\n    }\n    allChildrenHaveReportedTF() {\n        return this.children.every((child)=>child.hasReportedTransientFailure);\n    }\n    resetChildrenReportedTF() {\n        this.children.every((child)=>child.hasReportedTransientFailure = false);\n    }\n    calculateAndReportNewState() {\n        var _a;\n        if (this.currentPick) {\n            if (this.reportHealthStatus && !this.currentPick.isHealthy()) {\n                const errorMessage = `Picked subchannel ${this.currentPick.getAddress()} is unhealthy`;\n                this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\n                    details: errorMessage\n                }), errorMessage);\n            } else {\n                this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(this.currentPick), null);\n            }\n        } else if (((_a = this.latestAddressList) === null || _a === void 0 ? void 0 : _a.length) === 0) {\n            const errorMessage = `No connection established. Last error: ${this.lastError}`;\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\n                details: errorMessage\n            }), errorMessage);\n        } else if (this.children.length === 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this), null);\n        } else {\n            if (this.stickyTransientFailureMode) {\n                const errorMessage = `No connection established. Last error: ${this.lastError}`;\n                this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\n                    details: errorMessage\n                }), errorMessage);\n            } else {\n                this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this), null);\n            }\n        }\n    }\n    requestReresolution() {\n        this.channelControlHelper.requestReresolution();\n    }\n    maybeEnterStickyTransientFailureMode() {\n        if (!this.allChildrenHaveReportedTF()) {\n            return;\n        }\n        this.requestReresolution();\n        this.resetChildrenReportedTF();\n        if (this.stickyTransientFailureMode) {\n            this.calculateAndReportNewState();\n            return;\n        }\n        this.stickyTransientFailureMode = true;\n        for (const { subchannel } of this.children){\n            subchannel.startConnecting();\n        }\n        this.calculateAndReportNewState();\n    }\n    removeCurrentPick() {\n        if (this.currentPick !== null) {\n            this.currentPick.removeConnectivityStateListener(this.subchannelStateListener);\n            this.channelControlHelper.removeChannelzChild(this.currentPick.getChannelzRef());\n            this.currentPick.removeHealthStateWatcher(this.pickedSubchannelHealthListener);\n            // Unref last, to avoid triggering listeners\n            this.currentPick.unref();\n            this.currentPick = null;\n        }\n    }\n    onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage) {\n        var _a;\n        if ((_a = this.currentPick) === null || _a === void 0 ? void 0 : _a.realSubchannelEquals(subchannel)) {\n            if (newState !== connectivity_state_1.ConnectivityState.READY) {\n                this.removeCurrentPick();\n                this.calculateAndReportNewState();\n            }\n            return;\n        }\n        for (const [index, child] of this.children.entries()){\n            if (subchannel.realSubchannelEquals(child.subchannel)) {\n                if (newState === connectivity_state_1.ConnectivityState.READY) {\n                    this.pickSubchannel(child.subchannel);\n                }\n                if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                    child.hasReportedTransientFailure = true;\n                    if (errorMessage) {\n                        this.lastError = errorMessage;\n                    }\n                    this.maybeEnterStickyTransientFailureMode();\n                    if (index === this.currentSubchannelIndex) {\n                        this.startNextSubchannelConnecting(index + 1);\n                    }\n                }\n                child.subchannel.startConnecting();\n                return;\n            }\n        }\n    }\n    startNextSubchannelConnecting(startIndex) {\n        clearTimeout(this.connectionDelayTimeout);\n        for (const [index, child] of this.children.entries()){\n            if (index >= startIndex) {\n                const subchannelState = child.subchannel.getConnectivityState();\n                if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                    this.startConnecting(index);\n                    return;\n                }\n            }\n        }\n        this.maybeEnterStickyTransientFailureMode();\n    }\n    /**\n     * Have a single subchannel in the `subchannels` list start connecting.\n     * @param subchannelIndex The index into the `subchannels` list.\n     */ startConnecting(subchannelIndex) {\n        var _a, _b;\n        clearTimeout(this.connectionDelayTimeout);\n        this.currentSubchannelIndex = subchannelIndex;\n        if (this.children[subchannelIndex].subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {\n            trace(\"Start connecting to subchannel with address \" + this.children[subchannelIndex].subchannel.getAddress());\n            process.nextTick(()=>{\n                var _a;\n                (_a = this.children[subchannelIndex]) === null || _a === void 0 ? void 0 : _a.subchannel.startConnecting();\n            });\n        }\n        this.connectionDelayTimeout = setTimeout(()=>{\n            this.startNextSubchannelConnecting(subchannelIndex + 1);\n        }, CONNECTION_DELAY_INTERVAL_MS);\n        (_b = (_a = this.connectionDelayTimeout).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * Declare that the specified subchannel should be used to make requests.\n     * This functions the same independent of whether subchannel is a member of\n     * this.children and whether it is equal to this.currentPick.\n     * Prerequisite: subchannel.getConnectivityState() === READY.\n     * @param subchannel\n     */ pickSubchannel(subchannel) {\n        trace(\"Pick subchannel with address \" + subchannel.getAddress());\n        this.stickyTransientFailureMode = false;\n        /* Ref before removeCurrentPick and resetSubchannelList to avoid the\n         * refcount dropping to 0 during this process. */ subchannel.ref();\n        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n        this.removeCurrentPick();\n        this.resetSubchannelList();\n        subchannel.addConnectivityStateListener(this.subchannelStateListener);\n        subchannel.addHealthStateWatcher(this.pickedSubchannelHealthListener);\n        this.currentPick = subchannel;\n        clearTimeout(this.connectionDelayTimeout);\n        this.calculateAndReportNewState();\n    }\n    updateState(newState, picker, errorMessage) {\n        trace(connectivity_state_1.ConnectivityState[this.currentState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker, errorMessage);\n    }\n    resetSubchannelList() {\n        for (const child of this.children){\n            /* Always remoev the connectivity state listener. If the subchannel is\n               getting picked, it will be re-added then. */ child.subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n            /* Refs are counted independently for the children list and the\n             * currentPick, so we call unref whether or not the child is the\n             * currentPick. Channelz child references are also refcounted, so\n             * removeChannelzChild can be handled the same way. */ child.subchannel.unref();\n            this.channelControlHelper.removeChannelzChild(child.subchannel.getChannelzRef());\n        }\n        this.currentSubchannelIndex = 0;\n        this.children = [];\n    }\n    connectToAddressList(addressList, options) {\n        trace(\"connectToAddressList([\" + addressList.map((address)=>(0, subchannel_address_1.subchannelAddressToString)(address)) + \"])\");\n        const newChildrenList = addressList.map((address)=>({\n                subchannel: this.channelControlHelper.createSubchannel(address, options),\n                hasReportedTransientFailure: false\n            }));\n        for (const { subchannel } of newChildrenList){\n            if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {\n                this.pickSubchannel(subchannel);\n                return;\n            }\n        }\n        /* Ref each subchannel before resetting the list, to ensure that\n         * subchannels shared between the list don't drop to 0 refs during the\n         * transition. */ for (const { subchannel } of newChildrenList){\n            subchannel.ref();\n            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n        }\n        this.resetSubchannelList();\n        this.children = newChildrenList;\n        for (const { subchannel } of this.children){\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\n        }\n        for (const child of this.children){\n            if (child.subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                child.hasReportedTransientFailure = true;\n            }\n        }\n        this.startNextSubchannelConnecting(0);\n        this.calculateAndReportNewState();\n    }\n    updateAddressList(endpointList, lbConfig, options) {\n        if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {\n            return;\n        }\n        this.reportHealthStatus = options[REPORT_HEALTH_STATUS_OPTION_NAME];\n        /* Previously, an update would be discarded if it was identical to the\n         * previous update, to minimize churn. Now the DNS resolver is\n         * rate-limited, so that is less of a concern. */ if (lbConfig.getShuffleAddressList()) {\n            endpointList = shuffled(endpointList);\n        }\n        const rawAddressList = [].concat(...endpointList.map((endpoint)=>endpoint.addresses));\n        trace(\"updateAddressList([\" + rawAddressList.map((address)=>(0, subchannel_address_1.subchannelAddressToString)(address)) + \"])\");\n        if (rawAddressList.length === 0) {\n            this.lastError = \"No addresses resolved\";\n        }\n        const addressList = interleaveAddressFamilies(rawAddressList);\n        this.latestAddressList = addressList;\n        this.latestOptions = options;\n        this.connectToAddressList(addressList, options);\n    }\n    exitIdle() {\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE && this.latestAddressList) {\n            this.connectToAddressList(this.latestAddressList, this.latestOptions);\n        }\n    }\n    resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n         * does nothing */ }\n    destroy() {\n        this.resetSubchannelList();\n        this.removeCurrentPick();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\nconst LEAF_CONFIG = new PickFirstLoadBalancingConfig(false);\n/**\n * This class handles the leaf load balancing operations for a single endpoint.\n * It is a thin wrapper around a PickFirstLoadBalancer with a different API\n * that more closely reflects how it will be used as a leaf balancer.\n */ class LeafLoadBalancer {\n    constructor(endpoint, channelControlHelper, options){\n        this.endpoint = endpoint;\n        this.options = options;\n        this.latestState = connectivity_state_1.ConnectivityState.IDLE;\n        const childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {\n            updateState: (connectivityState, picker, errorMessage)=>{\n                this.latestState = connectivityState;\n                this.latestPicker = picker;\n                channelControlHelper.updateState(connectivityState, picker, errorMessage);\n            }\n        });\n        this.pickFirstBalancer = new PickFirstLoadBalancer(childChannelControlHelper);\n        this.latestPicker = new picker_1.QueuePicker(this.pickFirstBalancer);\n    }\n    startConnecting() {\n        this.pickFirstBalancer.updateAddressList([\n            this.endpoint\n        ], LEAF_CONFIG, Object.assign(Object.assign({}, this.options), {\n            [REPORT_HEALTH_STATUS_OPTION_NAME]: true\n        }));\n    }\n    /**\n     * Update the endpoint associated with this LeafLoadBalancer to a new\n     * endpoint. Does not trigger connection establishment if a connection\n     * attempt is not already in progress.\n     * @param newEndpoint\n     */ updateEndpoint(newEndpoint, newOptions) {\n        this.options = newOptions;\n        this.endpoint = newEndpoint;\n        if (this.latestState !== connectivity_state_1.ConnectivityState.IDLE) {\n            this.startConnecting();\n        }\n    }\n    getConnectivityState() {\n        return this.latestState;\n    }\n    getPicker() {\n        return this.latestPicker;\n    }\n    getEndpoint() {\n        return this.endpoint;\n    }\n    exitIdle() {\n        this.pickFirstBalancer.exitIdle();\n    }\n    destroy() {\n        this.pickFirstBalancer.destroy();\n    }\n}\nexports.LeafLoadBalancer = LeafLoadBalancer;\nfunction setup() {\n    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);\n    (0, load_balancer_1.registerDefaultLoadBalancerType)(TYPE_NAME);\n} //# sourceMappingURL=load-balancer-pick-first.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1waWNrLWZpcnN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx3QkFBd0IsR0FBR0EsNkJBQTZCLEdBQUdBLG9DQUFvQyxHQUFHLEtBQUs7QUFDdkdBLGdCQUFnQixHQUFHSztBQUNuQkwsYUFBYSxHQUFHTTtBQUNoQixNQUFNQyxrQkFBa0JDLG1CQUFPQSxDQUFDLHNGQUFpQjtBQUNqRCxNQUFNQyx1QkFBdUJELG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNRSxXQUFXRixtQkFBT0EsQ0FBQyx3RUFBVTtBQUNuQyxNQUFNRyx1QkFBdUJILG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNSSxVQUFVSixtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNSyxjQUFjTCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNTSx1QkFBdUJOLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNTyxRQUFRUCxtQkFBT0EsQ0FBQyxnQkFBSztBQUMzQixNQUFNUSxjQUFjO0FBQ3BCLFNBQVNDLE1BQU1DLElBQUk7SUFDZk4sUUFBUUssS0FBSyxDQUFDSixZQUFZTSxZQUFZLENBQUNDLEtBQUssRUFBRUosYUFBYUU7QUFDL0Q7QUFDQSxNQUFNRyxZQUFZO0FBQ2xCOzs7Q0FHQyxHQUNELE1BQU1DLCtCQUErQjtBQUNyQyxNQUFNbEI7SUFDRm1CLFlBQVlDLGtCQUFrQixDQUFFO1FBQzVCLElBQUksQ0FBQ0Esa0JBQWtCLEdBQUdBO0lBQzlCO0lBQ0FDLHNCQUFzQjtRQUNsQixPQUFPSjtJQUNYO0lBQ0FLLGVBQWU7UUFDWCxPQUFPO1lBQ0gsQ0FBQ0wsVUFBVSxFQUFFO2dCQUNURyxvQkFBb0IsSUFBSSxDQUFDQSxrQkFBa0I7WUFDL0M7UUFD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QUFDLEdBQUcsSUFBSSxDQUFDdkIsT0FBTyxHQUFHO1lBQUUsQ0FBQ3BFLGlDQUFpQyxFQUFFO1FBQUs7SUFDcks7SUFDQTs7Ozs7S0FLQyxHQUNENEYsZUFBZUMsV0FBVyxFQUFFQyxVQUFVLEVBQUU7UUFDcEMsSUFBSSxDQUFDMUIsT0FBTyxHQUFHMEI7UUFDZixJQUFJLENBQUNoQixRQUFRLEdBQUdlO1FBQ2hCLElBQUksSUFBSSxDQUFDUixXQUFXLEtBQUs1SSxxQkFBcUIyRCxpQkFBaUIsQ0FBQ0MsSUFBSSxFQUFFO1lBQ2xFLElBQUksQ0FBQ29DLGVBQWU7UUFDeEI7SUFDSjtJQUNBYyx1QkFBdUI7UUFDbkIsT0FBTyxJQUFJLENBQUM4QixXQUFXO0lBQzNCO0lBQ0FVLFlBQVk7UUFDUixPQUFPLElBQUksQ0FBQ04sWUFBWTtJQUM1QjtJQUNBTyxjQUFjO1FBQ1YsT0FBTyxJQUFJLENBQUNsQixRQUFRO0lBQ3hCO0lBQ0FFLFdBQVc7UUFDUCxJQUFJLENBQUNVLGlCQUFpQixDQUFDVixRQUFRO0lBQ25DO0lBQ0FFLFVBQVU7UUFDTixJQUFJLENBQUNRLGlCQUFpQixDQUFDUixPQUFPO0lBQ2xDO0FBQ0o7QUFDQWxKLHdCQUF3QixHQUFHRTtBQUMzQixTQUFTSTtJQUNKLElBQUdDLGdCQUFnQjBKLHdCQUF3QixFQUFFNUksV0FBV2xCLHVCQUF1QkM7SUFDL0UsSUFBR0csZ0JBQWdCMkosK0JBQStCLEVBQUU3STtBQUN6RCxFQUNBLG9EQUFvRCIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1ob3VzaW5nLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLXBpY2stZmlyc3QuanM/NTM4MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MZWFmTG9hZEJhbGFuY2VyID0gZXhwb3J0cy5QaWNrRmlyc3RMb2FkQmFsYW5jZXIgPSBleHBvcnRzLlBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWcgPSB2b2lkIDA7XG5leHBvcnRzLnNodWZmbGVkID0gc2h1ZmZsZWQ7XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18yID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncGlja19maXJzdCc7XG5mdW5jdGlvbiB0cmFjZSh0ZXh0KSB7XG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcbn1cbmNvbnN0IFRZUEVfTkFNRSA9ICdwaWNrX2ZpcnN0Jztcbi8qKlxuICogRGVsYXkgYWZ0ZXIgc3RhcnRpbmcgYSBjb25uZWN0aW9uIG9uIGEgc3ViY2hhbm5lbCBiZWZvcmUgc3RhcnRpbmcgYVxuICogY29ubmVjdGlvbiBvbiB0aGUgbmV4dCBzdWJjaGFubmVsIGluIHRoZSBsaXN0LCBmb3IgSGFwcHkgRXllYmFsbHMgYWxnb3JpdGhtLlxuICovXG5jb25zdCBDT05ORUNUSU9OX0RFTEFZX0lOVEVSVkFMX01TID0gMjUwO1xuY2xhc3MgUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZyB7XG4gICAgY29uc3RydWN0b3Ioc2h1ZmZsZUFkZHJlc3NMaXN0KSB7XG4gICAgICAgIHRoaXMuc2h1ZmZsZUFkZHJlc3NMaXN0ID0gc2h1ZmZsZUFkZHJlc3NMaXN0O1xuICAgIH1cbiAgICBnZXRMb2FkQmFsYW5jZXJOYW1lKCkge1xuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xuICAgIH1cbiAgICB0b0pzb25PYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbVFlQRV9OQU1FXToge1xuICAgICAgICAgICAgICAgIHNodWZmbGVBZGRyZXNzTGlzdDogdGhpcy5zaHVmZmxlQWRkcmVzc0xpc3QsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRTaHVmZmxlQWRkcmVzc0xpc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNodWZmbGVBZGRyZXNzTGlzdDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgY3JlYXRlRnJvbUpzb24ob2JqKSB7XG4gICAgICAgIGlmICgnc2h1ZmZsZUFkZHJlc3NMaXN0JyBpbiBvYmogJiZcbiAgICAgICAgICAgICEodHlwZW9mIG9iai5zaHVmZmxlQWRkcmVzc0xpc3QgPT09ICdib29sZWFuJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGlja19maXJzdCBjb25maWcgZmllbGQgc2h1ZmZsZUFkZHJlc3NMaXN0IG11c3QgYmUgYSBib29sZWFuIGlmIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnKG9iai5zaHVmZmxlQWRkcmVzc0xpc3QgPT09IHRydWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZyA9IFBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWc7XG4vKipcbiAqIFBpY2tlciBmb3IgYSBgUGlja0ZpcnN0TG9hZEJhbGFuY2VyYCBpbiB0aGUgUkVBRFkgc3RhdGUuIEFsd2F5cyByZXR1cm5zIHRoZVxuICogcGlja2VkIHN1YmNoYW5uZWwuXG4gKi9cbmNsYXNzIFBpY2tGaXJzdFBpY2tlciB7XG4gICAgY29uc3RydWN0b3Ioc3ViY2hhbm5lbCkge1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWwgPSBzdWJjaGFubmVsO1xuICAgIH1cbiAgICBwaWNrKHBpY2tBcmdzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwaWNrUmVzdWx0VHlwZTogcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuQ09NUExFVEUsXG4gICAgICAgICAgICBzdWJjaGFubmVsOiB0aGlzLnN1YmNoYW5uZWwsXG4gICAgICAgICAgICBzdGF0dXM6IG51bGwsXG4gICAgICAgICAgICBvbkNhbGxTdGFydGVkOiBudWxsLFxuICAgICAgICAgICAgb25DYWxsRW5kZWQ6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm4gYSBuZXcgYXJyYXkgd2l0aCB0aGUgZWxlbWVudHMgb2YgdGhlIGlucHV0IGFycmF5IGluIGEgcmFuZG9tIG9yZGVyXG4gKiBAcGFyYW0gbGlzdCBUaGUgaW5wdXQgYXJyYXlcbiAqIEByZXR1cm5zIEEgc2h1ZmZsZWQgYXJyYXkgb2YgdGhlIGVsZW1lbnRzIG9mIGxpc3RcbiAqL1xuZnVuY3Rpb24gc2h1ZmZsZWQobGlzdCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGxpc3Quc2xpY2UoKTtcbiAgICBmb3IgKGxldCBpID0gcmVzdWx0Lmxlbmd0aCAtIDE7IGkgPiAxOyBpLS0pIHtcbiAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICBjb25zdCB0ZW1wID0gcmVzdWx0W2ldO1xuICAgICAgICByZXN1bHRbaV0gPSByZXN1bHRbal07XG4gICAgICAgIHJlc3VsdFtqXSA9IHRlbXA7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEludGVybGVhdmUgYWRkcmVzc2VzIGluIGFkZHJlc3NMaXN0IGJ5IGZhbWlseSBpbiBhY2NvcmRhbmNlIHdpdGggUkZDLTgzMDQgc2VjdGlvbiA0XG4gKiBAcGFyYW0gYWRkcmVzc0xpc3RcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGludGVybGVhdmVBZGRyZXNzRmFtaWxpZXMoYWRkcmVzc0xpc3QpIHtcbiAgICBpZiAoYWRkcmVzc0xpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgaXB2NkFkZHJlc3NlcyA9IFtdO1xuICAgIGNvbnN0IGlwdjRBZGRyZXNzZXMgPSBbXTtcbiAgICBjb25zdCBpcHY2Rmlyc3QgPSAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzIuaXNUY3BTdWJjaGFubmVsQWRkcmVzcykoYWRkcmVzc0xpc3RbMF0pICYmICgwLCBuZXRfMS5pc0lQdjYpKGFkZHJlc3NMaXN0WzBdLmhvc3QpO1xuICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBhZGRyZXNzTGlzdCkge1xuICAgICAgICBpZiAoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18yLmlzVGNwU3ViY2hhbm5lbEFkZHJlc3MpKGFkZHJlc3MpICYmICgwLCBuZXRfMS5pc0lQdjYpKGFkZHJlc3MuaG9zdCkpIHtcbiAgICAgICAgICAgIGlwdjZBZGRyZXNzZXMucHVzaChhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlwdjRBZGRyZXNzZXMucHVzaChhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmaXJzdExpc3QgPSBpcHY2Rmlyc3QgPyBpcHY2QWRkcmVzc2VzIDogaXB2NEFkZHJlc3NlcztcbiAgICBjb25zdCBzZWNvbmRMaXN0ID0gaXB2NkZpcnN0ID8gaXB2NEFkZHJlc3NlcyA6IGlwdjZBZGRyZXNzZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1heChmaXJzdExpc3QubGVuZ3RoLCBzZWNvbmRMaXN0Lmxlbmd0aCk7IGkrKykge1xuICAgICAgICBpZiAoaSA8IGZpcnN0TGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZpcnN0TGlzdFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCBzZWNvbmRMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc2Vjb25kTGlzdFtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IFJFUE9SVF9IRUFMVEhfU1RBVFVTX09QVElPTl9OQU1FID0gJ2dycGMtbm9kZS5pbnRlcm5hbC5waWNrLWZpcnN0LnJlcG9ydF9oZWFsdGhfc3RhdHVzJztcbmNsYXNzIFBpY2tGaXJzdExvYWRCYWxhbmNlciB7XG4gICAgLyoqXG4gICAgICogTG9hZCBiYWxhbmNlciB0aGF0IGF0dGVtcHRzIHRvIGNvbm5lY3QgdG8gZWFjaCBiYWNrZW5kIGluIHRoZSBhZGRyZXNzIGxpc3RcbiAgICAgKiBpbiBvcmRlciwgYW5kIHBpY2tzIHRoZSBmaXJzdCBvbmUgdGhhdCBjb25uZWN0cywgdXNpbmcgaXQgZm9yIGV2ZXJ5XG4gICAgICogcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gY2hhbm5lbENvbnRyb2xIZWxwZXIgYENoYW5uZWxDb250cm9sSGVscGVyYCBpbnN0YW5jZSBwcm92aWRlZCBieVxuICAgICAqICAgICB0aGlzIGxvYWQgYmFsYW5jZXIncyBvd25lci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsQ29udHJvbEhlbHBlcikge1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyID0gY2hhbm5lbENvbnRyb2xIZWxwZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGlzdCBvZiBzdWJjaGFubmVscyB0aGlzIGxvYWQgYmFsYW5jZXIgaXMgY3VycmVudGx5IGF0dGVtcHRpbmcgdG9cbiAgICAgICAgICogY29ubmVjdCB0by5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IGNvbm5lY3Rpdml0eSBzdGF0ZSBvZiB0aGUgbG9hZCBiYWxhbmNlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbmRleCB3aXRoaW4gdGhlIGBzdWJjaGFubmVsc2AgYXJyYXkgb2YgdGhlIHN1YmNoYW5uZWwgd2l0aCB0aGUgbW9zdFxuICAgICAgICAgKiByZWNlbnRseSBzdGFydGVkIGNvbm5lY3Rpb24gYXR0ZW1wdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFN1YmNoYW5uZWxJbmRleCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudGx5IHBpY2tlZCBzdWJjaGFubmVsIHVzZWQgZm9yIG1ha2luZyBjYWxscy4gUG9wdWxhdGVkIGlmXG4gICAgICAgICAqIGFuZCBvbmx5IGlmIHRoZSBsb2FkIGJhbGFuY2VyJ3MgY3VycmVudCBzdGF0ZSBpcyBSRUFEWS4gSW4gdGhhdCBjYXNlLFxuICAgICAgICAgKiB0aGUgc3ViY2hhbm5lbCdzIGN1cnJlbnQgc3RhdGUgaXMgYWxzbyBSRUFEWS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFBpY2sgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdGVuZXIgY2FsbGJhY2sgYXR0YWNoZWQgdG8gZWFjaCBzdWJjaGFubmVsIGluIHRoZSBgc3ViY2hhbm5lbHNgIGxpc3RcbiAgICAgICAgICogd2hpbGUgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIgPSAoc3ViY2hhbm5lbCwgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUsIGtlZXBhbGl2ZVRpbWUsIGVycm9yTWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vblN1YmNoYW5uZWxTdGF0ZVVwZGF0ZShzdWJjaGFubmVsLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5waWNrZWRTdWJjaGFubmVsSGVhbHRoTGlzdGVuZXIgPSAoKSA9PiB0aGlzLmNhbGN1bGF0ZUFuZFJlcG9ydE5ld1N0YXRlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgTEIgcG9saWN5IGVudGVycyBzdGlja3kgVFJBTlNJRU5UX0ZBSUxVUkUgbW9kZSB3aGVuIGFsbFxuICAgICAgICAgKiBzdWJjaGFubmVscyBoYXZlIGZhaWxlZCB0byBjb25uZWN0IGF0IGxlYXN0IG9uY2UsIGFuZCBpdCBzdGF5cyBpbiB0aGF0XG4gICAgICAgICAqIG1vZGUgdW50aWwgYSBjb25uZWN0aW9uIGF0dGVtcHQgaXMgc3VjY2Vzc2Z1bC4gV2hpbGUgaW4gc3RpY2t5IFRGIG1vZGUsXG4gICAgICAgICAqIHRoZSBMQiBwb2xpY3kgY29udGludW91c2x5IGF0dGVtcHRzIHRvIGNvbm5lY3QgdG8gYWxsIG9mIGl0cyBzdWJjaGFubmVscy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXBvcnRIZWFsdGhTdGF0dXMgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtb3N0IHJlY2VudCBlcnJvciByZXBvcnRlZCBieSBhbnkgc3ViY2hhbm5lbCBhcyBpdCB0cmFuc2l0aW9uZWQgdG9cbiAgICAgICAgICogVFJBTlNJRU5UX0ZBSUxVUkUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RFcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0QWRkcmVzc0xpc3QgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdE9wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7IH0sIDApO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0KTtcbiAgICB9XG4gICAgYWxsQ2hpbGRyZW5IYXZlUmVwb3J0ZWRURigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uZXZlcnkoY2hpbGQgPT4gY2hpbGQuaGFzUmVwb3J0ZWRUcmFuc2llbnRGYWlsdXJlKTtcbiAgICB9XG4gICAgcmVzZXRDaGlsZHJlblJlcG9ydGVkVEYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZXZlcnkoY2hpbGQgPT4gY2hpbGQuaGFzUmVwb3J0ZWRUcmFuc2llbnRGYWlsdXJlID0gZmFsc2UpO1xuICAgIH1cbiAgICBjYWxjdWxhdGVBbmRSZXBvcnROZXdTdGF0ZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGljaykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVwb3J0SGVhbHRoU3RhdHVzICYmICF0aGlzLmN1cnJlbnRQaWNrLmlzSGVhbHRoeSgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYFBpY2tlZCBzdWJjaGFubmVsICR7dGhpcy5jdXJyZW50UGljay5nZXRBZGRyZXNzKCl9IGlzIHVuaGVhbHRoeWA7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSwgbmV3IFBpY2tGaXJzdFBpY2tlcih0aGlzLmN1cnJlbnRQaWNrKSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKChfYSA9IHRoaXMubGF0ZXN0QWRkcmVzc0xpc3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgTm8gY29ubmVjdGlvbiBlc3RhYmxpc2hlZC4gTGFzdCBlcnJvcjogJHt0aGlzLmxhc3RFcnJvcn1gO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICB9KSwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFLCBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcyksIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgTm8gY29ubmVjdGlvbiBlc3RhYmxpc2hlZC4gTGFzdCBlcnJvcjogJHt0aGlzLmxhc3RFcnJvcn1gO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUsIG5ldyBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcih7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KSwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORywgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXF1ZXN0UmVyZXNvbHV0aW9uKCkge1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnJlcXVlc3RSZXJlc29sdXRpb24oKTtcbiAgICB9XG4gICAgbWF5YmVFbnRlclN0aWNreVRyYW5zaWVudEZhaWx1cmVNb2RlKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsQ2hpbGRyZW5IYXZlUmVwb3J0ZWRURigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVyZXNvbHV0aW9uKCk7XG4gICAgICAgIHRoaXMucmVzZXRDaGlsZHJlblJlcG9ydGVkVEYoKTtcbiAgICAgICAgaWYgKHRoaXMuc3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQW5kUmVwb3J0TmV3U3RhdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0aWNreVRyYW5zaWVudEZhaWx1cmVNb2RlID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCB7IHN1YmNoYW5uZWwgfSBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsLnN0YXJ0Q29ubmVjdGluZygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQW5kUmVwb3J0TmV3U3RhdGUoKTtcbiAgICB9XG4gICAgcmVtb3ZlQ3VycmVudFBpY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQaWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQaWNrLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnJlbW92ZUNoYW5uZWx6Q2hpbGQodGhpcy5jdXJyZW50UGljay5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBpY2sucmVtb3ZlSGVhbHRoU3RhdGVXYXRjaGVyKHRoaXMucGlja2VkU3ViY2hhbm5lbEhlYWx0aExpc3RlbmVyKTtcbiAgICAgICAgICAgIC8vIFVucmVmIGxhc3QsIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGlzdGVuZXJzXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQaWNrLnVucmVmKCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQaWNrID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblN1YmNoYW5uZWxTdGF0ZVVwZGF0ZShzdWJjaGFubmVsLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwgZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKChfYSA9IHRoaXMuY3VycmVudFBpY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWFsU3ViY2hhbm5lbEVxdWFscyhzdWJjaGFubmVsKSkge1xuICAgICAgICAgICAgaWYgKG5ld1N0YXRlICE9PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ3VycmVudFBpY2soKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUFuZFJlcG9ydE5ld1N0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGNoaWxkXSBvZiB0aGlzLmNoaWxkcmVuLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHN1YmNoYW5uZWwucmVhbFN1YmNoYW5uZWxFcXVhbHMoY2hpbGQuc3ViY2hhbm5lbCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGlja1N1YmNoYW5uZWwoY2hpbGQuc3ViY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuaGFzUmVwb3J0ZWRUcmFuc2llbnRGYWlsdXJlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0RXJyb3IgPSBlcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXliZUVudGVyU3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLmN1cnJlbnRTdWJjaGFubmVsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnROZXh0U3ViY2hhbm5lbENvbm5lY3RpbmcoaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGlsZC5zdWJjaGFubmVsLnN0YXJ0Q29ubmVjdGluZygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydE5leHRTdWJjaGFubmVsQ29ubmVjdGluZyhzdGFydEluZGV4KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25EZWxheVRpbWVvdXQpO1xuICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgY2hpbGRdIG9mIHRoaXMuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxTdGF0ZSA9IGNoaWxkLnN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViY2hhbm5lbFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFIHx8XG4gICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdGluZyhpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXliZUVudGVyU3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGF2ZSBhIHNpbmdsZSBzdWJjaGFubmVsIGluIHRoZSBgc3ViY2hhbm5lbHNgIGxpc3Qgc3RhcnQgY29ubmVjdGluZy5cbiAgICAgKiBAcGFyYW0gc3ViY2hhbm5lbEluZGV4IFRoZSBpbmRleCBpbnRvIHRoZSBgc3ViY2hhbm5lbHNgIGxpc3QuXG4gICAgICovXG4gICAgc3RhcnRDb25uZWN0aW5nKHN1YmNoYW5uZWxJbmRleCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2hhbm5lbEluZGV4ID0gc3ViY2hhbm5lbEluZGV4O1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltzdWJjaGFubmVsSW5kZXhdLnN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSA9PT1cbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpIHtcbiAgICAgICAgICAgIHRyYWNlKCdTdGFydCBjb25uZWN0aW5nIHRvIHN1YmNoYW5uZWwgd2l0aCBhZGRyZXNzICcgK1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bc3ViY2hhbm5lbEluZGV4XS5zdWJjaGFubmVsLmdldEFkZHJlc3MoKSk7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5jaGlsZHJlbltzdWJjaGFubmVsSW5kZXhdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3ViY2hhbm5lbC5zdGFydENvbm5lY3RpbmcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdGFydE5leHRTdWJjaGFubmVsQ29ubmVjdGluZyhzdWJjaGFubmVsSW5kZXggKyAxKTtcbiAgICAgICAgfSwgQ09OTkVDVElPTl9ERUxBWV9JTlRFUlZBTF9NUyk7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjbGFyZSB0aGF0IHRoZSBzcGVjaWZpZWQgc3ViY2hhbm5lbCBzaG91bGQgYmUgdXNlZCB0byBtYWtlIHJlcXVlc3RzLlxuICAgICAqIFRoaXMgZnVuY3Rpb25zIHRoZSBzYW1lIGluZGVwZW5kZW50IG9mIHdoZXRoZXIgc3ViY2hhbm5lbCBpcyBhIG1lbWJlciBvZlxuICAgICAqIHRoaXMuY2hpbGRyZW4gYW5kIHdoZXRoZXIgaXQgaXMgZXF1YWwgdG8gdGhpcy5jdXJyZW50UGljay5cbiAgICAgKiBQcmVyZXF1aXNpdGU6IHN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSA9PT0gUkVBRFkuXG4gICAgICogQHBhcmFtIHN1YmNoYW5uZWxcbiAgICAgKi9cbiAgICBwaWNrU3ViY2hhbm5lbChzdWJjaGFubmVsKSB7XG4gICAgICAgIHRyYWNlKCdQaWNrIHN1YmNoYW5uZWwgd2l0aCBhZGRyZXNzICcgKyBzdWJjaGFubmVsLmdldEFkZHJlc3MoKSk7XG4gICAgICAgIHRoaXMuc3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUgPSBmYWxzZTtcbiAgICAgICAgLyogUmVmIGJlZm9yZSByZW1vdmVDdXJyZW50UGljayBhbmQgcmVzZXRTdWJjaGFubmVsTGlzdCB0byBhdm9pZCB0aGVcbiAgICAgICAgICogcmVmY291bnQgZHJvcHBpbmcgdG8gMCBkdXJpbmcgdGhpcyBwcm9jZXNzLiAqL1xuICAgICAgICBzdWJjaGFubmVsLnJlZigpO1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLmFkZENoYW5uZWx6Q2hpbGQoc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgdGhpcy5yZW1vdmVDdXJyZW50UGljaygpO1xuICAgICAgICB0aGlzLnJlc2V0U3ViY2hhbm5lbExpc3QoKTtcbiAgICAgICAgc3ViY2hhbm5lbC5hZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICBzdWJjaGFubmVsLmFkZEhlYWx0aFN0YXRlV2F0Y2hlcih0aGlzLnBpY2tlZFN1YmNoYW5uZWxIZWFsdGhMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuY3VycmVudFBpY2sgPSBzdWJjaGFubmVsO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRSZXBvcnROZXdTdGF0ZSgpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdHJhY2UoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jdXJyZW50U3RhdGVdICtcbiAgICAgICAgICAgICcgLT4gJyArXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBwaWNrZXIsIGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIHJlc2V0U3ViY2hhbm5lbExpc3QoKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgLyogQWx3YXlzIHJlbW9ldiB0aGUgY29ubmVjdGl2aXR5IHN0YXRlIGxpc3RlbmVyLiBJZiB0aGUgc3ViY2hhbm5lbCBpc1xuICAgICAgICAgICAgICAgZ2V0dGluZyBwaWNrZWQsIGl0IHdpbGwgYmUgcmUtYWRkZWQgdGhlbi4gKi9cbiAgICAgICAgICAgIGNoaWxkLnN1YmNoYW5uZWwucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIC8qIFJlZnMgYXJlIGNvdW50ZWQgaW5kZXBlbmRlbnRseSBmb3IgdGhlIGNoaWxkcmVuIGxpc3QgYW5kIHRoZVxuICAgICAgICAgICAgICogY3VycmVudFBpY2ssIHNvIHdlIGNhbGwgdW5yZWYgd2hldGhlciBvciBub3QgdGhlIGNoaWxkIGlzIHRoZVxuICAgICAgICAgICAgICogY3VycmVudFBpY2suIENoYW5uZWx6IGNoaWxkIHJlZmVyZW5jZXMgYXJlIGFsc28gcmVmY291bnRlZCwgc29cbiAgICAgICAgICAgICAqIHJlbW92ZUNoYW5uZWx6Q2hpbGQgY2FuIGJlIGhhbmRsZWQgdGhlIHNhbWUgd2F5LiAqL1xuICAgICAgICAgICAgY2hpbGQuc3ViY2hhbm5lbC51bnJlZigpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkKGNoaWxkLnN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2hhbm5lbEluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIH1cbiAgICBjb25uZWN0VG9BZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgb3B0aW9ucykge1xuICAgICAgICB0cmFjZSgnY29ubmVjdFRvQWRkcmVzc0xpc3QoWycgKyBhZGRyZXNzTGlzdC5tYXAoYWRkcmVzcyA9PiAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZykoYWRkcmVzcykpICsgJ10pJyk7XG4gICAgICAgIGNvbnN0IG5ld0NoaWxkcmVuTGlzdCA9IGFkZHJlc3NMaXN0Lm1hcChhZGRyZXNzID0+ICh7XG4gICAgICAgICAgICBzdWJjaGFubmVsOiB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLmNyZWF0ZVN1YmNoYW5uZWwoYWRkcmVzcywgb3B0aW9ucyksXG4gICAgICAgICAgICBoYXNSZXBvcnRlZFRyYW5zaWVudEZhaWx1cmU6IGZhbHNlLFxuICAgICAgICB9KSk7XG4gICAgICAgIGZvciAoY29uc3QgeyBzdWJjaGFubmVsIH0gb2YgbmV3Q2hpbGRyZW5MaXN0KSB7XG4gICAgICAgICAgICBpZiAoc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGlja1N1YmNoYW5uZWwoc3ViY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIFJlZiBlYWNoIHN1YmNoYW5uZWwgYmVmb3JlIHJlc2V0dGluZyB0aGUgbGlzdCwgdG8gZW5zdXJlIHRoYXRcbiAgICAgICAgICogc3ViY2hhbm5lbHMgc2hhcmVkIGJldHdlZW4gdGhlIGxpc3QgZG9uJ3QgZHJvcCB0byAwIHJlZnMgZHVyaW5nIHRoZVxuICAgICAgICAgKiB0cmFuc2l0aW9uLiAqL1xuICAgICAgICBmb3IgKGNvbnN0IHsgc3ViY2hhbm5lbCB9IG9mIG5ld0NoaWxkcmVuTGlzdCkge1xuICAgICAgICAgICAgc3ViY2hhbm5lbC5yZWYoKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIuYWRkQ2hhbm5lbHpDaGlsZChzdWJjaGFubmVsLmdldENoYW5uZWx6UmVmKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzZXRTdWJjaGFubmVsTGlzdCgpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW5MaXN0O1xuICAgICAgICBmb3IgKGNvbnN0IHsgc3ViY2hhbm5lbCB9IG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWwuYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5zdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgPT09XG4gICAgICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5oYXNSZXBvcnRlZFRyYW5zaWVudEZhaWx1cmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnROZXh0U3ViY2hhbm5lbENvbm5lY3RpbmcoMCk7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQW5kUmVwb3J0TmV3U3RhdGUoKTtcbiAgICB9XG4gICAgdXBkYXRlQWRkcmVzc0xpc3QoZW5kcG9pbnRMaXN0LCBsYkNvbmZpZywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIShsYkNvbmZpZyBpbnN0YW5jZW9mIFBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBvcnRIZWFsdGhTdGF0dXMgPSBvcHRpb25zW1JFUE9SVF9IRUFMVEhfU1RBVFVTX09QVElPTl9OQU1FXTtcbiAgICAgICAgLyogUHJldmlvdXNseSwgYW4gdXBkYXRlIHdvdWxkIGJlIGRpc2NhcmRlZCBpZiBpdCB3YXMgaWRlbnRpY2FsIHRvIHRoZVxuICAgICAgICAgKiBwcmV2aW91cyB1cGRhdGUsIHRvIG1pbmltaXplIGNodXJuLiBOb3cgdGhlIEROUyByZXNvbHZlciBpc1xuICAgICAgICAgKiByYXRlLWxpbWl0ZWQsIHNvIHRoYXQgaXMgbGVzcyBvZiBhIGNvbmNlcm4uICovXG4gICAgICAgIGlmIChsYkNvbmZpZy5nZXRTaHVmZmxlQWRkcmVzc0xpc3QoKSkge1xuICAgICAgICAgICAgZW5kcG9pbnRMaXN0ID0gc2h1ZmZsZWQoZW5kcG9pbnRMaXN0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXdBZGRyZXNzTGlzdCA9IFtdLmNvbmNhdCguLi5lbmRwb2ludExpc3QubWFwKGVuZHBvaW50ID0+IGVuZHBvaW50LmFkZHJlc3NlcykpO1xuICAgICAgICB0cmFjZSgndXBkYXRlQWRkcmVzc0xpc3QoWycgKyByYXdBZGRyZXNzTGlzdC5tYXAoYWRkcmVzcyA9PiAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZykoYWRkcmVzcykpICsgJ10pJyk7XG4gICAgICAgIGlmIChyYXdBZGRyZXNzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEVycm9yID0gJ05vIGFkZHJlc3NlcyByZXNvbHZlZCc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzc0xpc3QgPSBpbnRlcmxlYXZlQWRkcmVzc0ZhbWlsaWVzKHJhd0FkZHJlc3NMaXN0KTtcbiAgICAgICAgdGhpcy5sYXRlc3RBZGRyZXNzTGlzdCA9IGFkZHJlc3NMaXN0O1xuICAgICAgICB0aGlzLmxhdGVzdE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNvbm5lY3RUb0FkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgZXhpdElkbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSAmJlxuICAgICAgICAgICAgdGhpcy5sYXRlc3RBZGRyZXNzTGlzdCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0VG9BZGRyZXNzTGlzdCh0aGlzLmxhdGVzdEFkZHJlc3NMaXN0LCB0aGlzLmxhdGVzdE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc2V0QmFja29mZigpIHtcbiAgICAgICAgLyogVGhlIHBpY2sgZmlyc3QgbG9hZCBiYWxhbmNlciBkb2VzIG5vdCBoYXZlIGEgY29ubmVjdGlvbiBiYWNrb2ZmLCBzbyB0aGlzXG4gICAgICAgICAqIGRvZXMgbm90aGluZyAqL1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlc2V0U3ViY2hhbm5lbExpc3QoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVDdXJyZW50UGljaygpO1xuICAgIH1cbiAgICBnZXRUeXBlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFRZUEVfTkFNRTtcbiAgICB9XG59XG5leHBvcnRzLlBpY2tGaXJzdExvYWRCYWxhbmNlciA9IFBpY2tGaXJzdExvYWRCYWxhbmNlcjtcbmNvbnN0IExFQUZfQ09ORklHID0gbmV3IFBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWcoZmFsc2UpO1xuLyoqXG4gKiBUaGlzIGNsYXNzIGhhbmRsZXMgdGhlIGxlYWYgbG9hZCBiYWxhbmNpbmcgb3BlcmF0aW9ucyBmb3IgYSBzaW5nbGUgZW5kcG9pbnQuXG4gKiBJdCBpcyBhIHRoaW4gd3JhcHBlciBhcm91bmQgYSBQaWNrRmlyc3RMb2FkQmFsYW5jZXIgd2l0aCBhIGRpZmZlcmVudCBBUElcbiAqIHRoYXQgbW9yZSBjbG9zZWx5IHJlZmxlY3RzIGhvdyBpdCB3aWxsIGJlIHVzZWQgYXMgYSBsZWFmIGJhbGFuY2VyLlxuICovXG5jbGFzcyBMZWFmTG9hZEJhbGFuY2VyIHtcbiAgICBjb25zdHJ1Y3RvcihlbmRwb2ludCwgY2hhbm5lbENvbnRyb2xIZWxwZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5lbmRwb2ludCA9IGVuZHBvaW50O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmxhdGVzdFN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgY29uc3QgY2hpbGRDaGFubmVsQ29udHJvbEhlbHBlciA9ICgwLCBsb2FkX2JhbGFuY2VyXzEuY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlcikoY2hhbm5lbENvbnRyb2xIZWxwZXIsIHtcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlOiAoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlciwgZXJyb3JNZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RTdGF0ZSA9IGNvbm5lY3Rpdml0eVN0YXRlO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0UGlja2VyID0gcGlja2VyO1xuICAgICAgICAgICAgICAgIGNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5waWNrRmlyc3RCYWxhbmNlciA9IG5ldyBQaWNrRmlyc3RMb2FkQmFsYW5jZXIoY2hpbGRDaGFubmVsQ29udHJvbEhlbHBlcik7XG4gICAgICAgIHRoaXMubGF0ZXN0UGlja2VyID0gbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMucGlja0ZpcnN0QmFsYW5jZXIpO1xuICAgIH1cbiAgICBzdGFydENvbm5lY3RpbmcoKSB7XG4gICAgICAgIHRoaXMucGlja0ZpcnN0QmFsYW5jZXIudXBkYXRlQWRkcmVzc0xpc3QoW3RoaXMuZW5kcG9pbnRdLCBMRUFGX0NPTkZJRywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpLCB7IFtSRVBPUlRfSEVBTFRIX1NUQVRVU19PUFRJT05fTkFNRV06IHRydWUgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGVuZHBvaW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIExlYWZMb2FkQmFsYW5jZXIgdG8gYSBuZXdcbiAgICAgKiBlbmRwb2ludC4gRG9lcyBub3QgdHJpZ2dlciBjb25uZWN0aW9uIGVzdGFibGlzaG1lbnQgaWYgYSBjb25uZWN0aW9uXG4gICAgICogYXR0ZW1wdCBpcyBub3QgYWxyZWFkeSBpbiBwcm9ncmVzcy5cbiAgICAgKiBAcGFyYW0gbmV3RW5kcG9pbnRcbiAgICAgKi9cbiAgICB1cGRhdGVFbmRwb2ludChuZXdFbmRwb2ludCwgbmV3T3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgICAgICB0aGlzLmVuZHBvaW50ID0gbmV3RW5kcG9pbnQ7XG4gICAgICAgIGlmICh0aGlzLmxhdGVzdFN0YXRlICE9PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdGluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXRlc3RTdGF0ZTtcbiAgICB9XG4gICAgZ2V0UGlja2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXRlc3RQaWNrZXI7XG4gICAgfVxuICAgIGdldEVuZHBvaW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmRwb2ludDtcbiAgICB9XG4gICAgZXhpdElkbGUoKSB7XG4gICAgICAgIHRoaXMucGlja0ZpcnN0QmFsYW5jZXIuZXhpdElkbGUoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5waWNrRmlyc3RCYWxhbmNlci5kZXN0cm95KCk7XG4gICAgfVxufVxuZXhwb3J0cy5MZWFmTG9hZEJhbGFuY2VyID0gTGVhZkxvYWRCYWxhbmNlcjtcbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgICgwLCBsb2FkX2JhbGFuY2VyXzEucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlKShUWVBFX05BTUUsIFBpY2tGaXJzdExvYWRCYWxhbmNlciwgUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZyk7XG4gICAgKDAsIGxvYWRfYmFsYW5jZXJfMS5yZWdpc3RlckRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlKShUWVBFX05BTUUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC1iYWxhbmNlci1waWNrLWZpcnN0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkxlYWZMb2FkQmFsYW5jZXIiLCJQaWNrRmlyc3RMb2FkQmFsYW5jZXIiLCJQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnIiwic2h1ZmZsZWQiLCJzZXR1cCIsImxvYWRfYmFsYW5jZXJfMSIsInJlcXVpcmUiLCJjb25uZWN0aXZpdHlfc3RhdGVfMSIsInBpY2tlcl8xIiwic3ViY2hhbm5lbF9hZGRyZXNzXzEiLCJsb2dnaW5nIiwiY29uc3RhbnRzXzEiLCJzdWJjaGFubmVsX2FkZHJlc3NfMiIsIm5ldF8xIiwiVFJBQ0VSX05BTUUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIlRZUEVfTkFNRSIsIkNPTk5FQ1RJT05fREVMQVlfSU5URVJWQUxfTVMiLCJjb25zdHJ1Y3RvciIsInNodWZmbGVBZGRyZXNzTGlzdCIsImdldExvYWRCYWxhbmNlck5hbWUiLCJ0b0pzb25PYmplY3QiLCJnZXRTaHVmZmxlQWRkcmVzc0xpc3QiLCJjcmVhdGVGcm9tSnNvbiIsIm9iaiIsIkVycm9yIiwiUGlja0ZpcnN0UGlja2VyIiwic3ViY2hhbm5lbCIsInBpY2siLCJwaWNrQXJncyIsInBpY2tSZXN1bHRUeXBlIiwiUGlja1Jlc3VsdFR5cGUiLCJDT01QTEVURSIsInN0YXR1cyIsIm9uQ2FsbFN0YXJ0ZWQiLCJvbkNhbGxFbmRlZCIsImxpc3QiLCJyZXN1bHQiLCJzbGljZSIsImkiLCJsZW5ndGgiLCJqIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwidGVtcCIsImludGVybGVhdmVBZGRyZXNzRmFtaWxpZXMiLCJhZGRyZXNzTGlzdCIsImlwdjZBZGRyZXNzZXMiLCJpcHY0QWRkcmVzc2VzIiwiaXB2NkZpcnN0IiwiaXNUY3BTdWJjaGFubmVsQWRkcmVzcyIsImlzSVB2NiIsImhvc3QiLCJhZGRyZXNzIiwicHVzaCIsImZpcnN0TGlzdCIsInNlY29uZExpc3QiLCJtYXgiLCJSRVBPUlRfSEVBTFRIX1NUQVRVU19PUFRJT05fTkFNRSIsImNoYW5uZWxDb250cm9sSGVscGVyIiwiY2hpbGRyZW4iLCJjdXJyZW50U3RhdGUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIklETEUiLCJjdXJyZW50U3ViY2hhbm5lbEluZGV4IiwiY3VycmVudFBpY2siLCJzdWJjaGFubmVsU3RhdGVMaXN0ZW5lciIsInByZXZpb3VzU3RhdGUiLCJuZXdTdGF0ZSIsImtlZXBhbGl2ZVRpbWUiLCJlcnJvck1lc3NhZ2UiLCJvblN1YmNoYW5uZWxTdGF0ZVVwZGF0ZSIsInBpY2tlZFN1YmNoYW5uZWxIZWFsdGhMaXN0ZW5lciIsImNhbGN1bGF0ZUFuZFJlcG9ydE5ld1N0YXRlIiwic3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUiLCJyZXBvcnRIZWFsdGhTdGF0dXMiLCJsYXN0RXJyb3IiLCJsYXRlc3RBZGRyZXNzTGlzdCIsImxhdGVzdE9wdGlvbnMiLCJjb25uZWN0aW9uRGVsYXlUaW1lb3V0Iiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsImFsbENoaWxkcmVuSGF2ZVJlcG9ydGVkVEYiLCJldmVyeSIsImNoaWxkIiwiaGFzUmVwb3J0ZWRUcmFuc2llbnRGYWlsdXJlIiwicmVzZXRDaGlsZHJlblJlcG9ydGVkVEYiLCJfYSIsImlzSGVhbHRoeSIsImdldEFkZHJlc3MiLCJ1cGRhdGVTdGF0ZSIsIlRSQU5TSUVOVF9GQUlMVVJFIiwiVW5hdmFpbGFibGVQaWNrZXIiLCJkZXRhaWxzIiwiUkVBRFkiLCJRdWV1ZVBpY2tlciIsIkNPTk5FQ1RJTkciLCJyZXF1ZXN0UmVyZXNvbHV0aW9uIiwibWF5YmVFbnRlclN0aWNreVRyYW5zaWVudEZhaWx1cmVNb2RlIiwic3RhcnRDb25uZWN0aW5nIiwicmVtb3ZlQ3VycmVudFBpY2siLCJyZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyIiwicmVtb3ZlQ2hhbm5lbHpDaGlsZCIsImdldENoYW5uZWx6UmVmIiwicmVtb3ZlSGVhbHRoU3RhdGVXYXRjaGVyIiwidW5yZWYiLCJyZWFsU3ViY2hhbm5lbEVxdWFscyIsImluZGV4IiwiZW50cmllcyIsInBpY2tTdWJjaGFubmVsIiwic3RhcnROZXh0U3ViY2hhbm5lbENvbm5lY3RpbmciLCJzdGFydEluZGV4Iiwic3ViY2hhbm5lbFN0YXRlIiwiZ2V0Q29ubmVjdGl2aXR5U3RhdGUiLCJzdWJjaGFubmVsSW5kZXgiLCJfYiIsInByb2Nlc3MiLCJuZXh0VGljayIsImNhbGwiLCJyZWYiLCJhZGRDaGFubmVsekNoaWxkIiwicmVzZXRTdWJjaGFubmVsTGlzdCIsImFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIiLCJhZGRIZWFsdGhTdGF0ZVdhdGNoZXIiLCJwaWNrZXIiLCJjb25uZWN0VG9BZGRyZXNzTGlzdCIsIm9wdGlvbnMiLCJtYXAiLCJzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nIiwibmV3Q2hpbGRyZW5MaXN0IiwiY3JlYXRlU3ViY2hhbm5lbCIsInVwZGF0ZUFkZHJlc3NMaXN0IiwiZW5kcG9pbnRMaXN0IiwibGJDb25maWciLCJyYXdBZGRyZXNzTGlzdCIsImNvbmNhdCIsImVuZHBvaW50IiwiYWRkcmVzc2VzIiwiZXhpdElkbGUiLCJyZXNldEJhY2tvZmYiLCJkZXN0cm95IiwiZ2V0VHlwZU5hbWUiLCJMRUFGX0NPTkZJRyIsImxhdGVzdFN0YXRlIiwiY2hpbGRDaGFubmVsQ29udHJvbEhlbHBlciIsImNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIiLCJjb25uZWN0aXZpdHlTdGF0ZSIsImxhdGVzdFBpY2tlciIsInBpY2tGaXJzdEJhbGFuY2VyIiwiYXNzaWduIiwidXBkYXRlRW5kcG9pbnQiLCJuZXdFbmRwb2ludCIsIm5ld09wdGlvbnMiLCJnZXRQaWNrZXIiLCJnZXRFbmRwb2ludCIsInJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSIsInJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RoundRobinLoadBalancer = void 0;\nexports.setup = setup;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst load_balancer_pick_first_1 = __webpack_require__(/*! ./load-balancer-pick-first */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\");\nconst TRACER_NAME = \"round_robin\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = \"round_robin\";\nclass RoundRobinLoadBalancingConfig {\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    constructor(){}\n    toJsonObject() {\n        return {\n            [TYPE_NAME]: {}\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static createFromJson(obj) {\n        return new RoundRobinLoadBalancingConfig();\n    }\n}\nclass RoundRobinPicker {\n    constructor(children, nextIndex = 0){\n        this.children = children;\n        this.nextIndex = nextIndex;\n    }\n    pick(pickArgs) {\n        const childPicker = this.children[this.nextIndex].picker;\n        this.nextIndex = (this.nextIndex + 1) % this.children.length;\n        return childPicker.pick(pickArgs);\n    }\n    /**\n     * Check what the next subchannel returned would be. Used by the load\n     * balancer implementation to preserve this part of the picker state if\n     * possible when a subchannel connects or disconnects.\n     */ peekNextEndpoint() {\n        return this.children[this.nextIndex].endpoint;\n    }\n}\nclass RoundRobinLoadBalancer {\n    constructor(channelControlHelper){\n        this.channelControlHelper = channelControlHelper;\n        this.children = [];\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        this.currentReadyPicker = null;\n        this.updatesPaused = false;\n        this.lastError = null;\n        this.childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {\n            updateState: (connectivityState, picker, errorMessage)=>{\n                /* Ensure that name resolution is requested again after active\n                 * connections are dropped. This is more aggressive than necessary to\n                 * accomplish that, so we are counting on resolvers to have\n                 * reasonable rate limits. */ if (this.currentState === connectivity_state_1.ConnectivityState.READY && connectivityState !== connectivity_state_1.ConnectivityState.READY) {\n                    this.channelControlHelper.requestReresolution();\n                }\n                if (errorMessage) {\n                    this.lastError = errorMessage;\n                }\n                this.calculateAndUpdateState();\n            }\n        });\n    }\n    countChildrenWithState(state) {\n        return this.children.filter((child)=>child.getConnectivityState() === state).length;\n    }\n    calculateAndUpdateState() {\n        if (this.updatesPaused) {\n            return;\n        }\n        if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.READY) > 0) {\n            const readyChildren = this.children.filter((child)=>child.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);\n            let index = 0;\n            if (this.currentReadyPicker !== null) {\n                const nextPickedEndpoint = this.currentReadyPicker.peekNextEndpoint();\n                index = readyChildren.findIndex((child)=>(0, subchannel_address_1.endpointEqual)(child.getEndpoint(), nextPickedEndpoint));\n                if (index < 0) {\n                    index = 0;\n                }\n            }\n            this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readyChildren.map((child)=>({\n                    endpoint: child.getEndpoint(),\n                    picker: child.getPicker()\n                })), index), null);\n        } else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.CONNECTING) > 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this), null);\n        } else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) > 0) {\n            const errorMessage = `round_robin: No connection established. Last error: ${this.lastError}`;\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\n                details: errorMessage\n            }), errorMessage);\n        } else {\n            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this), null);\n        }\n        /* round_robin should keep all children connected, this is how we do that.\n         * We can't do this more efficiently in the individual child's updateState\n         * callback because that doesn't have a reference to which child the state\n         * change is associated with. */ for (const child of this.children){\n            if (child.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {\n                child.exitIdle();\n            }\n        }\n    }\n    updateState(newState, picker, errorMessage) {\n        trace(connectivity_state_1.ConnectivityState[this.currentState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        if (newState === connectivity_state_1.ConnectivityState.READY) {\n            this.currentReadyPicker = picker;\n        } else {\n            this.currentReadyPicker = null;\n        }\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker, errorMessage);\n    }\n    resetSubchannelList() {\n        for (const child of this.children){\n            child.destroy();\n        }\n    }\n    updateAddressList(endpointList, lbConfig, options) {\n        this.resetSubchannelList();\n        trace(\"Connect to endpoint list \" + endpointList.map(subchannel_address_1.endpointToString));\n        this.updatesPaused = true;\n        this.children = endpointList.map((endpoint)=>new load_balancer_pick_first_1.LeafLoadBalancer(endpoint, this.childChannelControlHelper, options));\n        for (const child of this.children){\n            child.startConnecting();\n        }\n        this.updatesPaused = false;\n        this.calculateAndUpdateState();\n    }\n    exitIdle() {\n    /* The round_robin LB policy is only in the IDLE state if it has no\n         * addresses to try to connect to and it has no picked subchannel.\n         * In that case, there is no meaningful action that can be taken here. */ }\n    resetBackoff() {\n    // This LB policy has no backoff to reset\n    }\n    destroy() {\n        this.resetSubchannelList();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;\nfunction setup() {\n    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);\n} //# sourceMappingURL=load-balancer-round-robin.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1yb3VuZC1yb2Jpbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsOEJBQThCLEdBQUcsS0FBSztBQUN0Q0EsYUFBYSxHQUFHRztBQUNoQixNQUFNQyxrQkFBa0JDLG1CQUFPQSxDQUFDLHNGQUFpQjtBQUNqRCxNQUFNQyx1QkFBdUJELG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNRSxXQUFXRixtQkFBT0EsQ0FBQyx3RUFBVTtBQUNuQyxNQUFNRyxVQUFVSCxtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNSSxjQUFjSixtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNSyx1QkFBdUJMLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNTSw2QkFBNkJOLG1CQUFPQSxDQUFDLDRHQUE0QjtBQUN2RSxNQUFNTyxjQUFjO0FBQ3BCLFNBQVNDLE1BQU1DLElBQUk7SUFDZk4sUUFBUUssS0FBSyxDQUFDSixZQUFZTSxZQUFZLENBQUNDLEtBQUssRUFBRUosYUFBYUU7QUFDL0Q7QUFDQSxNQUFNRyxZQUFZO0FBQ2xCLE1BQU1DO0lBQ0ZDLHNCQUFzQjtRQUNsQixPQUFPRjtJQUNYO0lBQ0FHLGFBQWMsQ0FBRTtJQUNoQkMsZUFBZTtRQUNYLE9BQU87WUFDSCxDQUFDSixVQUFVLEVBQUUsQ0FBQztRQUNsQjtJQUNKO0lBQ0EsOERBQThEO0lBQzlELE9BQU9LLGVBQWVDLEdBQUcsRUFBRTtRQUN2QixPQUFPLElBQUlMO0lBQ2Y7QUFDSjtBQUNBLE1BQU1NO0lBQ0ZKLFlBQVlLLFFBQVEsRUFBRUMsWUFBWSxDQUFDLENBQUU7UUFDakMsSUFBSSxDQUFDRCxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtJQUNyQjtJQUNBQyxLQUFLQyxRQUFRLEVBQUU7UUFDWCxNQUFNQyxjQUFjLElBQUksQ0FBQ0osUUFBUSxDQUFDLElBQUksQ0FBQ0MsU0FBUyxDQUFDLENBQUNJLE1BQU07UUFDeEQsSUFBSSxDQUFDSixTQUFTLEdBQUcsQ0FBQyxJQUFJLENBQUNBLFNBQVMsR0FBRyxLQUFLLElBQUksQ0FBQ0QsUUFBUSxDQUFDTSxNQUFNO1FBQzVELE9BQU9GLFlBQVlGLElBQUksQ0FBQ0M7SUFDNUI7SUFDQTs7OztLQUlDLEdBQ0RJLG1CQUFtQjtRQUNmLE9BQU8sSUFBSSxDQUFDUCxRQUFRLENBQUMsSUFBSSxDQUFDQyxTQUFTLENBQUMsQ0FBQ08sUUFBUTtJQUNqRDtBQUNKO0FBQ0EsTUFBTS9CO0lBQ0ZrQixZQUFZYyxvQkFBb0IsQ0FBRTtRQUM5QixJQUFJLENBQUNBLG9CQUFvQixHQUFHQTtRQUM1QixJQUFJLENBQUNULFFBQVEsR0FBRyxFQUFFO1FBQ2xCLElBQUksQ0FBQ1UsWUFBWSxHQUFHN0IscUJBQXFCOEIsaUJBQWlCLENBQUNDLElBQUk7UUFDL0QsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztRQUMxQixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNDLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNDLHlCQUF5QixHQUFHLENBQUMsR0FBR3JDLGdCQUFnQnNDLCtCQUErQixFQUFFUixzQkFBc0I7WUFDeEdTLGFBQWEsQ0FBQ0MsbUJBQW1CZCxRQUFRZTtnQkFDckM7OzsyQ0FHMkIsR0FDM0IsSUFBSSxJQUFJLENBQUNWLFlBQVksS0FBSzdCLHFCQUFxQjhCLGlCQUFpQixDQUFDVSxLQUFLLElBQUlGLHNCQUFzQnRDLHFCQUFxQjhCLGlCQUFpQixDQUFDVSxLQUFLLEVBQUU7b0JBQzFJLElBQUksQ0FBQ1osb0JBQW9CLENBQUNhLG1CQUFtQjtnQkFDakQ7Z0JBQ0EsSUFBSUYsY0FBYztvQkFDZCxJQUFJLENBQUNMLFNBQVMsR0FBR0s7Z0JBQ3JCO2dCQUNBLElBQUksQ0FBQ0csdUJBQXVCO1lBQ2hDO1FBQ0o7SUFDSjtJQUNBQyx1QkFBdUJDLEtBQUssRUFBRTtRQUMxQixPQUFPLElBQUksQ0FBQ3pCLFFBQVEsQ0FBQzBCLE1BQU0sQ0FBQ0MsQ0FBQUEsUUFBU0EsTUFBTUMsb0JBQW9CLE9BQU9ILE9BQ2pFbkIsTUFBTTtJQUNmO0lBQ0FpQiwwQkFBMEI7UUFDdEIsSUFBSSxJQUFJLENBQUNULGFBQWEsRUFBRTtZQUNwQjtRQUNKO1FBQ0EsSUFBSSxJQUFJLENBQUNVLHNCQUFzQixDQUFDM0MscUJBQXFCOEIsaUJBQWlCLENBQUNVLEtBQUssSUFBSSxHQUFHO1lBQy9FLE1BQU1RLGdCQUFnQixJQUFJLENBQUM3QixRQUFRLENBQUMwQixNQUFNLENBQUNDLENBQUFBLFFBQVNBLE1BQU1DLG9CQUFvQixPQUFPL0MscUJBQXFCOEIsaUJBQWlCLENBQUNVLEtBQUs7WUFDakksSUFBSVMsUUFBUTtZQUNaLElBQUksSUFBSSxDQUFDakIsa0JBQWtCLEtBQUssTUFBTTtnQkFDbEMsTUFBTWtCLHFCQUFxQixJQUFJLENBQUNsQixrQkFBa0IsQ0FBQ04sZ0JBQWdCO2dCQUNuRXVCLFFBQVFELGNBQWNHLFNBQVMsQ0FBQ0wsQ0FBQUEsUUFBUyxDQUFDLEdBQUcxQyxxQkFBcUJnRCxhQUFhLEVBQUVOLE1BQU1PLFdBQVcsSUFBSUg7Z0JBQ3RHLElBQUlELFFBQVEsR0FBRztvQkFDWEEsUUFBUTtnQkFDWjtZQUNKO1lBQ0EsSUFBSSxDQUFDWixXQUFXLENBQUNyQyxxQkFBcUI4QixpQkFBaUIsQ0FBQ1UsS0FBSyxFQUFFLElBQUl0QixpQkFBaUI4QixjQUFjTSxHQUFHLENBQUNSLENBQUFBLFFBQVU7b0JBQzVHbkIsVUFBVW1CLE1BQU1PLFdBQVc7b0JBQzNCN0IsUUFBUXNCLE1BQU1TLFNBQVM7Z0JBQzNCLEtBQUtOLFFBQVE7UUFDakIsT0FDSyxJQUFJLElBQUksQ0FBQ04sc0JBQXNCLENBQUMzQyxxQkFBcUI4QixpQkFBaUIsQ0FBQzBCLFVBQVUsSUFBSSxHQUFHO1lBQ3pGLElBQUksQ0FBQ25CLFdBQVcsQ0FBQ3JDLHFCQUFxQjhCLGlCQUFpQixDQUFDMEIsVUFBVSxFQUFFLElBQUl2RCxTQUFTd0QsV0FBVyxDQUFDLElBQUksR0FBRztRQUN4RyxPQUNLLElBQUksSUFBSSxDQUFDZCxzQkFBc0IsQ0FBQzNDLHFCQUFxQjhCLGlCQUFpQixDQUFDNEIsaUJBQWlCLElBQUksR0FBRztZQUNoRyxNQUFNbkIsZUFBZSxDQUFDLG9EQUFvRCxFQUFFLElBQUksQ0FBQ0wsU0FBUyxDQUFDLENBQUM7WUFDNUYsSUFBSSxDQUFDRyxXQUFXLENBQUNyQyxxQkFBcUI4QixpQkFBaUIsQ0FBQzRCLGlCQUFpQixFQUFFLElBQUl6RCxTQUFTMEQsaUJBQWlCLENBQUM7Z0JBQ3RHQyxTQUFTckI7WUFDYixJQUFJQTtRQUNSLE9BQ0s7WUFDRCxJQUFJLENBQUNGLFdBQVcsQ0FBQ3JDLHFCQUFxQjhCLGlCQUFpQixDQUFDQyxJQUFJLEVBQUUsSUFBSTlCLFNBQVN3RCxXQUFXLENBQUMsSUFBSSxHQUFHO1FBQ2xHO1FBQ0E7OztzQ0FHOEIsR0FDOUIsS0FBSyxNQUFNWCxTQUFTLElBQUksQ0FBQzNCLFFBQVEsQ0FBRTtZQUMvQixJQUFJMkIsTUFBTUMsb0JBQW9CLE9BQU8vQyxxQkFBcUI4QixpQkFBaUIsQ0FBQ0MsSUFBSSxFQUFFO2dCQUM5RWUsTUFBTWUsUUFBUTtZQUNsQjtRQUNKO0lBQ0o7SUFDQXhCLFlBQVl5QixRQUFRLEVBQUV0QyxNQUFNLEVBQUVlLFlBQVksRUFBRTtRQUN4Q2hDLE1BQU1QLHFCQUFxQjhCLGlCQUFpQixDQUFDLElBQUksQ0FBQ0QsWUFBWSxDQUFDLEdBQzNELFNBQ0E3QixxQkFBcUI4QixpQkFBaUIsQ0FBQ2dDLFNBQVM7UUFDcEQsSUFBSUEsYUFBYTlELHFCQUFxQjhCLGlCQUFpQixDQUFDVSxLQUFLLEVBQUU7WUFDM0QsSUFBSSxDQUFDUixrQkFBa0IsR0FBR1I7UUFDOUIsT0FDSztZQUNELElBQUksQ0FBQ1Esa0JBQWtCLEdBQUc7UUFDOUI7UUFDQSxJQUFJLENBQUNILFlBQVksR0FBR2lDO1FBQ3BCLElBQUksQ0FBQ2xDLG9CQUFvQixDQUFDUyxXQUFXLENBQUN5QixVQUFVdEMsUUFBUWU7SUFDNUQ7SUFDQXdCLHNCQUFzQjtRQUNsQixLQUFLLE1BQU1qQixTQUFTLElBQUksQ0FBQzNCLFFBQVEsQ0FBRTtZQUMvQjJCLE1BQU1rQixPQUFPO1FBQ2pCO0lBQ0o7SUFDQUMsa0JBQWtCQyxZQUFZLEVBQUVDLFFBQVEsRUFBRUMsT0FBTyxFQUFFO1FBQy9DLElBQUksQ0FBQ0wsbUJBQW1CO1FBQ3hCeEQsTUFBTSw4QkFBOEIyRCxhQUFhWixHQUFHLENBQUNsRCxxQkFBcUJpRSxnQkFBZ0I7UUFDMUYsSUFBSSxDQUFDcEMsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ2QsUUFBUSxHQUFHK0MsYUFBYVosR0FBRyxDQUFDM0IsQ0FBQUEsV0FBWSxJQUFJdEIsMkJBQTJCaUUsZ0JBQWdCLENBQUMzQyxVQUFVLElBQUksQ0FBQ1EseUJBQXlCLEVBQUVpQztRQUN2SSxLQUFLLE1BQU10QixTQUFTLElBQUksQ0FBQzNCLFFBQVEsQ0FBRTtZQUMvQjJCLE1BQU15QixlQUFlO1FBQ3pCO1FBQ0EsSUFBSSxDQUFDdEMsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ1MsdUJBQXVCO0lBQ2hDO0lBQ0FtQixXQUFXO0lBQ1A7OytFQUV1RSxHQUMzRTtJQUNBVyxlQUFlO0lBQ1gseUNBQXlDO0lBQzdDO0lBQ0FSLFVBQVU7UUFDTixJQUFJLENBQUNELG1CQUFtQjtJQUM1QjtJQUNBVSxjQUFjO1FBQ1YsT0FBTzlEO0lBQ1g7QUFDSjtBQUNBakIsOEJBQThCLEdBQUdFO0FBQ2pDLFNBQVNDO0lBQ0osSUFBR0MsZ0JBQWdCNEUsd0JBQXdCLEVBQUUvRCxXQUFXZix3QkFBd0JnQjtBQUNyRixFQUNBLHFEQUFxRCIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1ob3VzaW5nLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLXJvdW5kLXJvYmluLmpzPzllZDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUm91bmRSb2JpbkxvYWRCYWxhbmNlciA9IHZvaWQgMDtcbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IHBpY2tlcl8xID0gcmVxdWlyZShcIi4vcGlja2VyXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgbG9hZF9iYWxhbmNlcl9waWNrX2ZpcnN0XzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLXBpY2stZmlyc3RcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdyb3VuZF9yb2Jpbic7XG5mdW5jdGlvbiB0cmFjZSh0ZXh0KSB7XG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcbn1cbmNvbnN0IFRZUEVfTkFNRSA9ICdyb3VuZF9yb2Jpbic7XG5jbGFzcyBSb3VuZFJvYmluTG9hZEJhbGFuY2luZ0NvbmZpZyB7XG4gICAgZ2V0TG9hZEJhbGFuY2VyTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFRZUEVfTkFNRTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICB0b0pzb25PYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbVFlQRV9OQU1FXToge30sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIGNyZWF0ZUZyb21Kc29uKG9iaikge1xuICAgICAgICByZXR1cm4gbmV3IFJvdW5kUm9iaW5Mb2FkQmFsYW5jaW5nQ29uZmlnKCk7XG4gICAgfVxufVxuY2xhc3MgUm91bmRSb2JpblBpY2tlciB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4sIG5leHRJbmRleCA9IDApIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLm5leHRJbmRleCA9IG5leHRJbmRleDtcbiAgICB9XG4gICAgcGljayhwaWNrQXJncykge1xuICAgICAgICBjb25zdCBjaGlsZFBpY2tlciA9IHRoaXMuY2hpbGRyZW5bdGhpcy5uZXh0SW5kZXhdLnBpY2tlcjtcbiAgICAgICAgdGhpcy5uZXh0SW5kZXggPSAodGhpcy5uZXh0SW5kZXggKyAxKSAlIHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gY2hpbGRQaWNrZXIucGljayhwaWNrQXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoYXQgdGhlIG5leHQgc3ViY2hhbm5lbCByZXR1cm5lZCB3b3VsZCBiZS4gVXNlZCBieSB0aGUgbG9hZFxuICAgICAqIGJhbGFuY2VyIGltcGxlbWVudGF0aW9uIHRvIHByZXNlcnZlIHRoaXMgcGFydCBvZiB0aGUgcGlja2VyIHN0YXRlIGlmXG4gICAgICogcG9zc2libGUgd2hlbiBhIHN1YmNoYW5uZWwgY29ubmVjdHMgb3IgZGlzY29ubmVjdHMuXG4gICAgICovXG4gICAgcGVla05leHRFbmRwb2ludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bdGhpcy5uZXh0SW5kZXhdLmVuZHBvaW50O1xuICAgIH1cbn1cbmNsYXNzIFJvdW5kUm9iaW5Mb2FkQmFsYW5jZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxDb250cm9sSGVscGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIgPSBjaGFubmVsQ29udHJvbEhlbHBlcjtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIHRoaXMuY3VycmVudFJlYWR5UGlja2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy51cGRhdGVzUGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdEVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGlsZENoYW5uZWxDb250cm9sSGVscGVyID0gKDAsIGxvYWRfYmFsYW5jZXJfMS5jcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyKShjaGFubmVsQ29udHJvbEhlbHBlciwge1xuICAgICAgICAgICAgdXBkYXRlU3RhdGU6IChjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAvKiBFbnN1cmUgdGhhdCBuYW1lIHJlc29sdXRpb24gaXMgcmVxdWVzdGVkIGFnYWluIGFmdGVyIGFjdGl2ZVxuICAgICAgICAgICAgICAgICAqIGNvbm5lY3Rpb25zIGFyZSBkcm9wcGVkLiBUaGlzIGlzIG1vcmUgYWdncmVzc2l2ZSB0aGFuIG5lY2Vzc2FyeSB0b1xuICAgICAgICAgICAgICAgICAqIGFjY29tcGxpc2ggdGhhdCwgc28gd2UgYXJlIGNvdW50aW5nIG9uIHJlc29sdmVycyB0byBoYXZlXG4gICAgICAgICAgICAgICAgICogcmVhc29uYWJsZSByYXRlIGxpbWl0cy4gKi9cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZICYmIGNvbm5lY3Rpdml0eVN0YXRlICE9PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnJlcXVlc3RSZXJlc29sdXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RFcnJvciA9IGVycm9yTWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRVcGRhdGVTdGF0ZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvdW50Q2hpbGRyZW5XaXRoU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+IGNoaWxkLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgPT09IHN0YXRlKVxuICAgICAgICAgICAgLmxlbmd0aDtcbiAgICB9XG4gICAgY2FsY3VsYXRlQW5kVXBkYXRlU3RhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb3VudENoaWxkcmVuV2l0aFN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWR5Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLmZpbHRlcihjaGlsZCA9PiBjaGlsZC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSk7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFJlYWR5UGlja2VyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFBpY2tlZEVuZHBvaW50ID0gdGhpcy5jdXJyZW50UmVhZHlQaWNrZXIucGVla05leHRFbmRwb2ludCgpO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gcmVhZHlDaGlsZHJlbi5maW5kSW5kZXgoY2hpbGQgPT4gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLmVuZHBvaW50RXF1YWwpKGNoaWxkLmdldEVuZHBvaW50KCksIG5leHRQaWNrZWRFbmRwb2ludCkpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFksIG5ldyBSb3VuZFJvYmluUGlja2VyKHJlYWR5Q2hpbGRyZW4ubWFwKGNoaWxkID0+ICh7XG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IGNoaWxkLmdldEVuZHBvaW50KCksXG4gICAgICAgICAgICAgICAgcGlja2VyOiBjaGlsZC5nZXRQaWNrZXIoKSxcbiAgICAgICAgICAgIH0pKSwgaW5kZXgpLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvdW50Q2hpbGRyZW5XaXRoU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORykgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb3VudENoaWxkcmVuV2l0aFN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGByb3VuZF9yb2JpbjogTm8gY29ubmVjdGlvbiBlc3RhYmxpc2hlZC4gTGFzdCBlcnJvcjogJHt0aGlzLmxhc3RFcnJvcn1gO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICB9KSwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSwgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICAvKiByb3VuZF9yb2JpbiBzaG91bGQga2VlcCBhbGwgY2hpbGRyZW4gY29ubmVjdGVkLCB0aGlzIGlzIGhvdyB3ZSBkbyB0aGF0LlxuICAgICAgICAgKiBXZSBjYW4ndCBkbyB0aGlzIG1vcmUgZWZmaWNpZW50bHkgaW4gdGhlIGluZGl2aWR1YWwgY2hpbGQncyB1cGRhdGVTdGF0ZVxuICAgICAgICAgKiBjYWxsYmFjayBiZWNhdXNlIHRoYXQgZG9lc24ndCBoYXZlIGEgcmVmZXJlbmNlIHRvIHdoaWNoIGNoaWxkIHRoZSBzdGF0ZVxuICAgICAgICAgKiBjaGFuZ2UgaXMgYXNzb2NpYXRlZCB3aXRoLiAqL1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuZXhpdElkbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdHJhY2UoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jdXJyZW50U3RhdGVdICtcbiAgICAgICAgICAgICcgLT4gJyArXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xuICAgICAgICBpZiAobmV3U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZWFkeVBpY2tlciA9IHBpY2tlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlYWR5UGlja2VyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBwaWNrZXIsIGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIHJlc2V0U3ViY2hhbm5lbExpc3QoKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgY2hpbGQuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUFkZHJlc3NMaXN0KGVuZHBvaW50TGlzdCwgbGJDb25maWcsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XG4gICAgICAgIHRyYWNlKCdDb25uZWN0IHRvIGVuZHBvaW50IGxpc3QgJyArIGVuZHBvaW50TGlzdC5tYXAoc3ViY2hhbm5lbF9hZGRyZXNzXzEuZW5kcG9pbnRUb1N0cmluZykpO1xuICAgICAgICB0aGlzLnVwZGF0ZXNQYXVzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gZW5kcG9pbnRMaXN0Lm1hcChlbmRwb2ludCA9PiBuZXcgbG9hZF9iYWxhbmNlcl9waWNrX2ZpcnN0XzEuTGVhZkxvYWRCYWxhbmNlcihlbmRwb2ludCwgdGhpcy5jaGlsZENoYW5uZWxDb250cm9sSGVscGVyLCBvcHRpb25zKSk7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgY2hpbGQuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVzUGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQW5kVXBkYXRlU3RhdGUoKTtcbiAgICB9XG4gICAgZXhpdElkbGUoKSB7XG4gICAgICAgIC8qIFRoZSByb3VuZF9yb2JpbiBMQiBwb2xpY3kgaXMgb25seSBpbiB0aGUgSURMRSBzdGF0ZSBpZiBpdCBoYXMgbm9cbiAgICAgICAgICogYWRkcmVzc2VzIHRvIHRyeSB0byBjb25uZWN0IHRvIGFuZCBpdCBoYXMgbm8gcGlja2VkIHN1YmNoYW5uZWwuXG4gICAgICAgICAqIEluIHRoYXQgY2FzZSwgdGhlcmUgaXMgbm8gbWVhbmluZ2Z1bCBhY3Rpb24gdGhhdCBjYW4gYmUgdGFrZW4gaGVyZS4gKi9cbiAgICB9XG4gICAgcmVzZXRCYWNrb2ZmKCkge1xuICAgICAgICAvLyBUaGlzIExCIHBvbGljeSBoYXMgbm8gYmFja29mZiB0byByZXNldFxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlc2V0U3ViY2hhbm5lbExpc3QoKTtcbiAgICB9XG4gICAgZ2V0VHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxufVxuZXhwb3J0cy5Sb3VuZFJvYmluTG9hZEJhbGFuY2VyID0gUm91bmRSb2JpbkxvYWRCYWxhbmNlcjtcbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgICgwLCBsb2FkX2JhbGFuY2VyXzEucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlKShUWVBFX05BTUUsIFJvdW5kUm9iaW5Mb2FkQmFsYW5jZXIsIFJvdW5kUm9iaW5Mb2FkQmFsYW5jaW5nQ29uZmlnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtYmFsYW5jZXItcm91bmQtcm9iaW4uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUm91bmRSb2JpbkxvYWRCYWxhbmNlciIsInNldHVwIiwibG9hZF9iYWxhbmNlcl8xIiwicmVxdWlyZSIsImNvbm5lY3Rpdml0eV9zdGF0ZV8xIiwicGlja2VyXzEiLCJsb2dnaW5nIiwiY29uc3RhbnRzXzEiLCJzdWJjaGFubmVsX2FkZHJlc3NfMSIsImxvYWRfYmFsYW5jZXJfcGlja19maXJzdF8xIiwiVFJBQ0VSX05BTUUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIlRZUEVfTkFNRSIsIlJvdW5kUm9iaW5Mb2FkQmFsYW5jaW5nQ29uZmlnIiwiZ2V0TG9hZEJhbGFuY2VyTmFtZSIsImNvbnN0cnVjdG9yIiwidG9Kc29uT2JqZWN0IiwiY3JlYXRlRnJvbUpzb24iLCJvYmoiLCJSb3VuZFJvYmluUGlja2VyIiwiY2hpbGRyZW4iLCJuZXh0SW5kZXgiLCJwaWNrIiwicGlja0FyZ3MiLCJjaGlsZFBpY2tlciIsInBpY2tlciIsImxlbmd0aCIsInBlZWtOZXh0RW5kcG9pbnQiLCJlbmRwb2ludCIsImNoYW5uZWxDb250cm9sSGVscGVyIiwiY3VycmVudFN0YXRlIiwiQ29ubmVjdGl2aXR5U3RhdGUiLCJJRExFIiwiY3VycmVudFJlYWR5UGlja2VyIiwidXBkYXRlc1BhdXNlZCIsImxhc3RFcnJvciIsImNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIiLCJjcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyIiwidXBkYXRlU3RhdGUiLCJjb25uZWN0aXZpdHlTdGF0ZSIsImVycm9yTWVzc2FnZSIsIlJFQURZIiwicmVxdWVzdFJlcmVzb2x1dGlvbiIsImNhbGN1bGF0ZUFuZFVwZGF0ZVN0YXRlIiwiY291bnRDaGlsZHJlbldpdGhTdGF0ZSIsInN0YXRlIiwiZmlsdGVyIiwiY2hpbGQiLCJnZXRDb25uZWN0aXZpdHlTdGF0ZSIsInJlYWR5Q2hpbGRyZW4iLCJpbmRleCIsIm5leHRQaWNrZWRFbmRwb2ludCIsImZpbmRJbmRleCIsImVuZHBvaW50RXF1YWwiLCJnZXRFbmRwb2ludCIsIm1hcCIsImdldFBpY2tlciIsIkNPTk5FQ1RJTkciLCJRdWV1ZVBpY2tlciIsIlRSQU5TSUVOVF9GQUlMVVJFIiwiVW5hdmFpbGFibGVQaWNrZXIiLCJkZXRhaWxzIiwiZXhpdElkbGUiLCJuZXdTdGF0ZSIsInJlc2V0U3ViY2hhbm5lbExpc3QiLCJkZXN0cm95IiwidXBkYXRlQWRkcmVzc0xpc3QiLCJlbmRwb2ludExpc3QiLCJsYkNvbmZpZyIsIm9wdGlvbnMiLCJlbmRwb2ludFRvU3RyaW5nIiwiTGVhZkxvYWRCYWxhbmNlciIsInN0YXJ0Q29ubmVjdGluZyIsInJlc2V0QmFja29mZiIsImdldFR5cGVOYW1lIiwicmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createChildChannelControlHelper = createChildChannelControlHelper;\nexports.registerLoadBalancerType = registerLoadBalancerType;\nexports.registerDefaultLoadBalancerType = registerDefaultLoadBalancerType;\nexports.createLoadBalancer = createLoadBalancer;\nexports.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;\nexports.parseLoadBalancingConfig = parseLoadBalancingConfig;\nexports.getDefaultConfig = getDefaultConfig;\nexports.selectLbConfigFromList = selectLbConfigFromList;\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\n/**\n * Create a child ChannelControlHelper that overrides some methods of the\n * parent while letting others pass through to the parent unmodified. This\n * allows other code to create these children without needing to know about\n * all of the methods to be passed through.\n * @param parent\n * @param overrides\n */ function createChildChannelControlHelper(parent, overrides) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    return {\n        createSubchannel: (_b = (_a = overrides.createSubchannel) === null || _a === void 0 ? void 0 : _a.bind(overrides)) !== null && _b !== void 0 ? _b : parent.createSubchannel.bind(parent),\n        updateState: (_d = (_c = overrides.updateState) === null || _c === void 0 ? void 0 : _c.bind(overrides)) !== null && _d !== void 0 ? _d : parent.updateState.bind(parent),\n        requestReresolution: (_f = (_e = overrides.requestReresolution) === null || _e === void 0 ? void 0 : _e.bind(overrides)) !== null && _f !== void 0 ? _f : parent.requestReresolution.bind(parent),\n        addChannelzChild: (_h = (_g = overrides.addChannelzChild) === null || _g === void 0 ? void 0 : _g.bind(overrides)) !== null && _h !== void 0 ? _h : parent.addChannelzChild.bind(parent),\n        removeChannelzChild: (_k = (_j = overrides.removeChannelzChild) === null || _j === void 0 ? void 0 : _j.bind(overrides)) !== null && _k !== void 0 ? _k : parent.removeChannelzChild.bind(parent)\n    };\n}\nconst registeredLoadBalancerTypes = {};\nlet defaultLoadBalancerType = null;\nfunction registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {\n    registeredLoadBalancerTypes[typeName] = {\n        LoadBalancer: loadBalancerType,\n        LoadBalancingConfig: loadBalancingConfigType\n    };\n}\nfunction registerDefaultLoadBalancerType(typeName) {\n    defaultLoadBalancerType = typeName;\n}\nfunction createLoadBalancer(config, channelControlHelper) {\n    const typeName = config.getLoadBalancerName();\n    if (typeName in registeredLoadBalancerTypes) {\n        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper);\n    } else {\n        return null;\n    }\n}\nfunction isLoadBalancerNameRegistered(typeName) {\n    return typeName in registeredLoadBalancerTypes;\n}\nfunction parseLoadBalancingConfig(rawConfig) {\n    const keys = Object.keys(rawConfig);\n    if (keys.length !== 1) {\n        throw new Error(\"Provided load balancing config has multiple conflicting entries\");\n    }\n    const typeName = keys[0];\n    if (typeName in registeredLoadBalancerTypes) {\n        try {\n            return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(rawConfig[typeName]);\n        } catch (e) {\n            throw new Error(`${typeName}: ${e.message}`);\n        }\n    } else {\n        throw new Error(`Unrecognized load balancing config name ${typeName}`);\n    }\n}\nfunction getDefaultConfig() {\n    if (!defaultLoadBalancerType) {\n        throw new Error(\"No default load balancer type registered\");\n    }\n    return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();\n}\nfunction selectLbConfigFromList(configs, fallbackTodefault = false) {\n    for (const config of configs){\n        try {\n            return parseLoadBalancingConfig(config);\n        } catch (e) {\n            (0, logging_1.log)(constants_1.LogVerbosity.DEBUG, \"Config parsing failed with error\", e.message);\n            continue;\n        }\n    }\n    if (fallbackTodefault) {\n        if (defaultLoadBalancerType) {\n            return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();\n        } else {\n            return null;\n        }\n    } else {\n        return null;\n    }\n} //# sourceMappingURL=load-balancer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUNBQXVDLEdBQUdFO0FBQzFDRixnQ0FBZ0MsR0FBR0c7QUFDbkNILHVDQUF1QyxHQUFHSTtBQUMxQ0osMEJBQTBCLEdBQUdLO0FBQzdCTCxvQ0FBb0MsR0FBR007QUFDdkNOLGdDQUFnQyxHQUFHTztBQUNuQ1Asd0JBQXdCLEdBQUdRO0FBQzNCUiw4QkFBOEIsR0FBR1M7QUFDakMsTUFBTUMsWUFBWUMsbUJBQU9BLENBQUMsMEVBQVc7QUFDckMsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsOEVBQWE7QUFDekM7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNULGdDQUFnQ1csTUFBTSxFQUFFQyxTQUFTO0lBQ3RELElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDO0lBQ3hDLE9BQU87UUFDSEMsa0JBQWtCLENBQUNULEtBQUssQ0FBQ0QsS0FBS0QsVUFBVVcsZ0JBQWdCLE1BQU0sUUFBUVYsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHVyxJQUFJLENBQUNaLFVBQVMsTUFBTyxRQUFRRSxPQUFPLEtBQUssSUFBSUEsS0FBS0gsT0FBT1ksZ0JBQWdCLENBQUNDLElBQUksQ0FBQ2I7UUFDakxjLGFBQWEsQ0FBQ1QsS0FBSyxDQUFDRCxLQUFLSCxVQUFVYSxXQUFXLE1BQU0sUUFBUVYsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHUyxJQUFJLENBQUNaLFVBQVMsTUFBTyxRQUFRSSxPQUFPLEtBQUssSUFBSUEsS0FBS0wsT0FBT2MsV0FBVyxDQUFDRCxJQUFJLENBQUNiO1FBQ2xLZSxxQkFBcUIsQ0FBQ1IsS0FBSyxDQUFDRCxLQUFLTCxV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T0FDSztZQUNELE9BQU87UUFDWDtJQUNKLE9BQ0s7UUFDRCxPQUFPO0lBQ1g7QUFDSixFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1ob3VzaW5nLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLmpzPzI3Y2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlciA9IGNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXI7XG5leHBvcnRzLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSA9IHJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZTtcbmV4cG9ydHMucmVnaXN0ZXJEZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSA9IHJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGU7XG5leHBvcnRzLmNyZWF0ZUxvYWRCYWxhbmNlciA9IGNyZWF0ZUxvYWRCYWxhbmNlcjtcbmV4cG9ydHMuaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZCA9IGlzTG9hZEJhbGFuY2VyTmFtZVJlZ2lzdGVyZWQ7XG5leHBvcnRzLnBhcnNlTG9hZEJhbGFuY2luZ0NvbmZpZyA9IHBhcnNlTG9hZEJhbGFuY2luZ0NvbmZpZztcbmV4cG9ydHMuZ2V0RGVmYXVsdENvbmZpZyA9IGdldERlZmF1bHRDb25maWc7XG5leHBvcnRzLnNlbGVjdExiQ29uZmlnRnJvbUxpc3QgPSBzZWxlY3RMYkNvbmZpZ0Zyb21MaXN0O1xuY29uc3QgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuLyoqXG4gKiBDcmVhdGUgYSBjaGlsZCBDaGFubmVsQ29udHJvbEhlbHBlciB0aGF0IG92ZXJyaWRlcyBzb21lIG1ldGhvZHMgb2YgdGhlXG4gKiBwYXJlbnQgd2hpbGUgbGV0dGluZyBvdGhlcnMgcGFzcyB0aHJvdWdoIHRvIHRoZSBwYXJlbnQgdW5tb2RpZmllZC4gVGhpc1xuICogYWxsb3dzIG90aGVyIGNvZGUgdG8gY3JlYXRlIHRoZXNlIGNoaWxkcmVuIHdpdGhvdXQgbmVlZGluZyB0byBrbm93IGFib3V0XG4gKiBhbGwgb2YgdGhlIG1ldGhvZHMgdG8gYmUgcGFzc2VkIHRocm91Z2guXG4gKiBAcGFyYW0gcGFyZW50XG4gKiBAcGFyYW0gb3ZlcnJpZGVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIocGFyZW50LCBvdmVycmlkZXMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2s7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogKF9iID0gKF9hID0gb3ZlcnJpZGVzLmNyZWF0ZVN1YmNoYW5uZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHBhcmVudC5jcmVhdGVTdWJjaGFubmVsLmJpbmQocGFyZW50KSxcbiAgICAgICAgdXBkYXRlU3RhdGU6IChfZCA9IChfYyA9IG92ZXJyaWRlcy51cGRhdGVTdGF0ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmJpbmQob3ZlcnJpZGVzKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogcGFyZW50LnVwZGF0ZVN0YXRlLmJpbmQocGFyZW50KSxcbiAgICAgICAgcmVxdWVzdFJlcmVzb2x1dGlvbjogKF9mID0gKF9lID0gb3ZlcnJpZGVzLnJlcXVlc3RSZXJlc29sdXRpb24pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHBhcmVudC5yZXF1ZXN0UmVyZXNvbHV0aW9uLmJpbmQocGFyZW50KSxcbiAgICAgICAgYWRkQ2hhbm5lbHpDaGlsZDogKF9oID0gKF9nID0gb3ZlcnJpZGVzLmFkZENoYW5uZWx6Q2hpbGQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IHBhcmVudC5hZGRDaGFubmVsekNoaWxkLmJpbmQocGFyZW50KSxcbiAgICAgICAgcmVtb3ZlQ2hhbm5lbHpDaGlsZDogKF9rID0gKF9qID0gb3ZlcnJpZGVzLnJlbW92ZUNoYW5uZWx6Q2hpbGQpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6IHBhcmVudC5yZW1vdmVDaGFubmVsekNoaWxkLmJpbmQocGFyZW50KSxcbiAgICB9O1xufVxuY29uc3QgcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzID0ge307XG5sZXQgZGVmYXVsdExvYWRCYWxhbmNlclR5cGUgPSBudWxsO1xuZnVuY3Rpb24gcmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlKHR5cGVOYW1lLCBsb2FkQmFsYW5jZXJUeXBlLCBsb2FkQmFsYW5jaW5nQ29uZmlnVHlwZSkge1xuICAgIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1t0eXBlTmFtZV0gPSB7XG4gICAgICAgIExvYWRCYWxhbmNlcjogbG9hZEJhbGFuY2VyVHlwZSxcbiAgICAgICAgTG9hZEJhbGFuY2luZ0NvbmZpZzogbG9hZEJhbGFuY2luZ0NvbmZpZ1R5cGUsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUodHlwZU5hbWUpIHtcbiAgICBkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSA9IHR5cGVOYW1lO1xufVxuZnVuY3Rpb24gY3JlYXRlTG9hZEJhbGFuY2VyKGNvbmZpZywgY2hhbm5lbENvbnRyb2xIZWxwZXIpIHtcbiAgICBjb25zdCB0eXBlTmFtZSA9IGNvbmZpZy5nZXRMb2FkQmFsYW5jZXJOYW1lKCk7XG4gICAgaWYgKHR5cGVOYW1lIGluIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlcykge1xuICAgICAgICByZXR1cm4gbmV3IHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1t0eXBlTmFtZV0uTG9hZEJhbGFuY2VyKGNoYW5uZWxDb250cm9sSGVscGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTG9hZEJhbGFuY2VyTmFtZVJlZ2lzdGVyZWQodHlwZU5hbWUpIHtcbiAgICByZXR1cm4gdHlwZU5hbWUgaW4gcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzO1xufVxuZnVuY3Rpb24gcGFyc2VMb2FkQmFsYW5jaW5nQ29uZmlnKHJhd0NvbmZpZykge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhyYXdDb25maWcpO1xuICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVkIGxvYWQgYmFsYW5jaW5nIGNvbmZpZyBoYXMgbXVsdGlwbGUgY29uZmxpY3RpbmcgZW50cmllcycpO1xuICAgIH1cbiAgICBjb25zdCB0eXBlTmFtZSA9IGtleXNbMF07XG4gICAgaWYgKHR5cGVOYW1lIGluIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1t0eXBlTmFtZV0uTG9hZEJhbGFuY2luZ0NvbmZpZy5jcmVhdGVGcm9tSnNvbihyYXdDb25maWdbdHlwZU5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3R5cGVOYW1lfTogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGxvYWQgYmFsYW5jaW5nIGNvbmZpZyBuYW1lICR7dHlwZU5hbWV9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdENvbmZpZygpIHtcbiAgICBpZiAoIWRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGVmYXVsdCBsb2FkIGJhbGFuY2VyIHR5cGUgcmVnaXN0ZXJlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1tkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZV0uTG9hZEJhbGFuY2luZ0NvbmZpZygpO1xufVxuZnVuY3Rpb24gc2VsZWN0TGJDb25maWdGcm9tTGlzdChjb25maWdzLCBmYWxsYmFja1RvZGVmYXVsdCA9IGZhbHNlKSB7XG4gICAgZm9yIChjb25zdCBjb25maWcgb2YgY29uZmlncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTG9hZEJhbGFuY2luZ0NvbmZpZyhjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAoMCwgbG9nZ2luZ18xLmxvZykoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAnQ29uZmlnIHBhcnNpbmcgZmFpbGVkIHdpdGggZXJyb3InLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZhbGxiYWNrVG9kZWZhdWx0KSB7XG4gICAgICAgIGlmIChkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXNbZGVmYXVsdExvYWRCYWxhbmNlclR5cGVdLkxvYWRCYWxhbmNpbmdDb25maWcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIiLCJyZWdpc3RlckxvYWRCYWxhbmNlclR5cGUiLCJyZWdpc3RlckRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlIiwiY3JlYXRlTG9hZEJhbGFuY2VyIiwiaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZCIsInBhcnNlTG9hZEJhbGFuY2luZ0NvbmZpZyIsImdldERlZmF1bHRDb25maWciLCJzZWxlY3RMYkNvbmZpZ0Zyb21MaXN0IiwibG9nZ2luZ18xIiwicmVxdWlyZSIsImNvbnN0YW50c18xIiwicGFyZW50Iiwib3ZlcnJpZGVzIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJfaCIsIl9qIiwiX2siLCJjcmVhdGVTdWJjaGFubmVsIiwiYmluZCIsInVwZGF0ZVN0YXRlIiwicmVxdWVzdFJlcmVzb2x1dGlvbiIsImFkZENoYW5uZWx6Q2hpbGQiLCJyZW1vdmVDaGFubmVsekNoaWxkIiwicmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzIiwiZGVmYXVsdExvYWRCYWxhbmNlclR5cGUiLCJ0eXBlTmFtZSIsImxvYWRCYWxhbmNlclR5cGUiLCJsb2FkQmFsYW5jaW5nQ29uZmlnVHlwZSIsIkxvYWRCYWxhbmNlciIsIkxvYWRCYWxhbmNpbmdDb25maWciLCJjb25maWciLCJjaGFubmVsQ29udHJvbEhlbHBlciIsImdldExvYWRCYWxhbmNlck5hbWUiLCJyYXdDb25maWciLCJrZXlzIiwibGVuZ3RoIiwiRXJyb3IiLCJjcmVhdGVGcm9tSnNvbiIsImUiLCJtZXNzYWdlIiwiY29uZmlncyIsImZhbGxiYWNrVG9kZWZhdWx0IiwibG9nIiwiTG9nVmVyYm9zaXR5IiwiREVCVUciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LoadBalancingCall = void 0;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst TRACER_NAME = \"load_balancing_call\";\nclass LoadBalancingCall {\n    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber){\n        var _a, _b;\n        this.channel = channel;\n        this.callConfig = callConfig;\n        this.methodName = methodName;\n        this.host = host;\n        this.credentials = credentials;\n        this.deadline = deadline;\n        this.callNumber = callNumber;\n        this.child = null;\n        this.readPending = false;\n        this.pendingMessage = null;\n        this.pendingHalfClose = false;\n        this.ended = false;\n        this.metadata = null;\n        this.listener = null;\n        this.onCallEnded = null;\n        this.childStartTime = null;\n        const splitPath = this.methodName.split(\"/\");\n        let serviceName = \"\";\n        /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n         * by '/', the first item should be empty and the second should be the\n         * service name */ if (splitPath.length >= 2) {\n            serviceName = splitPath[1];\n        }\n        const hostname = (_b = (_a = (0, uri_parser_1.splitHostPort)(this.host)) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : \"localhost\";\n        /* Currently, call credentials are only allowed on HTTPS connections, so we\n         * can assume that the scheme is \"https\" */ this.serviceUrl = `https://${hostname}/${serviceName}`;\n        this.startTime = new Date();\n    }\n    getDeadlineInfo() {\n        var _a, _b;\n        const deadlineInfo = [];\n        if (this.childStartTime) {\n            if (this.childStartTime > this.startTime) {\n                if ((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.getOptions().waitForReady) {\n                    deadlineInfo.push(\"wait_for_ready\");\n                }\n                deadlineInfo.push(`LB pick: ${(0, deadline_1.formatDateDifference)(this.startTime, this.childStartTime)}`);\n            }\n            deadlineInfo.push(...this.child.getDeadlineInfo());\n            return deadlineInfo;\n        } else {\n            if ((_b = this.metadata) === null || _b === void 0 ? void 0 : _b.getOptions().waitForReady) {\n                deadlineInfo.push(\"wait_for_ready\");\n            }\n            deadlineInfo.push(\"Waiting for LB pick\");\n        }\n        return deadlineInfo;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"[\" + this.callNumber + \"] \" + text);\n    }\n    outputStatus(status, progress) {\n        var _a, _b;\n        if (!this.ended) {\n            this.ended = true;\n            this.trace(\"ended with status: code=\" + status.code + ' details=\"' + status.details + '\" start time=' + this.startTime.toISOString());\n            const finalStatus = Object.assign(Object.assign({}, status), {\n                progress\n            });\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(finalStatus);\n            (_b = this.onCallEnded) === null || _b === void 0 ? void 0 : _b.call(this, finalStatus.code);\n        }\n    }\n    doPick() {\n        var _a, _b;\n        if (this.ended) {\n            return;\n        }\n        if (!this.metadata) {\n            throw new Error(\"doPick called before start\");\n        }\n        this.trace(\"Pick called\");\n        const finalMetadata = this.metadata.clone();\n        const pickResult = this.channel.doPick(finalMetadata, this.callConfig.pickInformation);\n        const subchannelString = pickResult.subchannel ? \"(\" + pickResult.subchannel.getChannelzRef().id + \") \" + pickResult.subchannel.getAddress() : \"\" + pickResult.subchannel;\n        this.trace(\"Pick result: \" + picker_1.PickResultType[pickResult.pickResultType] + \" subchannel: \" + subchannelString + \" status: \" + ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) + \" \" + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));\n        switch(pickResult.pickResultType){\n            case picker_1.PickResultType.COMPLETE:\n                const combinedCallCredentials = this.credentials.compose(pickResult.subchannel.getCallCredentials());\n                combinedCallCredentials.generateMetadata({\n                    method_name: this.methodName,\n                    service_url: this.serviceUrl\n                }).then((credsMetadata)=>{\n                    var _a;\n                    /* If this call was cancelled (e.g. by the deadline) before\n                     * metadata generation finished, we shouldn't do anything with\n                     * it. */ if (this.ended) {\n                        this.trace(\"Credentials metadata generation finished after call ended\");\n                        return;\n                    }\n                    finalMetadata.merge(credsMetadata);\n                    if (finalMetadata.get(\"authorization\").length > 1) {\n                        this.outputStatus({\n                            code: constants_1.Status.INTERNAL,\n                            details: '\"authorization\" metadata cannot have multiple values',\n                            metadata: new metadata_1.Metadata()\n                        }, \"PROCESSED\");\n                    }\n                    if (pickResult.subchannel.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) {\n                        this.trace(\"Picked subchannel \" + subchannelString + \" has state \" + connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()] + \" after getting credentials metadata. Retrying pick\");\n                        this.doPick();\n                        return;\n                    }\n                    if (this.deadline !== Infinity) {\n                        finalMetadata.set(\"grpc-timeout\", (0, deadline_1.getDeadlineTimeoutString)(this.deadline));\n                    }\n                    try {\n                        this.child = pickResult.subchannel.getRealSubchannel().createCall(finalMetadata, this.host, this.methodName, {\n                            onReceiveMetadata: (metadata)=>{\n                                this.trace(\"Received metadata\");\n                                this.listener.onReceiveMetadata(metadata);\n                            },\n                            onReceiveMessage: (message)=>{\n                                this.trace(\"Received message\");\n                                this.listener.onReceiveMessage(message);\n                            },\n                            onReceiveStatus: (status)=>{\n                                this.trace(\"Received status\");\n                                if (status.rstCode === http2.constants.NGHTTP2_REFUSED_STREAM) {\n                                    this.outputStatus(status, \"REFUSED\");\n                                } else {\n                                    this.outputStatus(status, \"PROCESSED\");\n                                }\n                            }\n                        });\n                        this.childStartTime = new Date();\n                    } catch (error) {\n                        this.trace(\"Failed to start call on picked subchannel \" + subchannelString + \" with error \" + error.message);\n                        this.outputStatus({\n                            code: constants_1.Status.INTERNAL,\n                            details: \"Failed to start HTTP/2 stream with error \" + error.message,\n                            metadata: new metadata_1.Metadata()\n                        }, \"NOT_STARTED\");\n                        return;\n                    }\n                    (_a = pickResult.onCallStarted) === null || _a === void 0 ? void 0 : _a.call(pickResult);\n                    this.onCallEnded = pickResult.onCallEnded;\n                    this.trace(\"Created child call [\" + this.child.getCallNumber() + \"]\");\n                    if (this.readPending) {\n                        this.child.startRead();\n                    }\n                    if (this.pendingMessage) {\n                        this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);\n                    }\n                    if (this.pendingHalfClose) {\n                        this.child.halfClose();\n                    }\n                }, (error)=>{\n                    // We assume the error code isn't 0 (Status.OK)\n                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(typeof error.code === \"number\" ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n                    this.outputStatus({\n                        code: code,\n                        details: details,\n                        metadata: new metadata_1.Metadata()\n                    }, \"PROCESSED\");\n                });\n                break;\n            case picker_1.PickResultType.DROP:\n                const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\n                setImmediate(()=>{\n                    this.outputStatus({\n                        code,\n                        details,\n                        metadata: pickResult.status.metadata\n                    }, \"DROP\");\n                });\n                break;\n            case picker_1.PickResultType.TRANSIENT_FAILURE:\n                if (this.metadata.getOptions().waitForReady) {\n                    this.channel.queueCallForPick(this);\n                } else {\n                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\n                    setImmediate(()=>{\n                        this.outputStatus({\n                            code,\n                            details,\n                            metadata: pickResult.status.metadata\n                        }, \"PROCESSED\");\n                    });\n                }\n                break;\n            case picker_1.PickResultType.QUEUE:\n                this.channel.queueCallForPick(this);\n        }\n    }\n    cancelWithStatus(status, details) {\n        var _a;\n        this.trace(\"cancelWithStatus code: \" + status + ' details: \"' + details + '\"');\n        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);\n        this.outputStatus({\n            code: status,\n            details: details,\n            metadata: new metadata_1.Metadata()\n        }, \"PROCESSED\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n    }\n    start(metadata, listener) {\n        this.trace(\"start called\");\n        this.listener = listener;\n        this.metadata = metadata;\n        this.doPick();\n    }\n    sendMessageWithContext(context, message) {\n        this.trace(\"write() called with message of length \" + message.length);\n        if (this.child) {\n            this.child.sendMessageWithContext(context, message);\n        } else {\n            this.pendingMessage = {\n                context,\n                message\n            };\n        }\n    }\n    startRead() {\n        this.trace(\"startRead called\");\n        if (this.child) {\n            this.child.startRead();\n        } else {\n            this.readPending = true;\n        }\n    }\n    halfClose() {\n        this.trace(\"halfClose called\");\n        if (this.child) {\n            this.child.halfClose();\n        } else {\n            this.pendingHalfClose = true;\n        }\n    }\n    setCredentials(credentials) {\n        throw new Error(\"Method not implemented.\");\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n}\nexports.LoadBalancingCall = LoadBalancingCall; //# sourceMappingURL=load-balancing-call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNpbmctY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQseUJBQXlCLEdBQUcsS0FBSztBQUNqQyxNQUFNRyx1QkFBdUJDLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNRyxhQUFhSCxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNSSxXQUFXSixtQkFBT0EsQ0FBQyx3RUFBVTtBQUNuQyxNQUFNSyxlQUFlTCxtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNTSxVQUFVTixtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNTyx5QkFBeUJQLG1CQUFPQSxDQUFDLG9HQUF3QjtBQUMvRCxNQUFNUSxRQUFRUixtQkFBT0EsQ0FBQyxvQkFBTztBQUM3QixNQUFNUyxjQUFjO0FBQ3BCLE1BQU1YO0lBQ0ZZLFlBQVlDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxVQUFVLEVBQUVDLElBQUksRUFBRUMsV0FBVyxFQUFFQyxRQUFRLEVBQUVDLFVBQVUsQ0FBRTtRQUNsRixJQUFJQyxJQUFJQztRQUNSLElBQUksQ0FBQ1IsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDRyxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNDLFdBQVcs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QjtRQUNaLE9BQU8sSUFBSSxDQUFDcEYsVUFBVTtJQUMxQjtBQUNKO0FBQ0FyQix5QkFBeUIsR0FBR0UsbUJBQzVCLCtDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1ob3VzaW5nLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2luZy1jYWxsLmpzPzI4ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9hZEJhbGFuY2luZ0NhbGwgPSB2b2lkIDA7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZGVhZGxpbmVfMSA9IHJlcXVpcmUoXCIuL2RlYWRsaW5lXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb250cm9sX3BsYW5lX3N0YXR1c18xID0gcmVxdWlyZShcIi4vY29udHJvbC1wbGFuZS1zdGF0dXNcIik7XG5jb25zdCBodHRwMiA9IHJlcXVpcmUoXCJodHRwMlwiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ2xvYWRfYmFsYW5jaW5nX2NhbGwnO1xuY2xhc3MgTG9hZEJhbGFuY2luZ0NhbGwge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwsIGNhbGxDb25maWcsIG1ldGhvZE5hbWUsIGhvc3QsIGNyZWRlbnRpYWxzLCBkZWFkbGluZSwgY2FsbE51bWJlcikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB0aGlzLmNhbGxDb25maWcgPSBjYWxsQ29uZmlnO1xuICAgICAgICB0aGlzLm1ldGhvZE5hbWUgPSBtZXRob2ROYW1lO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuZGVhZGxpbmUgPSBkZWFkbGluZTtcbiAgICAgICAgdGhpcy5jYWxsTnVtYmVyID0gY2FsbE51bWJlcjtcbiAgICAgICAgdGhpcy5jaGlsZCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVhZFBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZ0hhbGZDbG9zZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbkNhbGxFbmRlZCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2hpbGRTdGFydFRpbWUgPSBudWxsO1xuICAgICAgICBjb25zdCBzcGxpdFBhdGggPSB0aGlzLm1ldGhvZE5hbWUuc3BsaXQoJy8nKTtcbiAgICAgICAgbGV0IHNlcnZpY2VOYW1lID0gJyc7XG4gICAgICAgIC8qIFRoZSBzdGFuZGFyZCBwYXRoIGZvcm1hdCBpcyBcIi97c2VydmljZU5hbWV9L3ttZXRob2ROYW1lfVwiLCBzbyBpZiB3ZSBzcGxpdFxuICAgICAgICAgKiBieSAnLycsIHRoZSBmaXJzdCBpdGVtIHNob3VsZCBiZSBlbXB0eSBhbmQgdGhlIHNlY29uZCBzaG91bGQgYmUgdGhlXG4gICAgICAgICAqIHNlcnZpY2UgbmFtZSAqL1xuICAgICAgICBpZiAoc3BsaXRQYXRoLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBzZXJ2aWNlTmFtZSA9IHNwbGl0UGF0aFsxXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3N0bmFtZSA9IChfYiA9IChfYSA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkodGhpcy5ob3N0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhvc3QpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdsb2NhbGhvc3QnO1xuICAgICAgICAvKiBDdXJyZW50bHksIGNhbGwgY3JlZGVudGlhbHMgYXJlIG9ubHkgYWxsb3dlZCBvbiBIVFRQUyBjb25uZWN0aW9ucywgc28gd2VcbiAgICAgICAgICogY2FuIGFzc3VtZSB0aGF0IHRoZSBzY2hlbWUgaXMgXCJodHRwc1wiICovXG4gICAgICAgIHRoaXMuc2VydmljZVVybCA9IGBodHRwczovLyR7aG9zdG5hbWV9LyR7c2VydmljZU5hbWV9YDtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgICBnZXREZWFkbGluZUluZm8oKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGRlYWRsaW5lSW5mbyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5jaGlsZFN0YXJ0VGltZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRTdGFydFRpbWUgPiB0aGlzLnN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIGlmICgoX2EgPSB0aGlzLm1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0T3B0aW9ucygpLndhaXRGb3JSZWFkeSkge1xuICAgICAgICAgICAgICAgICAgICBkZWFkbGluZUluZm8ucHVzaCgnd2FpdF9mb3JfcmVhZHknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVhZGxpbmVJbmZvLnB1c2goYExCIHBpY2s6ICR7KDAsIGRlYWRsaW5lXzEuZm9ybWF0RGF0ZURpZmZlcmVuY2UpKHRoaXMuc3RhcnRUaW1lLCB0aGlzLmNoaWxkU3RhcnRUaW1lKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlYWRsaW5lSW5mby5wdXNoKC4uLnRoaXMuY2hpbGQuZ2V0RGVhZGxpbmVJbmZvKCkpO1xuICAgICAgICAgICAgcmV0dXJuIGRlYWRsaW5lSW5mbztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICgoX2IgPSB0aGlzLm1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0T3B0aW9ucygpLndhaXRGb3JSZWFkeSkge1xuICAgICAgICAgICAgICAgIGRlYWRsaW5lSW5mby5wdXNoKCd3YWl0X2Zvcl9yZWFkeScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVhZGxpbmVJbmZvLnB1c2goJ1dhaXRpbmcgZm9yIExCIHBpY2snKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVhZGxpbmVJbmZvO1xuICAgIH1cbiAgICB0cmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgJ1snICsgdGhpcy5jYWxsTnVtYmVyICsgJ10gJyArIHRleHQpO1xuICAgIH1cbiAgICBvdXRwdXRTdGF0dXMoc3RhdHVzLCBwcm9ncmVzcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoIXRoaXMuZW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnZW5kZWQgd2l0aCBzdGF0dXM6IGNvZGU9JyArXG4gICAgICAgICAgICAgICAgc3RhdHVzLmNvZGUgK1xuICAgICAgICAgICAgICAgICcgZGV0YWlscz1cIicgK1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kZXRhaWxzICtcbiAgICAgICAgICAgICAgICAnXCIgc3RhcnQgdGltZT0nICtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0VGltZS50b0lTT1N0cmluZygpKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsU3RhdHVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0dXMpLCB7IHByb2dyZXNzIH0pO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5saXN0ZW5lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uUmVjZWl2ZVN0YXR1cyhmaW5hbFN0YXR1cyk7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLm9uQ2FsbEVuZGVkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbCh0aGlzLCBmaW5hbFN0YXR1cy5jb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb1BpY2soKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm1ldGFkYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvUGljayBjYWxsZWQgYmVmb3JlIHN0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZSgnUGljayBjYWxsZWQnKTtcbiAgICAgICAgY29uc3QgZmluYWxNZXRhZGF0YSA9IHRoaXMubWV0YWRhdGEuY2xvbmUoKTtcbiAgICAgICAgY29uc3QgcGlja1Jlc3VsdCA9IHRoaXMuY2hhbm5lbC5kb1BpY2soZmluYWxNZXRhZGF0YSwgdGhpcy5jYWxsQ29uZmlnLnBpY2tJbmZvcm1hdGlvbik7XG4gICAgICAgIGNvbnN0IHN1YmNoYW5uZWxTdHJpbmcgPSBwaWNrUmVzdWx0LnN1YmNoYW5uZWxcbiAgICAgICAgICAgID8gJygnICtcbiAgICAgICAgICAgICAgICBwaWNrUmVzdWx0LnN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKS5pZCArXG4gICAgICAgICAgICAgICAgJykgJyArXG4gICAgICAgICAgICAgICAgcGlja1Jlc3VsdC5zdWJjaGFubmVsLmdldEFkZHJlc3MoKVxuICAgICAgICAgICAgOiAnJyArIHBpY2tSZXN1bHQuc3ViY2hhbm5lbDtcbiAgICAgICAgdGhpcy50cmFjZSgnUGljayByZXN1bHQ6ICcgK1xuICAgICAgICAgICAgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGVbcGlja1Jlc3VsdC5waWNrUmVzdWx0VHlwZV0gK1xuICAgICAgICAgICAgJyBzdWJjaGFubmVsOiAnICtcbiAgICAgICAgICAgIHN1YmNoYW5uZWxTdHJpbmcgK1xuICAgICAgICAgICAgJyBzdGF0dXM6ICcgK1xuICAgICAgICAgICAgKChfYSA9IHBpY2tSZXN1bHQuc3RhdHVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICgoX2IgPSBwaWNrUmVzdWx0LnN0YXR1cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRldGFpbHMpKTtcbiAgICAgICAgc3dpdGNoIChwaWNrUmVzdWx0LnBpY2tSZXN1bHRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlLkNPTVBMRVRFOlxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkQ2FsbENyZWRlbnRpYWxzID0gdGhpcy5jcmVkZW50aWFscy5jb21wb3NlKHBpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDYWxsQ3JlZGVudGlhbHMoKSk7XG4gICAgICAgICAgICAgICAgY29tYmluZWRDYWxsQ3JlZGVudGlhbHNcbiAgICAgICAgICAgICAgICAgICAgLmdlbmVyYXRlTWV0YWRhdGEoeyBtZXRob2RfbmFtZTogdGhpcy5tZXRob2ROYW1lLCBzZXJ2aWNlX3VybDogdGhpcy5zZXJ2aWNlVXJsIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGNyZWRzTWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIC8qIElmIHRoaXMgY2FsbCB3YXMgY2FuY2VsbGVkIChlLmcuIGJ5IHRoZSBkZWFkbGluZSkgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgICAqIG1ldGFkYXRhIGdlbmVyYXRpb24gZmluaXNoZWQsIHdlIHNob3VsZG4ndCBkbyBhbnl0aGluZyB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAqIGl0LiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnQ3JlZGVudGlhbHMgbWV0YWRhdGEgZ2VuZXJhdGlvbiBmaW5pc2hlZCBhZnRlciBjYWxsIGVuZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxNZXRhZGF0YS5tZXJnZShjcmVkc01ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsTWV0YWRhdGEuZ2V0KCdhdXRob3JpemF0aW9uJykubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAnXCJhdXRob3JpemF0aW9uXCIgbWV0YWRhdGEgY2Fubm90IGhhdmUgbXVsdGlwbGUgdmFsdWVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sICdQUk9DRVNTRUQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGlja1Jlc3VsdC5zdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUGlja2VkIHN1YmNoYW5uZWwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFN0cmluZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBoYXMgc3RhdGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbcGlja1Jlc3VsdC5zdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCldICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGFmdGVyIGdldHRpbmcgY3JlZGVudGlhbHMgbWV0YWRhdGEuIFJldHJ5aW5nIHBpY2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9QaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVhZGxpbmUgIT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE1ldGFkYXRhLnNldCgnZ3JwYy10aW1lb3V0JywgKDAsIGRlYWRsaW5lXzEuZ2V0RGVhZGxpbmVUaW1lb3V0U3RyaW5nKSh0aGlzLmRlYWRsaW5lKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQgPSBwaWNrUmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN1YmNoYW5uZWwuZ2V0UmVhbFN1YmNoYW5uZWwoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jcmVhdGVDYWxsKGZpbmFsTWV0YWRhdGEsIHRoaXMuaG9zdCwgdGhpcy5tZXRob2ROYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgbWV0YWRhdGEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiBtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgbWVzc2FnZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIHN0YXR1cycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnJzdENvZGUgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9SRUZVU0VEX1NUUkVBTSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoc3RhdHVzLCAnUkVGVVNFRCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoc3RhdHVzLCAnUFJPQ0VTU0VEJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkU3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0ZhaWxlZCB0byBzdGFydCBjYWxsIG9uIHBpY2tlZCBzdWJjaGFubmVsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxTdHJpbmcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgd2l0aCBlcnJvciAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogJ0ZhaWxlZCB0byBzdGFydCBIVFRQLzIgc3RyZWFtIHdpdGggZXJyb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAnTk9UX1NUQVJURUQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAoX2EgPSBwaWNrUmVzdWx0Lm9uQ2FsbFN0YXJ0ZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHBpY2tSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2FsbEVuZGVkID0gcGlja1Jlc3VsdC5vbkNhbGxFbmRlZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnQ3JlYXRlZCBjaGlsZCBjYWxsIFsnICsgdGhpcy5jaGlsZC5nZXRDYWxsTnVtYmVyKCkgKyAnXScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkUGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZC5zdGFydFJlYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KHRoaXMucGVuZGluZ01lc3NhZ2UuY29udGV4dCwgdGhpcy5wZW5kaW5nTWVzc2FnZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nSGFsZkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkLmhhbGZDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGUgZXJyb3IgY29kZSBpc24ndCAwIChTdGF0dXMuT0spXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY29kZSwgZGV0YWlscyB9ID0gKDAsIGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEucmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlKSh0eXBlb2YgZXJyb3IuY29kZSA9PT0gJ251bWJlcicgPyBlcnJvci5jb2RlIDogY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV04sIGBHZXR0aW5nIG1ldGFkYXRhIGZyb20gcGx1Z2luIGZhaWxlZCB3aXRoIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBkZXRhaWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgIH0sICdQUk9DRVNTRUQnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuRFJPUDpcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNvZGUsIGRldGFpbHMgfSA9ICgwLCBjb250cm9sX3BsYW5lX3N0YXR1c18xLnJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZSkocGlja1Jlc3VsdC5zdGF0dXMuY29kZSwgcGlja1Jlc3VsdC5zdGF0dXMuZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoeyBjb2RlLCBkZXRhaWxzLCBtZXRhZGF0YTogcGlja1Jlc3VsdC5zdGF0dXMubWV0YWRhdGEgfSwgJ0RST1AnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuVFJBTlNJRU5UX0ZBSUxVUkU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEuZ2V0T3B0aW9ucygpLndhaXRGb3JSZWFkeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWwucXVldWVDYWxsRm9yUGljayh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY29kZSwgZGV0YWlscyB9ID0gKDAsIGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEucmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlKShwaWNrUmVzdWx0LnN0YXR1cy5jb2RlLCBwaWNrUmVzdWx0LnN0YXR1cy5kZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHsgY29kZSwgZGV0YWlscywgbWV0YWRhdGE6IHBpY2tSZXN1bHQuc3RhdHVzLm1ldGFkYXRhIH0sICdQUk9DRVNTRUQnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5RVUVVRTpcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWwucXVldWVDYWxsRm9yUGljayh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NhbmNlbFdpdGhTdGF0dXMgY29kZTogJyArIHN0YXR1cyArICcgZGV0YWlsczogXCInICsgZGV0YWlscyArICdcIicpO1xuICAgICAgICAoX2EgPSB0aGlzLmNoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpO1xuICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh7IGNvZGU6IHN0YXR1cywgZGV0YWlsczogZGV0YWlscywgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCkgfSwgJ1BST0NFU1NFRCcpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlZXIoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5jaGFubmVsLmdldFRhcmdldCgpO1xuICAgIH1cbiAgICBzdGFydChtZXRhZGF0YSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnc3RhcnQgY2FsbGVkJyk7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLmRvUGljaygpO1xuICAgIH1cbiAgICBzZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnd3JpdGUoKSBjYWxsZWQgd2l0aCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICBpZiAodGhpcy5jaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IHsgY29udGV4dCwgbWVzc2FnZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0UmVhZCgpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnc3RhcnRSZWFkIGNhbGxlZCcpO1xuICAgICAgICBpZiAodGhpcy5jaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZC5zdGFydFJlYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbGZDbG9zZSgpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnaGFsZkNsb3NlIGNhbGxlZCcpO1xuICAgICAgICBpZiAodGhpcy5jaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0hhbGZDbG9zZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgICBnZXRDYWxsTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsTnVtYmVyO1xuICAgIH1cbn1cbmV4cG9ydHMuTG9hZEJhbGFuY2luZ0NhbGwgPSBMb2FkQmFsYW5jaW5nQ2FsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtYmFsYW5jaW5nLWNhbGwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTG9hZEJhbGFuY2luZ0NhbGwiLCJjb25uZWN0aXZpdHlfc3RhdGVfMSIsInJlcXVpcmUiLCJjb25zdGFudHNfMSIsImRlYWRsaW5lXzEiLCJtZXRhZGF0YV8xIiwicGlja2VyXzEiLCJ1cmlfcGFyc2VyXzEiLCJsb2dnaW5nIiwiY29udHJvbF9wbGFuZV9zdGF0dXNfMSIsImh0dHAyIiwiVFJBQ0VSX05BTUUiLCJjb25zdHJ1Y3RvciIsImNoYW5uZWwiLCJjYWxsQ29uZmlnIiwibWV0aG9kTmFtZSIsImhvc3QiLCJjcmVkZW50aWFscyIsImRlYWRsaW5lIiwiY2FsbE51bWJlciIsIl9hIiwiX2IiLCJjaGlsZCIsInJlYWRQZW5kaW5nIiwicGVuZGluZ01lc3NhZ2UiLCJwZW5kaW5nSGFsZkNsb3NlIiwiZW5kZWQiLCJtZXRhZGF0YSIsImxpc3RlbmVyIiwib25DYWxsRW5kZWQiLCJjaGlsZFN0YXJ0VGltZSIsInNwbGl0UGF0aCIsInNwbGl0Iiwic2VydmljZU5hbWUiLCJsZW5ndGgiLCJob3N0bmFtZSIsInNwbGl0SG9zdFBvcnQiLCJzZXJ2aWNlVXJsIiwic3RhcnRUaW1lIiwiRGF0ZSIsImdldERlYWRsaW5lSW5mbyIsImRlYWRsaW5lSW5mbyIsImdldE9wdGlvbnMiLCJ3YWl0Rm9yUmVhZHkiLCJwdXNoIiwiZm9ybWF0RGF0ZURpZmZlcmVuY2UiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIm91dHB1dFN0YXR1cyIsInN0YXR1cyIsInByb2dyZXNzIiwiY29kZSIsImRldGFpbHMiLCJ0b0lTT1N0cmluZyIsImZpbmFsU3RhdHVzIiwiYXNzaWduIiwib25SZWNlaXZlU3RhdHVzIiwiY2FsbCIsImRvUGljayIsIkVycm9yIiwiZmluYWxNZXRhZGF0YSIsImNsb25lIiwicGlja1Jlc3VsdCIsInBpY2tJbmZvcm1hdGlvbiIsInN1YmNoYW5uZWxTdHJpbmciLCJzdWJjaGFubmVsIiwiZ2V0Q2hhbm5lbHpSZWYiLCJpZCIsImdldEFkZHJlc3MiLCJQaWNrUmVzdWx0VHlwZSIsInBpY2tSZXN1bHRUeXBlIiwiQ09NUExFVEUiLCJjb21iaW5lZENhbGxDcmVkZW50aWFscyIsImNvbXBvc2UiLCJnZXRDYWxsQ3JlZGVudGlhbHMiLCJnZW5lcmF0ZU1ldGFkYXRhIiwibWV0aG9kX25hbWUiLCJzZXJ2aWNlX3VybCIsInRoZW4iLCJjcmVkc01ldGFkYXRhIiwibWVyZ2UiLCJnZXQiLCJTdGF0dXMiLCJJTlRFUk5BTCIsIk1ldGFkYXRhIiwiZ2V0Q29ubmVjdGl2aXR5U3RhdGUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIlJFQURZIiwiSW5maW5pdHkiLCJzZXQiLCJnZXREZWFkbGluZVRpbWVvdXRTdHJpbmciLCJnZXRSZWFsU3ViY2hhbm5lbCIsImNyZWF0ZUNhbGwiLCJvblJlY2VpdmVNZXRhZGF0YSIsIm9uUmVjZWl2ZU1lc3NhZ2UiLCJtZXNzYWdlIiwicnN0Q29kZSIsImNvbnN0YW50cyIsIk5HSFRUUDJfUkVGVVNFRF9TVFJFQU0iLCJlcnJvciIsIm9uQ2FsbFN0YXJ0ZWQiLCJnZXRDYWxsTnVtYmVyIiwic3RhcnRSZWFkIiwic2VuZE1lc3NhZ2VXaXRoQ29udGV4dCIsImNvbnRleHQiLCJoYWxmQ2xvc2UiLCJyZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUiLCJVTktOT1dOIiwiRFJPUCIsInNldEltbWVkaWF0ZSIsIlRSQU5TSUVOVF9GQUlMVVJFIiwicXVldWVDYWxsRm9yUGljayIsIlFVRVVFIiwiY2FuY2VsV2l0aFN0YXR1cyIsImdldFBlZXIiLCJnZXRUYXJnZXQiLCJzdGFydCIsInNldENyZWRlbnRpYWxzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/logging.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ var _a, _b, _c, _d;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.log = exports.setLoggerVerbosity = exports.setLogger = exports.getLogger = void 0;\nexports.trace = trace;\nexports.isTracerEnabled = isTracerEnabled;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst process_1 = __webpack_require__(/*! process */ \"process\");\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/@grpc/grpc-js/package.json\").version);\nconst DEFAULT_LOGGER = {\n    error: (message, ...optionalParams)=>{\n        console.error(\"E \" + message, ...optionalParams);\n    },\n    info: (message, ...optionalParams)=>{\n        console.error(\"I \" + message, ...optionalParams);\n    },\n    debug: (message, ...optionalParams)=>{\n        console.error(\"D \" + message, ...optionalParams);\n    }\n};\nlet _logger = DEFAULT_LOGGER;\nlet _logVerbosity = constants_1.LogVerbosity.ERROR;\nconst verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== void 0 ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== void 0 ? _b : \"\";\nswitch(verbosityString.toUpperCase()){\n    case \"DEBUG\":\n        _logVerbosity = constants_1.LogVerbosity.DEBUG;\n        break;\n    case \"INFO\":\n        _logVerbosity = constants_1.LogVerbosity.INFO;\n        break;\n    case \"ERROR\":\n        _logVerbosity = constants_1.LogVerbosity.ERROR;\n        break;\n    case \"NONE\":\n        _logVerbosity = constants_1.LogVerbosity.NONE;\n        break;\n    default:\n}\nconst getLogger = ()=>{\n    return _logger;\n};\nexports.getLogger = getLogger;\nconst setLogger = (logger)=>{\n    _logger = logger;\n};\nexports.setLogger = setLogger;\nconst setLoggerVerbosity = (verbosity)=>{\n    _logVerbosity = verbosity;\n};\nexports.setLoggerVerbosity = setLoggerVerbosity;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst log = (severity, ...args)=>{\n    let logFunction;\n    if (severity >= _logVerbosity) {\n        switch(severity){\n            case constants_1.LogVerbosity.DEBUG:\n                logFunction = _logger.debug;\n                break;\n            case constants_1.LogVerbosity.INFO:\n                logFunction = _logger.info;\n                break;\n            case constants_1.LogVerbosity.ERROR:\n                logFunction = _logger.error;\n                break;\n        }\n        /* Fall back to _logger.error when other methods are not available for\n         * compatiblity with older behavior that always logged to _logger.error */ if (!logFunction) {\n            logFunction = _logger.error;\n        }\n        if (logFunction) {\n            logFunction.bind(_logger)(...args);\n        }\n    }\n};\nexports.log = log;\nconst tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== void 0 ? _c : process.env.GRPC_TRACE) !== null && _d !== void 0 ? _d : \"\";\nconst enabledTracers = new Set();\nconst disabledTracers = new Set();\nfor (const tracerName of tracersString.split(\",\")){\n    if (tracerName.startsWith(\"-\")) {\n        disabledTracers.add(tracerName.substring(1));\n    } else {\n        enabledTracers.add(tracerName);\n    }\n}\nconst allEnabled = enabledTracers.has(\"all\");\nfunction trace(severity, tracer, text) {\n    if (isTracerEnabled(tracer)) {\n        (0, exports.log)(severity, new Date().toISOString() + \" | v\" + clientVersion + \" \" + process_1.pid + \" | \" + tracer + \" | \" + text);\n    }\n}\nfunction isTracerEnabled(tracer) {\n    return !disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer));\n} //# sourceMappingURL=logging.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9nZ2luZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELElBQUlBLElBQUlDLElBQUlDLElBQUlDO0FBQ2hCQyw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsV0FBVyxHQUFHQSwwQkFBMEIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHLEtBQUs7QUFDeEZBLGFBQWEsR0FBR007QUFDaEJOLHVCQUF1QixHQUFHTztBQUMxQixNQUFNQyxjQUFjQyxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQyx3QkFBUztBQUNuQyxNQUFNRSxnQkFBZ0JGLDBHQUFxQztBQUMzRCxNQUFNSSxpQkFBaUI7SUFDbkJDLE9BQU8sQ0FBQ0MsU0FBUyxHQUFHQztRQUNoQkMsUUFBUUgsS0FBSyxDQUFDLE9BQU9DLFlBQVlDO0lBQ3JDO0lBQ0FFLE1BQU0sQ0FBQ0gsU0FBUyxHQUFHQztRQUNmQyxRQUFRSCxLQUFLLENBQUMsT0FBT0MsWUFBWUM7SUFDckM7SUFDQUcsT0FBTyxDQUFDSixTQUFTLEdBQUdDO1FBQ2hCQyxRQUFRSCxLQUFLLENBQUMsT0FBT0MsWUFBWUM7SUFDckM7QUFDSjtBQUNBLElBQUlJLFVBQVVQO0FBQ2QsSUFBSVEsZ0JBQWdCYixZQUFZYyxZQUFZLENBQUNDLEtBQUs7QUFDbEQsTUFBTUMsa0JBQWtCLENBQUM3QixLQUFLLENBQUNELEtBQUsrQixRQUFRQyxHQUFHLENBQUNDLG1CQUFtQixNQUFNLFFBQVFqQyxPQUFPLEtBQUssSUFBSUEsS0FBSytCLFFBQVFDLEdBQUcsQ0FBQ0UsY0FBYyxNQUFNLFFBQVFqQyxPQUFPLEtBQUssSUFBSUEsS0FBSztBQUNuSyxPQUFRNkIsZ0JBQWdCSyxXQUFXO0lBQy9CLEtBQUs7UUFDRFIsZ0JBQWdCYixZQUFZYyxZQUFZLENBQUNRLEtBQUs7UUFDOUM7SUFDSixLQUFLO1FBQ0RULGdCQUFnQmIsWUFBWWMsWUFBWSxDQUFDUyxJQUFJO1FBQzdDO0lBQ0osS0FBSztRQUNEVixnQkFBZ0JiLFlBQVljLFlBQVksQ0FBQ0MsS0FBSztRQUM5QztJQUNKLEtBQUs7UUFDREYsZ0JBQWdCYixZQUFZYyxZQUFZLENBQUNVLElBQUk7UUFDN0M7SUFDSjtBQUVKO0FBQ0EsTUFBTTNCLFlBQVk7SUFDZCxPQUFPZTtBQUNYO0FBQ0FwQixpQkFBaUIsR0FBR0s7QUFDcEIsTUFBTUQsWUFBWSxDQUFDNkI7SUFDZmIsVUFBVWE7QUFDZDtBQUNBakMsaUJBQWlCLEdBQUdJO0FBQ3BCLE1BQU1ELHFCQUFxQixDQUFDK0I7SUFDeEJiLGdCQUFnQmE7QUFDcEI7QUFDQWxDLDBCQUEwQixHQUFHRztBQUM3Qiw4REFBOEQ7QUFDOUQsTUFBTUQsTUFBTSxDQUFDaUMsVUFBVSxHQUFHQztJQUN0QixJQUFJQztJQUNKLElBQUlGLFlBQVlkLGVBQWU7UUFDM0IsT0FBUWM7WUFDSixLQUFLM0IsWUFBWWMsWUFBWSxDQUFDUSxLQUFLO2dCQUMvQk8sY0FBY2pCLFFBQVFELEtBQUs7Z0JBQzNCO1lBQ0osS0FBS1gsWUFBWWMsWUFBWSxDQUFDUyxJQUFJO2dCQUM5Qk0sY0FBY2pCLFFBQVFGLElBQUk7Z0JBQzFCO1lBQ0osS0FBS1YsWUFBWWMsWUFBWSxDQUFDQyxLQUFLO2dCQUMvQmMsY0FBY2pCLFFBQVFOLEtBQUs7Z0JBQzNCO1FBQ1I7UUFDQTtnRkFDd0UsR0FDeEUsSUFBSSxDQUFDdUIsYUFBYTtZQUNkQSxjQUFjakIsUUFBUU4sS0FBSztRQUMvQjtRQUNBLElBQUl1QixhQUFhO1lBQ2JBLFlBQVlDLElBQUksQ0FBQ2xCLFlBQVlnQjtRQUNqQztJQUNKO0FBQ0o7QUFDQXBDLFdBQVcsR0FBR0U7QUFDZCxNQUFNcUMsZ0JBQWdCLENBQUMxQyxLQUFLLENBQUNELEtBQUs2QixRQUFRQyxHQUFHLENBQUNjLGVBQWUsTUFBTSxRQUFRNUMsT0FBTyxLQUFLLElBQUlBLEtBQUs2QixRQUFRQyxHQUFHLENBQUNlLFVBQVUsTUFBTSxRQUFRNUMsT0FBTyxLQUFLLElBQUlBLEtBQUs7QUFDekosTUFBTTZDLGlCQUFpQixJQUFJQztBQUMzQixNQUFNQyxrQkFBa0IsSUFBSUQ7QUFDNUIsS0FBSyxNQUFNRSxjQUFjTixjQUFjTyxLQUFLLENBQUMsS0FBTTtJQUMvQyxJQUFJRCxXQUFXRSxVQUFVLENBQUMsTUFBTTtRQUM1QkgsZ0JBQWdCSSxHQUFHLENBQUNILFdBQVdJLFNBQVMsQ0FBQztJQUM3QyxPQUNLO1FBQ0RQLGVBQWVNLEdBQUcsQ0FBQ0g7SUFDdkI7QUFDSjtBQUNBLE1BQU1LLGFBQWFSLGVBQWVTLEdBQUcsQ0FBQztBQUN0QyxTQUFTN0MsTUFBTTZCLFFBQVEsRUFBRWlCLE1BQU0sRUFBRUMsSUFBSTtJQUNqQyxJQUFJOUMsZ0JBQWdCNkMsU0FBUztRQUN4QixJQUFHcEQsUUFBUUUsR0FBRyxFQUFFaUMsVUFBVSxJQUFJbUIsT0FBT0MsV0FBVyxLQUM3QyxTQUNBNUMsZ0JBQ0EsTUFDQUQsVUFBVThDLEdBQUcsR0FDYixRQUNBSixTQUNBLFFBQ0FDO0lBQ1I7QUFDSjtBQUNBLFNBQVM5QyxnQkFBZ0I2QyxNQUFNO0lBQzNCLE9BQVEsQ0FBQ1IsZ0JBQWdCTyxHQUFHLENBQUNDLFdBQVlGLENBQUFBLGNBQWNSLGVBQWVTLEdBQUcsQ0FBQ0MsT0FBTTtBQUNwRixFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1ob3VzaW5nLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2dnaW5nLmpzPzQ1M2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbnZhciBfYSwgX2IsIF9jLCBfZDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9nID0gZXhwb3J0cy5zZXRMb2dnZXJWZXJib3NpdHkgPSBleHBvcnRzLnNldExvZ2dlciA9IGV4cG9ydHMuZ2V0TG9nZ2VyID0gdm9pZCAwO1xuZXhwb3J0cy50cmFjZSA9IHRyYWNlO1xuZXhwb3J0cy5pc1RyYWNlckVuYWJsZWQgPSBpc1RyYWNlckVuYWJsZWQ7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHByb2Nlc3NfMSA9IHJlcXVpcmUoXCJwcm9jZXNzXCIpO1xuY29uc3QgY2xpZW50VmVyc2lvbiA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG5jb25zdCBERUZBVUxUX0xPR0dFUiA9IHtcbiAgICBlcnJvcjogKG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0UgJyArIG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKTtcbiAgICB9LFxuICAgIGluZm86IChtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcykgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdJICcgKyBtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcyk7XG4gICAgfSxcbiAgICBkZWJ1ZzogKG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0QgJyArIG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKTtcbiAgICB9LFxufTtcbmxldCBfbG9nZ2VyID0gREVGQVVMVF9MT0dHRVI7XG5sZXQgX2xvZ1ZlcmJvc2l0eSA9IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUjtcbmNvbnN0IHZlcmJvc2l0eVN0cmluZyA9IChfYiA9IChfYSA9IHByb2Nlc3MuZW52LkdSUENfTk9ERV9WRVJCT1NJVFkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHByb2Nlc3MuZW52LkdSUENfVkVSQk9TSVRZKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJztcbnN3aXRjaCAodmVyYm9zaXR5U3RyaW5nLnRvVXBwZXJDYXNlKCkpIHtcbiAgICBjYXNlICdERUJVRyc6XG4gICAgICAgIF9sb2dWZXJib3NpdHkgPSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUc7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0lORk8nOlxuICAgICAgICBfbG9nVmVyYm9zaXR5ID0gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LklORk87XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0VSUk9SJzpcbiAgICAgICAgX2xvZ1ZlcmJvc2l0eSA9IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUjtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTk9ORSc6XG4gICAgICAgIF9sb2dWZXJib3NpdHkgPSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuTk9ORTtcbiAgICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAvLyBJZ25vcmUgYW55IG90aGVyIHZhbHVlc1xufVxuY29uc3QgZ2V0TG9nZ2VyID0gKCkgPT4ge1xuICAgIHJldHVybiBfbG9nZ2VyO1xufTtcbmV4cG9ydHMuZ2V0TG9nZ2VyID0gZ2V0TG9nZ2VyO1xuY29uc3Qgc2V0TG9nZ2VyID0gKGxvZ2dlcikgPT4ge1xuICAgIF9sb2dnZXIgPSBsb2dnZXI7XG59O1xuZXhwb3J0cy5zZXRMb2dnZXIgPSBzZXRMb2dnZXI7XG5jb25zdCBzZXRMb2dnZXJWZXJib3NpdHkgPSAodmVyYm9zaXR5KSA9PiB7XG4gICAgX2xvZ1ZlcmJvc2l0eSA9IHZlcmJvc2l0eTtcbn07XG5leHBvcnRzLnNldExvZ2dlclZlcmJvc2l0eSA9IHNldExvZ2dlclZlcmJvc2l0eTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBsb2cgPSAoc2V2ZXJpdHksIC4uLmFyZ3MpID0+IHtcbiAgICBsZXQgbG9nRnVuY3Rpb247XG4gICAgaWYgKHNldmVyaXR5ID49IF9sb2dWZXJib3NpdHkpIHtcbiAgICAgICAgc3dpdGNoIChzZXZlcml0eSkge1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUc6XG4gICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24gPSBfbG9nZ2VyLmRlYnVnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuSU5GTzpcbiAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbiA9IF9sb2dnZXIuaW5mbztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SOlxuICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uID0gX2xvZ2dlci5lcnJvcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvKiBGYWxsIGJhY2sgdG8gX2xvZ2dlci5lcnJvciB3aGVuIG90aGVyIG1ldGhvZHMgYXJlIG5vdCBhdmFpbGFibGUgZm9yXG4gICAgICAgICAqIGNvbXBhdGlibGl0eSB3aXRoIG9sZGVyIGJlaGF2aW9yIHRoYXQgYWx3YXlzIGxvZ2dlZCB0byBfbG9nZ2VyLmVycm9yICovXG4gICAgICAgIGlmICghbG9nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGxvZ0Z1bmN0aW9uID0gX2xvZ2dlci5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGxvZ0Z1bmN0aW9uLmJpbmQoX2xvZ2dlcikoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5jb25zdCB0cmFjZXJzU3RyaW5nID0gKF9kID0gKF9jID0gcHJvY2Vzcy5lbnYuR1JQQ19OT0RFX1RSQUNFKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBwcm9jZXNzLmVudi5HUlBDX1RSQUNFKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnJztcbmNvbnN0IGVuYWJsZWRUcmFjZXJzID0gbmV3IFNldCgpO1xuY29uc3QgZGlzYWJsZWRUcmFjZXJzID0gbmV3IFNldCgpO1xuZm9yIChjb25zdCB0cmFjZXJOYW1lIG9mIHRyYWNlcnNTdHJpbmcuc3BsaXQoJywnKSkge1xuICAgIGlmICh0cmFjZXJOYW1lLnN0YXJ0c1dpdGgoJy0nKSkge1xuICAgICAgICBkaXNhYmxlZFRyYWNlcnMuYWRkKHRyYWNlck5hbWUuc3Vic3RyaW5nKDEpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVuYWJsZWRUcmFjZXJzLmFkZCh0cmFjZXJOYW1lKTtcbiAgICB9XG59XG5jb25zdCBhbGxFbmFibGVkID0gZW5hYmxlZFRyYWNlcnMuaGFzKCdhbGwnKTtcbmZ1bmN0aW9uIHRyYWNlKHNldmVyaXR5LCB0cmFjZXIsIHRleHQpIHtcbiAgICBpZiAoaXNUcmFjZXJFbmFibGVkKHRyYWNlcikpIHtcbiAgICAgICAgKDAsIGV4cG9ydHMubG9nKShzZXZlcml0eSwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpICtcbiAgICAgICAgICAgICcgfCB2JyArXG4gICAgICAgICAgICBjbGllbnRWZXJzaW9uICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICBwcm9jZXNzXzEucGlkICtcbiAgICAgICAgICAgICcgfCAnICtcbiAgICAgICAgICAgIHRyYWNlciArXG4gICAgICAgICAgICAnIHwgJyArXG4gICAgICAgICAgICB0ZXh0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1RyYWNlckVuYWJsZWQodHJhY2VyKSB7XG4gICAgcmV0dXJuICghZGlzYWJsZWRUcmFjZXJzLmhhcyh0cmFjZXIpICYmIChhbGxFbmFibGVkIHx8IGVuYWJsZWRUcmFjZXJzLmhhcyh0cmFjZXIpKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJfYSIsIl9iIiwiX2MiLCJfZCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibG9nIiwic2V0TG9nZ2VyVmVyYm9zaXR5Iiwic2V0TG9nZ2VyIiwiZ2V0TG9nZ2VyIiwidHJhY2UiLCJpc1RyYWNlckVuYWJsZWQiLCJjb25zdGFudHNfMSIsInJlcXVpcmUiLCJwcm9jZXNzXzEiLCJjbGllbnRWZXJzaW9uIiwidmVyc2lvbiIsIkRFRkFVTFRfTE9HR0VSIiwiZXJyb3IiLCJtZXNzYWdlIiwib3B0aW9uYWxQYXJhbXMiLCJjb25zb2xlIiwiaW5mbyIsImRlYnVnIiwiX2xvZ2dlciIsIl9sb2dWZXJib3NpdHkiLCJMb2dWZXJib3NpdHkiLCJFUlJPUiIsInZlcmJvc2l0eVN0cmluZyIsInByb2Nlc3MiLCJlbnYiLCJHUlBDX05PREVfVkVSQk9TSVRZIiwiR1JQQ19WRVJCT1NJVFkiLCJ0b1VwcGVyQ2FzZSIsIkRFQlVHIiwiSU5GTyIsIk5PTkUiLCJsb2dnZXIiLCJ2ZXJib3NpdHkiLCJzZXZlcml0eSIsImFyZ3MiLCJsb2dGdW5jdGlvbiIsImJpbmQiLCJ0cmFjZXJzU3RyaW5nIiwiR1JQQ19OT0RFX1RSQUNFIiwiR1JQQ19UUkFDRSIsImVuYWJsZWRUcmFjZXJzIiwiU2V0IiwiZGlzYWJsZWRUcmFjZXJzIiwidHJhY2VyTmFtZSIsInNwbGl0Iiwic3RhcnRzV2l0aCIsImFkZCIsInN1YnN0cmluZyIsImFsbEVuYWJsZWQiLCJoYXMiLCJ0cmFjZXIiLCJ0ZXh0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwicGlkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/make-client.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/make-client.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.makeClientConstructor = makeClientConstructor;\nexports.loadPackageDefinition = loadPackageDefinition;\nconst client_1 = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/client.js\");\n/**\n * Map with short names for each of the requester maker functions. Used in\n * makeClientConstructor\n * @private\n */ const requesterFuncs = {\n    unary: client_1.Client.prototype.makeUnaryRequest,\n    server_stream: client_1.Client.prototype.makeServerStreamRequest,\n    client_stream: client_1.Client.prototype.makeClientStreamRequest,\n    bidi: client_1.Client.prototype.makeBidiStreamRequest\n};\n/**\n * Returns true, if given key is included in the blacklisted\n * keys.\n * @param key key for check, string.\n */ function isPrototypePolluted(key) {\n    return [\n        \"__proto__\",\n        \"prototype\",\n        \"constructor\"\n    ].includes(key);\n}\n/**\n * Creates a constructor for a client with the given methods, as specified in\n * the methods argument. The resulting class will have an instance method for\n * each method in the service, which is a partial application of one of the\n * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`\n * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`\n * arguments predefined.\n * @param methods An object mapping method names to\n *     method attributes\n * @param serviceName The fully qualified name of the service\n * @param classOptions An options object.\n * @return New client constructor, which is a subclass of\n *     {@link grpc.Client}, and has the same arguments as that constructor.\n */ function makeClientConstructor(methods, serviceName, classOptions) {\n    if (!classOptions) {\n        classOptions = {};\n    }\n    class ServiceClientImpl extends client_1.Client {\n    }\n    Object.keys(methods).forEach((name)=>{\n        if (isPrototypePolluted(name)) {\n            return;\n        }\n        const attrs = methods[name];\n        let methodType;\n        // TODO(murgatroid99): Verify that we don't need this anymore\n        if (typeof name === \"string\" && name.charAt(0) === \"$\") {\n            throw new Error(\"Method names cannot start with $\");\n        }\n        if (attrs.requestStream) {\n            if (attrs.responseStream) {\n                methodType = \"bidi\";\n            } else {\n                methodType = \"client_stream\";\n            }\n        } else {\n            if (attrs.responseStream) {\n                methodType = \"server_stream\";\n            } else {\n                methodType = \"unary\";\n            }\n        }\n        const serialize = attrs.requestSerialize;\n        const deserialize = attrs.responseDeserialize;\n        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);\n        ServiceClientImpl.prototype[name] = methodFunc;\n        // Associate all provided attributes with the method\n        Object.assign(ServiceClientImpl.prototype[name], attrs);\n        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {\n            ServiceClientImpl.prototype[attrs.originalName] = ServiceClientImpl.prototype[name];\n        }\n    });\n    ServiceClientImpl.service = methods;\n    ServiceClientImpl.serviceName = serviceName;\n    return ServiceClientImpl;\n}\nfunction partial(fn, path, serialize, deserialize) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return function(...args) {\n        return fn.call(this, path, serialize, deserialize, ...args);\n    };\n}\nfunction isProtobufTypeDefinition(obj) {\n    return \"format\" in obj;\n}\n/**\n * Load a gRPC package definition as a gRPC object hierarchy.\n * @param packageDef The package definition object.\n * @return The resulting gRPC object.\n */ function loadPackageDefinition(packageDef) {\n    const result = {};\n    for(const serviceFqn in packageDef){\n        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {\n            const service = packageDef[serviceFqn];\n            const nameComponents = serviceFqn.split(\".\");\n            if (nameComponents.some((comp)=>isPrototypePolluted(comp))) {\n                continue;\n            }\n            const serviceName = nameComponents[nameComponents.length - 1];\n            let current = result;\n            for (const packageName of nameComponents.slice(0, -1)){\n                if (!current[packageName]) {\n                    current[packageName] = {};\n                }\n                current = current[packageName];\n            }\n            if (isProtobufTypeDefinition(service)) {\n                current[serviceName] = service;\n            } else {\n                current[serviceName] = makeClientConstructor(service, serviceName, {});\n            }\n        }\n    }\n    return result;\n} //# sourceMappingURL=make-client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWFrZS1jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHRTtBQUNoQ0YsNkJBQTZCLEdBQUdHO0FBQ2hDLE1BQU1DLFdBQVdDLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DOzs7O0NBSUMsR0FDRCxNQUFNQyxpQkFBaUI7SUFDbkJDLE9BQU9ILFNBQVNJLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDQyxnQkFBZ0I7SUFDakRDLGVBQWVQLFNBQVNJLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDRyx1QkFBdUI7SUFDaEVDLGVBQWVULFNBQVNJLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDSyx1QkFBdUI7SUFDaEVDLE1BQU1YLFNBQVNJLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDTyxxQkFBcUI7QUFDekQ7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU0Msb0JBQW9CQyxHQUFHO0lBQzVCLE9BQU87UUFBQztRQUFhO1FBQWE7S0FBYyxDQUFDQyxRQUFRLENBQUNEO0FBQzlEO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNELFNBQVNoQixzQkFBc0JrQixPQUFPLEVBQUVDLFdBQVcsRUFBRUMsWUFBWTtJQUM3RCxJQUFJLENBQUNBLGNBQWM7UUFDZkEsZUFBZSxDQUFDO0lBQ3BCO0lBQ0EsTUFBTUMsMEJBQTBCbkIsU0FBU0ksTUFBTTtJQUMvQztJQUNBVixPQUFPMEIsSUFBSSxDQUFDSixTQUFTSyxPQUFPLENBQUNDLENBQUFBO1FBQ3pCLElBQUlULG9CQUFvQlMsT0FBTztZQUMzQjtRQUNKO1FBQ0EsTUFBTUMsUUFBUVAsT0FBTyxDQUFDTSxLQUFLO1FBQzNCLElBQUlFO1FBQ0osNkRBQTZEO1FBQzdELElBQUksT0FBT0YsU0FBUyxZQUFZQSxLQUFLRyxNQUFNLENBQUMsT0FBTyxLQUFLO1lBQ3BELE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLElBQUlILE1BQU1JLGFBQWEsRUFBRTtZQUNyQixJQUFJSixNQUFNSyxjQUFjLEVBQUU7Z0JBQ3RCSixhQUFhO1lBQ2pCLE9BQ0s7Z0JBQ0RBLGFBQWE7WUFDakI7UUFDSixPQUNLO1lBQ0QsSUFBSUQsTUFBTUssY0FBYyxFQUFFO2dCQUN0QkosYUFBYTtZQUNqQixPQUNLO2dCQUNEQSxhQUFhO1lBQ2pCO1FBQ0o7UUFDQSxNQUFNSyxZQUFZTixNQUFNTyxnQkFBZ0I7UUFDeEMsTUFBTUMsY0FBY1IsTUFBTVMsbUJBQW1CO1FBQzdDLE1BQU1DLGFBQWFDLFFBQVFoQyxjQUFjLENBQUNzQixXQUFXLEVBQUVELE1BQU1ZLElBQUksRUFBRU4sV0FBV0U7UUFDOUVaLGtCQUFrQmQsU0FBUyxDQUFDaUIsS0FBSyxHQUFHVztRQUNwQyxvREFBb0Q7UUFDcER2QyxPQUFPMEMsTUFBTSxDQUFDakIsa0JBQWtCZCxTQUFTLENBQUNpQixLQUFLLEVBQUVDO1FBQ2pELElBQUlBLE1BQU1jLFlBQVksSUFBSSxDQUFDeEIsb0JBQW9CVSxNQUFNYyxZQUFZLEdBQUc7WUFDaEVsQixrQkFBa0JkLFNBQVMsQ0FBQ2tCLE1BQU1jLFlBQVksQ0FBQyxHQUMzQ2xCLGtCQUFrQmQsU0FBUyxDQUFDaUIsS0FBSztRQUN6QztJQUNKO0lBQ0FILGtCQUFrQm1CLE9BQU8sR0FBR3RCO0lBQzVCRyxrQkFBa0JGLFdBQVcsR0FBR0E7SUFDaEMsT0FBT0U7QUFDWDtBQUNBLFNBQVNlLFFBQVFLLEVBQUUsRUFBRUosSUFBSSxFQUFFTixTQUFTLEVBQUVFLFdBQVc7SUFDN0MsOERBQThEO0lBQzlELE9BQU8sU0FBVSxHQUFHUyxJQUFJO1FBQ3BCLE9BQU9ELEdBQUdFLElBQUksQ0FBQyxJQUFJLEVBQUVOLE1BQU1OLFdBQVdFLGdCQUFnQlM7SUFDMUQ7QUFDSjtBQUNBLFNBQVNFLHlCQUF5QkMsR0FBRztJQUNqQyxPQUFPLFlBQVlBO0FBQ3ZCO0FBQ0E7Ozs7Q0FJQyxHQUNELFNBQVM1QyxzQkFBc0I2QyxVQUFVO0lBQ3JDLE1BQU1DLFNBQVMsQ0FBQztJQUNoQixJQUFLLE1BQU1DLGNBQWNGLFdBQVk7UUFDakMsSUFBSWxELE9BQU9XLFNBQVMsQ0FBQzBDLGNBQWMsQ0FBQ04sSUFBSSxDQUFDRyxZQUFZRSxhQUFhO1lBQzlELE1BQU1SLFVBQVVNLFVBQVUsQ0FBQ0UsV0FBVztZQUN0QyxNQUFNRSxpQkFBaUJGLFdBQVdHLEtBQUssQ0FBQztZQUN4QyxJQUFJRCxlQUFlRSxJQUFJLENBQUMsQ0FBQ0MsT0FBU3RDLG9CQUFvQnNDLFFBQVE7Z0JBQzFEO1lBQ0o7WUFDQSxNQUFNbEMsY0FBYytCLGNBQWMsQ0FBQ0EsZUFBZUksTUFBTSxHQUFHLEVBQUU7WUFDN0QsSUFBSUMsVUFBVVI7WUFDZCxLQUFLLE1BQU1TLGVBQWVOLGVBQWVPLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBSTtnQkFDbkQsSUFBSSxDQUFDRixPQUFPLENBQUNDLFlBQVksRUFBRTtvQkFDdkJELE9BQU8sQ0FBQ0MsWUFBWSxHQUFHLENBQUM7Z0JBQzVCO2dCQUNBRCxVQUFVQSxPQUFPLENBQUNDLFlBQVk7WUFDbEM7WUFDQSxJQUFJWix5QkFBeUJKLFVBQVU7Z0JBQ25DZSxPQUFPLENBQUNwQyxZQUFZLEdBQUdxQjtZQUMzQixPQUNLO2dCQUNEZSxPQUFPLENBQUNwQyxZQUFZLEdBQUduQixzQkFBc0J3QyxTQUFTckIsYUFBYSxDQUFDO1lBQ3hFO1FBQ0o7SUFDSjtJQUNBLE9BQU80QjtBQUNYLEVBQ0EsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnljLWhvdXNpbmctYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL21ha2UtY2xpZW50LmpzPzZiYmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWFrZUNsaWVudENvbnN0cnVjdG9yID0gbWFrZUNsaWVudENvbnN0cnVjdG9yO1xuZXhwb3J0cy5sb2FkUGFja2FnZURlZmluaXRpb24gPSBsb2FkUGFja2FnZURlZmluaXRpb247XG5jb25zdCBjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NsaWVudFwiKTtcbi8qKlxuICogTWFwIHdpdGggc2hvcnQgbmFtZXMgZm9yIGVhY2ggb2YgdGhlIHJlcXVlc3RlciBtYWtlciBmdW5jdGlvbnMuIFVzZWQgaW5cbiAqIG1ha2VDbGllbnRDb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgcmVxdWVzdGVyRnVuY3MgPSB7XG4gICAgdW5hcnk6IGNsaWVudF8xLkNsaWVudC5wcm90b3R5cGUubWFrZVVuYXJ5UmVxdWVzdCxcbiAgICBzZXJ2ZXJfc3RyZWFtOiBjbGllbnRfMS5DbGllbnQucHJvdG90eXBlLm1ha2VTZXJ2ZXJTdHJlYW1SZXF1ZXN0LFxuICAgIGNsaWVudF9zdHJlYW06IGNsaWVudF8xLkNsaWVudC5wcm90b3R5cGUubWFrZUNsaWVudFN0cmVhbVJlcXVlc3QsXG4gICAgYmlkaTogY2xpZW50XzEuQ2xpZW50LnByb3RvdHlwZS5tYWtlQmlkaVN0cmVhbVJlcXVlc3QsXG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUsIGlmIGdpdmVuIGtleSBpcyBpbmNsdWRlZCBpbiB0aGUgYmxhY2tsaXN0ZWRcbiAqIGtleXMuXG4gKiBAcGFyYW0ga2V5IGtleSBmb3IgY2hlY2ssIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGVQb2xsdXRlZChrZXkpIHtcbiAgICByZXR1cm4gWydfX3Byb3RvX18nLCAncHJvdG90eXBlJywgJ2NvbnN0cnVjdG9yJ10uaW5jbHVkZXMoa2V5KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGNvbnN0cnVjdG9yIGZvciBhIGNsaWVudCB3aXRoIHRoZSBnaXZlbiBtZXRob2RzLCBhcyBzcGVjaWZpZWQgaW5cbiAqIHRoZSBtZXRob2RzIGFyZ3VtZW50LiBUaGUgcmVzdWx0aW5nIGNsYXNzIHdpbGwgaGF2ZSBhbiBpbnN0YW5jZSBtZXRob2QgZm9yXG4gKiBlYWNoIG1ldGhvZCBpbiB0aGUgc2VydmljZSwgd2hpY2ggaXMgYSBwYXJ0aWFsIGFwcGxpY2F0aW9uIG9mIG9uZSBvZiB0aGVcbiAqIFtDbGllbnRde0BsaW5rIGdycGMuQ2xpZW50fSByZXF1ZXN0IG1ldGhvZHMsIGRlcGVuZGluZyBvbiBgcmVxdWVzdFNlcmlhbGl6ZWBcbiAqIGFuZCBgcmVzcG9uc2VTZXJpYWxpemVgLCB3aXRoIHRoZSBgbWV0aG9kYCwgYHNlcmlhbGl6ZWAsIGFuZCBgZGVzZXJpYWxpemVgXG4gKiBhcmd1bWVudHMgcHJlZGVmaW5lZC5cbiAqIEBwYXJhbSBtZXRob2RzIEFuIG9iamVjdCBtYXBwaW5nIG1ldGhvZCBuYW1lcyB0b1xuICogICAgIG1ldGhvZCBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0gc2VydmljZU5hbWUgVGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lIG9mIHRoZSBzZXJ2aWNlXG4gKiBAcGFyYW0gY2xhc3NPcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0LlxuICogQHJldHVybiBOZXcgY2xpZW50IGNvbnN0cnVjdG9yLCB3aGljaCBpcyBhIHN1YmNsYXNzIG9mXG4gKiAgICAge0BsaW5rIGdycGMuQ2xpZW50fSwgYW5kIGhhcyB0aGUgc2FtZSBhcmd1bWVudHMgYXMgdGhhdCBjb25zdHJ1Y3Rvci5cbiAqL1xuZnVuY3Rpb24gbWFrZUNsaWVudENvbnN0cnVjdG9yKG1ldGhvZHMsIHNlcnZpY2VOYW1lLCBjbGFzc09wdGlvbnMpIHtcbiAgICBpZiAoIWNsYXNzT3B0aW9ucykge1xuICAgICAgICBjbGFzc09wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY2xhc3MgU2VydmljZUNsaWVudEltcGwgZXh0ZW5kcyBjbGllbnRfMS5DbGllbnQge1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhtZXRob2RzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICBpZiAoaXNQcm90b3R5cGVQb2xsdXRlZChuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHJzID0gbWV0aG9kc1tuYW1lXTtcbiAgICAgICAgbGV0IG1ldGhvZFR5cGU7XG4gICAgICAgIC8vIFRPRE8obXVyZ2F0cm9pZDk5KTogVmVyaWZ5IHRoYXQgd2UgZG9uJ3QgbmVlZCB0aGlzIGFueW1vcmVcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyAmJiBuYW1lLmNoYXJBdCgwKSA9PT0gJyQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBuYW1lcyBjYW5ub3Qgc3RhcnQgd2l0aCAkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJzLnJlcXVlc3RTdHJlYW0pIHtcbiAgICAgICAgICAgIGlmIChhdHRycy5yZXNwb25zZVN0cmVhbSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAnYmlkaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ2NsaWVudF9zdHJlYW0nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGF0dHJzLnJlc3BvbnNlU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICdzZXJ2ZXJfc3RyZWFtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAndW5hcnknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZSA9IGF0dHJzLnJlcXVlc3RTZXJpYWxpemU7XG4gICAgICAgIGNvbnN0IGRlc2VyaWFsaXplID0gYXR0cnMucmVzcG9uc2VEZXNlcmlhbGl6ZTtcbiAgICAgICAgY29uc3QgbWV0aG9kRnVuYyA9IHBhcnRpYWwocmVxdWVzdGVyRnVuY3NbbWV0aG9kVHlwZV0sIGF0dHJzLnBhdGgsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUpO1xuICAgICAgICBTZXJ2aWNlQ2xpZW50SW1wbC5wcm90b3R5cGVbbmFtZV0gPSBtZXRob2RGdW5jO1xuICAgICAgICAvLyBBc3NvY2lhdGUgYWxsIHByb3ZpZGVkIGF0dHJpYnV0ZXMgd2l0aCB0aGUgbWV0aG9kXG4gICAgICAgIE9iamVjdC5hc3NpZ24oU2VydmljZUNsaWVudEltcGwucHJvdG90eXBlW25hbWVdLCBhdHRycyk7XG4gICAgICAgIGlmIChhdHRycy5vcmlnaW5hbE5hbWUgJiYgIWlzUHJvdG90eXBlUG9sbHV0ZWQoYXR0cnMub3JpZ2luYWxOYW1lKSkge1xuICAgICAgICAgICAgU2VydmljZUNsaWVudEltcGwucHJvdG90eXBlW2F0dHJzLm9yaWdpbmFsTmFtZV0gPVxuICAgICAgICAgICAgICAgIFNlcnZpY2VDbGllbnRJbXBsLnByb3RvdHlwZVtuYW1lXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFNlcnZpY2VDbGllbnRJbXBsLnNlcnZpY2UgPSBtZXRob2RzO1xuICAgIFNlcnZpY2VDbGllbnRJbXBsLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XG4gICAgcmV0dXJuIFNlcnZpY2VDbGllbnRJbXBsO1xufVxuZnVuY3Rpb24gcGFydGlhbChmbiwgcGF0aCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIHBhdGgsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIC4uLmFyZ3MpO1xuICAgIH07XG59XG5mdW5jdGlvbiBpc1Byb3RvYnVmVHlwZURlZmluaXRpb24ob2JqKSB7XG4gICAgcmV0dXJuICdmb3JtYXQnIGluIG9iajtcbn1cbi8qKlxuICogTG9hZCBhIGdSUEMgcGFja2FnZSBkZWZpbml0aW9uIGFzIGEgZ1JQQyBvYmplY3QgaGllcmFyY2h5LlxuICogQHBhcmFtIHBhY2thZ2VEZWYgVGhlIHBhY2thZ2UgZGVmaW5pdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJuIFRoZSByZXN1bHRpbmcgZ1JQQyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGxvYWRQYWNrYWdlRGVmaW5pdGlvbihwYWNrYWdlRGVmKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBzZXJ2aWNlRnFuIGluIHBhY2thZ2VEZWYpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYWNrYWdlRGVmLCBzZXJ2aWNlRnFuKSkge1xuICAgICAgICAgICAgY29uc3Qgc2VydmljZSA9IHBhY2thZ2VEZWZbc2VydmljZUZxbl07XG4gICAgICAgICAgICBjb25zdCBuYW1lQ29tcG9uZW50cyA9IHNlcnZpY2VGcW4uc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIGlmIChuYW1lQ29tcG9uZW50cy5zb21lKChjb21wKSA9PiBpc1Byb3RvdHlwZVBvbGx1dGVkKGNvbXApKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VydmljZU5hbWUgPSBuYW1lQ29tcG9uZW50c1tuYW1lQ29tcG9uZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gcmVzdWx0O1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYWNrYWdlTmFtZSBvZiBuYW1lQ29tcG9uZW50cy5zbGljZSgwLCAtMSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRbcGFja2FnZU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRbcGFja2FnZU5hbWVdID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhY2thZ2VOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1Byb3RvYnVmVHlwZURlZmluaXRpb24oc2VydmljZSkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50W3NlcnZpY2VOYW1lXSA9IHNlcnZpY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50W3NlcnZpY2VOYW1lXSA9IG1ha2VDbGllbnRDb25zdHJ1Y3RvcihzZXJ2aWNlLCBzZXJ2aWNlTmFtZSwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlLWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtYWtlQ2xpZW50Q29uc3RydWN0b3IiLCJsb2FkUGFja2FnZURlZmluaXRpb24iLCJjbGllbnRfMSIsInJlcXVpcmUiLCJyZXF1ZXN0ZXJGdW5jcyIsInVuYXJ5IiwiQ2xpZW50IiwicHJvdG90eXBlIiwibWFrZVVuYXJ5UmVxdWVzdCIsInNlcnZlcl9zdHJlYW0iLCJtYWtlU2VydmVyU3RyZWFtUmVxdWVzdCIsImNsaWVudF9zdHJlYW0iLCJtYWtlQ2xpZW50U3RyZWFtUmVxdWVzdCIsImJpZGkiLCJtYWtlQmlkaVN0cmVhbVJlcXVlc3QiLCJpc1Byb3RvdHlwZVBvbGx1dGVkIiwia2V5IiwiaW5jbHVkZXMiLCJtZXRob2RzIiwic2VydmljZU5hbWUiLCJjbGFzc09wdGlvbnMiLCJTZXJ2aWNlQ2xpZW50SW1wbCIsImtleXMiLCJmb3JFYWNoIiwibmFtZSIsImF0dHJzIiwibWV0aG9kVHlwZSIsImNoYXJBdCIsIkVycm9yIiwicmVxdWVzdFN0cmVhbSIsInJlc3BvbnNlU3RyZWFtIiwic2VyaWFsaXplIiwicmVxdWVzdFNlcmlhbGl6ZSIsImRlc2VyaWFsaXplIiwicmVzcG9uc2VEZXNlcmlhbGl6ZSIsIm1ldGhvZEZ1bmMiLCJwYXJ0aWFsIiwicGF0aCIsImFzc2lnbiIsIm9yaWdpbmFsTmFtZSIsInNlcnZpY2UiLCJmbiIsImFyZ3MiLCJjYWxsIiwiaXNQcm90b2J1ZlR5cGVEZWZpbml0aW9uIiwib2JqIiwicGFja2FnZURlZiIsInJlc3VsdCIsInNlcnZpY2VGcW4iLCJoYXNPd25Qcm9wZXJ0eSIsIm5hbWVDb21wb25lbnRzIiwic3BsaXQiLCJzb21lIiwiY29tcCIsImxlbmd0aCIsImN1cnJlbnQiLCJwYWNrYWdlTmFtZSIsInNsaWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/make-client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/metadata.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Metadata = void 0;\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/error.js\");\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\nfunction isLegalKey(key) {\n    return LEGAL_KEY_REGEX.test(key);\n}\nfunction isLegalNonBinaryValue(value) {\n    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\nfunction isBinaryKey(key) {\n    return key.endsWith(\"-bin\");\n}\nfunction isCustomMetadata(key) {\n    return !key.startsWith(\"grpc-\");\n}\nfunction normalizeKey(key) {\n    return key.toLowerCase();\n}\nfunction validate(key, value) {\n    if (!isLegalKey(key)) {\n        throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n    }\n    if (value !== null && value !== undefined) {\n        if (isBinaryKey(key)) {\n            if (!Buffer.isBuffer(value)) {\n                throw new Error(\"keys that end with '-bin' must have Buffer values\");\n            }\n        } else {\n            if (Buffer.isBuffer(value)) {\n                throw new Error(\"keys that don't end with '-bin' must have String values\");\n            }\n            if (!isLegalNonBinaryValue(value)) {\n                throw new Error('Metadata string value \"' + value + '\" contains illegal characters');\n            }\n        }\n    }\n}\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */ class Metadata {\n    constructor(options = {}){\n        this.internalRepr = new Map();\n        this.options = options;\n    }\n    /**\n     * Sets the given value for the given key by replacing any other values\n     * associated with that key. Normalizes the key.\n     * @param key The key to whose value should be set.\n     * @param value The value to set. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */ set(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        this.internalRepr.set(key, [\n            value\n        ]);\n    }\n    /**\n     * Adds the given value for the given key by appending to a list of previous\n     * values associated with that key. Normalizes the key.\n     * @param key The key for which a new value should be appended.\n     * @param value The value to add. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */ add(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        const existingValue = this.internalRepr.get(key);\n        if (existingValue === undefined) {\n            this.internalRepr.set(key, [\n                value\n            ]);\n        } else {\n            existingValue.push(value);\n        }\n    }\n    /**\n     * Removes the given key and any associated values. Normalizes the key.\n     * @param key The key whose values should be removed.\n     */ remove(key) {\n        key = normalizeKey(key);\n        // validate(key);\n        this.internalRepr.delete(key);\n    }\n    /**\n     * Gets a list of all values associated with the key. Normalizes the key.\n     * @param key The key whose value should be retrieved.\n     * @return A list of values associated with the given key.\n     */ get(key) {\n        key = normalizeKey(key);\n        // validate(key);\n        return this.internalRepr.get(key) || [];\n    }\n    /**\n     * Gets a plain object mapping each key to the first value associated with it.\n     * This reflects the most common way that people will want to see metadata.\n     * @return A key/value mapping of the metadata.\n     */ getMap() {\n        const result = {};\n        for (const [key, values] of this.internalRepr){\n            if (values.length > 0) {\n                const v = values[0];\n                result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;\n            }\n        }\n        return result;\n    }\n    /**\n     * Clones the metadata object.\n     * @return The newly cloned object.\n     */ clone() {\n        const newMetadata = new Metadata(this.options);\n        const newInternalRepr = newMetadata.internalRepr;\n        for (const [key, value] of this.internalRepr){\n            const clonedValue = value.map((v)=>{\n                if (Buffer.isBuffer(v)) {\n                    return Buffer.from(v);\n                } else {\n                    return v;\n                }\n            });\n            newInternalRepr.set(key, clonedValue);\n        }\n        return newMetadata;\n    }\n    /**\n     * Merges all key-value pairs from a given Metadata object into this one.\n     * If both this object and the given object have values in the same key,\n     * values from the other Metadata object will be appended to this object's\n     * values.\n     * @param other A Metadata object.\n     */ merge(other) {\n        for (const [key, values] of other.internalRepr){\n            const mergedValue = (this.internalRepr.get(key) || []).concat(values);\n            this.internalRepr.set(key, mergedValue);\n        }\n    }\n    setOptions(options) {\n        this.options = options;\n    }\n    getOptions() {\n        return this.options;\n    }\n    /**\n     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n     */ toHttp2Headers() {\n        // NOTE: Node <8.9 formats http2 headers incorrectly.\n        const result = {};\n        for (const [key, values] of this.internalRepr){\n            // We assume that the user's interaction with this object is limited to\n            // through its public API (i.e. keys and values are already validated).\n            result[key] = values.map(bufToString);\n        }\n        return result;\n    }\n    /**\n     * This modifies the behavior of JSON.stringify to show an object\n     * representation of the metadata map.\n     */ toJSON() {\n        const result = {};\n        for (const [key, values] of this.internalRepr){\n            result[key] = values;\n        }\n        return result;\n    }\n    /**\n     * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n     * object.\n     * @param headers An IncomingHttpHeaders object.\n     */ static fromHttp2Headers(headers) {\n        const result = new Metadata();\n        for (const key of Object.keys(headers)){\n            // Reserved headers (beginning with `:`) are not valid keys.\n            if (key.charAt(0) === \":\") {\n                continue;\n            }\n            const values = headers[key];\n            try {\n                if (isBinaryKey(key)) {\n                    if (Array.isArray(values)) {\n                        values.forEach((value)=>{\n                            result.add(key, Buffer.from(value, \"base64\"));\n                        });\n                    } else if (values !== undefined) {\n                        if (isCustomMetadata(key)) {\n                            values.split(\",\").forEach((v)=>{\n                                result.add(key, Buffer.from(v.trim(), \"base64\"));\n                            });\n                        } else {\n                            result.add(key, Buffer.from(values, \"base64\"));\n                        }\n                    }\n                } else {\n                    if (Array.isArray(values)) {\n                        values.forEach((value)=>{\n                            result.add(key, value);\n                        });\n                    } else if (values !== undefined) {\n                        result.add(key, values);\n                    }\n                }\n            } catch (error) {\n                const message = `Failed to add metadata entry ${key}: ${values}. ${(0, error_1.getErrorMessage)(error)}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\n                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, message);\n            }\n        }\n        return result;\n    }\n}\nexports.Metadata = Metadata;\nconst bufToString = (val)=>{\n    return Buffer.isBuffer(val) ? val.toString(\"base64\") : val;\n}; //# sourceMappingURL=metadata.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWV0YWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdCQUFnQixHQUFHLEtBQUs7QUFDeEIsTUFBTUcsWUFBWUMsbUJBQU9BLENBQUMsMEVBQVc7QUFDckMsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMsc0VBQVM7QUFDakMsTUFBTUcsa0JBQWtCO0FBQ3hCLE1BQU1DLCtCQUErQjtBQUNyQyxTQUFTQyxXQUFXQyxHQUFHO0lBQ25CLE9BQU9ILGdCQUFnQkksSUFBSSxDQUFDRDtBQUNoQztBQUNBLFNBQVNFLHNCQUFzQlgsS0FBSztJQUNoQyxPQUFPTyw2QkFBNkJHLElBQUksQ0FBQ1Y7QUFDN0M7QUFDQSxTQUFTWSxZQUFZSCxHQUFHO0lBQ3BCLE9BQU9BLElBQUlJLFFBQVEsQ0FBQztBQUN4QjtBQUNBLFNBQVNDLGlCQUFpQkwsR0FBRztJQUN6QixPQUFPLENBQUNBLElBQUlNLFVBQVUsQ0FBQztBQUMzQjtBQUNBLFNBQVNDLGFBQWFQLEdBQUc7SUFDckIsT0FBT0EsSUFBSVEsV0FBVztBQUMxQjtBQUNBLFNBQVNDLFNBQVNULEdBQUcsRUFBRVQsS0FBSztJQUN4QixJQUFJLENBQUNRLFdBQVdDLE1BQU07UUFDbEIsTUFBTSxJQUFJVSxNQUFNLG1CQUFtQlYsTUFBTTtJQUM3QztJQUNBLElBQUlULFVBQVUsUUFBUUEsVUFBVW9CLFdBQVc7UUFDdkMsSUFBSVIsWUFBWUgsTUFBTTtZQUNsQixJQUFJLENBQUNZLE9BQU9DLFFBQVEsQ0FBQ3RCLFFBQVE7Z0JBQ3pCLE1BQU0sSUFBSW1CLE1BQU07WUFDcEI7UUFDSixPQUNLO1lBQ0QsSUFBSUUsT0FBT0MsUUFBUSxDQUFDdEIsUUFBUTtnQkFDeEIs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Q3ZCMkIsT0FBT3lCLEtBQUssQ0FBQyxLQUFLRCxPQUFPLENBQUN0QixDQUFBQTtnQ0FDdEJILE9BQU9QLEdBQUcsQ0FBQ25CLEtBQUtZLE9BQU9rQixJQUFJLENBQUNELEVBQUV3QixJQUFJLElBQUk7NEJBQzFDO3dCQUNKLE9BQ0s7NEJBQ0QzQixPQUFPUCxHQUFHLENBQUNuQixLQUFLWSxPQUFPa0IsSUFBSSxDQUFDSCxRQUFRO3dCQUN4QztvQkFDSjtnQkFDSixPQUNLO29CQUNELElBQUlzQixNQUFNQyxPQUFPLENBQUN2QixTQUFTO3dCQUN2QkEsT0FBT3dCLE9BQU8sQ0FBQzVELENBQUFBOzRCQUNYbUMsT0FBT1AsR0FBRyxDQUFDbkIsS0FBS1Q7d0JBQ3BCO29CQUNKLE9BQ0ssSUFBSW9DLFdBQVdoQixXQUFXO3dCQUMzQmUsT0FBT1AsR0FBRyxDQUFDbkIsS0FBSzJCO29CQUNwQjtnQkFDSjtZQUNKLEVBQ0EsT0FBTzJCLE9BQU87Z0JBQ1YsTUFBTUMsVUFBVSxDQUFDLDZCQUE2QixFQUFFdkQsSUFBSSxFQUFFLEVBQUUyQixPQUFPLEVBQUUsRUFBRSxDQUFDLEdBQUcvQixRQUFRNEQsZUFBZSxFQUFFRixPQUFPLHdFQUF3RSxDQUFDO2dCQUMvSyxJQUFHN0QsVUFBVWdFLEdBQUcsRUFBRTlELFlBQVkrRCxZQUFZLENBQUNDLEtBQUssRUFBRUo7WUFDdkQ7UUFDSjtRQUNBLE9BQU83QjtJQUNYO0FBQ0o7QUFDQXBDLGdCQUFnQixHQUFHRTtBQUNuQixNQUFNbUQsY0FBYyxDQUFDaUI7SUFDakIsT0FBT2hELE9BQU9DLFFBQVEsQ0FBQytDLE9BQU9BLElBQUlDLFFBQVEsQ0FBQyxZQUFZRDtBQUMzRCxHQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1ob3VzaW5nLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9tZXRhZGF0YS5qcz8xYzVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1ldGFkYXRhID0gdm9pZCAwO1xuY29uc3QgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xuY29uc3QgTEVHQUxfS0VZX1JFR0VYID0gL15bMC05YS16Xy4tXSskLztcbmNvbnN0IExFR0FMX05PTl9CSU5BUllfVkFMVUVfUkVHRVggPSAvXlsgLX5dKiQvO1xuZnVuY3Rpb24gaXNMZWdhbEtleShrZXkpIHtcbiAgICByZXR1cm4gTEVHQUxfS0VZX1JFR0VYLnRlc3Qoa2V5KTtcbn1cbmZ1bmN0aW9uIGlzTGVnYWxOb25CaW5hcnlWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBMRUdBTF9OT05fQklOQVJZX1ZBTFVFX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNCaW5hcnlLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5lbmRzV2l0aCgnLWJpbicpO1xufVxuZnVuY3Rpb24gaXNDdXN0b21NZXRhZGF0YShrZXkpIHtcbiAgICByZXR1cm4gIWtleS5zdGFydHNXaXRoKCdncnBjLScpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplS2V5KGtleSkge1xuICAgIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzTGVnYWxLZXkoa2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFkYXRhIGtleSBcIicgKyBrZXkgKyAnXCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc0JpbmFyeUtleShrZXkpKSB7XG4gICAgICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXlzIHRoYXQgZW5kIHdpdGggJy1iaW4nIG11c3QgaGF2ZSBCdWZmZXIgdmFsdWVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXlzIHRoYXQgZG9uJ3QgZW5kIHdpdGggJy1iaW4nIG11c3QgaGF2ZSBTdHJpbmcgdmFsdWVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0xlZ2FsTm9uQmluYXJ5VmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhZGF0YSBzdHJpbmcgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEEgY2xhc3MgZm9yIHN0b3JpbmcgbWV0YWRhdGEuIEtleXMgYXJlIG5vcm1hbGl6ZWQgdG8gbG93ZXJjYXNlIEFTQ0lJLlxuICovXG5jbGFzcyBNZXRhZGF0YSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxSZXByID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBnaXZlbiB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleSBieSByZXBsYWNpbmcgYW55IG90aGVyIHZhbHVlc1xuICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGF0IGtleS4gTm9ybWFsaXplcyB0aGUga2V5LlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byB3aG9zZSB2YWx1ZSBzaG91bGQgYmUgc2V0LlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LiBNdXN0IGJlIGEgYnVmZmVyIGlmIGFuZCBvbmx5XG4gICAgICogICBpZiB0aGUgbm9ybWFsaXplZCBrZXkgZW5kcyB3aXRoICctYmluJy5cbiAgICAgKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcbiAgICAgICAgdmFsaWRhdGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxSZXByLnNldChrZXksIFt2YWx1ZV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleSBieSBhcHBlbmRpbmcgdG8gYSBsaXN0IG9mIHByZXZpb3VzXG4gICAgICogdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGF0IGtleS4gTm9ybWFsaXplcyB0aGUga2V5LlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBmb3Igd2hpY2ggYSBuZXcgdmFsdWUgc2hvdWxkIGJlIGFwcGVuZGVkLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkLiBNdXN0IGJlIGEgYnVmZmVyIGlmIGFuZCBvbmx5XG4gICAgICogICBpZiB0aGUgbm9ybWFsaXplZCBrZXkgZW5kcyB3aXRoICctYmluJy5cbiAgICAgKi9cbiAgICBhZGQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcbiAgICAgICAgdmFsaWRhdGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVmFsdWUgPSB0aGlzLmludGVybmFsUmVwci5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFJlcHIuc2V0KGtleSwgW3ZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleGlzdGluZ1ZhbHVlLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIGtleSBhbmQgYW55IGFzc29jaWF0ZWQgdmFsdWVzLiBOb3JtYWxpemVzIHRoZSBrZXkuXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHdob3NlIHZhbHVlcyBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICByZW1vdmUoa2V5KSB7XG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuICAgICAgICAvLyB2YWxpZGF0ZShrZXkpO1xuICAgICAgICB0aGlzLmludGVybmFsUmVwci5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2YgYWxsIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGtleS4gTm9ybWFsaXplcyB0aGUga2V5LlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB3aG9zZSB2YWx1ZSBzaG91bGQgYmUgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4gQSBsaXN0IG9mIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGtleS5cbiAgICAgKi9cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuICAgICAgICAvLyB2YWxpZGF0ZShrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFJlcHIuZ2V0KGtleSkgfHwgW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBwbGFpbiBvYmplY3QgbWFwcGluZyBlYWNoIGtleSB0byB0aGUgZmlyc3QgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICAgICAqIFRoaXMgcmVmbGVjdHMgdGhlIG1vc3QgY29tbW9uIHdheSB0aGF0IHBlb3BsZSB3aWxsIHdhbnQgdG8gc2VlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm4gQSBrZXkvdmFsdWUgbWFwcGluZyBvZiB0aGUgbWV0YWRhdGEuXG4gICAgICovXG4gICAgZ2V0TWFwKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIHRoaXMuaW50ZXJuYWxSZXByKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gdmFsdWVzWzBdO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gQnVmZmVyLmlzQnVmZmVyKHYpID8gQnVmZmVyLmZyb20odikgOiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lcyB0aGUgbWV0YWRhdGEgb2JqZWN0LlxuICAgICAqIEByZXR1cm4gVGhlIG5ld2x5IGNsb25lZCBvYmplY3QuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IG5ld01ldGFkYXRhID0gbmV3IE1ldGFkYXRhKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG5ld0ludGVybmFsUmVwciA9IG5ld01ldGFkYXRhLmludGVybmFsUmVwcjtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5pbnRlcm5hbFJlcHIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lZFZhbHVlID0gdmFsdWUubWFwKHYgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZXdJbnRlcm5hbFJlcHIuc2V0KGtleSwgY2xvbmVkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdNZXRhZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVyZ2VzIGFsbCBrZXktdmFsdWUgcGFpcnMgZnJvbSBhIGdpdmVuIE1ldGFkYXRhIG9iamVjdCBpbnRvIHRoaXMgb25lLlxuICAgICAqIElmIGJvdGggdGhpcyBvYmplY3QgYW5kIHRoZSBnaXZlbiBvYmplY3QgaGF2ZSB2YWx1ZXMgaW4gdGhlIHNhbWUga2V5LFxuICAgICAqIHZhbHVlcyBmcm9tIHRoZSBvdGhlciBNZXRhZGF0YSBvYmplY3Qgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGlzIG9iamVjdCdzXG4gICAgICogdmFsdWVzLlxuICAgICAqIEBwYXJhbSBvdGhlciBBIE1ldGFkYXRhIG9iamVjdC5cbiAgICAgKi9cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2Ygb3RoZXIuaW50ZXJuYWxSZXByKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRWYWx1ZSA9ICh0aGlzLmludGVybmFsUmVwci5nZXQoa2V5KSB8fCBbXSkuY29uY2F0KHZhbHVlcyk7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsUmVwci5zZXQoa2V5LCBtZXJnZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGdldE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT3V0Z29pbmdIdHRwSGVhZGVycyBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHRoZSBodHRwMiBBUEkuXG4gICAgICovXG4gICAgdG9IdHRwMkhlYWRlcnMoKSB7XG4gICAgICAgIC8vIE5PVEU6IE5vZGUgPDguOSBmb3JtYXRzIGh0dHAyIGhlYWRlcnMgaW5jb3JyZWN0bHkuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2YgdGhpcy5pbnRlcm5hbFJlcHIpIHtcbiAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHRoZSB1c2VyJ3MgaW50ZXJhY3Rpb24gd2l0aCB0aGlzIG9iamVjdCBpcyBsaW1pdGVkIHRvXG4gICAgICAgICAgICAvLyB0aHJvdWdoIGl0cyBwdWJsaWMgQVBJIChpLmUuIGtleXMgYW5kIHZhbHVlcyBhcmUgYWxyZWFkeSB2YWxpZGF0ZWQpLlxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZXMubWFwKGJ1ZlRvU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1vZGlmaWVzIHRoZSBiZWhhdmlvciBvZiBKU09OLnN0cmluZ2lmeSB0byBzaG93IGFuIG9iamVjdFxuICAgICAqIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtZXRhZGF0YSBtYXAuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIHRoaXMuaW50ZXJuYWxSZXByKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IE1ldGFkYXRhIG9iamVjdCBiYXNlZCBmaWVsZHMgaW4gYSBnaXZlbiBJbmNvbWluZ0h0dHBIZWFkZXJzXG4gICAgICogb2JqZWN0LlxuICAgICAqIEBwYXJhbSBoZWFkZXJzIEFuIEluY29taW5nSHR0cEhlYWRlcnMgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSHR0cDJIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1ldGFkYXRhKCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgICAvLyBSZXNlcnZlZCBoZWFkZXJzIChiZWdpbm5pbmcgd2l0aCBgOmApIGFyZSBub3QgdmFsaWQga2V5cy5cbiAgICAgICAgICAgIGlmIChrZXkuY2hhckF0KDApID09PSAnOicpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQmluYXJ5S2V5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoa2V5LCBCdWZmZXIuZnJvbSh2YWx1ZSwgJ2Jhc2U2NCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXN0b21NZXRhZGF0YShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnNwbGl0KCcsJykuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIEJ1ZmZlci5mcm9tKHYudHJpbSgpLCAnYmFzZTY0JykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIEJ1ZmZlci5mcm9tKHZhbHVlcywgJ2Jhc2U2NCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYEZhaWxlZCB0byBhZGQgbWV0YWRhdGEgZW50cnkgJHtrZXl9OiAke3ZhbHVlc30uICR7KDAsIGVycm9yXzEuZ2V0RXJyb3JNZXNzYWdlKShlcnJvcil9LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy1ub2RlL2lzc3Vlcy8xMTczYDtcbiAgICAgICAgICAgICAgICAoMCwgbG9nZ2luZ18xLmxvZykoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuTWV0YWRhdGEgPSBNZXRhZGF0YTtcbmNvbnN0IGJ1ZlRvU3RyaW5nID0gKHZhbCkgPT4ge1xuICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIodmFsKSA/IHZhbC50b1N0cmluZygnYmFzZTY0JykgOiB2YWw7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTWV0YWRhdGEiLCJsb2dnaW5nXzEiLCJyZXF1aXJlIiwiY29uc3RhbnRzXzEiLCJlcnJvcl8xIiwiTEVHQUxfS0VZX1JFR0VYIiwiTEVHQUxfTk9OX0JJTkFSWV9WQUxVRV9SRUdFWCIsImlzTGVnYWxLZXkiLCJrZXkiLCJ0ZXN0IiwiaXNMZWdhbE5vbkJpbmFyeVZhbHVlIiwiaXNCaW5hcnlLZXkiLCJlbmRzV2l0aCIsImlzQ3VzdG9tTWV0YWRhdGEiLCJzdGFydHNXaXRoIiwibm9ybWFsaXplS2V5IiwidG9Mb3dlckNhc2UiLCJ2YWxpZGF0ZSIsIkVycm9yIiwidW5kZWZpbmVkIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJpbnRlcm5hbFJlcHIiLCJNYXAiLCJzZXQiLCJhZGQiLCJleGlzdGluZ1ZhbHVlIiwiZ2V0IiwicHVzaCIsInJlbW92ZSIsImRlbGV0ZSIsImdldE1hcCIsInJlc3VsdCIsInZhbHVlcyIsImxlbmd0aCIsInYiLCJmcm9tIiwiY2xvbmUiLCJuZXdNZXRhZGF0YSIsIm5ld0ludGVybmFsUmVwciIsImNsb25lZFZhbHVlIiwibWFwIiwibWVyZ2UiLCJvdGhlciIsIm1lcmdlZFZhbHVlIiwiY29uY2F0Iiwic2V0T3B0aW9ucyIsImdldE9wdGlvbnMiLCJ0b0h0dHAySGVhZGVycyIsImJ1ZlRvU3RyaW5nIiwidG9KU09OIiwiZnJvbUh0dHAySGVhZGVycyIsImhlYWRlcnMiLCJrZXlzIiwiY2hhckF0IiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsInNwbGl0IiwidHJpbSIsImVycm9yIiwibWVzc2FnZSIsImdldEVycm9yTWVzc2FnZSIsImxvZyIsIkxvZ1ZlcmJvc2l0eSIsIkVSUk9SIiwidmFsIiwidG9TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/picker.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.QueuePicker = exports.UnavailablePicker = exports.PickResultType = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nvar PickResultType;\n(function(PickResultType) {\n    PickResultType[PickResultType[\"COMPLETE\"] = 0] = \"COMPLETE\";\n    PickResultType[PickResultType[\"QUEUE\"] = 1] = \"QUEUE\";\n    PickResultType[PickResultType[\"TRANSIENT_FAILURE\"] = 2] = \"TRANSIENT_FAILURE\";\n    PickResultType[PickResultType[\"DROP\"] = 3] = \"DROP\";\n})(PickResultType || (exports.PickResultType = PickResultType = {}));\n/**\n * A standard picker representing a load balancer in the TRANSIENT_FAILURE\n * state. Always responds to every pick request with an UNAVAILABLE status.\n */ class UnavailablePicker {\n    constructor(status){\n        this.status = Object.assign({\n            code: constants_1.Status.UNAVAILABLE,\n            details: \"No connection established\",\n            metadata: new metadata_1.Metadata()\n        }, status);\n    }\n    pick(pickArgs) {\n        return {\n            pickResultType: PickResultType.TRANSIENT_FAILURE,\n            subchannel: null,\n            status: this.status,\n            onCallStarted: null,\n            onCallEnded: null\n        };\n    }\n}\nexports.UnavailablePicker = UnavailablePicker;\n/**\n * A standard picker representing a load balancer in the IDLE or CONNECTING\n * state. Always responds to every pick request with a QUEUE pick result\n * indicating that the pick should be tried again with the next `Picker`. Also\n * reports back to the load balancer that a connection should be established\n * once any pick is attempted.\n * If the childPicker is provided, delegate to it instead of returning the\n * hardcoded QUEUE pick result, but still calls exitIdle.\n */ class QueuePicker {\n    // Constructed with a load balancer. Calls exitIdle on it the first time pick is called\n    constructor(loadBalancer, childPicker){\n        this.loadBalancer = loadBalancer;\n        this.childPicker = childPicker;\n        this.calledExitIdle = false;\n    }\n    pick(pickArgs) {\n        if (!this.calledExitIdle) {\n            process.nextTick(()=>{\n                this.loadBalancer.exitIdle();\n            });\n            this.calledExitIdle = true;\n        }\n        if (this.childPicker) {\n            return this.childPicker.pick(pickArgs);\n        } else {\n            return {\n                pickResultType: PickResultType.QUEUE,\n                subchannel: null,\n                status: null,\n                onCallStarted: null,\n                onCallEnded: null\n            };\n        }\n    }\n}\nexports.QueuePicker = QueuePicker; //# sourceMappingURL=picker.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcGlja2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQkFBbUIsR0FBR0EseUJBQXlCLEdBQUdBLHNCQUFzQixHQUFHLEtBQUs7QUFDaEYsTUFBTUssYUFBYUMsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsSUFBSUY7QUFDSCxVQUFVQSxjQUFjO0lBQ3JCQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxXQUFXLEdBQUcsRUFBRSxHQUFHO0lBQ2pEQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQzlDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxvQkFBb0IsR0FBRyxFQUFFLEdBQUc7SUFDMURBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7QUFDakQsR0FBR0Esa0JBQW1CSixDQUFBQSxzQkFBc0IsR0FBR0ksaUJBQWlCLENBQUM7QUFDakU7OztDQUdDLEdBQ0QsTUFBTUQ7SUFDRkssWUFBWUMsTUFBTSxDQUFFO1FBQ2hCLElBQUksQ0FBQ0EsTUFBTSxHQUFHWCxPQUFPWSxNQUFNLENBQUM7WUFBRUMsTUFBTUosWUFBWUssTUFBTSxDQUFDQyxXQUFXO1lBQUVDLFNBQVM7WUFBNkJDLFVBQVUsSUFBSVYsV0FBV1csUUFBUTtRQUFHLEdBQUdQO0lBQ3JKO0lBQ0FRLEtBQUtDLFFBQVEsRUFBRTtRQUNYLE9BQU87WUFDSEMsZ0JBQWdCZixlQUFlZ0IsaUJBQWlCO1lBQ2hEQyxZQUFZO1lBQ1paLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CYSxlQUFlO1lBQ2ZDLGFBQWE7UUFDakI7SUFDSjtBQUNKO0FBQ0F2Qix5QkFBeUIsR0FBR0c7QUFDNUI7Ozs7Ozs7O0NBUUMsR0FDRCxNQUFNRDtJQUNGLHVGQUF1RjtJQUN2Rk0sWUFBWWdCLFlBQVksRUFBRUMsV0FBVyxDQUFFO1FBQ25DLElBQUksQ0FBQ0QsWUFBWSxHQUFHQTtRQUNwQixJQUFJLENBQUNDLFdBQVcsR0FBR0E7UUFDbkIsSUFBSSxDQUFDQyxjQUFjLEdBQUc7SUFDMUI7SUFDQVQsS0FBS0MsUUFBUSxFQUFFO1FBQ1gsSUFBSSxDQUFDLElBQUksQ0FBQ1EsY0FBYyxFQUFFO1lBQ3RCQyxRQUFRQyxRQUFRLENBQUM7Z0JBQ2IsSUFBSSxDQUFDSixZQUFZLENBQUNLLFFBQVE7WUFDOUI7WUFDQSxJQUFJLENBQUNILGNBQWMsR0FBRztRQUMxQjtRQUNBLElBQUksSUFBSSxDQUFDRCxXQUFXLEVBQUU7WUFDbEIsT0FBTyxJQUFJLENBQUNBLFdBQVcsQ0FBQ1IsSUFBSSxDQUFDQztRQUNqQyxPQUNLO1lBQ0QsT0FBTztnQkFDSEMsZ0JBQWdCZixlQUFlMEIsS0FBSztnQkFDcENULFlBQVk7Z0JBQ1paLFFBQVE7Z0JBQ1JhLGVBQWU7Z0JBQ2ZDLGFBQWE7WUFDakI7UUFDSjtJQUNKO0FBQ0o7QUFDQXZCLG1CQUFtQixHQUFHRSxhQUN0QixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcGlja2VyLmpzPzU3ZTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUXVldWVQaWNrZXIgPSBleHBvcnRzLlVuYXZhaWxhYmxlUGlja2VyID0gZXhwb3J0cy5QaWNrUmVzdWx0VHlwZSA9IHZvaWQgMDtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIFBpY2tSZXN1bHRUeXBlO1xuKGZ1bmN0aW9uIChQaWNrUmVzdWx0VHlwZSkge1xuICAgIFBpY2tSZXN1bHRUeXBlW1BpY2tSZXN1bHRUeXBlW1wiQ09NUExFVEVcIl0gPSAwXSA9IFwiQ09NUExFVEVcIjtcbiAgICBQaWNrUmVzdWx0VHlwZVtQaWNrUmVzdWx0VHlwZVtcIlFVRVVFXCJdID0gMV0gPSBcIlFVRVVFXCI7XG4gICAgUGlja1Jlc3VsdFR5cGVbUGlja1Jlc3VsdFR5cGVbXCJUUkFOU0lFTlRfRkFJTFVSRVwiXSA9IDJdID0gXCJUUkFOU0lFTlRfRkFJTFVSRVwiO1xuICAgIFBpY2tSZXN1bHRUeXBlW1BpY2tSZXN1bHRUeXBlW1wiRFJPUFwiXSA9IDNdID0gXCJEUk9QXCI7XG59KShQaWNrUmVzdWx0VHlwZSB8fCAoZXhwb3J0cy5QaWNrUmVzdWx0VHlwZSA9IFBpY2tSZXN1bHRUeXBlID0ge30pKTtcbi8qKlxuICogQSBzdGFuZGFyZCBwaWNrZXIgcmVwcmVzZW50aW5nIGEgbG9hZCBiYWxhbmNlciBpbiB0aGUgVFJBTlNJRU5UX0ZBSUxVUkVcbiAqIHN0YXRlLiBBbHdheXMgcmVzcG9uZHMgdG8gZXZlcnkgcGljayByZXF1ZXN0IHdpdGggYW4gVU5BVkFJTEFCTEUgc3RhdHVzLlxuICovXG5jbGFzcyBVbmF2YWlsYWJsZVBpY2tlciB7XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gT2JqZWN0LmFzc2lnbih7IGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSwgZGV0YWlsczogJ05vIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQnLCBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSB9LCBzdGF0dXMpO1xuICAgIH1cbiAgICBwaWNrKHBpY2tBcmdzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwaWNrUmVzdWx0VHlwZTogUGlja1Jlc3VsdFR5cGUuVFJBTlNJRU5UX0ZBSUxVUkUsXG4gICAgICAgICAgICBzdWJjaGFubmVsOiBudWxsLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIG9uQ2FsbFN0YXJ0ZWQ6IG51bGwsXG4gICAgICAgICAgICBvbkNhbGxFbmRlZDogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlVuYXZhaWxhYmxlUGlja2VyID0gVW5hdmFpbGFibGVQaWNrZXI7XG4vKipcbiAqIEEgc3RhbmRhcmQgcGlja2VyIHJlcHJlc2VudGluZyBhIGxvYWQgYmFsYW5jZXIgaW4gdGhlIElETEUgb3IgQ09OTkVDVElOR1xuICogc3RhdGUuIEFsd2F5cyByZXNwb25kcyB0byBldmVyeSBwaWNrIHJlcXVlc3Qgd2l0aCBhIFFVRVVFIHBpY2sgcmVzdWx0XG4gKiBpbmRpY2F0aW5nIHRoYXQgdGhlIHBpY2sgc2hvdWxkIGJlIHRyaWVkIGFnYWluIHdpdGggdGhlIG5leHQgYFBpY2tlcmAuIEFsc29cbiAqIHJlcG9ydHMgYmFjayB0byB0aGUgbG9hZCBiYWxhbmNlciB0aGF0IGEgY29ubmVjdGlvbiBzaG91bGQgYmUgZXN0YWJsaXNoZWRcbiAqIG9uY2UgYW55IHBpY2sgaXMgYXR0ZW1wdGVkLlxuICogSWYgdGhlIGNoaWxkUGlja2VyIGlzIHByb3ZpZGVkLCBkZWxlZ2F0ZSB0byBpdCBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGVcbiAqIGhhcmRjb2RlZCBRVUVVRSBwaWNrIHJlc3VsdCwgYnV0IHN0aWxsIGNhbGxzIGV4aXRJZGxlLlxuICovXG5jbGFzcyBRdWV1ZVBpY2tlciB7XG4gICAgLy8gQ29uc3RydWN0ZWQgd2l0aCBhIGxvYWQgYmFsYW5jZXIuIENhbGxzIGV4aXRJZGxlIG9uIGl0IHRoZSBmaXJzdCB0aW1lIHBpY2sgaXMgY2FsbGVkXG4gICAgY29uc3RydWN0b3IobG9hZEJhbGFuY2VyLCBjaGlsZFBpY2tlcikge1xuICAgICAgICB0aGlzLmxvYWRCYWxhbmNlciA9IGxvYWRCYWxhbmNlcjtcbiAgICAgICAgdGhpcy5jaGlsZFBpY2tlciA9IGNoaWxkUGlja2VyO1xuICAgICAgICB0aGlzLmNhbGxlZEV4aXRJZGxlID0gZmFsc2U7XG4gICAgfVxuICAgIHBpY2socGlja0FyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbGxlZEV4aXRJZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRCYWxhbmNlci5leGl0SWRsZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNhbGxlZEV4aXRJZGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaGlsZFBpY2tlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRQaWNrZXIucGljayhwaWNrQXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBpY2tSZXN1bHRUeXBlOiBQaWNrUmVzdWx0VHlwZS5RVUVVRSxcbiAgICAgICAgICAgICAgICBzdWJjaGFubmVsOiBudWxsLFxuICAgICAgICAgICAgICAgIHN0YXR1czogbnVsbCxcbiAgICAgICAgICAgICAgICBvbkNhbGxTdGFydGVkOiBudWxsLFxuICAgICAgICAgICAgICAgIG9uQ2FsbEVuZGVkOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUXVldWVQaWNrZXIgPSBRdWV1ZVBpY2tlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBpY2tlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJRdWV1ZVBpY2tlciIsIlVuYXZhaWxhYmxlUGlja2VyIiwiUGlja1Jlc3VsdFR5cGUiLCJtZXRhZGF0YV8xIiwicmVxdWlyZSIsImNvbnN0YW50c18xIiwiY29uc3RydWN0b3IiLCJzdGF0dXMiLCJhc3NpZ24iLCJjb2RlIiwiU3RhdHVzIiwiVU5BVkFJTEFCTEUiLCJkZXRhaWxzIiwibWV0YWRhdGEiLCJNZXRhZGF0YSIsInBpY2siLCJwaWNrQXJncyIsInBpY2tSZXN1bHRUeXBlIiwiVFJBTlNJRU5UX0ZBSUxVUkUiLCJzdWJjaGFubmVsIiwib25DYWxsU3RhcnRlZCIsIm9uQ2FsbEVuZGVkIiwibG9hZEJhbGFuY2VyIiwiY2hpbGRQaWNrZXIiLCJjYWxsZWRFeGl0SWRsZSIsInByb2Nlc3MiLCJuZXh0VGljayIsImV4aXRJZGxlIiwiUVVFVUUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-dns.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DEFAULT_PORT = void 0;\nexports.setup = setup;\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst dns_1 = __webpack_require__(/*! dns */ \"dns\");\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst environment_1 = __webpack_require__(/*! ./environment */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/environment.js\");\nconst TRACER_NAME = \"dns_resolver\";\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */ exports.DEFAULT_PORT = 443;\nconst DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30000;\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */ class DnsResolver {\n    constructor(target, listener, channelOptions){\n        var _a, _b, _c;\n        this.target = target;\n        this.listener = listener;\n        this.pendingLookupPromise = null;\n        this.pendingTxtPromise = null;\n        this.latestLookupResult = null;\n        this.latestServiceConfig = null;\n        this.latestServiceConfigError = null;\n        this.continueResolving = false;\n        this.isNextResolutionTimerRunning = false;\n        this.isServiceConfigEnabled = true;\n        this.returnedIpResult = false;\n        this.alternativeResolver = new dns_1.promises.Resolver();\n        trace(\"Resolver constructed for target \" + (0, uri_parser_1.uriToString)(target));\n        if (target.authority) {\n            this.alternativeResolver.setServers([\n                target.authority\n            ]);\n        }\n        const hostPort = (0, uri_parser_1.splitHostPort)(target.path);\n        if (hostPort === null) {\n            this.ipResult = null;\n            this.dnsHostname = null;\n            this.port = null;\n        } else {\n            if ((0, net_1.isIPv4)(hostPort.host) || (0, net_1.isIPv6)(hostPort.host)) {\n                this.ipResult = [\n                    {\n                        addresses: [\n                            {\n                                host: hostPort.host,\n                                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : exports.DEFAULT_PORT\n                            }\n                        ]\n                    }\n                ];\n                this.dnsHostname = null;\n                this.port = null;\n            } else {\n                this.ipResult = null;\n                this.dnsHostname = hostPort.host;\n                this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : exports.DEFAULT_PORT;\n            }\n        }\n        this.percentage = Math.random() * 100;\n        if (channelOptions[\"grpc.service_config_disable_resolution\"] === 1) {\n            this.isServiceConfigEnabled = false;\n        }\n        this.defaultResolutionError = {\n            code: constants_1.Status.UNAVAILABLE,\n            details: `Name resolution failed for target ${(0, uri_parser_1.uriToString)(this.target)}`,\n            metadata: new metadata_1.Metadata()\n        };\n        const backoffOptions = {\n            initialDelay: channelOptions[\"grpc.initial_reconnect_backoff_ms\"],\n            maxDelay: channelOptions[\"grpc.max_reconnect_backoff_ms\"]\n        };\n        this.backoff = new backoff_timeout_1.BackoffTimeout(()=>{\n            if (this.continueResolving) {\n                this.startResolutionWithBackoff();\n            }\n        }, backoffOptions);\n        this.backoff.unref();\n        this.minTimeBetweenResolutionsMs = (_c = channelOptions[\"grpc.dns_min_time_between_resolutions_ms\"]) !== null && _c !== void 0 ? _c : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;\n        this.nextResolutionTimer = setTimeout(()=>{}, 0);\n        clearTimeout(this.nextResolutionTimer);\n    }\n    /**\n     * If the target is an IP address, just provide that address as a result.\n     * Otherwise, initiate A, AAAA, and TXT lookups\n     */ startResolution() {\n        if (this.ipResult !== null) {\n            if (!this.returnedIpResult) {\n                trace(\"Returning IP address for target \" + (0, uri_parser_1.uriToString)(this.target));\n                setImmediate(()=>{\n                    this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});\n                });\n                this.returnedIpResult = true;\n            }\n            this.backoff.stop();\n            this.backoff.reset();\n            this.stopNextResolutionTimer();\n            return;\n        }\n        if (this.dnsHostname === null) {\n            trace(\"Failed to parse DNS address \" + (0, uri_parser_1.uriToString)(this.target));\n            setImmediate(()=>{\n                this.listener.onError({\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse DNS address ${(0, uri_parser_1.uriToString)(this.target)}`,\n                    metadata: new metadata_1.Metadata()\n                });\n            });\n            this.stopNextResolutionTimer();\n        } else {\n            if (this.pendingLookupPromise !== null) {\n                return;\n            }\n            trace(\"Looking up DNS hostname \" + this.dnsHostname);\n            /* We clear out latestLookupResult here to ensure that it contains the\n             * latest result since the last time we started resolving. That way, the\n             * TXT resolution handler can use it, but only if it finishes second. We\n             * don't clear out any previous service config results because it's\n             * better to use a service config that's slightly out of date than to\n             * revert to an effectively blank one. */ this.latestLookupResult = null;\n            const hostname = this.dnsHostname;\n            this.pendingLookupPromise = this.lookup(hostname);\n            this.pendingLookupPromise.then((addressList)=>{\n                if (this.pendingLookupPromise === null) {\n                    return;\n                }\n                this.pendingLookupPromise = null;\n                this.backoff.reset();\n                this.backoff.stop();\n                this.latestLookupResult = addressList.map((address)=>({\n                        addresses: [\n                            address\n                        ]\n                    }));\n                const allAddressesString = \"[\" + addressList.map((addr)=>addr.host + \":\" + addr.port).join(\",\") + \"]\";\n                trace(\"Resolved addresses for target \" + (0, uri_parser_1.uriToString)(this.target) + \": \" + allAddressesString);\n                if (this.latestLookupResult.length === 0) {\n                    this.listener.onError(this.defaultResolutionError);\n                    return;\n                }\n                /* If the TXT lookup has not yet finished, both of the last two\n                 * arguments will be null, which is the equivalent of getting an\n                 * empty TXT response. When the TXT lookup does finish, its handler\n                 * can update the service config by using the same address list */ this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n            }, (err)=>{\n                if (this.pendingLookupPromise === null) {\n                    return;\n                }\n                trace(\"Resolution error for target \" + (0, uri_parser_1.uriToString)(this.target) + \": \" + err.message);\n                this.pendingLookupPromise = null;\n                this.stopNextResolutionTimer();\n                this.listener.onError(this.defaultResolutionError);\n            });\n            /* If there already is a still-pending TXT resolution, we can just use\n             * that result when it comes in */ if (this.isServiceConfigEnabled && this.pendingTxtPromise === null) {\n                /* We handle the TXT query promise differently than the others because\n                 * the name resolution attempt as a whole is a success even if the TXT\n                 * lookup fails */ this.pendingTxtPromise = this.resolveTxt(hostname);\n                this.pendingTxtPromise.then((txtRecord)=>{\n                    if (this.pendingTxtPromise === null) {\n                        return;\n                    }\n                    this.pendingTxtPromise = null;\n                    try {\n                        this.latestServiceConfig = (0, service_config_1.extractAndSelectServiceConfig)(txtRecord, this.percentage);\n                    } catch (err) {\n                        this.latestServiceConfigError = {\n                            code: constants_1.Status.UNAVAILABLE,\n                            details: `Parsing service config failed with error ${err.message}`,\n                            metadata: new metadata_1.Metadata()\n                        };\n                    }\n                    if (this.latestLookupResult !== null) {\n                        /* We rely here on the assumption that calling this function with\n                         * identical parameters will be essentialy idempotent, and calling\n                         * it with the same address list and a different service config\n                         * should result in a fast and seamless switchover. */ this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n                    }\n                }, (err)=>{\n                /* If TXT lookup fails we should do nothing, which means that we\n                     * continue to use the result of the most recent successful lookup,\n                     * or the default null config object if there has never been a\n                     * successful lookup. We do not set the latestServiceConfigError\n                     * here because that is specifically used for response validation\n                     * errors. We still need to handle this error so that it does not\n                     * bubble up as an unhandled promise rejection. */ });\n            }\n        }\n    }\n    async lookup(hostname) {\n        if (environment_1.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {\n            trace(\"Using alternative DNS resolver.\");\n            const records = await Promise.allSettled([\n                this.alternativeResolver.resolve4(hostname),\n                this.alternativeResolver.resolve6(hostname)\n            ]);\n            if (records.every((result)=>result.status === \"rejected\")) {\n                throw new Error(records[0].reason);\n            }\n            return records.reduce((acc, result)=>{\n                return result.status === \"fulfilled\" ? [\n                    ...acc,\n                    ...result.value\n                ] : acc;\n            }, []).map((addr)=>({\n                    host: addr,\n                    port: +this.port\n                }));\n        }\n        /* We lookup both address families here and then split them up later\n         * because when looking up a single family, dns.lookup outputs an error\n         * if the name exists but there are no records for that family, and that\n         * error is indistinguishable from other kinds of errors */ const addressList = await dns_1.promises.lookup(hostname, {\n            all: true\n        });\n        return addressList.map((addr)=>({\n                host: addr.address,\n                port: +this.port\n            }));\n    }\n    async resolveTxt(hostname) {\n        if (environment_1.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {\n            trace(\"Using alternative DNS resolver.\");\n            return this.alternativeResolver.resolveTxt(hostname);\n        }\n        return dns_1.promises.resolveTxt(hostname);\n    }\n    startNextResolutionTimer() {\n        var _a, _b;\n        clearTimeout(this.nextResolutionTimer);\n        this.nextResolutionTimer = setTimeout(()=>{\n            this.stopNextResolutionTimer();\n            if (this.continueResolving) {\n                this.startResolutionWithBackoff();\n            }\n        }, this.minTimeBetweenResolutionsMs);\n        (_b = (_a = this.nextResolutionTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.isNextResolutionTimerRunning = true;\n    }\n    stopNextResolutionTimer() {\n        clearTimeout(this.nextResolutionTimer);\n        this.isNextResolutionTimerRunning = false;\n    }\n    startResolutionWithBackoff() {\n        if (this.pendingLookupPromise === null) {\n            this.continueResolving = false;\n            this.backoff.runOnce();\n            this.startNextResolutionTimer();\n            this.startResolution();\n        }\n    }\n    updateResolution() {\n        /* If there is a pending lookup, just let it finish. Otherwise, if the\n         * nextResolutionTimer or backoff timer is running, set the\n         * continueResolving flag to resolve when whichever of those timers\n         * fires. Otherwise, start resolving immediately. */ if (this.pendingLookupPromise === null) {\n            if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {\n                if (this.isNextResolutionTimerRunning) {\n                    trace('resolution update delayed by \"min time between resolutions\" rate limit');\n                } else {\n                    trace(\"resolution update delayed by backoff timer until \" + this.backoff.getEndTime().toISOString());\n                }\n                this.continueResolving = true;\n            } else {\n                this.startResolutionWithBackoff();\n            }\n        }\n    }\n    /**\n     * Reset the resolver to the same state it had when it was created. In-flight\n     * DNS requests cannot be cancelled, but they are discarded and their results\n     * will be ignored.\n     */ destroy() {\n        this.continueResolving = false;\n        this.backoff.reset();\n        this.backoff.stop();\n        this.stopNextResolutionTimer();\n        this.pendingLookupPromise = null;\n        this.pendingTxtPromise = null;\n        this.latestLookupResult = null;\n        this.latestServiceConfig = null;\n        this.latestServiceConfigError = null;\n        this.returnedIpResult = false;\n    }\n    /**\n     * Get the default authority for the given target. For IP targets, that is\n     * the IP address. For DNS targets, it is the hostname.\n     * @param target\n     */ static getDefaultAuthority(target) {\n        return target.path;\n    }\n}\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */ function setup() {\n    (0, resolver_1.registerResolver)(\"dns\", DnsResolver);\n    (0, resolver_1.registerDefaultScheme)(\"dns\");\n} //# sourceMappingURL=resolver-dns.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItZG5zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHLEtBQUs7QUFDNUJBLGFBQWEsR0FBR0c7QUFDaEIsTUFBTUMsYUFBYUMsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUMsZ0JBQUs7QUFDM0IsTUFBTUUsbUJBQW1CRixtQkFBT0EsQ0FBQyx3RkFBa0I7QUFDbkQsTUFBTUcsY0FBY0gsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUksYUFBYUosbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUssVUFBVUwsbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTU0sY0FBY04sbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTU8sZUFBZVAsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTVEsUUFBUVIsbUJBQU9BLENBQUMsZ0JBQUs7QUFDM0IsTUFBTVMsb0JBQW9CVCxtQkFBT0EsQ0FBQywwRkFBbUI7QUFDckQsTUFBTVUsZ0JBQWdCVixtQkFBT0EsQ0FBQyxrRkFBZTtBQUM3QyxNQUFNVyxjQUFjO0FBQ3BCLFNBQVNDLE1BQU1DLElBQUk7SUFDZlIsUUFBUU8sS0FBSyxDQUFDTixZQUFZUSxZQUFZLENBQUNDLEtBQUssRUFBRUosYUFBYUU7QUFDL0Q7QUFDQTs7Q0FFQyxHQUNEbEIsb0JBQW9CLEdBQUc7QUFDdkIsTUFBTXFCLDBDQUEwQztBQUNoRDs7Q0FFQyxHQUNELE1BQU1DO0lBQ0ZDLFlBQVlDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxjQUFjLENBQUU7UUFDMUMsSUFBSUMsSUFBSUMsSUFBSUM7UUFDWixJQUFJLENBQUNMLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLFFBQVEs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cnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmVyLWRucy5qcz83MWU0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuREVGQVVMVF9QT1JUID0gdm9pZCAwO1xuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xuY29uc3QgZG5zXzEgPSByZXF1aXJlKFwiZG5zXCIpO1xuY29uc3Qgc2VydmljZV9jb25maWdfMSA9IHJlcXVpcmUoXCIuL3NlcnZpY2UtY29uZmlnXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18yID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcbmNvbnN0IGJhY2tvZmZfdGltZW91dF8xID0gcmVxdWlyZShcIi4vYmFja29mZi10aW1lb3V0XCIpO1xuY29uc3QgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50XCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnZG5zX3Jlc29sdmVyJztcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18yLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBUQ1AgcG9ydCB0byBjb25uZWN0IHRvIGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCBpbiB0aGUgdGFyZ2V0LlxuICovXG5leHBvcnRzLkRFRkFVTFRfUE9SVCA9IDQ0MztcbmNvbnN0IERFRkFVTFRfTUlOX1RJTUVfQkVUV0VFTl9SRVNPTFVUSU9OU19NUyA9IDMwMDAwO1xuLyoqXG4gKiBSZXNvbHZlciBpbXBsZW1lbnRhdGlvbiB0aGF0IGhhbmRsZXMgRE5TIG5hbWVzIGFuZCBJUCBhZGRyZXNzZXMuXG4gKi9cbmNsYXNzIERuc1Jlc29sdmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGxpc3RlbmVyLCBjaGFubmVsT3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZ1R4dFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzTmV4dFJlc29sdXRpb25UaW1lclJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1NlcnZpY2VDb25maWdFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXR1cm5lZElwUmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWx0ZXJuYXRpdmVSZXNvbHZlciA9IG5ldyBkbnNfMS5wcm9taXNlcy5SZXNvbHZlcigpO1xuICAgICAgICB0cmFjZSgnUmVzb2x2ZXIgY29uc3RydWN0ZWQgZm9yIHRhcmdldCAnICsgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGFyZ2V0KSk7XG4gICAgICAgIGlmICh0YXJnZXQuYXV0aG9yaXR5KSB7XG4gICAgICAgICAgICB0aGlzLmFsdGVybmF0aXZlUmVzb2x2ZXIuc2V0U2VydmVycyhbdGFyZ2V0LmF1dGhvcml0eV0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvc3RQb3J0ID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KSh0YXJnZXQucGF0aCk7XG4gICAgICAgIGlmIChob3N0UG9ydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pcFJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRuc0hvc3RuYW1lID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucG9ydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKDAsIG5ldF8xLmlzSVB2NCkoaG9zdFBvcnQuaG9zdCkgfHwgKDAsIG5ldF8xLmlzSVB2NikoaG9zdFBvcnQuaG9zdCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlwUmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IGhvc3RQb3J0Lmhvc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6IChfYSA9IGhvc3RQb3J0LnBvcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGV4cG9ydHMuREVGQVVMVF9QT1JULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgdGhpcy5kbnNIb3N0bmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaXBSZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZG5zSG9zdG5hbWUgPSBob3N0UG9ydC5ob3N0O1xuICAgICAgICAgICAgICAgIHRoaXMucG9ydCA9IChfYiA9IGhvc3RQb3J0LnBvcnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGV4cG9ydHMuREVGQVVMVF9QT1JUO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVyY2VudGFnZSA9IE1hdGgucmFuZG9tKCkgKiAxMDA7XG4gICAgICAgIGlmIChjaGFubmVsT3B0aW9uc1snZ3JwYy5zZXJ2aWNlX2NvbmZpZ19kaXNhYmxlX3Jlc29sdXRpb24nXSA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5pc1NlcnZpY2VDb25maWdFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWZhdWx0UmVzb2x1dGlvbkVycm9yID0ge1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgZGV0YWlsczogYE5hbWUgcmVzb2x1dGlvbiBmYWlsZWQgZm9yIHRhcmdldCAkeygwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KX1gLFxuICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJhY2tvZmZPcHRpb25zID0ge1xuICAgICAgICAgICAgaW5pdGlhbERlbGF5OiBjaGFubmVsT3B0aW9uc1snZ3JwYy5pbml0aWFsX3JlY29ubmVjdF9iYWNrb2ZmX21zJ10sXG4gICAgICAgICAgICBtYXhEZWxheTogY2hhbm5lbE9wdGlvbnNbJ2dycGMubWF4X3JlY29ubmVjdF9iYWNrb2ZmX21zJ10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmFja29mZiA9IG5ldyBiYWNrb2ZmX3RpbWVvdXRfMS5CYWNrb2ZmVGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250aW51ZVJlc29sdmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgYmFja29mZk9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJhY2tvZmYudW5yZWYoKTtcbiAgICAgICAgdGhpcy5taW5UaW1lQmV0d2VlblJlc29sdXRpb25zTXMgPVxuICAgICAgICAgICAgKF9jID0gY2hhbm5lbE9wdGlvbnNbJ2dycGMuZG5zX21pbl90aW1lX2JldHdlZW5fcmVzb2x1dGlvbnNfbXMnXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogREVGQVVMVF9NSU5fVElNRV9CRVRXRUVOX1JFU09MVVRJT05TX01TO1xuICAgICAgICB0aGlzLm5leHRSZXNvbHV0aW9uVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHsgfSwgMCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm5leHRSZXNvbHV0aW9uVGltZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdGFyZ2V0IGlzIGFuIElQIGFkZHJlc3MsIGp1c3QgcHJvdmlkZSB0aGF0IGFkZHJlc3MgYXMgYSByZXN1bHQuXG4gICAgICogT3RoZXJ3aXNlLCBpbml0aWF0ZSBBLCBBQUFBLCBhbmQgVFhUIGxvb2t1cHNcbiAgICAgKi9cbiAgICBzdGFydFJlc29sdXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmlwUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmV0dXJuZWRJcFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRyYWNlKCdSZXR1cm5pbmcgSVAgYWRkcmVzcyBmb3IgdGFyZ2V0ICcgKyAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCkpO1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbih0aGlzLmlwUmVzdWx0LCBudWxsLCBudWxsLCBudWxsLCB7fSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXR1cm5lZElwUmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcE5leHRSZXNvbHV0aW9uVGltZXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kbnNIb3N0bmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhY2UoJ0ZhaWxlZCB0byBwYXJzZSBETlMgYWRkcmVzcyAnICsgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpKTtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgRmFpbGVkIHRvIHBhcnNlIEROUyBhZGRyZXNzICR7KDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpfWAsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnN0b3BOZXh0UmVzb2x1dGlvblRpbWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlKCdMb29raW5nIHVwIEROUyBob3N0bmFtZSAnICsgdGhpcy5kbnNIb3N0bmFtZSk7XG4gICAgICAgICAgICAvKiBXZSBjbGVhciBvdXQgbGF0ZXN0TG9va3VwUmVzdWx0IGhlcmUgdG8gZW5zdXJlIHRoYXQgaXQgY29udGFpbnMgdGhlXG4gICAgICAgICAgICAgKiBsYXRlc3QgcmVzdWx0IHNpbmNlIHRoZSBsYXN0IHRpbWUgd2Ugc3RhcnRlZCByZXNvbHZpbmcuIFRoYXQgd2F5LCB0aGVcbiAgICAgICAgICAgICAqIFRYVCByZXNvbHV0aW9uIGhhbmRsZXIgY2FuIHVzZSBpdCwgYnV0IG9ubHkgaWYgaXQgZmluaXNoZXMgc2Vjb25kLiBXZVxuICAgICAgICAgICAgICogZG9uJ3QgY2xlYXIgb3V0IGFueSBwcmV2aW91cyBzZXJ2aWNlIGNvbmZpZyByZXN1bHRzIGJlY2F1c2UgaXQnc1xuICAgICAgICAgICAgICogYmV0dGVyIHRvIHVzZSBhIHNlcnZpY2UgY29uZmlnIHRoYXQncyBzbGlnaHRseSBvdXQgb2YgZGF0ZSB0aGFuIHRvXG4gICAgICAgICAgICAgKiByZXZlcnQgdG8gYW4gZWZmZWN0aXZlbHkgYmxhbmsgb25lLiAqL1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RMb29rdXBSZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgaG9zdG5hbWUgPSB0aGlzLmRuc0hvc3RuYW1lO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9IHRoaXMubG9va3VwKGhvc3RuYW1lKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UudGhlbihhZGRyZXNzTGlzdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmYuc3RvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0ID0gYWRkcmVzc0xpc3QubWFwKGFkZHJlc3MgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzOiBbYWRkcmVzc10sXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsbEFkZHJlc3Nlc1N0cmluZyA9ICdbJyArXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3NMaXN0Lm1hcChhZGRyID0+IGFkZHIuaG9zdCArICc6JyArIGFkZHIucG9ydCkuam9pbignLCcpICtcbiAgICAgICAgICAgICAgICAgICAgJ10nO1xuICAgICAgICAgICAgICAgIHRyYWNlKCdSZXNvbHZlZCBhZGRyZXNzZXMgZm9yIHRhcmdldCAnICtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpICtcbiAgICAgICAgICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICAgICAgICAgIGFsbEFkZHJlc3Nlc1N0cmluZyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uRXJyb3IodGhpcy5kZWZhdWx0UmVzb2x1dGlvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBJZiB0aGUgVFhUIGxvb2t1cCBoYXMgbm90IHlldCBmaW5pc2hlZCwgYm90aCBvZiB0aGUgbGFzdCB0d29cbiAgICAgICAgICAgICAgICAgKiBhcmd1bWVudHMgd2lsbCBiZSBudWxsLCB3aGljaCBpcyB0aGUgZXF1aXZhbGVudCBvZiBnZXR0aW5nIGFuXG4gICAgICAgICAgICAgICAgICogZW1wdHkgVFhUIHJlc3BvbnNlLiBXaGVuIHRoZSBUWFQgbG9va3VwIGRvZXMgZmluaXNoLCBpdHMgaGFuZGxlclxuICAgICAgICAgICAgICAgICAqIGNhbiB1cGRhdGUgdGhlIHNlcnZpY2UgY29uZmlnIGJ5IHVzaW5nIHRoZSBzYW1lIGFkZHJlc3MgbGlzdCAqL1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbih0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCwgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnLCB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWdFcnJvciwgbnVsbCwge30pO1xuICAgICAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYWNlKCdSZXNvbHV0aW9uIGVycm9yIGZvciB0YXJnZXQgJyArXG4gICAgICAgICAgICAgICAgICAgICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KSArXG4gICAgICAgICAgICAgICAgICAgICc6ICcgK1xuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wTmV4dFJlc29sdXRpb25UaW1lcigpO1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25FcnJvcih0aGlzLmRlZmF1bHRSZXNvbHV0aW9uRXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKiBJZiB0aGVyZSBhbHJlYWR5IGlzIGEgc3RpbGwtcGVuZGluZyBUWFQgcmVzb2x1dGlvbiwgd2UgY2FuIGp1c3QgdXNlXG4gICAgICAgICAgICAgKiB0aGF0IHJlc3VsdCB3aGVuIGl0IGNvbWVzIGluICovXG4gICAgICAgICAgICBpZiAodGhpcy5pc1NlcnZpY2VDb25maWdFbmFibGVkICYmIHRoaXMucGVuZGluZ1R4dFByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvKiBXZSBoYW5kbGUgdGhlIFRYVCBxdWVyeSBwcm9taXNlIGRpZmZlcmVudGx5IHRoYW4gdGhlIG90aGVycyBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICogdGhlIG5hbWUgcmVzb2x1dGlvbiBhdHRlbXB0IGFzIGEgd2hvbGUgaXMgYSBzdWNjZXNzIGV2ZW4gaWYgdGhlIFRYVFxuICAgICAgICAgICAgICAgICAqIGxvb2t1cCBmYWlscyAqL1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1R4dFByb21pc2UgPSB0aGlzLnJlc29sdmVUeHQoaG9zdG5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1R4dFByb21pc2UudGhlbih0eHRSZWNvcmQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nVHh0UHJvbWlzZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1R4dFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnID0gKDAsIHNlcnZpY2VfY29uZmlnXzEuZXh0cmFjdEFuZFNlbGVjdFNlcnZpY2VDb25maWcpKHR4dFJlY29yZCwgdGhpcy5wZXJjZW50YWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWdFcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFBhcnNpbmcgc2VydmljZSBjb25maWcgZmFpbGVkIHdpdGggZXJyb3IgJHtlcnIubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXRlc3RMb29rdXBSZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFdlIHJlbHkgaGVyZSBvbiB0aGUgYXNzdW1wdGlvbiB0aGF0IGNhbGxpbmcgdGhpcyBmdW5jdGlvbiB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBpZGVudGljYWwgcGFyYW1ldGVycyB3aWxsIGJlIGVzc2VudGlhbHkgaWRlbXBvdGVudCwgYW5kIGNhbGxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGl0IHdpdGggdGhlIHNhbWUgYWRkcmVzcyBsaXN0IGFuZCBhIGRpZmZlcmVudCBzZXJ2aWNlIGNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICogc2hvdWxkIHJlc3VsdCBpbiBhIGZhc3QgYW5kIHNlYW1sZXNzIHN3aXRjaG92ZXIuICovXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24odGhpcy5sYXRlc3RMb29rdXBSZXN1bHQsIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZywgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnRXJyb3IsIG51bGwsIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8qIElmIFRYVCBsb29rdXAgZmFpbHMgd2Ugc2hvdWxkIGRvIG5vdGhpbmcsIHdoaWNoIG1lYW5zIHRoYXQgd2VcbiAgICAgICAgICAgICAgICAgICAgICogY29udGludWUgdG8gdXNlIHRoZSByZXN1bHQgb2YgdGhlIG1vc3QgcmVjZW50IHN1Y2Nlc3NmdWwgbG9va3VwLFxuICAgICAgICAgICAgICAgICAgICAgKiBvciB0aGUgZGVmYXVsdCBudWxsIGNvbmZpZyBvYmplY3QgaWYgdGhlcmUgaGFzIG5ldmVyIGJlZW4gYVxuICAgICAgICAgICAgICAgICAgICAgKiBzdWNjZXNzZnVsIGxvb2t1cC4gV2UgZG8gbm90IHNldCB0aGUgbGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yXG4gICAgICAgICAgICAgICAgICAgICAqIGhlcmUgYmVjYXVzZSB0aGF0IGlzIHNwZWNpZmljYWxseSB1c2VkIGZvciByZXNwb25zZSB2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAqIGVycm9ycy4gV2Ugc3RpbGwgbmVlZCB0byBoYW5kbGUgdGhpcyBlcnJvciBzbyB0aGF0IGl0IGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAgICAqIGJ1YmJsZSB1cCBhcyBhbiB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24uICovXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbG9va3VwKGhvc3RuYW1lKSB7XG4gICAgICAgIGlmIChlbnZpcm9ubWVudF8xLkdSUENfTk9ERV9VU0VfQUxURVJOQVRJVkVfUkVTT0xWRVIpIHtcbiAgICAgICAgICAgIHRyYWNlKCdVc2luZyBhbHRlcm5hdGl2ZSBETlMgcmVzb2x2ZXIuJyk7XG4gICAgICAgICAgICBjb25zdCByZWNvcmRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKFtcbiAgICAgICAgICAgICAgICB0aGlzLmFsdGVybmF0aXZlUmVzb2x2ZXIucmVzb2x2ZTQoaG9zdG5hbWUpLFxuICAgICAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRpdmVSZXNvbHZlci5yZXNvbHZlNihob3N0bmFtZSksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGlmIChyZWNvcmRzLmV2ZXJ5KHJlc3VsdCA9PiByZXN1bHQuc3RhdHVzID09PSAncmVqZWN0ZWQnKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWNvcmRzWzBdLnJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjb3Jkc1xuICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnXG4gICAgICAgICAgICAgICAgICAgID8gWy4uLmFjYywgLi4ucmVzdWx0LnZhbHVlXVxuICAgICAgICAgICAgICAgICAgICA6IGFjYztcbiAgICAgICAgICAgIH0sIFtdKVxuICAgICAgICAgICAgICAgIC5tYXAoYWRkciA9PiAoe1xuICAgICAgICAgICAgICAgIGhvc3Q6IGFkZHIsXG4gICAgICAgICAgICAgICAgcG9ydDogK3RoaXMucG9ydCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBXZSBsb29rdXAgYm90aCBhZGRyZXNzIGZhbWlsaWVzIGhlcmUgYW5kIHRoZW4gc3BsaXQgdGhlbSB1cCBsYXRlclxuICAgICAgICAgKiBiZWNhdXNlIHdoZW4gbG9va2luZyB1cCBhIHNpbmdsZSBmYW1pbHksIGRucy5sb29rdXAgb3V0cHV0cyBhbiBlcnJvclxuICAgICAgICAgKiBpZiB0aGUgbmFtZSBleGlzdHMgYnV0IHRoZXJlIGFyZSBubyByZWNvcmRzIGZvciB0aGF0IGZhbWlseSwgYW5kIHRoYXRcbiAgICAgICAgICogZXJyb3IgaXMgaW5kaXN0aW5ndWlzaGFibGUgZnJvbSBvdGhlciBraW5kcyBvZiBlcnJvcnMgKi9cbiAgICAgICAgY29uc3QgYWRkcmVzc0xpc3QgPSBhd2FpdCBkbnNfMS5wcm9taXNlcy5sb29rdXAoaG9zdG5hbWUsIHsgYWxsOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gYWRkcmVzc0xpc3QubWFwKGFkZHIgPT4gKHsgaG9zdDogYWRkci5hZGRyZXNzLCBwb3J0OiArdGhpcy5wb3J0IH0pKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZVR4dChob3N0bmFtZSkge1xuICAgICAgICBpZiAoZW52aXJvbm1lbnRfMS5HUlBDX05PREVfVVNFX0FMVEVSTkFUSVZFX1JFU09MVkVSKSB7XG4gICAgICAgICAgICB0cmFjZSgnVXNpbmcgYWx0ZXJuYXRpdmUgRE5TIHJlc29sdmVyLicpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWx0ZXJuYXRpdmVSZXNvbHZlci5yZXNvbHZlVHh0KGhvc3RuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG5zXzEucHJvbWlzZXMucmVzb2x2ZVR4dChob3N0bmFtZSk7XG4gICAgfVxuICAgIHN0YXJ0TmV4dFJlc29sdXRpb25UaW1lcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubmV4dFJlc29sdXRpb25UaW1lcik7XG4gICAgICAgIHRoaXMubmV4dFJlc29sdXRpb25UaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdG9wTmV4dFJlc29sdXRpb25UaW1lcigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGludWVSZXNvbHZpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UmVzb2x1dGlvbldpdGhCYWNrb2ZmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMubWluVGltZUJldHdlZW5SZXNvbHV0aW9uc01zKTtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5uZXh0UmVzb2x1dGlvblRpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB0aGlzLmlzTmV4dFJlc29sdXRpb25UaW1lclJ1bm5pbmcgPSB0cnVlO1xuICAgIH1cbiAgICBzdG9wTmV4dFJlc29sdXRpb25UaW1lcigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubmV4dFJlc29sdXRpb25UaW1lcik7XG4gICAgICAgIHRoaXMuaXNOZXh0UmVzb2x1dGlvblRpbWVyUnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBzdGFydFJlc29sdXRpb25XaXRoQmFja29mZigpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5ydW5PbmNlKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0TmV4dFJlc29sdXRpb25UaW1lcigpO1xuICAgICAgICAgICAgdGhpcy5zdGFydFJlc29sdXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVSZXNvbHV0aW9uKCkge1xuICAgICAgICAvKiBJZiB0aGVyZSBpcyBhIHBlbmRpbmcgbG9va3VwLCBqdXN0IGxldCBpdCBmaW5pc2guIE90aGVyd2lzZSwgaWYgdGhlXG4gICAgICAgICAqIG5leHRSZXNvbHV0aW9uVGltZXIgb3IgYmFja29mZiB0aW1lciBpcyBydW5uaW5nLCBzZXQgdGhlXG4gICAgICAgICAqIGNvbnRpbnVlUmVzb2x2aW5nIGZsYWcgdG8gcmVzb2x2ZSB3aGVuIHdoaWNoZXZlciBvZiB0aG9zZSB0aW1lcnNcbiAgICAgICAgICogZmlyZXMuIE90aGVyd2lzZSwgc3RhcnQgcmVzb2x2aW5nIGltbWVkaWF0ZWx5LiAqL1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNOZXh0UmVzb2x1dGlvblRpbWVyUnVubmluZyB8fCB0aGlzLmJhY2tvZmYuaXNSdW5uaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdyZXNvbHV0aW9uIHVwZGF0ZSBkZWxheWVkIGJ5IFwibWluIHRpbWUgYmV0d2VlbiByZXNvbHV0aW9uc1wiIHJhdGUgbGltaXQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdyZXNvbHV0aW9uIHVwZGF0ZSBkZWxheWVkIGJ5IGJhY2tvZmYgdGltZXIgdW50aWwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmYuZ2V0RW5kVGltZSgpLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgcmVzb2x2ZXIgdG8gdGhlIHNhbWUgc3RhdGUgaXQgaGFkIHdoZW4gaXQgd2FzIGNyZWF0ZWQuIEluLWZsaWdodFxuICAgICAqIEROUyByZXF1ZXN0cyBjYW5ub3QgYmUgY2FuY2VsbGVkLCBidXQgdGhleSBhcmUgZGlzY2FyZGVkIGFuZCB0aGVpciByZXN1bHRzXG4gICAgICogd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuYmFja29mZi5zdG9wKCk7XG4gICAgICAgIHRoaXMuc3RvcE5leHRSZXNvbHV0aW9uVGltZXIoKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZ1R4dFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXR1cm5lZElwUmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGVmYXVsdCBhdXRob3JpdHkgZm9yIHRoZSBnaXZlbiB0YXJnZXQuIEZvciBJUCB0YXJnZXRzLCB0aGF0IGlzXG4gICAgICogdGhlIElQIGFkZHJlc3MuIEZvciBETlMgdGFyZ2V0cywgaXQgaXMgdGhlIGhvc3RuYW1lLlxuICAgICAqIEBwYXJhbSB0YXJnZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5wYXRoO1xuICAgIH1cbn1cbi8qKlxuICogU2V0IHVwIHRoZSBETlMgcmVzb2x2ZXIgY2xhc3MgYnkgcmVnaXN0ZXJpbmcgaXQgYXMgdGhlIGhhbmRsZXIgZm9yIHRoZVxuICogXCJkbnM6XCIgcHJlZml4IGFuZCBhcyB0aGUgZGVmYXVsdCByZXNvbHZlci5cbiAqL1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgKDAsIHJlc29sdmVyXzEucmVnaXN0ZXJSZXNvbHZlcikoJ2RucycsIERuc1Jlc29sdmVyKTtcbiAgICAoMCwgcmVzb2x2ZXJfMS5yZWdpc3RlckRlZmF1bHRTY2hlbWUpKCdkbnMnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVyLWRucy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJERUZBVUxUX1BPUlQiLCJzZXR1cCIsInJlc29sdmVyXzEiLCJyZXF1aXJlIiwiZG5zXzEiLCJzZXJ2aWNlX2NvbmZpZ18xIiwiY29uc3RhbnRzXzEiLCJtZXRhZGF0YV8xIiwibG9nZ2luZyIsImNvbnN0YW50c18yIiwidXJpX3BhcnNlcl8xIiwibmV0XzEiLCJiYWNrb2ZmX3RpbWVvdXRfMSIsImVudmlyb25tZW50XzEiLCJUUkFDRVJfTkFNRSIsInRyYWNlIiwidGV4dCIsIkxvZ1ZlcmJvc2l0eSIsIkRFQlVHIiwiREVGQVVMVF9NSU5fVElNRV9CRVRXRUVOX1JFU09MVVRJT05TX01TIiwiRG5zUmVzb2x2ZXIiLCJjb25zdHJ1Y3RvciIsInRhcmdldCIsImxpc3RlbmVyIiwiY2hhbm5lbE9wdGlvbnMiLCJfYSIsIl9iIiwiX2MiLCJwZW5kaW5nTG9va3VwUHJvbWlzZSIsInBlbmRpbmdUeHRQcm9taXNlIiwibGF0ZXN0TG9va3VwUmVzdWx0IiwibGF0ZXN0U2VydmljZUNvbmZpZyIsImxhdGVzdFNlcnZpY2VDb25maWdFcnJvciIsImNvbnRpbnVlUmVzb2x2aW5nIiwiaXNOZXh0UmVzb2x1dGlvblRpbWVyUnVubmluZyIsImlzU2VydmljZUNvbmZpZ0VuYWJsZWQiLCJyZXR1cm5lZElwUmVzdWx0IiwiYWx0ZXJuYXRpdmVSZXNvbHZlciIsInByb21pc2VzIiwiUmVzb2x2ZXIiLCJ1cmlUb1N0cmluZyIsImF1dGhvcml0eSIsInNldFNlcnZlcnMiLCJob3N0UG9ydCIsInNwbGl0SG9zdFBvcnQiLCJwYXRoIiwiaXBSZXN1bHQiLCJkbnNIb3N0bmFtZSIsInBvcnQiLCJpc0lQdjQiLCJob3N0IiwiaXNJUHY2IiwiYWRkcmVzc2VzIiwicGVyY2VudGFnZSIsIk1hdGgiLCJyYW5kb20iLCJkZWZhdWx0UmVzb2x1dGlvbkVycm9yIiwiY29kZSIsIlN0YXR1cyIsIlVOQVZBSUxBQkxFIiwiZGV0YWlscyIsIm1ldGFkYXRhIiwiTWV0YWRhdGEiLCJiYWNrb2ZmT3B0aW9ucyIsImluaXRpYWxEZWxheSIsIm1heERlbGF5IiwiYmFja29mZiIsIkJhY2tvZmZUaW1lb3V0Iiwic3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYiLCJ1bnJlZiIsIm1pblRpbWVCZXR3ZWVuUmVzb2x1dGlvbnNNcyIsIm5leHRSZXNvbHV0aW9uVGltZXIiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwic3RhcnRSZXNvbHV0aW9uIiwic2V0SW1tZWRpYXRlIiwib25TdWNjZXNzZnVsUmVzb2x1dGlvbiIsInN0b3AiLCJyZXNldCIsInN0b3BOZXh0UmVzb2x1dGlvblRpbWVyIiwib25FcnJvciIsImhvc3RuYW1lIiwibG9va3VwIiwidGhlbiIsImFkZHJlc3NMaXN0IiwibWFwIiwiYWRkcmVzcyIsImFsbEFkZHJlc3Nlc1N0cmluZyIsImFkZHIiLCJqb2luIiwibGVuZ3RoIiwiZXJyIiwibWVzc2FnZSIsInJlc29sdmVUeHQiLCJ0eHRSZWNvcmQiLCJleHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZyIsIkdSUENfTk9ERV9VU0VfQUxURVJOQVRJVkVfUkVTT0xWRVIiLCJyZWNvcmRzIiwiUHJvbWlzZSIsImFsbFNldHRsZWQiLCJyZXNvbHZlNCIsInJlc29sdmU2IiwiZXZlcnkiLCJyZXN1bHQiLCJzdGF0dXMiLCJFcnJvciIsInJlYXNvbiIsInJlZHVjZSIsImFjYyIsImFsbCIsInN0YXJ0TmV4dFJlc29sdXRpb25UaW1lciIsImNhbGwiLCJydW5PbmNlIiwidXBkYXRlUmVzb2x1dGlvbiIsImlzUnVubmluZyIsImdldEVuZFRpbWUiLCJ0b0lTT1N0cmluZyIsImRlc3Ryb3kiLCJnZXREZWZhdWx0QXV0aG9yaXR5IiwicmVnaXN0ZXJSZXNvbHZlciIsInJlZ2lzdGVyRGVmYXVsdFNjaGVtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-ip.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = setup;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = \"ip_resolver\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst IPV4_SCHEME = \"ipv4\";\nconst IPV6_SCHEME = \"ipv6\";\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */ const DEFAULT_PORT = 443;\nclass IpResolver {\n    constructor(target, listener, channelOptions){\n        var _a;\n        this.listener = listener;\n        this.endpoints = [];\n        this.error = null;\n        this.hasReturnedResult = false;\n        trace(\"Resolver constructed for target \" + (0, uri_parser_1.uriToString)(target));\n        const addresses = [];\n        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {\n            this.error = {\n                code: constants_1.Status.UNAVAILABLE,\n                details: `Unrecognized scheme ${target.scheme} in IP resolver`,\n                metadata: new metadata_1.Metadata()\n            };\n            return;\n        }\n        const pathList = target.path.split(\",\");\n        for (const path of pathList){\n            const hostPort = (0, uri_parser_1.splitHostPort)(path);\n            if (hostPort === null) {\n                this.error = {\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse ${target.scheme} address ${path}`,\n                    metadata: new metadata_1.Metadata()\n                };\n                return;\n            }\n            if (target.scheme === IPV4_SCHEME && !(0, net_1.isIPv4)(hostPort.host) || target.scheme === IPV6_SCHEME && !(0, net_1.isIPv6)(hostPort.host)) {\n                this.error = {\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse ${target.scheme} address ${path}`,\n                    metadata: new metadata_1.Metadata()\n                };\n                return;\n            }\n            addresses.push({\n                host: hostPort.host,\n                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT\n            });\n        }\n        this.endpoints = addresses.map((address)=>({\n                addresses: [\n                    address\n                ]\n            }));\n        trace(\"Parsed \" + target.scheme + \" address list \" + addresses);\n    }\n    updateResolution() {\n        if (!this.hasReturnedResult) {\n            this.hasReturnedResult = true;\n            process.nextTick(()=>{\n                if (this.error) {\n                    this.listener.onError(this.error);\n                } else {\n                    this.listener.onSuccessfulResolution(this.endpoints, null, null, null, {});\n                }\n            });\n        }\n    }\n    destroy() {\n        this.hasReturnedResult = false;\n    }\n    static getDefaultAuthority(target) {\n        return target.path.split(\",\")[0];\n    }\n}\nfunction setup() {\n    (0, resolver_1.registerResolver)(IPV4_SCHEME, IpResolver);\n    (0, resolver_1.registerResolver)(IPV6_SCHEME, IpResolver);\n} //# sourceMappingURL=resolver-ip.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItaXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHRTtBQUNoQixNQUFNQyxRQUFRQyxtQkFBT0EsQ0FBQyxnQkFBSztBQUMzQixNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNRyxhQUFhSCxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNSSxlQUFlSixtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNSyxVQUFVTCxtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNTSxjQUFjO0FBQ3BCLFNBQVNDLE1BQU1DLElBQUk7SUFDZkgsUUFBUUUsS0FBSyxDQUFDTixZQUFZUSxZQUFZLENBQUNDLEtBQUssRUFBRUosYUFBYUU7QUFDL0Q7QUFDQSxNQUFNRyxjQUFjO0FBQ3BCLE1BQU1DLGNBQWM7QUFDcEI7O0NBRUMsR0FDRCxNQUFNQyxlQUFlO0FBQ3JCLE1BQU1DO0lBQ0ZDLFlBQVlDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxjQUFjLENBQUU7UUFDMUMsSUFBSUM7UUFDSixJQUFJLENBQUNGLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDRyxTQUFTLEdBQUcsRUFBRTtRQUNuQixJQUFJLENBQUNDLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7UUFDekJmLE1BQU0scUNBQXFDLENBQUMsR0FBR0gsYUFBYW1CLFdBQVcsRUFBRVA7UUFDekUsTUFBTVEsWUFBWSxFQUFFO1FBQ3BCLElBQUksQ0FBRVIsQ0FBQUEsT0FBT1MsTUFBTSxLQUFLZCxlQUFlSyxPQUFPUyxNQUFNLEtBQUtiLFdBQVUsR0FBSTtZQUNuRSxJQUFJLENBQUNTLEtBQUssR0FBRztnQkFDVEssTUFBTXpCLFlBQVkwQixNQUFNLENBQUNDLFdBQVc7Z0JBQ3BDQyxTQUFTLENBQUMsb0JBQW9CLEVBQUViLE9BQU9TLE1BQU0sQ0FBQyxlQUFlLENBQUM7Z0JBQzlESyxVQUFVLElBQUk1QixXQUFXNkIsUUFBUTtZQUNyQztZQUNBO1FBQ0o7UUFDQSxNQUFNQyxXQUFXaEIsT0FBT2lCLElBQUksQ0FBQ0MsS0FBSyxDQUFDO1FBQ25DLEtBQUssTUFBTUQsUUFBUUQsU0FBVTtZQUN6QixNQUFNRyxXQUFXLENBQUMsR0FBRy9CLGFBQWFnQyxhQUFhLEVBQUVIO1lBQ2pELElBQUlFLGFBQWEsTUFBTTtnQkFDbkIsSUFBSSxDQUFDZCxLQUFLLEdBQUc7b0JBQ1RLLE1BQU16QixZQUFZMEIsTUFBTSxDQUFDQyxXQUFXO29CQUNwQ0MsU0FBUyxDQUFDLGdCQUFnQixFQUFFYixPQUFPUyxNQUFNLENBQUMsU0FBUyxFQUFFUSxLQUFLLENBQUM7b0JBQzNESCxVQUFVLElBQUk1QixXQUFXNkIsUUFBUTtnQkFDckM7Z0JBQ0E7WUFDSjtZQUNBLElBQUksT0FBUU4sTUFBTSxLQUFLZCxlQUFlLENBQUMsQ0FBQyxHQUFHWixNQUFNc0MsTUFBTSxFQUFFRixTQUFTRyxJQUFJLEtBQ2pFdEIsT0FBT1MsTUFBTSxLQUFLYixlQUFlLENBQUMsQ0FBQyxHQUFHYixNQUFNd0MsTUFBTSxFQUFFSixTQUFTRyxJQUFJLEdBQUk7Z0JBQ3RFLElBQUksQ0FBQ2pCLEtBQUssR0FBRztvQkFDVEssTUFBTXpCLFlBQVkwQixNQUFNLENBQUNDLFdBQVc7b0JBQ3BDQyxTQUFTLENBQUMsZ0JBQWdCLEVBQUViLE9BQU9TLE1BQU0sQ0FBQyxTQUFTLEVBQUVRLEtBQUssQ0FBQztvQkFDM0RILFVBQVUsSUFBSTVCLFdBQVc2QixRQUFRO2dCQUNyQztnQkFDQTtZQUNKO1lBQ0FQLFVBQVVnQixJQUFJLENBQUM7Z0JBQ1hGLE1BQU1ILFNBQVNHLElBQUk7Z0JBQ25CRyxNQUFNLENBQUN0QixLQUFLZ0IsU0FBU00sSUFBSSxNQUFNLFFBQVF0QixPQUFPLEtBQUssSUFBSUEsS0FBS047WUFDaEU7UUFDSjtRQUNBLElBQUksQ0FBQ08sU0FBUyxHQUFHSSxVQUFVa0IsR0FBRyxDQUFDQyxDQUFBQSxVQUFZO2dCQUFFbkIsV0FBVztvQkFBQ21CO2lCQUFRO1lBQUM7UUFDbEVwQyxNQUFNLFlBQVlTLE9BQU9TLE1BQU0sR0FBRyxtQkFBbUJEO0lBQ3pEO0lBQ0FvQixtQkFBbUI7UUFDZixJQUFJLENBQUMsSUFBSSxDQUFDdEIsaUJBQWlCLEVBQUU7WUFDekIsSUFBSSxDQUFDQSxpQkFBaUIsR0FBRztZQUN6QnVCLFFBQVFDLFFBQVEsQ0FBQztnQkFDYixJQUFJLElBQUksQ0FBQ3pCLEtBQUssRUFBRTtvQkFDWixJQUFJLENBQUNKLFFBQVEsQ0FBQzhCLE9BQU8sQ0FBQyxJQUFJLENBQUMxQixLQUFLO2dCQUNwQyxPQUNLO29CQUNELElBQUksQ0FBQ0osUUFBUSxDQUFDK0Isc0JBQXNCLENBQUMsSUFBSSxDQUFDNUIsU0FBUyxFQUFFLE1BQU0sTUFBTSxNQUFNLENBQUM7Z0JBQzVFO1lBQ0o7UUFDSjtJQUNKO0lBQ0E2QixVQUFVO1FBQ04sSUFBSSxDQUFDM0IsaUJBQWlCLEdBQUc7SUFDN0I7SUFDQSxPQUFPNEIsb0JBQW9CbEMsTUFBTSxFQUFFO1FBQy9CLE9BQU9BLE9BQU9pQixJQUFJLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtJQUNwQztBQUNKO0FBQ0EsU0FBU3BDO0lBQ0osSUFBR0ssV0FBV2dELGdCQUFnQixFQUFFeEMsYUFBYUc7SUFDN0MsSUFBR1gsV0FBV2dELGdCQUFnQixFQUFFdkMsYUFBYUU7QUFDbEQsRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItaXAuanM/N2QyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG5jb25zdCBuZXRfMSA9IHJlcXVpcmUoXCJuZXRcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ2lwX3Jlc29sdmVyJztcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xufVxuY29uc3QgSVBWNF9TQ0hFTUUgPSAnaXB2NCc7XG5jb25zdCBJUFY2X1NDSEVNRSA9ICdpcHY2Jztcbi8qKlxuICogVGhlIGRlZmF1bHQgVENQIHBvcnQgdG8gY29ubmVjdCB0byBpZiBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQgaW4gdGhlIHRhcmdldC5cbiAqL1xuY29uc3QgREVGQVVMVF9QT1JUID0gNDQzO1xuY2xhc3MgSXBSZXNvbHZlciB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBsaXN0ZW5lciwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMuZW5kcG9pbnRzID0gW107XG4gICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc1JldHVybmVkUmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIHRyYWNlKCdSZXNvbHZlciBjb25zdHJ1Y3RlZCBmb3IgdGFyZ2V0ICcgKyAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0YXJnZXQpKTtcbiAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gW107XG4gICAgICAgIGlmICghKHRhcmdldC5zY2hlbWUgPT09IElQVjRfU0NIRU1FIHx8IHRhcmdldC5zY2hlbWUgPT09IElQVjZfU0NIRU1FKSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogYFVucmVjb2duaXplZCBzY2hlbWUgJHt0YXJnZXQuc2NoZW1lfSBpbiBJUCByZXNvbHZlcmAsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGhMaXN0ID0gdGFyZ2V0LnBhdGguc3BsaXQoJywnKTtcbiAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBob3N0UG9ydCA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkocGF0aCk7XG4gICAgICAgICAgICBpZiAoaG9zdFBvcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBGYWlsZWQgdG8gcGFyc2UgJHt0YXJnZXQuc2NoZW1lfSBhZGRyZXNzICR7cGF0aH1gLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFyZ2V0LnNjaGVtZSA9PT0gSVBWNF9TQ0hFTUUgJiYgISgwLCBuZXRfMS5pc0lQdjQpKGhvc3RQb3J0Lmhvc3QpKSB8fFxuICAgICAgICAgICAgICAgICh0YXJnZXQuc2NoZW1lID09PSBJUFY2X1NDSEVNRSAmJiAhKDAsIG5ldF8xLmlzSVB2NikoaG9zdFBvcnQuaG9zdCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgRmFpbGVkIHRvIHBhcnNlICR7dGFyZ2V0LnNjaGVtZX0gYWRkcmVzcyAke3BhdGh9YCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRyZXNzZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaG9zdDogaG9zdFBvcnQuaG9zdCxcbiAgICAgICAgICAgICAgICBwb3J0OiAoX2EgPSBob3N0UG9ydC5wb3J0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBERUZBVUxUX1BPUlQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVuZHBvaW50cyA9IGFkZHJlc3Nlcy5tYXAoYWRkcmVzcyA9PiAoeyBhZGRyZXNzZXM6IFthZGRyZXNzXSB9KSk7XG4gICAgICAgIHRyYWNlKCdQYXJzZWQgJyArIHRhcmdldC5zY2hlbWUgKyAnIGFkZHJlc3MgbGlzdCAnICsgYWRkcmVzc2VzKTtcbiAgICB9XG4gICAgdXBkYXRlUmVzb2x1dGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1JldHVybmVkUmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmhhc1JldHVybmVkUmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25FcnJvcih0aGlzLmVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbih0aGlzLmVuZHBvaW50cywgbnVsbCwgbnVsbCwgbnVsbCwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaGFzUmV0dXJuZWRSZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RhdGljIGdldERlZmF1bHRBdXRob3JpdHkodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQucGF0aC5zcGxpdCgnLCcpWzBdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgICgwLCByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXIpKElQVjRfU0NIRU1FLCBJcFJlc29sdmVyKTtcbiAgICAoMCwgcmVzb2x2ZXJfMS5yZWdpc3RlclJlc29sdmVyKShJUFY2X1NDSEVNRSwgSXBSZXNvbHZlcik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlci1pcC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzZXR1cCIsIm5ldF8xIiwicmVxdWlyZSIsImNvbnN0YW50c18xIiwibWV0YWRhdGFfMSIsInJlc29sdmVyXzEiLCJ1cmlfcGFyc2VyXzEiLCJsb2dnaW5nIiwiVFJBQ0VSX05BTUUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIklQVjRfU0NIRU1FIiwiSVBWNl9TQ0hFTUUiLCJERUZBVUxUX1BPUlQiLCJJcFJlc29sdmVyIiwiY29uc3RydWN0b3IiLCJ0YXJnZXQiLCJsaXN0ZW5lciIsImNoYW5uZWxPcHRpb25zIiwiX2EiLCJlbmRwb2ludHMiLCJlcnJvciIsImhhc1JldHVybmVkUmVzdWx0IiwidXJpVG9TdHJpbmciLCJhZGRyZXNzZXMiLCJzY2hlbWUiLCJjb2RlIiwiU3RhdHVzIiwiVU5BVkFJTEFCTEUiLCJkZXRhaWxzIiwibWV0YWRhdGEiLCJNZXRhZGF0YSIsInBhdGhMaXN0IiwicGF0aCIsInNwbGl0IiwiaG9zdFBvcnQiLCJzcGxpdEhvc3RQb3J0IiwiaXNJUHY0IiwiaG9zdCIsImlzSVB2NiIsInB1c2giLCJwb3J0IiwibWFwIiwiYWRkcmVzcyIsInVwZGF0ZVJlc29sdXRpb24iLCJwcm9jZXNzIiwibmV4dFRpY2siLCJvbkVycm9yIiwib25TdWNjZXNzZnVsUmVzb2x1dGlvbiIsImRlc3Ryb3kiLCJnZXREZWZhdWx0QXV0aG9yaXR5IiwicmVnaXN0ZXJSZXNvbHZlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-uds.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = setup;\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nclass UdsResolver {\n    constructor(target, listener, channelOptions){\n        this.listener = listener;\n        this.hasReturnedResult = false;\n        this.endpoints = [];\n        let path;\n        if (target.authority === \"\") {\n            path = \"/\" + target.path;\n        } else {\n            path = target.path;\n        }\n        this.endpoints = [\n            {\n                addresses: [\n                    {\n                        path\n                    }\n                ]\n            }\n        ];\n    }\n    updateResolution() {\n        if (!this.hasReturnedResult) {\n            this.hasReturnedResult = true;\n            process.nextTick(this.listener.onSuccessfulResolution, this.endpoints, null, null, null, {});\n        }\n    }\n    destroy() {\n        this.hasReturnedResult = false;\n    }\n    static getDefaultAuthority(target) {\n        return \"localhost\";\n    }\n}\nfunction setup() {\n    (0, resolver_1.registerResolver)(\"unix\", UdsResolver);\n} //# sourceMappingURL=resolver-uds.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItdWRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGFBQWEsR0FBR0U7QUFDaEIsTUFBTUMsYUFBYUMsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUM7SUFDRkMsWUFBWUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLGNBQWMsQ0FBRTtRQUMxQyxJQUFJLENBQUNELFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDRSxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNDLFNBQVMsR0FBRyxFQUFFO1FBQ25CLElBQUlDO1FBQ0osSUFBSUwsT0FBT00sU0FBUyxLQUFLLElBQUk7WUFDekJELE9BQU8sTUFBTUwsT0FBT0ssSUFBSTtRQUM1QixPQUNLO1lBQ0RBLE9BQU9MLE9BQU9LLElBQUk7UUFDdEI7UUFDQSxJQUFJLENBQUNELFNBQVMsR0FBRztZQUFDO2dCQUFFRyxXQUFXO29CQUFDO3dCQUFFRjtvQkFBSztpQkFBRTtZQUFDO1NBQUU7SUFDaEQ7SUFDQUcsbUJBQW1CO1FBQ2YsSUFBSSxDQUFDLElBQUksQ0FBQ0wsaUJBQWlCLEVBQUU7WUFDekIsSUFBSSxDQUFDQSxpQkFBaUIsR0FBRztZQUN6Qk0sUUFBUUMsUUFBUSxDQUFDLElBQUksQ0FBQ1QsUUFBUSxDQUFDVSxzQkFBc0IsRUFBRSxJQUFJLENBQUNQLFNBQVMsRUFBRSxNQUFNLE1BQU0sTUFBTSxDQUFDO1FBQzlGO0lBQ0o7SUFDQVEsVUFBVTtRQUNOLElBQUksQ0FBQ1QsaUJBQWlCLEdBQUc7SUFDN0I7SUFDQSxPQUFPVSxvQkFBb0JiLE1BQU0sRUFBRTtRQUMvQixPQUFPO0lBQ1g7QUFDSjtBQUNBLFNBQVNMO0lBQ0osSUFBR0MsV0FBV2tCLGdCQUFnQixFQUFFLFFBQVFoQjtBQUM3QyxFQUNBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1ob3VzaW5nLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZlci11ZHMuanM/Njk1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5jbGFzcyBVZHNSZXNvbHZlciB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBsaXN0ZW5lciwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLmhhc1JldHVybmVkUmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5kcG9pbnRzID0gW107XG4gICAgICAgIGxldCBwYXRoO1xuICAgICAgICBpZiAodGFyZ2V0LmF1dGhvcml0eSA9PT0gJycpIHtcbiAgICAgICAgICAgIHBhdGggPSAnLycgKyB0YXJnZXQucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGggPSB0YXJnZXQucGF0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVuZHBvaW50cyA9IFt7IGFkZHJlc3NlczogW3sgcGF0aCB9XSB9XTtcbiAgICB9XG4gICAgdXBkYXRlUmVzb2x1dGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1JldHVybmVkUmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmhhc1JldHVybmVkUmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2sodGhpcy5saXN0ZW5lci5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uLCB0aGlzLmVuZHBvaW50cywgbnVsbCwgbnVsbCwgbnVsbCwge30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaGFzUmV0dXJuZWRSZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RhdGljIGdldERlZmF1bHRBdXRob3JpdHkodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiAnbG9jYWxob3N0JztcbiAgICB9XG59XG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgICAoMCwgcmVzb2x2ZXJfMS5yZWdpc3RlclJlc29sdmVyKSgndW5peCcsIFVkc1Jlc29sdmVyKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVyLXVkcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzZXR1cCIsInJlc29sdmVyXzEiLCJyZXF1aXJlIiwiVWRzUmVzb2x2ZXIiLCJjb25zdHJ1Y3RvciIsInRhcmdldCIsImxpc3RlbmVyIiwiY2hhbm5lbE9wdGlvbnMiLCJoYXNSZXR1cm5lZFJlc3VsdCIsImVuZHBvaW50cyIsInBhdGgiLCJhdXRob3JpdHkiLCJhZGRyZXNzZXMiLCJ1cGRhdGVSZXNvbHV0aW9uIiwicHJvY2VzcyIsIm5leHRUaWNrIiwib25TdWNjZXNzZnVsUmVzb2x1dGlvbiIsImRlc3Ryb3kiLCJnZXREZWZhdWx0QXV0aG9yaXR5IiwicmVnaXN0ZXJSZXNvbHZlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.registerResolver = registerResolver;\nexports.registerDefaultScheme = registerDefaultScheme;\nexports.createResolver = createResolver;\nexports.getDefaultAuthority = getDefaultAuthority;\nexports.mapUriDefaultScheme = mapUriDefaultScheme;\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst registeredResolvers = {};\nlet defaultScheme = null;\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */ function registerResolver(scheme, resolverClass) {\n    registeredResolvers[scheme] = resolverClass;\n}\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */ function registerDefaultScheme(scheme) {\n    defaultScheme = scheme;\n}\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */ function createResolver(target, listener, options) {\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n        return new registeredResolvers[target.scheme](target, listener, options);\n    } else {\n        throw new Error(`No resolver could be created for target ${(0, uri_parser_1.uriToString)(target)}`);\n    }\n}\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */ function getDefaultAuthority(target) {\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n        return registeredResolvers[target.scheme].getDefaultAuthority(target);\n    } else {\n        throw new Error(`Invalid target ${(0, uri_parser_1.uriToString)(target)}`);\n    }\n}\nfunction mapUriDefaultScheme(target) {\n    if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\n        if (defaultScheme !== null) {\n            return {\n                scheme: defaultScheme,\n                authority: undefined,\n                path: (0, uri_parser_1.uriToString)(target)\n            };\n        } else {\n            return null;\n        }\n    }\n    return target;\n} //# sourceMappingURL=resolver.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHdCQUF3QixHQUFHRTtBQUMzQkYsNkJBQTZCLEdBQUdHO0FBQ2hDSCxzQkFBc0IsR0FBR0k7QUFDekJKLDJCQUEyQixHQUFHSztBQUM5QkwsMkJBQTJCLEdBQUdNO0FBQzlCLE1BQU1DLGVBQWVDLG1CQUFPQSxDQUFDLGdGQUFjO0FBQzNDLE1BQU1DLHNCQUFzQixDQUFDO0FBQzdCLElBQUlDLGdCQUFnQjtBQUNwQjs7Ozs7O0NBTUMsR0FDRCxTQUFTUixpQkFBaUJTLE1BQU0sRUFBRUMsYUFBYTtJQUMzQ0gsbUJBQW1CLENBQUNFLE9BQU8sR0FBR0M7QUFDbEM7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU1Qsc0JBQXNCUSxNQUFNO0lBQ2pDRCxnQkFBZ0JDO0FBQ3BCO0FBQ0E7Ozs7O0NBS0MsR0FDRCxTQUFTUCxlQUFlUyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsT0FBTztJQUM3QyxJQUFJRixPQUFPRixNQUFNLEtBQUtLLGFBQWFILE9BQU9GLE1BQU0sSUFBSUYscUJBQXFCO1FBQ3JFLE9BQU8sSUFBSUEsbUJBQW1CLENBQUNJLE9BQU9GLE1BQU0sQ0FBQyxDQUFDRSxRQUFRQyxVQUFVQztJQUNwRSxPQUNLO1FBQ0QsTUFBTSxJQUFJRSxNQUFNLENBQUMsd0NBQXdDLEVBQUUsQ0FBQyxHQUFHVixhQUFhVyxXQUFXLEVBQUVMLFFBQVEsQ0FBQztJQUN0RztBQUNKO0FBQ0E7Ozs7Q0FJQyxHQUNELFNBQVNSLG9CQUFvQlEsTUFBTTtJQUMvQixJQUFJQSxPQUFPRixNQUFNLEtBQUtLLGFBQWFILE9BQU9GLE1BQU0sSUFBSUYscUJBQXFCO1FBQ3JFLE9BQU9BLG1CQUFtQixDQUFDSSxPQUFPRixNQUFNLENBQUMsQ0FBQ04sbUJBQW1CLENBQUNRO0lBQ2xFLE9BQ0s7UUFDRCxNQUFNLElBQUlJLE1BQU0sQ0FBQyxlQUFlLEVBQUUsQ0FBQyxHQUFHVixhQUFhVyxXQUFXLEVBQUVMLFFBQVEsQ0FBQztJQUM3RTtBQUNKO0FBQ0EsU0FBU1Asb0JBQW9CTyxNQUFNO0lBQy9CLElBQUlBLE9BQU9GLE1BQU0sS0FBS0ssYUFBYSxDQUFFSCxDQUFBQSxPQUFPRixNQUFNLElBQUlGLG1CQUFrQixHQUFJO1FBQ3hFLElBQUlDLGtCQUFrQixNQUFNO1lBQ3hCLE9BQU87Z0JBQ0hDLFFBQVFEO2dCQUNSUyxXQUFXSDtnQkFDWEksTUFBTSxDQUFDLEdBQUdiLGFBQWFXLFdBQVcsRUFBRUw7WUFDeEM7UUFDSixPQUNLO1lBQ0QsT0FBTztRQUNYO0lBQ0o7SUFDQSxPQUFPQTtBQUNYLEVBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnljLWhvdXNpbmctYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmVyLmpzPzFkOTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVnaXN0ZXJSZXNvbHZlciA9IHJlZ2lzdGVyUmVzb2x2ZXI7XG5leHBvcnRzLnJlZ2lzdGVyRGVmYXVsdFNjaGVtZSA9IHJlZ2lzdGVyRGVmYXVsdFNjaGVtZTtcbmV4cG9ydHMuY3JlYXRlUmVzb2x2ZXIgPSBjcmVhdGVSZXNvbHZlcjtcbmV4cG9ydHMuZ2V0RGVmYXVsdEF1dGhvcml0eSA9IGdldERlZmF1bHRBdXRob3JpdHk7XG5leHBvcnRzLm1hcFVyaURlZmF1bHRTY2hlbWUgPSBtYXBVcmlEZWZhdWx0U2NoZW1lO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IHJlZ2lzdGVyZWRSZXNvbHZlcnMgPSB7fTtcbmxldCBkZWZhdWx0U2NoZW1lID0gbnVsbDtcbi8qKlxuICogUmVnaXN0ZXIgYSByZXNvbHZlciBjbGFzcyB0byBoYW5kbGUgdGFyZ2V0IG5hbWVzIHByZWZpeGVkIHdpdGggdGhlIGBwcmVmaXhgXG4gKiBzdHJpbmcuIFRoaXMgcHJlZml4IHNob3VsZCBjb3JyZXNwb25kIHRvIGEgVVJJIHNjaGVtZSBuYW1lIGxpc3RlZCBpbiB0aGVcbiAqIFtnUlBDIE5hbWUgUmVzb2x1dGlvbiBkb2N1bWVudF0oaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL21hc3Rlci9kb2MvbmFtaW5nLm1kKVxuICogQHBhcmFtIHByZWZpeFxuICogQHBhcmFtIHJlc29sdmVyQ2xhc3NcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJSZXNvbHZlcihzY2hlbWUsIHJlc29sdmVyQ2xhc3MpIHtcbiAgICByZWdpc3RlcmVkUmVzb2x2ZXJzW3NjaGVtZV0gPSByZXNvbHZlckNsYXNzO1xufVxuLyoqXG4gKiBSZWdpc3RlciBhIGRlZmF1bHQgcmVzb2x2ZXIgdG8gaGFuZGxlIHRhcmdldCBuYW1lcyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoXG4gKiBhbnkgcmVnaXN0ZXJlZCBwcmVmaXguXG4gKiBAcGFyYW0gcmVzb2x2ZXJDbGFzc1xuICovXG5mdW5jdGlvbiByZWdpc3RlckRlZmF1bHRTY2hlbWUoc2NoZW1lKSB7XG4gICAgZGVmYXVsdFNjaGVtZSA9IHNjaGVtZTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmFtZSByZXNvbHZlciBmb3IgdGhlIHNwZWNpZmllZCB0YXJnZXQsIGlmIHBvc3NpYmxlLiBUaHJvd3MgYW5cbiAqIGVycm9yIGlmIG5vIHN1Y2ggbmFtZSByZXNvbHZlciBjYW4gYmUgY3JlYXRlZC5cbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEBwYXJhbSBsaXN0ZW5lclxuICovXG5mdW5jdGlvbiBjcmVhdGVSZXNvbHZlcih0YXJnZXQsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgaWYgKHRhcmdldC5zY2hlbWUgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQuc2NoZW1lIGluIHJlZ2lzdGVyZWRSZXNvbHZlcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByZWdpc3RlcmVkUmVzb2x2ZXJzW3RhcmdldC5zY2hlbWVdKHRhcmdldCwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyByZXNvbHZlciBjb3VsZCBiZSBjcmVhdGVkIGZvciB0YXJnZXQgJHsoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0YXJnZXQpfWApO1xuICAgIH1cbn1cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IGF1dGhvcml0eSBmb3IgdGhlIHNwZWNpZmllZCB0YXJnZXQsIGlmIHBvc3NpYmxlLiBUaHJvd3MgYW5cbiAqIGVycm9yIGlmIG5vIHJlZ2lzdGVyZWQgbmFtZSByZXNvbHZlciBjYW4gcGFyc2UgdGhhdCB0YXJnZXQgc3RyaW5nLlxuICogQHBhcmFtIHRhcmdldFxuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0QXV0aG9yaXR5KHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQuc2NoZW1lICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0LnNjaGVtZSBpbiByZWdpc3RlcmVkUmVzb2x2ZXJzKSB7XG4gICAgICAgIHJldHVybiByZWdpc3RlcmVkUmVzb2x2ZXJzW3RhcmdldC5zY2hlbWVdLmdldERlZmF1bHRBdXRob3JpdHkodGFyZ2V0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0YXJnZXQgJHsoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0YXJnZXQpfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcFVyaURlZmF1bHRTY2hlbWUodGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5zY2hlbWUgPT09IHVuZGVmaW5lZCB8fCAhKHRhcmdldC5zY2hlbWUgaW4gcmVnaXN0ZXJlZFJlc29sdmVycykpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRTY2hlbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2NoZW1lOiBkZWZhdWx0U2NoZW1lLFxuICAgICAgICAgICAgICAgIGF1dGhvcml0eTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHBhdGg6ICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlZ2lzdGVyUmVzb2x2ZXIiLCJyZWdpc3RlckRlZmF1bHRTY2hlbWUiLCJjcmVhdGVSZXNvbHZlciIsImdldERlZmF1bHRBdXRob3JpdHkiLCJtYXBVcmlEZWZhdWx0U2NoZW1lIiwidXJpX3BhcnNlcl8xIiwicmVxdWlyZSIsInJlZ2lzdGVyZWRSZXNvbHZlcnMiLCJkZWZhdWx0U2NoZW1lIiwic2NoZW1lIiwicmVzb2x2ZXJDbGFzcyIsInRhcmdldCIsImxpc3RlbmVyIiwib3B0aW9ucyIsInVuZGVmaW5lZCIsIkVycm9yIiwidXJpVG9TdHJpbmciLCJhdXRob3JpdHkiLCJwYXRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolving-call.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ResolvingCall = void 0;\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\nconst TRACER_NAME = \"resolving_call\";\nclass ResolvingCall {\n    constructor(channel, method, options, filterStackFactory, callNumber){\n        this.channel = channel;\n        this.method = method;\n        this.filterStackFactory = filterStackFactory;\n        this.callNumber = callNumber;\n        this.child = null;\n        this.readPending = false;\n        this.pendingMessage = null;\n        this.pendingHalfClose = false;\n        this.ended = false;\n        this.readFilterPending = false;\n        this.writeFilterPending = false;\n        this.pendingChildStatus = null;\n        this.metadata = null;\n        this.listener = null;\n        this.statusWatchers = [];\n        this.deadlineTimer = setTimeout(()=>{}, 0);\n        this.filterStack = null;\n        this.deadlineStartTime = null;\n        this.configReceivedTime = null;\n        this.childStartTime = null;\n        /**\n         * Credentials configured for this specific call. Does not include\n         * call credentials associated with the channel credentials used to create\n         * the channel.\n         */ this.credentials = call_credentials_1.CallCredentials.createEmpty();\n        this.deadline = options.deadline;\n        this.host = options.host;\n        if (options.parentCall) {\n            if (options.flags & constants_1.Propagate.CANCELLATION) {\n                options.parentCall.on(\"cancelled\", ()=>{\n                    this.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled by parent call\");\n                });\n            }\n            if (options.flags & constants_1.Propagate.DEADLINE) {\n                this.trace(\"Propagating deadline from parent: \" + options.parentCall.getDeadline());\n                this.deadline = (0, deadline_1.minDeadline)(this.deadline, options.parentCall.getDeadline());\n            }\n        }\n        this.trace(\"Created\");\n        this.runDeadlineTimer();\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"[\" + this.callNumber + \"] \" + text);\n    }\n    runDeadlineTimer() {\n        clearTimeout(this.deadlineTimer);\n        this.deadlineStartTime = new Date();\n        this.trace(\"Deadline: \" + (0, deadline_1.deadlineToString)(this.deadline));\n        const timeout = (0, deadline_1.getRelativeTimeout)(this.deadline);\n        if (timeout !== Infinity) {\n            this.trace(\"Deadline will be reached in \" + timeout + \"ms\");\n            const handleDeadline = ()=>{\n                if (!this.deadlineStartTime) {\n                    this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, \"Deadline exceeded\");\n                    return;\n                }\n                const deadlineInfo = [];\n                const deadlineEndTime = new Date();\n                deadlineInfo.push(`Deadline exceeded after ${(0, deadline_1.formatDateDifference)(this.deadlineStartTime, deadlineEndTime)}`);\n                if (this.configReceivedTime) {\n                    if (this.configReceivedTime > this.deadlineStartTime) {\n                        deadlineInfo.push(`name resolution: ${(0, deadline_1.formatDateDifference)(this.deadlineStartTime, this.configReceivedTime)}`);\n                    }\n                    if (this.childStartTime) {\n                        if (this.childStartTime > this.configReceivedTime) {\n                            deadlineInfo.push(`metadata filters: ${(0, deadline_1.formatDateDifference)(this.configReceivedTime, this.childStartTime)}`);\n                        }\n                    } else {\n                        deadlineInfo.push(\"waiting for metadata filters\");\n                    }\n                } else {\n                    deadlineInfo.push(\"waiting for name resolution\");\n                }\n                if (this.child) {\n                    deadlineInfo.push(...this.child.getDeadlineInfo());\n                }\n                this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, deadlineInfo.join(\",\"));\n            };\n            if (timeout <= 0) {\n                process.nextTick(handleDeadline);\n            } else {\n                this.deadlineTimer = setTimeout(handleDeadline, timeout);\n            }\n        }\n    }\n    outputStatus(status) {\n        if (!this.ended) {\n            this.ended = true;\n            if (!this.filterStack) {\n                this.filterStack = this.filterStackFactory.createFilter();\n            }\n            clearTimeout(this.deadlineTimer);\n            const filteredStatus = this.filterStack.receiveTrailers(status);\n            this.trace(\"ended with status: code=\" + filteredStatus.code + ' details=\"' + filteredStatus.details + '\"');\n            this.statusWatchers.forEach((watcher)=>watcher(filteredStatus));\n            process.nextTick(()=>{\n                var _a;\n                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);\n            });\n        }\n    }\n    sendMessageOnChild(context, message) {\n        if (!this.child) {\n            throw new Error(\"sendMessageonChild called with child not populated\");\n        }\n        const child = this.child;\n        this.writeFilterPending = true;\n        this.filterStack.sendMessage(Promise.resolve({\n            message: message,\n            flags: context.flags\n        })).then((filteredMessage)=>{\n            this.writeFilterPending = false;\n            child.sendMessageWithContext(context, filteredMessage.message);\n            if (this.pendingHalfClose) {\n                child.halfClose();\n            }\n        }, (status)=>{\n            this.cancelWithStatus(status.code, status.details);\n        });\n    }\n    getConfig() {\n        if (this.ended) {\n            return;\n        }\n        if (!this.metadata || !this.listener) {\n            throw new Error(\"getConfig called before start\");\n        }\n        const configResult = this.channel.getConfig(this.method, this.metadata);\n        if (configResult.type === \"NONE\") {\n            this.channel.queueCallForConfig(this);\n            return;\n        } else if (configResult.type === \"ERROR\") {\n            if (this.metadata.getOptions().waitForReady) {\n                this.channel.queueCallForConfig(this);\n            } else {\n                this.outputStatus(configResult.error);\n            }\n            return;\n        }\n        // configResult.type === 'SUCCESS'\n        this.configReceivedTime = new Date();\n        const config = configResult.config;\n        if (config.status !== constants_1.Status.OK) {\n            const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(config.status, \"Failed to route call to method \" + this.method);\n            this.outputStatus({\n                code: code,\n                details: details,\n                metadata: new metadata_1.Metadata()\n            });\n            return;\n        }\n        if (config.methodConfig.timeout) {\n            const configDeadline = new Date();\n            configDeadline.setSeconds(configDeadline.getSeconds() + config.methodConfig.timeout.seconds);\n            configDeadline.setMilliseconds(configDeadline.getMilliseconds() + config.methodConfig.timeout.nanos / 1000000);\n            this.deadline = (0, deadline_1.minDeadline)(this.deadline, configDeadline);\n            this.runDeadlineTimer();\n        }\n        this.filterStackFactory.push(config.dynamicFilterFactories);\n        this.filterStack = this.filterStackFactory.createFilter();\n        this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then((filteredMetadata)=>{\n            this.child = this.channel.createRetryingCall(config, this.method, this.host, this.credentials, this.deadline);\n            this.trace(\"Created child [\" + this.child.getCallNumber() + \"]\");\n            this.childStartTime = new Date();\n            this.child.start(filteredMetadata, {\n                onReceiveMetadata: (metadata)=>{\n                    this.trace(\"Received metadata\");\n                    this.listener.onReceiveMetadata(this.filterStack.receiveMetadata(metadata));\n                },\n                onReceiveMessage: (message)=>{\n                    this.trace(\"Received message\");\n                    this.readFilterPending = true;\n                    this.filterStack.receiveMessage(message).then((filteredMesssage)=>{\n                        this.trace(\"Finished filtering received message\");\n                        this.readFilterPending = false;\n                        this.listener.onReceiveMessage(filteredMesssage);\n                        if (this.pendingChildStatus) {\n                            this.outputStatus(this.pendingChildStatus);\n                        }\n                    }, (status)=>{\n                        this.cancelWithStatus(status.code, status.details);\n                    });\n                },\n                onReceiveStatus: (status)=>{\n                    this.trace(\"Received status\");\n                    if (this.readFilterPending) {\n                        this.pendingChildStatus = status;\n                    } else {\n                        this.outputStatus(status);\n                    }\n                }\n            });\n            if (this.readPending) {\n                this.child.startRead();\n            }\n            if (this.pendingMessage) {\n                this.sendMessageOnChild(this.pendingMessage.context, this.pendingMessage.message);\n            } else if (this.pendingHalfClose) {\n                this.child.halfClose();\n            }\n        }, (status)=>{\n            this.outputStatus(status);\n        });\n    }\n    reportResolverError(status) {\n        var _a;\n        if ((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.getOptions().waitForReady) {\n            this.channel.queueCallForConfig(this);\n        } else {\n            this.outputStatus(status);\n        }\n    }\n    cancelWithStatus(status, details) {\n        var _a;\n        this.trace(\"cancelWithStatus code: \" + status + ' details: \"' + details + '\"');\n        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);\n        this.outputStatus({\n            code: status,\n            details: details,\n            metadata: new metadata_1.Metadata()\n        });\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n    }\n    start(metadata, listener) {\n        this.trace(\"start called\");\n        this.metadata = metadata.clone();\n        this.listener = listener;\n        this.getConfig();\n    }\n    sendMessageWithContext(context, message) {\n        this.trace(\"write() called with message of length \" + message.length);\n        if (this.child) {\n            this.sendMessageOnChild(context, message);\n        } else {\n            this.pendingMessage = {\n                context,\n                message\n            };\n        }\n    }\n    startRead() {\n        this.trace(\"startRead called\");\n        if (this.child) {\n            this.child.startRead();\n        } else {\n            this.readPending = true;\n        }\n    }\n    halfClose() {\n        this.trace(\"halfClose called\");\n        if (this.child && !this.writeFilterPending) {\n            this.child.halfClose();\n        } else {\n            this.pendingHalfClose = true;\n        }\n    }\n    setCredentials(credentials) {\n        this.credentials = credentials;\n    }\n    addStatusWatcher(watcher) {\n        this.statusWatchers.push(watcher);\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n}\nexports.ResolvingCall = ResolvingCall; //# sourceMappingURL=resolving-call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWNhbGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHLEtBQUs7QUFDN0IsTUFBTUcscUJBQXFCQyxtQkFBT0EsQ0FBQyw0RkFBb0I7QUFDdkQsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUUsYUFBYUYsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUcsYUFBYUgsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUksVUFBVUosbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTUsseUJBQXlCTCxtQkFBT0EsQ0FBQyxvR0FBd0I7QUFDL0QsTUFBTU0sY0FBYztBQUNwQixNQUFNUjtJQUNGUyxZQUFZQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxrQkFBa0IsRUFBRUMsVUFBVSxDQUFFO1FBQ2xFLElBQUksQ0FBQ0osT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0Usa0JBQWtCLEdBQUdBO1FBQzFCLElBQUksQ0FBQ0MsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNDLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztRQUMxQixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNo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O1FBQ3BFLElBQUksSUFBSSxDQUFDaEgsS0FBSyxFQUFFO1lBQ1osSUFBSSxDQUFDaUUsa0JBQWtCLENBQUNDLFNBQVNDO1FBQ3JDLE9BQ0s7WUFDRCxJQUFJLENBQUNqRSxjQUFjLEdBQUc7Z0JBQUVnRTtnQkFBU0M7WUFBUTtRQUM3QztJQUNKO0lBQ0F1QyxZQUFZO1FBQ1IsSUFBSSxDQUFDM0UsS0FBSyxDQUFDO1FBQ1gsSUFBSSxJQUFJLENBQUMvQixLQUFLLEVBQUU7WUFDWixJQUFJLENBQUNBLEtBQUssQ0FBQzBHLFNBQVM7UUFDeEIsT0FDSztZQUNELElBQUksQ0FBQ3pHLFdBQVcsR0FBRztRQUN2QjtJQUNKO0lBQ0EwRSxZQUFZO1FBQ1IsSUFBSSxDQUFDNUMsS0FBSyxDQUFDO1FBQ1gsSUFBSSxJQUFJLENBQUMvQixLQUFLLElBQUksQ0FBQyxJQUFJLENBQUNNLGtCQUFrQixFQUFFO1lBQ3hDLElBQUksQ0FBQ04sS0FBSyxDQUFDMkUsU0FBUztRQUN4QixPQUNLO1lBQ0QsSUFBSSxDQUFDeEUsZ0JBQWdCLEdBQUc7UUFDNUI7SUFDSjtJQUNBOEcsZUFBZWhHLFdBQVcsRUFBRTtRQUN4QixJQUFJLENBQUNBLFdBQVcsR0FBR0E7SUFDdkI7SUFDQWlHLGlCQUFpQnBELE9BQU8sRUFBRTtRQUN0QixJQUFJLENBQUNwRCxjQUFjLENBQUNzQyxJQUFJLENBQUNjO0lBQzdCO0lBQ0FxQyxnQkFBZ0I7UUFDWixPQUFPLElBQUksQ0FBQ3BHLFVBQVU7SUFDMUI7QUFDSjtBQUNBaEIscUJBQXFCLEdBQUdFLGVBQ3hCLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1ob3VzaW5nLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZpbmctY2FsbC5qcz82MWFmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlc29sdmluZ0NhbGwgPSB2b2lkIDA7XG5jb25zdCBjYWxsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jYWxsLWNyZWRlbnRpYWxzXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBkZWFkbGluZV8xID0gcmVxdWlyZShcIi4vZGVhZGxpbmVcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEgPSByZXF1aXJlKFwiLi9jb250cm9sLXBsYW5lLXN0YXR1c1wiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3Jlc29sdmluZ19jYWxsJztcbmNsYXNzIFJlc29sdmluZ0NhbGwge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwsIG1ldGhvZCwgb3B0aW9ucywgZmlsdGVyU3RhY2tGYWN0b3J5LCBjYWxsTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICB0aGlzLmZpbHRlclN0YWNrRmFjdG9yeSA9IGZpbHRlclN0YWNrRmFjdG9yeTtcbiAgICAgICAgdGhpcy5jYWxsTnVtYmVyID0gY2FsbE51bWJlcjtcbiAgICAgICAgdGhpcy5jaGlsZCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVhZFBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZ0hhbGZDbG9zZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVhZEZpbHRlclBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy53cml0ZUZpbHRlclBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGRTdGF0dXMgPSBudWxsO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdHVzV2F0Y2hlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5kZWFkbGluZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7IH0sIDApO1xuICAgICAgICB0aGlzLmZpbHRlclN0YWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZWFkbGluZVN0YXJ0VGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29uZmlnUmVjZWl2ZWRUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGlsZFN0YXJ0VGltZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVkZW50aWFscyBjb25maWd1cmVkIGZvciB0aGlzIHNwZWNpZmljIGNhbGwuIERvZXMgbm90IGluY2x1ZGVcbiAgICAgICAgICogY2FsbCBjcmVkZW50aWFscyBhc3NvY2lhdGVkIHdpdGggdGhlIGNoYW5uZWwgY3JlZGVudGlhbHMgdXNlZCB0byBjcmVhdGVcbiAgICAgICAgICogdGhlIGNoYW5uZWwuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVFbXB0eSgpO1xuICAgICAgICB0aGlzLmRlYWRsaW5lID0gb3B0aW9ucy5kZWFkbGluZTtcbiAgICAgICAgdGhpcy5ob3N0ID0gb3B0aW9ucy5ob3N0O1xuICAgICAgICBpZiAob3B0aW9ucy5wYXJlbnRDYWxsKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mbGFncyAmIGNvbnN0YW50c18xLlByb3BhZ2F0ZS5DQU5DRUxMQVRJT04pIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmVudENhbGwub24oJ2NhbmNlbGxlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdDYW5jZWxsZWQgYnkgcGFyZW50IGNhbGwnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZsYWdzICYgY29uc3RhbnRzXzEuUHJvcGFnYXRlLkRFQURMSU5FKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUHJvcGFnYXRpbmcgZGVhZGxpbmUgZnJvbSBwYXJlbnQ6ICcgK1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmVudENhbGwuZ2V0RGVhZGxpbmUoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWFkbGluZSA9ICgwLCBkZWFkbGluZV8xLm1pbkRlYWRsaW5lKSh0aGlzLmRlYWRsaW5lLCBvcHRpb25zLnBhcmVudENhbGwuZ2V0RGVhZGxpbmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZSgnQ3JlYXRlZCcpO1xuICAgICAgICB0aGlzLnJ1bkRlYWRsaW5lVGltZXIoKTtcbiAgICB9XG4gICAgdHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICdbJyArIHRoaXMuY2FsbE51bWJlciArICddICcgKyB0ZXh0KTtcbiAgICB9XG4gICAgcnVuRGVhZGxpbmVUaW1lcigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVhZGxpbmVUaW1lcik7XG4gICAgICAgIHRoaXMuZGVhZGxpbmVTdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLnRyYWNlKCdEZWFkbGluZTogJyArICgwLCBkZWFkbGluZV8xLmRlYWRsaW5lVG9TdHJpbmcpKHRoaXMuZGVhZGxpbmUpKTtcbiAgICAgICAgY29uc3QgdGltZW91dCA9ICgwLCBkZWFkbGluZV8xLmdldFJlbGF0aXZlVGltZW91dCkodGhpcy5kZWFkbGluZSk7XG4gICAgICAgIGlmICh0aW1lb3V0ICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnRGVhZGxpbmUgd2lsbCBiZSByZWFjaGVkIGluICcgKyB0aW1lb3V0ICsgJ21zJyk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVEZWFkbGluZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVhZGxpbmVTdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5ERUFETElORV9FWENFRURFRCwgJ0RlYWRsaW5lIGV4Y2VlZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGVhZGxpbmVJbmZvID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgZGVhZGxpbmVFbmRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICBkZWFkbGluZUluZm8ucHVzaChgRGVhZGxpbmUgZXhjZWVkZWQgYWZ0ZXIgJHsoMCwgZGVhZGxpbmVfMS5mb3JtYXREYXRlRGlmZmVyZW5jZSkodGhpcy5kZWFkbGluZVN0YXJ0VGltZSwgZGVhZGxpbmVFbmRUaW1lKX1gKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWdSZWNlaXZlZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnUmVjZWl2ZWRUaW1lID4gdGhpcy5kZWFkbGluZVN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVhZGxpbmVJbmZvLnB1c2goYG5hbWUgcmVzb2x1dGlvbjogJHsoMCwgZGVhZGxpbmVfMS5mb3JtYXREYXRlRGlmZmVyZW5jZSkodGhpcy5kZWFkbGluZVN0YXJ0VGltZSwgdGhpcy5jb25maWdSZWNlaXZlZFRpbWUpfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkU3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZFN0YXJ0VGltZSA+IHRoaXMuY29uZmlnUmVjZWl2ZWRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVhZGxpbmVJbmZvLnB1c2goYG1ldGFkYXRhIGZpbHRlcnM6ICR7KDAsIGRlYWRsaW5lXzEuZm9ybWF0RGF0ZURpZmZlcmVuY2UpKHRoaXMuY29uZmlnUmVjZWl2ZWRUaW1lLCB0aGlzLmNoaWxkU3RhcnRUaW1lKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYWRsaW5lSW5mby5wdXNoKCd3YWl0aW5nIGZvciBtZXRhZGF0YSBmaWx0ZXJzJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYWRsaW5lSW5mby5wdXNoKCd3YWl0aW5nIGZvciBuYW1lIHJlc29sdXRpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVhZGxpbmVJbmZvLnB1c2goLi4udGhpcy5jaGlsZC5nZXREZWFkbGluZUluZm8oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuREVBRExJTkVfRVhDRUVERUQsIGRlYWRsaW5lSW5mby5qb2luKCcsJykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0IDw9IDApIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGhhbmRsZURlYWRsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVhZGxpbmVUaW1lciA9IHNldFRpbWVvdXQoaGFuZGxlRGVhZGxpbmUsIHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG91dHB1dFN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5maWx0ZXJTdGFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyU3RhY2sgPSB0aGlzLmZpbHRlclN0YWNrRmFjdG9yeS5jcmVhdGVGaWx0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYWRsaW5lVGltZXIpO1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRTdGF0dXMgPSB0aGlzLmZpbHRlclN0YWNrLnJlY2VpdmVUcmFpbGVycyhzdGF0dXMpO1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnZW5kZWQgd2l0aCBzdGF0dXM6IGNvZGU9JyArXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRTdGF0dXMuY29kZSArXG4gICAgICAgICAgICAgICAgJyBkZXRhaWxzPVwiJyArXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRTdGF0dXMuZGV0YWlscyArXG4gICAgICAgICAgICAgICAgJ1wiJyk7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c1dhdGNoZXJzLmZvckVhY2god2F0Y2hlciA9PiB3YXRjaGVyKGZpbHRlcmVkU3RhdHVzKSk7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5saXN0ZW5lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uUmVjZWl2ZVN0YXR1cyhmaWx0ZXJlZFN0YXR1cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kTWVzc2FnZU9uQ2hpbGQoY29udGV4dCwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIXRoaXMuY2hpbGQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2VuZE1lc3NhZ2VvbkNoaWxkIGNhbGxlZCB3aXRoIGNoaWxkIG5vdCBwb3B1bGF0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGQ7XG4gICAgICAgIHRoaXMud3JpdGVGaWx0ZXJQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFjay5zZW5kTWVzc2FnZShQcm9taXNlLnJlc29sdmUoeyBtZXNzYWdlOiBtZXNzYWdlLCBmbGFnczogY29udGV4dC5mbGFncyB9KSkudGhlbihmaWx0ZXJlZE1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgdGhpcy53cml0ZUZpbHRlclBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGNoaWxkLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgZmlsdGVyZWRNZXNzYWdlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0hhbGZDbG9zZSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLmhhbGZDbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLmNvZGUsIHN0YXR1cy5kZXRhaWxzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldENvbmZpZygpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5kZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubWV0YWRhdGEgfHwgIXRoaXMubGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0Q29uZmlnIGNhbGxlZCBiZWZvcmUgc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWdSZXN1bHQgPSB0aGlzLmNoYW5uZWwuZ2V0Q29uZmlnKHRoaXMubWV0aG9kLCB0aGlzLm1ldGFkYXRhKTtcbiAgICAgICAgaWYgKGNvbmZpZ1Jlc3VsdC50eXBlID09PSAnTk9ORScpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5xdWV1ZUNhbGxGb3JDb25maWcodGhpcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29uZmlnUmVzdWx0LnR5cGUgPT09ICdFUlJPUicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1ldGFkYXRhLmdldE9wdGlvbnMoKS53YWl0Rm9yUmVhZHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWwucXVldWVDYWxsRm9yQ29uZmlnKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoY29uZmlnUmVzdWx0LmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25maWdSZXN1bHQudHlwZSA9PT0gJ1NVQ0NFU1MnXG4gICAgICAgIHRoaXMuY29uZmlnUmVjZWl2ZWRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gY29uZmlnUmVzdWx0LmNvbmZpZztcbiAgICAgICAgaWYgKGNvbmZpZy5zdGF0dXMgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgY29uc3QgeyBjb2RlLCBkZXRhaWxzIH0gPSAoMCwgY29udHJvbF9wbGFuZV9zdGF0dXNfMS5yZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUpKGNvbmZpZy5zdGF0dXMsICdGYWlsZWQgdG8gcm91dGUgY2FsbCB0byBtZXRob2QgJyArIHRoaXMubWV0aG9kKTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGRldGFpbHMsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLm1ldGhvZENvbmZpZy50aW1lb3V0KSB7XG4gICAgICAgICAgICBjb25zdCBjb25maWdEZWFkbGluZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBjb25maWdEZWFkbGluZS5zZXRTZWNvbmRzKGNvbmZpZ0RlYWRsaW5lLmdldFNlY29uZHMoKSArIGNvbmZpZy5tZXRob2RDb25maWcudGltZW91dC5zZWNvbmRzKTtcbiAgICAgICAgICAgIGNvbmZpZ0RlYWRsaW5lLnNldE1pbGxpc2Vjb25kcyhjb25maWdEZWFkbGluZS5nZXRNaWxsaXNlY29uZHMoKSArXG4gICAgICAgICAgICAgICAgY29uZmlnLm1ldGhvZENvbmZpZy50aW1lb3V0Lm5hbm9zIC8gMTAwMDAwMCk7XG4gICAgICAgICAgICB0aGlzLmRlYWRsaW5lID0gKDAsIGRlYWRsaW5lXzEubWluRGVhZGxpbmUpKHRoaXMuZGVhZGxpbmUsIGNvbmZpZ0RlYWRsaW5lKTtcbiAgICAgICAgICAgIHRoaXMucnVuRGVhZGxpbmVUaW1lcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2tGYWN0b3J5LnB1c2goY29uZmlnLmR5bmFtaWNGaWx0ZXJGYWN0b3JpZXMpO1xuICAgICAgICB0aGlzLmZpbHRlclN0YWNrID0gdGhpcy5maWx0ZXJTdGFja0ZhY3RvcnkuY3JlYXRlRmlsdGVyKCk7XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2suc2VuZE1ldGFkYXRhKFByb21pc2UucmVzb2x2ZSh0aGlzLm1ldGFkYXRhKSkudGhlbihmaWx0ZXJlZE1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGQgPSB0aGlzLmNoYW5uZWwuY3JlYXRlUmV0cnlpbmdDYWxsKGNvbmZpZywgdGhpcy5tZXRob2QsIHRoaXMuaG9zdCwgdGhpcy5jcmVkZW50aWFscywgdGhpcy5kZWFkbGluZSk7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdDcmVhdGVkIGNoaWxkIFsnICsgdGhpcy5jaGlsZC5nZXRDYWxsTnVtYmVyKCkgKyAnXScpO1xuICAgICAgICAgICAgdGhpcy5jaGlsZFN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB0aGlzLmNoaWxkLnN0YXJ0KGZpbHRlcmVkTWV0YWRhdGEsIHtcbiAgICAgICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogbWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBtZXRhZGF0YScpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKHRoaXMuZmlsdGVyU3RhY2sucmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiBtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgbWVzc2FnZScpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRGaWx0ZXJQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJTdGFjay5yZWNlaXZlTWVzc2FnZShtZXNzYWdlKS50aGVuKGZpbHRlcmVkTWVzc3NhZ2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnRmluaXNoZWQgZmlsdGVyaW5nIHJlY2VpdmVkIG1lc3NhZ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEZpbHRlclBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZShmaWx0ZXJlZE1lc3NzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdDaGlsZFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHRoaXMucGVuZGluZ0NoaWxkU3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxXaXRoU3RhdHVzKHN0YXR1cy5jb2RlLCBzdGF0dXMuZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiBzdGF0dXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBzdGF0dXMnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZEZpbHRlclBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkU3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRQZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZC5zdGFydFJlYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZU9uQ2hpbGQodGhpcy5wZW5kaW5nTWVzc2FnZS5jb250ZXh0LCB0aGlzLnBlbmRpbmdNZXNzYWdlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZW5kaW5nSGFsZkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlcG9ydFJlc29sdmVyRXJyb3Ioc3RhdHVzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKChfYSA9IHRoaXMubWV0YWRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRPcHRpb25zKCkud2FpdEZvclJlYWR5KSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwucXVldWVDYWxsRm9yQ29uZmlnKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NhbmNlbFdpdGhTdGF0dXMgY29kZTogJyArIHN0YXR1cyArICcgZGV0YWlsczogXCInICsgZGV0YWlscyArICdcIicpO1xuICAgICAgICAoX2EgPSB0aGlzLmNoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpO1xuICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh7XG4gICAgICAgICAgICBjb2RlOiBzdGF0dXMsXG4gICAgICAgICAgICBkZXRhaWxzOiBkZXRhaWxzLFxuICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlZXIoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5jaGFubmVsLmdldFRhcmdldCgpO1xuICAgIH1cbiAgICBzdGFydChtZXRhZGF0YSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnc3RhcnQgY2FsbGVkJyk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YS5jbG9uZSgpO1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMuZ2V0Q29uZmlnKCk7XG4gICAgfVxuICAgIHNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLnRyYWNlKCd3cml0ZSgpIGNhbGxlZCB3aXRoIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgKyBtZXNzYWdlLmxlbmd0aCk7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlT25DaGlsZChjb250ZXh0LCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSB7IGNvbnRleHQsIG1lc3NhZ2UgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydFJlYWQoKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXJ0UmVhZCBjYWxsZWQnKTtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGQuc3RhcnRSZWFkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYWxmQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ2hhbGZDbG9zZSBjYWxsZWQnKTtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGQgJiYgIXRoaXMud3JpdGVGaWx0ZXJQZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkLmhhbGZDbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nSGFsZkNsb3NlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRDcmVkZW50aWFscyhjcmVkZW50aWFscykge1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gICAgfVxuICAgIGFkZFN0YXR1c1dhdGNoZXIod2F0Y2hlcikge1xuICAgICAgICB0aGlzLnN0YXR1c1dhdGNoZXJzLnB1c2god2F0Y2hlcik7XG4gICAgfVxuICAgIGdldENhbGxOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxOdW1iZXI7XG4gICAgfVxufVxuZXhwb3J0cy5SZXNvbHZpbmdDYWxsID0gUmVzb2x2aW5nQ2FsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmluZy1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlJlc29sdmluZ0NhbGwiLCJjYWxsX2NyZWRlbnRpYWxzXzEiLCJyZXF1aXJlIiwiY29uc3RhbnRzXzEiLCJkZWFkbGluZV8xIiwibWV0YWRhdGFfMSIsImxvZ2dpbmciLCJjb250cm9sX3BsYW5lX3N0YXR1c18xIiwiVFJBQ0VSX05BTUUiLCJjb25zdHJ1Y3RvciIsImNoYW5uZWwiLCJtZXRob2QiLCJvcHRpb25zIiwiZmlsdGVyU3RhY2tGYWN0b3J5IiwiY2FsbE51bWJlciIsImNoaWxkIiwicmVhZFBlbmRpbmciLCJwZW5kaW5nTWVzc2FnZSIsInBlbmRpbmdIYWxmQ2xvc2UiLCJlbmRlZCIsInJlYWRGaWx0ZXJQZW5kaW5nIiwid3JpdGVGaWx0ZXJQZW5kaW5nIiwicGVuZGluZ0NoaWxkU3RhdHVzIiwibWV0YWRhdGEiLCJsaXN0ZW5lciIsInN0YXR1c1dhdGNoZXJzIiwiZGVhZGxpbmVUaW1lciIsInNldFRpbWVvdXQiLCJmaWx0ZXJTdGFjayIsImRlYWRsaW5lU3RhcnRUaW1lIiwiY29uZmlnUmVjZWl2ZWRUaW1lIiwiY2hpbGRTdGFydFRpbWUiLCJjcmVkZW50aWFscyIsIkNhbGxDcmVkZW50aWFscyIsImNyZWF0ZUVtcHR5IiwiZGVhZGxpbmUiLCJob3N0IiwicGFyZW50Q2FsbCIsImZsYWdzIiwiUHJvcGFnYXRlIiwiQ0FOQ0VMTEFUSU9OIiwib24iLCJjYW5jZWxXaXRoU3RhdHVzIiwiU3RhdHVzIiwiQ0FOQ0VMTEVEIiwiREVBRExJTkUiLCJ0cmFjZSIsImdldERlYWRsaW5lIiwibWluRGVhZGxpbmUiLCJydW5EZWFkbGluZVRpbWVyIiwidGV4dCIsIkxvZ1ZlcmJvc2l0eSIsIkRFQlVHIiwiY2xlYXJUaW1lb3V0IiwiRGF0ZSIsImRlYWRsaW5lVG9TdHJpbmciLCJ0aW1lb3V0IiwiZ2V0UmVsYXRpdmVUaW1lb3V0IiwiSW5maW5pdHkiLCJoYW5kbGVEZWFkbGluZSIsIkRFQURMSU5FX0VYQ0VFREVEIiwiZGVhZGxpbmVJbmZvIiwiZGVhZGxpbmVFbmRUaW1lIiwicHVzaCIsImZvcm1hdERhdGVEaWZmZXJlbmNlIiwiZ2V0RGVhZGxpbmVJbmZvIiwiam9pbiIsInByb2Nlc3MiLCJuZXh0VGljayIsIm91dHB1dFN0YXR1cyIsInN0YXR1cyIsImNyZWF0ZUZpbHRlciIsImZpbHRlcmVkU3RhdHVzIiwicmVjZWl2ZVRyYWlsZXJzIiwiY29kZSIsImRldGFpbHMiLCJmb3JFYWNoIiwid2F0Y2hlciIsIl9hIiwib25SZWNlaXZlU3RhdHVzIiwic2VuZE1lc3NhZ2VPbkNoaWxkIiwiY29udGV4dCIsIm1lc3NhZ2UiLCJFcnJvciIsInNlbmRNZXNzYWdlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiZmlsdGVyZWRNZXNzYWdlIiwic2VuZE1lc3NhZ2VXaXRoQ29udGV4dCIsImhhbGZDbG9zZSIsImdldENvbmZpZyIsImNvbmZpZ1Jlc3VsdCIsInR5cGUiLCJxdWV1ZUNhbGxGb3JDb25maWciLCJnZXRPcHRpb25zIiwid2FpdEZvclJlYWR5IiwiZXJyb3IiLCJjb25maWciLCJPSyIsInJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZSIsIk1ldGFkYXRhIiwibWV0aG9kQ29uZmlnIiwiY29uZmlnRGVhZGxpbmUiLCJzZXRTZWNvbmRzIiwiZ2V0U2Vjb25kcyIsInNlY29uZHMiLCJzZXRNaWxsaXNlY29uZHMiLCJnZXRNaWxsaXNlY29uZHMiLCJuYW5vcyIsImR5bmFtaWNGaWx0ZXJGYWN0b3JpZXMiLCJzZW5kTWV0YWRhdGEiLCJmaWx0ZXJlZE1ldGFkYXRhIiwiY3JlYXRlUmV0cnlpbmdDYWxsIiwiZ2V0Q2FsbE51bWJlciIsInN0YXJ0Iiwib25SZWNlaXZlTWV0YWRhdGEiLCJyZWNlaXZlTWV0YWRhdGEiLCJvblJlY2VpdmVNZXNzYWdlIiwicmVjZWl2ZU1lc3NhZ2UiLCJmaWx0ZXJlZE1lc3NzYWdlIiwic3RhcnRSZWFkIiwicmVwb3J0UmVzb2x2ZXJFcnJvciIsImdldFBlZXIiLCJfYiIsImdldFRhcmdldCIsImNsb25lIiwibGVuZ3RoIiwic2V0Q3JlZGVudGlhbHMiLCJhZGRTdGF0dXNXYXRjaGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ResolvingLoadBalancer = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nconst TRACER_NAME = \"resolving_load_balancer\";\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * Name match levels in order from most to least specific. This is the order in\n * which searches will be performed.\n */ const NAME_MATCH_LEVEL_ORDER = [\n    \"SERVICE_AND_METHOD\",\n    \"SERVICE\",\n    \"EMPTY\"\n];\nfunction hasMatchingName(service, method, methodConfig, matchLevel) {\n    for (const name of methodConfig.name){\n        switch(matchLevel){\n            case \"EMPTY\":\n                if (!name.service && !name.method) {\n                    return true;\n                }\n                break;\n            case \"SERVICE\":\n                if (name.service === service && !name.method) {\n                    return true;\n                }\n                break;\n            case \"SERVICE_AND_METHOD\":\n                if (name.service === service && name.method === method) {\n                    return true;\n                }\n        }\n    }\n    return false;\n}\nfunction findMatchingConfig(service, method, methodConfigs, matchLevel) {\n    for (const config of methodConfigs){\n        if (hasMatchingName(service, method, config, matchLevel)) {\n            return config;\n        }\n    }\n    return null;\n}\nfunction getDefaultConfigSelector(serviceConfig) {\n    return {\n        invoke (methodName, metadata) {\n            var _a, _b;\n            const splitName = methodName.split(\"/\").filter((x)=>x.length > 0);\n            const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : \"\";\n            const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : \"\";\n            if (serviceConfig && serviceConfig.methodConfig) {\n                /* Check for the following in order, and return the first method\n                * config that matches:\n                * 1. A name that exactly matches the service and method\n                * 2. A name with no method set that matches the service\n                * 3. An empty name\n                */ for (const matchLevel of NAME_MATCH_LEVEL_ORDER){\n                    const matchingConfig = findMatchingConfig(service, method, serviceConfig.methodConfig, matchLevel);\n                    if (matchingConfig) {\n                        return {\n                            methodConfig: matchingConfig,\n                            pickInformation: {},\n                            status: constants_1.Status.OK,\n                            dynamicFilterFactories: []\n                        };\n                    }\n                }\n            }\n            return {\n                methodConfig: {\n                    name: []\n                },\n                pickInformation: {},\n                status: constants_1.Status.OK,\n                dynamicFilterFactories: []\n            };\n        },\n        unref () {}\n    };\n}\nclass ResolvingLoadBalancer {\n    /**\n     * Wrapper class that behaves like a `LoadBalancer` and also handles name\n     * resolution internally.\n     * @param target The address of the backend to connect to.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     * @param defaultServiceConfig The default service configuration to be used\n     *     if none is provided by the name resolver. A `null` value indicates\n     *     that the default behavior should be the default unconfigured behavior.\n     *     In practice, that means using the \"pick first\" load balancer\n     *     implmentation\n     */ constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution){\n        this.target = target;\n        this.channelControlHelper = channelControlHelper;\n        this.channelOptions = channelOptions;\n        this.onSuccessfulResolution = onSuccessfulResolution;\n        this.onFailedResolution = onFailedResolution;\n        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\n        this.latestChildPicker = new picker_1.QueuePicker(this);\n        this.latestChildErrorMessage = null;\n        /**\n         * This resolving load balancer's current connectivity state.\n         */ this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The service config object from the last successful resolution, if\n         * available. A value of null indicates that we have not yet received a valid\n         * service config from the resolver.\n         */ this.previousServiceConfig = null;\n        /**\n         * Indicates whether we should attempt to resolve again after the backoff\n         * timer runs out.\n         */ this.continueResolving = false;\n        if (channelOptions[\"grpc.service_config\"]) {\n            this.defaultServiceConfig = (0, service_config_1.validateServiceConfig)(JSON.parse(channelOptions[\"grpc.service_config\"]));\n        } else {\n            this.defaultServiceConfig = {\n                loadBalancingConfig: [],\n                methodConfig: []\n            };\n        }\n        this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this), null);\n        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({\n            createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),\n            requestReresolution: ()=>{\n                /* If the backoffTimeout is running, we're still backing off from\n                 * making resolve requests, so we shouldn't make another one here.\n                 * In that case, the backoff timer callback will call\n                 * updateResolution */ if (this.backoffTimeout.isRunning()) {\n                    trace(\"requestReresolution delayed by backoff timer until \" + this.backoffTimeout.getEndTime().toISOString());\n                    this.continueResolving = true;\n                } else {\n                    this.updateResolution();\n                }\n            },\n            updateState: (newState, picker, errorMessage)=>{\n                this.latestChildState = newState;\n                this.latestChildPicker = picker;\n                this.latestChildErrorMessage = errorMessage;\n                this.updateState(newState, picker, errorMessage);\n            },\n            addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),\n            removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper)\n        });\n        this.innerResolver = (0, resolver_1.createResolver)(target, {\n            onSuccessfulResolution: (endpointList, serviceConfig, serviceConfigError, configSelector, attributes)=>{\n                var _a;\n                this.backoffTimeout.stop();\n                this.backoffTimeout.reset();\n                let workingServiceConfig = null;\n                /* This first group of conditionals implements the algorithm described\n                 * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\n                 * in the section called \"Behavior on receiving a new gRPC Config\".\n                 */ if (serviceConfig === null) {\n                    // Step 4 and 5\n                    if (serviceConfigError === null) {\n                        // Step 5\n                        this.previousServiceConfig = null;\n                        workingServiceConfig = this.defaultServiceConfig;\n                    } else {\n                        // Step 4\n                        if (this.previousServiceConfig === null) {\n                            // Step 4.ii\n                            this.handleResolutionFailure(serviceConfigError);\n                        } else {\n                            // Step 4.i\n                            workingServiceConfig = this.previousServiceConfig;\n                        }\n                    }\n                } else {\n                    // Step 3\n                    workingServiceConfig = serviceConfig;\n                    this.previousServiceConfig = serviceConfig;\n                }\n                const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];\n                const loadBalancingConfig = (0, load_balancer_1.selectLbConfigFromList)(workingConfigList, true);\n                if (loadBalancingConfig === null) {\n                    // There were load balancing configs but none are supported. This counts as a resolution failure\n                    this.handleResolutionFailure({\n                        code: constants_1.Status.UNAVAILABLE,\n                        details: \"All load balancer options in service config are not compatible\",\n                        metadata: new metadata_1.Metadata()\n                    });\n                    configSelector === null || configSelector === void 0 ? void 0 : configSelector.unref();\n                    return;\n                }\n                this.childLoadBalancer.updateAddressList(endpointList, loadBalancingConfig, Object.assign(Object.assign({}, this.channelOptions), attributes));\n                const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;\n                this.onSuccessfulResolution(finalServiceConfig, configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));\n            },\n            onError: (error)=>{\n                this.handleResolutionFailure(error);\n            }\n        }, channelOptions);\n        const backoffOptions = {\n            initialDelay: channelOptions[\"grpc.initial_reconnect_backoff_ms\"],\n            maxDelay: channelOptions[\"grpc.max_reconnect_backoff_ms\"]\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(()=>{\n            if (this.continueResolving) {\n                this.updateResolution();\n                this.continueResolving = false;\n            } else {\n                this.updateState(this.latestChildState, this.latestChildPicker, this.latestChildErrorMessage);\n            }\n        }, backoffOptions);\n        this.backoffTimeout.unref();\n    }\n    updateResolution() {\n        this.innerResolver.updateResolution();\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n            /* this.latestChildPicker is initialized as new QueuePicker(this), which\n             * is an appropriate value here if the child LB policy is unset.\n             * Otherwise, we want to delegate to the child here, in case that\n             * triggers something. */ this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, this.latestChildPicker, this.latestChildErrorMessage);\n        }\n        this.backoffTimeout.runOnce();\n    }\n    updateState(connectivityState, picker, errorMessage) {\n        trace((0, uri_parser_1.uriToString)(this.target) + \" \" + connectivity_state_1.ConnectivityState[this.currentState] + \" -> \" + connectivity_state_1.ConnectivityState[connectivityState]);\n        // Ensure that this.exitIdle() is called by the picker\n        if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {\n            picker = new picker_1.QueuePicker(this, picker);\n        }\n        this.currentState = connectivityState;\n        this.channelControlHelper.updateState(connectivityState, picker, errorMessage);\n    }\n    handleResolutionFailure(error) {\n        if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error), error.details);\n            this.onFailedResolution(error);\n        }\n    }\n    exitIdle() {\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE || this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n            if (this.backoffTimeout.isRunning()) {\n                this.continueResolving = true;\n            } else {\n                this.updateResolution();\n            }\n        }\n        this.childLoadBalancer.exitIdle();\n    }\n    updateAddressList(endpointList, lbConfig) {\n        throw new Error(\"updateAddressList not supported on ResolvingLoadBalancer\");\n    }\n    resetBackoff() {\n        this.backoffTimeout.reset();\n        this.childLoadBalancer.resetBackoff();\n    }\n    destroy() {\n        this.childLoadBalancer.destroy();\n        this.innerResolver.destroy();\n        this.backoffTimeout.reset();\n        this.backoffTimeout.stop();\n        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\n        this.latestChildPicker = new picker_1.QueuePicker(this);\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        this.previousServiceConfig = null;\n        this.continueResolving = false;\n    }\n    getTypeName() {\n        return \"resolving_load_balancer\";\n    }\n}\nexports.ResolvingLoadBalancer = ResolvingLoadBalancer; //# sourceMappingURL=resolving-load-balancer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWxvYWQtYmFsYW5jZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHLEtBQUs7QUFDckMsTUFBTUcsa0JBQWtCQyxtQkFBT0EsQ0FBQyxzRkFBaUI7QUFDakQsTUFBTUMsbUJBQW1CRCxtQkFBT0EsQ0FBQyx3RkFBa0I7QUFDbkQsTUFBTUUsdUJBQXVCRixtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTUcsYUFBYUgsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUksV0FBV0osbUJBQU9BLENBQUMsd0VBQVU7QUFDbkMsTUFBTUssb0JBQW9CTCxtQkFBT0EsQ0FBQywwRkFBbUI7QUFDckQsTUFBTU0sY0FBY04sbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTU8sYUFBYVAsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTVEsVUFBVVIsbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTVMsY0FBY1QsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTVUsZUFBZVYsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTVcsZ0NBQWdDWCxtQkFBT0EsQ0FBQyxrSEFBK0I7QUFDN0UsTUFBTVksY0FBYztBQUNwQixTQUFTQyxNQUFNQyxJQUFJO0lBQ2ZOLFFBQVFLLEtBQUssQ0FBQ0osWUFBWU0sWUFBWSxDQUFDQyxLQUFLLEVBQUVKLGFBQWFFO0FBQy9EO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTUcseUJBQXlCO0lBQzNCO0lBQ0E7SUFDQTtDQUNIO0FBQ0QsU0FBU0MsZ0JBQWdCQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsWUFBWSxFQUFFQyxVQUFVO0lBQzlELEtBQUssTUFBTUMsUUFBUUYsYUFBYUUsSUFBSSxDQUFFO1FBQ2xDLE9BQVFEO1lBQ0osS0FBSztnQkFDRCxJQUFJLENBQUNDLEtBQUtKLE9BQU8sSUFBSSxDQUFDSSxLQUFLSCxNQUFNLEVBQUU7b0JBQy9CLE9BQU87Z0JBQ1g7Z0JBQ0E7WUFDSixLQUFLO2dCQUNELElBQUlHLEtBQUtKLE9BQU8sS0FBS0EsV0FBVyxDQUFDSSxLQUFLSCxNQUFNLEVBQUU7b0JBQzFDLE9BQU87Z0JBQ1g7Z0JBQ0E7WUFDSixLQUFLO2dCQUNELElBQUlHLEtBQUtKLE9BQU8sS0FBS0EsV0FBV0ksS0FBS0gsTUFBTSxLQUFLQSxRQUFRO29CQUNwRCxPQUFPO2dCQUNYO1FBQ1I7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUNBLFNBQVNJLG1CQUFtQkwsT0FBTyxFQUFFQyxNQUFNLEVBQUVLLGFBQWEsRUFBRUgsVUFBVTtJQUNsRSxLQUFLLE1BQU1JLFVBQVVELGNBQWU7UUFDaEMsSUFBSVAsZ0JBQWdCQyxTQUFTQyxRQUFRTSxRQUFRSixhQUFhO1lBQ3RELE9BQU9JO1FBQ1g7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUNBLFNBQVNDLHlCQUF5QkMsYUFBYTtJQUMzQyxPQUFPO1FBQ0hDLFFBQU9DLFVBQVUsRUFBRUMsUUFBUTtZQUN2QixJQUFJQyxJQUFJQztZQUNSLE1BQU1DLFlBQVlKLFdBQVdLLEtBQUssQ0FBQyxLQUFLQyxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU0sR0FBRztZQUMvRCxNQUFNbkIsVUFBVSxDQUFDYSxLQUFLRSxTQUFTLENBQUMsRUFBRSxNQUFNLFFBQVFGLE9BQU8sS0FBSyxJQUFJQSxLQUFLO1lBQ3JFLE1BQU1aLFNBQVMsQ0FBQ2EsS0FBS0MsU0FBUyxDQUFDLEVBQUUsTUFBTSxRQUFRRCxPQUFPLEtBQUssSUFBSUEsS0FBSztZQUNwRSxJQUFJTCxpQkFBaUJBLGNBQWNQLFlBQVksRUFBRTtnQkFDN0M7Ozs7O2dCQUtBLEdBQ0EsS0FBSyxNQUFNQyxjQUFjTCx1QkFBd0I7b0JBQzdDLE1BQU1zQixpQkFBaUJmLG1CQUFtQkwsU0FBU0MsUUFBUVEsY0FBY1AsWUFBWSxFQUFFQztvQkFDdkYsSUFBSWlCLGdCQUFnQjt3QkFDaEIsT0FBTzs0QkFDSGxCLGNBQWNrQjs0QkFDZEMsaUJBQWlCLENBQUM7NEJBQ2xCQyxRQUFRbkMsWUFBWW9DLE1BQU0sQ0FBQ0MsRUFBRTs0QkFDN0JDLHdCQUF3QixFQUFFO3dCQUM5QjtvQkFDSjtnQkFDSjtZQUNKO1lBQ0EsT0FBTztnQkFDSHZCLGNBQWM7b0JBQUVFLE1BQU0sRUFBRTtnQkFBQztnQkFDekJpQixpQkFBaUIsQ0FBQztnQkFDbEJDLFFBQVFuQyxZQUFZb0MsTUFBTSxDQUFDQyxFQUFFO2dCQUM3QkMsd0JBQXdCLEVBQUU7WUFDOUI7UUFDSjtRQUNBQyxVQUFVO0lBQ2Q7QUFDSjtBQUNBLE1BQU0vQztJQUNGOzs7Ozs7Ozs7OztLQVdDLEdBQ0RnRCxZQUFZQyxNQUFNLEVBQUVDLG9CQUFvQixFQUFFQyxjQUFjLEVBQUVDLHNCQUFzQixFQUFFQyxrQkFBa0IsQ0FBRTtRQUNsRyxJQUFJLENBQUNKLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLG9CQUFvQixHQUFHQTtRQUM1QixJQUFJLENBQUNDLGNBQWMsR0FBR0E7UUFDdEIsSUFBSSxDQUFDQyxzQkFBc0IsR0FBR0E7UUFDOUIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBR0E7UUFDMUIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBR2xELHFCQUFxQm1ELGlCQUFpQixDQUFDQyxJQUFJO1FBQ25FLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUcsSUFBSW5ELFNBQVNvRCxXQUFXLENBQUMsSUFBSTtRQUN0RCxJQUFJLENBQUNDLHVCQUF1QixHQUFHO1FBQy9COztTQUVDLEdBQ0QsSUFBSSxDQUFDQyxZQUFZLEdBQUd4RCxxQkFBcUJtRCxpQkFBaUIsQ0FBQ0MsSUFBSTtRQUMvRDs7OztTQUlDLEdBQ0QsSUFBSSxDQUFDSyxxQkFBcUIsR0FBRztRQUM3Qjs7O1NBR0MsR0FDRCxJQUFJLENBQUNDLGlCQUFpQixHQUFHO1FBQ3pCLElBQUlYLGNBQWMsQ0FBQyxzQkFBc0IsRUFBRTtZQUN2QyxJQUFJLENBQUNZLG9CQUFvQixHQUFHLENBQUMsR0FBRzVELGlCQUFpQjZELHFCQUFxQixFQUFFQyxLQUFLQyxLQUFLLENBQUNmLGNBQWMsQ0FBQyxzQkFBc0I7UUFDNUgsT0FDSztZQUNELElBQUksQ0FBQ1ksb0JBQW9CLEdBQUc7Z0JBQ3hCSSxxQkFBcUIsRUFBRTtnQkFDdkI1QyxjQUFjLEVBQUU7WUFDcEI7UUFDSjtRQUNBLElBQUksQ0FBQzZDLFdBQVcsQ0FBQ2hFLHFCQUFxQm1ELGlCQUFpQixDQUFDQyxJQUFJLEVBQUUsSUFBSWxELFNBQVNvRCxXQUFXLENBQUMsSUFBSSxHQUFHO1FBQzlGLElBQUksQ0FBQ1csaUJBQWlCLEdBQUcsSUFBSXhELDhCQUE4QnlELHdCQUF3QixDQUFDO1lBQ2hGQyxrQkFBa0JyQixxQkFBcUJxQixnQkFBZ0IsQ0FBQ0MsSUFBSSxDQUFDdEI7WUFDN0R1QixxQkFBcUI7Z0JBQ2pCOzs7b0NBR29CLEdBQ3BCLElBQUksSUFBSSxDQUFDQyxjQUFjLENBQUNDLFNBQVMsSUFBSTtvQkFDakM1RCxNQUFNLHdEQUNGLElBQUksQ0FBQzJELGNBQWMsQ0FBQ0UsVUFBVSxHQUFHQyxXQUFXO29CQUNoRCxJQUFJLENBQUNmLGlCQUFpQixHQUFHO2dCQUM3QixPQUNLO29CQUNELElBQUksQ0FBQ2dCLGdCQUFnQjtnQkFDekI7WUFDSjtZQUNBVixhQUFhLENBQUNXLFVBQVVDLFFBQVFDO2dCQUM1QixJQUFJLENBQUMzQixnQkFBZ0IsR0FBR3lCO2dCQUN4QixJQUFJLENBQUN0QixpQkFBaUIsR0FBR3VCO2dCQUN6QixJQUFJLENBQUNyQix1QkFBdUIsR0FBR3NCO2dCQUMvQixJQUFJLENBQUNiLFdBQVcsQ0FBQ1csVUFBVUMsUUFBUUM7WUFDdkM7WUFDQUMsa0JBQWtCaEMscUJBQXFCZ0MsZ0JBQWdCLENBQUNWLElBQUksQ0FBQ3RCO1lBQzdEaUMscUJBQXFCakMscUJBQXFCaUMsbUJBQW1CLENBQUNYLElBQUksQ0FBQ3RCO1FBQ3ZFO1FBQ0EsSUFBSSxDQUFDa0MsYUFBYSxHQUFHLENBQUMsR0FBRy9FLFdBQVdnRixjQUFjLEVBQUVwQyxRQUFRO1lBQ3hERyx3QkFBd0IsQ0FBQ2tDLGNBQWN4RCxlQUFleUQsb0JBQW9CQyxnQkFBZ0JDO2dCQUN0RixJQUFJdkQ7Z0JBQ0osSUFBSSxDQUFDd0MsY0FBYyxDQUFDZ0IsSUFBSTtnQkFDeEIsSUFBSSxDQUFDaEIsY0FBYyxDQUFDaUIsS0FBSztnQkFDekIsSUFBSUMsdUJBQXVCO2dCQUMzQjs7O2lCQUdDLEdBQ0QsSUFBSTlELGtCQUFrQixNQUFNO29CQUN4QixlQUFlO29CQUNmLElBQUl5RCx1QkFBdUIsTUFBTTt3QkFDN0IsU0FBUzt3QkFDVCxJQUFJLENBQUMxQixxQkFBcUIsR0FBRzt3QkFDN0IrQix1QkFBdUIsSUFBSSxDQUFDN0Isb0JBQW9CO29CQUNwRCxPQUNLO3dCQUNELFNBQVM7d0JBQ1QsSUFBSSxJQUFJLENBQUNGLHFCQUFxQixLQUFLLE1BQU07NEJBQ3JDLFlBQVk7NEJBQ1osSUFBSSxDQUFDZ0MsdUJBQXVCLENBQUNOO3dCQUNqQyxPQUNLOzRCQUNELFdBQVc7NEJBQ1hLLHVCQUF1QixJQUFJLENBQUMvQixxQkFBcUI7d0JBQ3JEO29CQUNKO2dCQUNKLE9BQ0s7b0JBQ0QsU0FBUztvQkFDVCtCLHVCQUF1QjlEO29CQUN2QixJQUFJLENBQUMrQixxQkFBcUIsR0FBRy9CO2dCQUNqQztnQkFDQSxNQUFNZ0Usb0JBQW9CLENBQUM1RCxLQUFLMEQseUJBQXlCLFFBQVFBLHlCQUF5QixLQUFLLElBQUksS0FBSyxJQUFJQSxxQkFBcUJ6QixtQkFBbUIsTUFBTSxRQUFRakMsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRTtnQkFDekwsTUFBTWlDLHNCQUFzQixDQUFDLEdBQUdsRSxnQkFBZ0I4RixzQkFBc0IsRUFBRUQsbUJBQW1CO2dCQUMzRixJQUFJM0Isd0JBQXdCLE1BQU07b0JBQzlCLGdHQUFnRztvQkFDaEcsSUFBSSxDQUFDMEIsdUJBQXVCLENBQUM7d0JBQ3pCRyxNQUFNeEYsWUFBWW9DLE1BQU0sQ0FBQ3FELFdBQVc7d0JBQ3BDQyxTQUFTO3dCQUNUakUsVUFBVSxJQUFJeEIsV0FBVzBGLFFBQVE7b0JBQ3JDO29CQUNBWCxtQkFBbUIsUUFBUUEsbUJBQW1CLEtBQUssSUFBSSxLQUFLLElBQUlBLGVBQWV6QyxLQUFLO29CQUNwRjtnQkFDSjtnQkFDQSxJQUFJLENBQUNzQixpQkFBaUIsQ0FBQytCLGlCQUFpQixDQUFDZCxjQUFjbkIscUJBQXFCdkUsT0FBT3lHLE1BQU0sQ0FBQ3pHLE9BQU95RyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQ2xELGNBQWMsR0FBR3NDO2dCQUNsSSxNQUFNYSxxQkFBcUJWLHlCQUF5QixRQUFRQSx5QkFBeUIsS0FBSyxJQUFJQSx1QkFBdUIsSUFBSSxDQUFDN0Isb0JBQW9CO2dCQUM5SSxJQUFJLENBQUNYLHNCQUFzQixDQUFDa0Qsb0JBQW9CZCxtQkFBbUIsUUFBUUEsbUJBQW1CLEtBQUssSUFBSUEsaUJBQWlCM0QseUJBQXlCeUU7WUFDcko7WUFDQUMsU0FBUyxDQUFDQztnQkFDTixJQUFJLENBQUNYLHVCQUF1QixDQUFDVztZQUNqQztRQUNKLEdBQUdyRDtRQUNILE1BQU1zRCxpQkFBaUI7WUFDbkJDLGNBQWN2RCxjQUFjLENBQUMsb0NBQW9DO1lBQ2pFd0QsVUFBVXhELGNBQWMsQ0FBQyxnQ0FBZ0M7UUFDN0Q7UUFDQSxJQUFJLENBQUN1QixjQUFjLEdBQUcsSUFBSW5FLGtCQUFrQnFHLGNBQWMsQ0FBQztZQUN2RCxJQUFJLElBQUksQ0FBQzlDLGlCQUFpQixFQUFFO2dCQUN4QixJQUFJLENBQUNnQixnQkFBZ0I7Z0JBQ3JCLElBQUksQ0FBQ2hCLGlCQUFpQixHQUFHO1lBQzdCLE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDTSxXQUFXLENBQUMsSUFBSSxDQUFDZCxnQkFBZ0IsRUFBRSxJQUFJLENBQUNHLGlCQUFpQixFQUFFLElBQUksQ0FBQ0UsdUJBQXVCO1lBQ2hHO1FBQ0osR0FBRzhDO1FBQ0gsSUFBSSxDQUFDL0IsY0FBYyxDQUFDM0IsS0FBSztJQUM3QjtJQUNBK0IsbUJBQW1CO1FBQ2YsSUFBSSxDQUFDTSxhQUFhLENBQUNOLGdCQUFnQjtRQUNuQyxJQUFJLElBQUksQ0FBQ2xCLFlBQVksS0FBS3hELHFCQUFxQm1ELGlCQUFpQixDQUFDQyxJQUFJLEVBQUU7WUFDbkU7OzttQ0FHdUIsR0FDdkIsSUFBSSxDQUFDWSxXQUFXLENBQUNoRSxxQkFBcUJtRCxpQkFBaUIsQ0FBQ3NELFVBQVUsRUFBRSxJQUFJLENBQUNwRCxpQkFBaUIsRUFBRSxJQUFJLENBQUNFLHVCQUF1QjtRQUM1SDtRQUNBLElBQUksQ0FBQ2UsY0FBYyxDQUFDb0MsT0FBTztJQUMvQjtJQUNBMUMsWUFBWTJDLGlCQUFpQixFQUFFL0IsTUFBTSxFQUFFQyxZQUFZLEVBQUU7UUFDakRsRSxNQUFNLENBQUMsR0FBR0gsYUFBYW9HLFdBQVcsRUFBRSxJQUFJLENBQUMvRCxNQUFNLElBQzNDLE1BQ0E3QyxxQkFBcUJtRCxpQkFBaUIsQ0FBQyxJQUFJLENBQUNLLFlBQVksQ0FBQyxHQUN6RCxTQUNBeEQscUJBQXFCbUQsaUJBQWlCLENBQUN3RCxrQkFBa0I7UUFDN0Qsc0RBQXNEO1FBQ3RELElBQUlBLHNCQUFzQjNHLHFCQUFxQm1ELGlCQUFpQixDQUFDQyxJQUFJLEVBQUU7WUFDbkV3QixTQUFTLElBQUkxRSxTQUFTb0QsV0FBVyxDQUFDLElBQUksRUFBRXNCO1FBQzVDO1FBQ0EsSUFBSSxDQUFDcEIsWUFBWSxHQUFHbUQ7UUFDcEIsSUFBSSxDQUFDN0Qsb0JBQW9CLENBQUNrQixXQUFXLENBQUMyQyxtQkFBbUIvQixRQUFRQztJQUNyRTtJQUNBWSx3QkFBd0JXLEtBQUssRUFBRTtRQUMzQixJQUFJLElBQUksQ0FBQ2xELGdCQUFnQixLQUFLbEQscUJBQXFCbUQsaUJBQWlCLENBQUNDLElBQUksRUFBRTtZQUN2RSxJQUFJLENBQUNZLFdBQVcsQ0FBQ2hFLHFCQUFxQm1ELGlCQUFpQixDQUFDMEQsaUJBQWlCLEVBQUUsSUFBSTNHLFNBQVM0RyxpQkFBaUIsQ0FBQ1YsUUFBUUEsTUFBTU4sT0FBTztZQUMvSCxJQUFJLENBQUM3QyxrQkFBa0IsQ0FBQ21EO1FBQzVCO0lBQ0o7SUFDQVcsV0FBVztRQUNQLElBQUksSUFBSSxDQUFDdkQsWUFBWSxLQUFLeEQscUJBQXFCbUQsaUJBQWlCLENBQUNDLElBQUksSUFDakUsSUFBSSxDQUFDSSxZQUFZLEtBQUt4RCxxQkFBcUJtRCxpQkFBaUIsQ0FBQzBELGlCQUFpQixFQUFFO1lBQ2hGLElBQUksSUFBSSxDQUFDdkMsY0FBYyxDQUFDQyxTQUFTLElBQUk7Z0JBQ2pDLElBQUksQ0FBQ2IsaUJBQWlCLEdBQUc7WUFDN0IsT0FDSztnQkFDRCxJQUFJLENBQUNnQixnQkFBZ0I7WUFDekI7UUFDSjtRQUNBLElBQUksQ0FBQ1QsaUJBQWlCLENBQUM4QyxRQUFRO0lBQ25DO0lBQ0FmLGtCQUFrQmQsWUFBWSxFQUFFOEIsUUFBUSxFQUFFO1FBQ3RDLE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtJQUNBQyxlQUFlO1FBQ1gsSUFBSSxDQUFDNUMsY0FBYyxDQUFDaUIsS0FBSztRQUN6QixJQUFJLENBQUN0QixpQkFBaUIsQ0FBQ2lELFlBQVk7SUFDdkM7SUFDQUMsVUFBVTtRQUNOLElBQUksQ0FBQ2xELGlCQUFpQixDQUFDa0QsT0FBTztRQUM5QixJQUFJLENBQUNuQyxhQUFhLENBQUNtQyxPQUFPO1FBQzFCLElBQUksQ0FBQzdDLGNBQWMsQ0FBQ2lCLEtBQUs7UUFDekIsSUFBSSxDQUFDakIsY0FBYyxDQUFDZ0IsSUFBSTtRQUN4QixJQUFJLENBQUNwQyxnQkFBZ0IsR0FBR2xELHFCQUFxQm1ELGlCQUFpQixDQUFDQyxJQUFJO1FBQ25FLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUcsSUFBSW5ELFNBQVNvRCxXQUFXLENBQUMsSUFBSTtRQUN0RCxJQUFJLENBQUNFLFlBQVksR0FBR3hELHFCQUFxQm1ELGlCQUFpQixDQUFDQyxJQUFJO1FBQy9ELElBQUksQ0FBQ0sscUJBQXFCLEdBQUc7UUFDN0IsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztJQUM3QjtJQUNBMEQsY0FBYztRQUNWLE9BQU87SUFDWDtBQUNKO0FBQ0ExSCw2QkFBNkIsR0FBR0UsdUJBQ2hDLG1EQUFtRCIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1ob3VzaW5nLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZpbmctbG9hZC1iYWxhbmNlci5qcz80OTdjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlc29sdmluZ0xvYWRCYWxhbmNlciA9IHZvaWQgMDtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG5jb25zdCBzZXJ2aWNlX2NvbmZpZ18xID0gcmVxdWlyZShcIi4vc2VydmljZS1jb25maWdcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IHBpY2tlcl8xID0gcmVxdWlyZShcIi4vcGlja2VyXCIpO1xuY29uc3QgYmFja29mZl90aW1lb3V0XzEgPSByZXF1aXJlKFwiLi9iYWNrb2ZmLXRpbWVvdXRcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzIgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgbG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLWNoaWxkLWhhbmRsZXJcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdyZXNvbHZpbmdfbG9hZF9iYWxhbmNlcic7XG5mdW5jdGlvbiB0cmFjZSh0ZXh0KSB7XG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMi5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcbn1cbi8qKlxuICogTmFtZSBtYXRjaCBsZXZlbHMgaW4gb3JkZXIgZnJvbSBtb3N0IHRvIGxlYXN0IHNwZWNpZmljLiBUaGlzIGlzIHRoZSBvcmRlciBpblxuICogd2hpY2ggc2VhcmNoZXMgd2lsbCBiZSBwZXJmb3JtZWQuXG4gKi9cbmNvbnN0IE5BTUVfTUFUQ0hfTEVWRUxfT1JERVIgPSBbXG4gICAgJ1NFUlZJQ0VfQU5EX01FVEhPRCcsXG4gICAgJ1NFUlZJQ0UnLFxuICAgICdFTVBUWScsXG5dO1xuZnVuY3Rpb24gaGFzTWF0Y2hpbmdOYW1lKHNlcnZpY2UsIG1ldGhvZCwgbWV0aG9kQ29uZmlnLCBtYXRjaExldmVsKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIG1ldGhvZENvbmZpZy5uYW1lKSB7XG4gICAgICAgIHN3aXRjaCAobWF0Y2hMZXZlbCkge1xuICAgICAgICAgICAgY2FzZSAnRU1QVFknOlxuICAgICAgICAgICAgICAgIGlmICghbmFtZS5zZXJ2aWNlICYmICFuYW1lLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdTRVJWSUNFJzpcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zZXJ2aWNlID09PSBzZXJ2aWNlICYmICFuYW1lLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdTRVJWSUNFX0FORF9NRVRIT0QnOlxuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNlcnZpY2UgPT09IHNlcnZpY2UgJiYgbmFtZS5tZXRob2QgPT09IG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZmluZE1hdGNoaW5nQ29uZmlnKHNlcnZpY2UsIG1ldGhvZCwgbWV0aG9kQ29uZmlncywgbWF0Y2hMZXZlbCkge1xuICAgIGZvciAoY29uc3QgY29uZmlnIG9mIG1ldGhvZENvbmZpZ3MpIHtcbiAgICAgICAgaWYgKGhhc01hdGNoaW5nTmFtZShzZXJ2aWNlLCBtZXRob2QsIGNvbmZpZywgbWF0Y2hMZXZlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0Q29uZmlnU2VsZWN0b3Ioc2VydmljZUNvbmZpZykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGludm9rZShtZXRob2ROYW1lLCBtZXRhZGF0YSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IHNwbGl0TmFtZSA9IG1ldGhvZE5hbWUuc3BsaXQoJy8nKS5maWx0ZXIoeCA9PiB4Lmxlbmd0aCA+IDApO1xuICAgICAgICAgICAgY29uc3Qgc2VydmljZSA9IChfYSA9IHNwbGl0TmFtZVswXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICAgICAgICBjb25zdCBtZXRob2QgPSAoX2IgPSBzcGxpdE5hbWVbMV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuICAgICAgICAgICAgaWYgKHNlcnZpY2VDb25maWcgJiYgc2VydmljZUNvbmZpZy5tZXRob2RDb25maWcpIHtcbiAgICAgICAgICAgICAgICAvKiBDaGVjayBmb3IgdGhlIGZvbGxvd2luZyBpbiBvcmRlciwgYW5kIHJldHVybiB0aGUgZmlyc3QgbWV0aG9kXG4gICAgICAgICAgICAgICAgKiBjb25maWcgdGhhdCBtYXRjaGVzOlxuICAgICAgICAgICAgICAgICogMS4gQSBuYW1lIHRoYXQgZXhhY3RseSBtYXRjaGVzIHRoZSBzZXJ2aWNlIGFuZCBtZXRob2RcbiAgICAgICAgICAgICAgICAqIDIuIEEgbmFtZSB3aXRoIG5vIG1ldGhvZCBzZXQgdGhhdCBtYXRjaGVzIHRoZSBzZXJ2aWNlXG4gICAgICAgICAgICAgICAgKiAzLiBBbiBlbXB0eSBuYW1lXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1hdGNoTGV2ZWwgb2YgTkFNRV9NQVRDSF9MRVZFTF9PUkRFUikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGluZ0NvbmZpZyA9IGZpbmRNYXRjaGluZ0NvbmZpZyhzZXJ2aWNlLCBtZXRob2QsIHNlcnZpY2VDb25maWcubWV0aG9kQ29uZmlnLCBtYXRjaExldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZENvbmZpZzogbWF0Y2hpbmdDb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGlja0luZm9ybWF0aW9uOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGNvbnN0YW50c18xLlN0YXR1cy5PSyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeW5hbWljRmlsdGVyRmFjdG9yaWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1ldGhvZENvbmZpZzogeyBuYW1lOiBbXSB9LFxuICAgICAgICAgICAgICAgIHBpY2tJbmZvcm1hdGlvbjoge30sXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBjb25zdGFudHNfMS5TdGF0dXMuT0ssXG4gICAgICAgICAgICAgICAgZHluYW1pY0ZpbHRlckZhY3RvcmllczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICB1bnJlZigpIHsgfVxuICAgIH07XG59XG5jbGFzcyBSZXNvbHZpbmdMb2FkQmFsYW5jZXIge1xuICAgIC8qKlxuICAgICAqIFdyYXBwZXIgY2xhc3MgdGhhdCBiZWhhdmVzIGxpa2UgYSBgTG9hZEJhbGFuY2VyYCBhbmQgYWxzbyBoYW5kbGVzIG5hbWVcbiAgICAgKiByZXNvbHV0aW9uIGludGVybmFsbHkuXG4gICAgICogQHBhcmFtIHRhcmdldCBUaGUgYWRkcmVzcyBvZiB0aGUgYmFja2VuZCB0byBjb25uZWN0IHRvLlxuICAgICAqIEBwYXJhbSBjaGFubmVsQ29udHJvbEhlbHBlciBgQ2hhbm5lbENvbnRyb2xIZWxwZXJgIGluc3RhbmNlIHByb3ZpZGVkIGJ5XG4gICAgICogICAgIHRoaXMgbG9hZCBiYWxhbmNlcidzIG93bmVyLlxuICAgICAqIEBwYXJhbSBkZWZhdWx0U2VydmljZUNvbmZpZyBUaGUgZGVmYXVsdCBzZXJ2aWNlIGNvbmZpZ3VyYXRpb24gdG8gYmUgdXNlZFxuICAgICAqICAgICBpZiBub25lIGlzIHByb3ZpZGVkIGJ5IHRoZSBuYW1lIHJlc29sdmVyLiBBIGBudWxsYCB2YWx1ZSBpbmRpY2F0ZXNcbiAgICAgKiAgICAgdGhhdCB0aGUgZGVmYXVsdCBiZWhhdmlvciBzaG91bGQgYmUgdGhlIGRlZmF1bHQgdW5jb25maWd1cmVkIGJlaGF2aW9yLlxuICAgICAqICAgICBJbiBwcmFjdGljZSwgdGhhdCBtZWFucyB1c2luZyB0aGUgXCJwaWNrIGZpcnN0XCIgbG9hZCBiYWxhbmNlclxuICAgICAqICAgICBpbXBsbWVudGF0aW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBjaGFubmVsQ29udHJvbEhlbHBlciwgY2hhbm5lbE9wdGlvbnMsIG9uU3VjY2Vzc2Z1bFJlc29sdXRpb24sIG9uRmFpbGVkUmVzb2x1dGlvbikge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlciA9IGNoYW5uZWxDb250cm9sSGVscGVyO1xuICAgICAgICB0aGlzLmNoYW5uZWxPcHRpb25zID0gY2hhbm5lbE9wdGlvbnM7XG4gICAgICAgIHRoaXMub25TdWNjZXNzZnVsUmVzb2x1dGlvbiA9IG9uU3VjY2Vzc2Z1bFJlc29sdXRpb247XG4gICAgICAgIHRoaXMub25GYWlsZWRSZXNvbHV0aW9uID0gb25GYWlsZWRSZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLmxhdGVzdENoaWxkU3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICB0aGlzLmxhdGVzdENoaWxkUGlja2VyID0gbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpO1xuICAgICAgICB0aGlzLmxhdGVzdENoaWxkRXJyb3JNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgcmVzb2x2aW5nIGxvYWQgYmFsYW5jZXIncyBjdXJyZW50IGNvbm5lY3Rpdml0eSBzdGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzZXJ2aWNlIGNvbmZpZyBvYmplY3QgZnJvbSB0aGUgbGFzdCBzdWNjZXNzZnVsIHJlc29sdXRpb24sIGlmXG4gICAgICAgICAqIGF2YWlsYWJsZS4gQSB2YWx1ZSBvZiBudWxsIGluZGljYXRlcyB0aGF0IHdlIGhhdmUgbm90IHlldCByZWNlaXZlZCBhIHZhbGlkXG4gICAgICAgICAqIHNlcnZpY2UgY29uZmlnIGZyb20gdGhlIHJlc29sdmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWcgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgd2Ugc2hvdWxkIGF0dGVtcHQgdG8gcmVzb2x2ZSBhZ2FpbiBhZnRlciB0aGUgYmFja29mZlxuICAgICAgICAgKiB0aW1lciBydW5zIG91dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKGNoYW5uZWxPcHRpb25zWydncnBjLnNlcnZpY2VfY29uZmlnJ10pIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFNlcnZpY2VDb25maWcgPSAoMCwgc2VydmljZV9jb25maWdfMS52YWxpZGF0ZVNlcnZpY2VDb25maWcpKEpTT04ucGFyc2UoY2hhbm5lbE9wdGlvbnNbJ2dycGMuc2VydmljZV9jb25maWcnXSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0U2VydmljZUNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBsb2FkQmFsYW5jaW5nQ29uZmlnOiBbXSxcbiAgICAgICAgICAgICAgICBtZXRob2RDb25maWc6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSwgbnVsbCk7XG4gICAgICAgIHRoaXMuY2hpbGRMb2FkQmFsYW5jZXIgPSBuZXcgbG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyKHtcbiAgICAgICAgICAgIGNyZWF0ZVN1YmNoYW5uZWw6IGNoYW5uZWxDb250cm9sSGVscGVyLmNyZWF0ZVN1YmNoYW5uZWwuYmluZChjaGFubmVsQ29udHJvbEhlbHBlciksXG4gICAgICAgICAgICByZXF1ZXN0UmVyZXNvbHV0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLyogSWYgdGhlIGJhY2tvZmZUaW1lb3V0IGlzIHJ1bm5pbmcsIHdlJ3JlIHN0aWxsIGJhY2tpbmcgb2ZmIGZyb21cbiAgICAgICAgICAgICAgICAgKiBtYWtpbmcgcmVzb2x2ZSByZXF1ZXN0cywgc28gd2Ugc2hvdWxkbid0IG1ha2UgYW5vdGhlciBvbmUgaGVyZS5cbiAgICAgICAgICAgICAgICAgKiBJbiB0aGF0IGNhc2UsIHRoZSBiYWNrb2ZmIHRpbWVyIGNhbGxiYWNrIHdpbGwgY2FsbFxuICAgICAgICAgICAgICAgICAqIHVwZGF0ZVJlc29sdXRpb24gKi9cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iYWNrb2ZmVGltZW91dC5pc1J1bm5pbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgncmVxdWVzdFJlcmVzb2x1dGlvbiBkZWxheWVkIGJ5IGJhY2tvZmYgdGltZXIgdW50aWwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LmdldEVuZFRpbWUoKS50b0lTT1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc29sdXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlU3RhdGU6IChuZXdTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdENoaWxkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdENoaWxkUGlja2VyID0gcGlja2VyO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRFcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZENoYW5uZWx6Q2hpbGQ6IGNoYW5uZWxDb250cm9sSGVscGVyLmFkZENoYW5uZWx6Q2hpbGQuYmluZChjaGFubmVsQ29udHJvbEhlbHBlciksXG4gICAgICAgICAgICByZW1vdmVDaGFubmVsekNoaWxkOiBjaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkLmJpbmQoY2hhbm5lbENvbnRyb2xIZWxwZXIpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbm5lclJlc29sdmVyID0gKDAsIHJlc29sdmVyXzEuY3JlYXRlUmVzb2x2ZXIpKHRhcmdldCwge1xuICAgICAgICAgICAgb25TdWNjZXNzZnVsUmVzb2x1dGlvbjogKGVuZHBvaW50TGlzdCwgc2VydmljZUNvbmZpZywgc2VydmljZUNvbmZpZ0Vycm9yLCBjb25maWdTZWxlY3RvciwgYXR0cmlidXRlcykgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgbGV0IHdvcmtpbmdTZXJ2aWNlQ29uZmlnID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvKiBUaGlzIGZpcnN0IGdyb3VwIG9mIGNvbmRpdGlvbmFscyBpbXBsZW1lbnRzIHRoZSBhbGdvcml0aG0gZGVzY3JpYmVkXG4gICAgICAgICAgICAgICAgICogaW4gaHR0cHM6Ly9naXRodWIuY29tL2dycGMvcHJvcG9zYWwvYmxvYi9tYXN0ZXIvQTIxLXNlcnZpY2UtY29uZmlnLWVycm9yLWhhbmRsaW5nLm1kXG4gICAgICAgICAgICAgICAgICogaW4gdGhlIHNlY3Rpb24gY2FsbGVkIFwiQmVoYXZpb3Igb24gcmVjZWl2aW5nIGEgbmV3IGdSUEMgQ29uZmlnXCIuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKHNlcnZpY2VDb25maWcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCA0IGFuZCA1XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXJ2aWNlQ29uZmlnRXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgNVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ1NlcnZpY2VDb25maWcgPSB0aGlzLmRlZmF1bHRTZXJ2aWNlQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCA0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGVwIDQuaWlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc29sdXRpb25GYWlsdXJlKHNlcnZpY2VDb25maWdFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGVwIDQuaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmdTZXJ2aWNlQ29uZmlnID0gdGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgM1xuICAgICAgICAgICAgICAgICAgICB3b3JraW5nU2VydmljZUNvbmZpZyA9IHNlcnZpY2VDb25maWc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNTZXJ2aWNlQ29uZmlnID0gc2VydmljZUNvbmZpZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgd29ya2luZ0NvbmZpZ0xpc3QgPSAoX2EgPSB3b3JraW5nU2VydmljZUNvbmZpZyA9PT0gbnVsbCB8fCB3b3JraW5nU2VydmljZUNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd29ya2luZ1NlcnZpY2VDb25maWcubG9hZEJhbGFuY2luZ0NvbmZpZykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgICAgICAgICAgY29uc3QgbG9hZEJhbGFuY2luZ0NvbmZpZyA9ICgwLCBsb2FkX2JhbGFuY2VyXzEuc2VsZWN0TGJDb25maWdGcm9tTGlzdCkod29ya2luZ0NvbmZpZ0xpc3QsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChsb2FkQmFsYW5jaW5nQ29uZmlnID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIHdlcmUgbG9hZCBiYWxhbmNpbmcgY29uZmlncyBidXQgbm9uZSBhcmUgc3VwcG9ydGVkLiBUaGlzIGNvdW50cyBhcyBhIHJlc29sdXRpb24gZmFpbHVyZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc29sdXRpb25GYWlsdXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdBbGwgbG9hZCBiYWxhbmNlciBvcHRpb25zIGluIHNlcnZpY2UgY29uZmlnIGFyZSBub3QgY29tcGF0aWJsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ1NlbGVjdG9yID09PSBudWxsIHx8IGNvbmZpZ1NlbGVjdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWdTZWxlY3Rvci51bnJlZigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRMb2FkQmFsYW5jZXIudXBkYXRlQWRkcmVzc0xpc3QoZW5kcG9pbnRMaXN0LCBsb2FkQmFsYW5jaW5nQ29uZmlnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY2hhbm5lbE9wdGlvbnMpLCBhdHRyaWJ1dGVzKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmluYWxTZXJ2aWNlQ29uZmlnID0gd29ya2luZ1NlcnZpY2VDb25maWcgIT09IG51bGwgJiYgd29ya2luZ1NlcnZpY2VDb25maWcgIT09IHZvaWQgMCA/IHdvcmtpbmdTZXJ2aWNlQ29uZmlnIDogdGhpcy5kZWZhdWx0U2VydmljZUNvbmZpZztcbiAgICAgICAgICAgICAgICB0aGlzLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24oZmluYWxTZXJ2aWNlQ29uZmlnLCBjb25maWdTZWxlY3RvciAhPT0gbnVsbCAmJiBjb25maWdTZWxlY3RvciAhPT0gdm9pZCAwID8gY29uZmlnU2VsZWN0b3IgOiBnZXREZWZhdWx0Q29uZmlnU2VsZWN0b3IoZmluYWxTZXJ2aWNlQ29uZmlnKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25FcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXNvbHV0aW9uRmFpbHVyZShlcnJvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LCBjaGFubmVsT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGJhY2tvZmZPcHRpb25zID0ge1xuICAgICAgICAgICAgaW5pdGlhbERlbGF5OiBjaGFubmVsT3B0aW9uc1snZ3JwYy5pbml0aWFsX3JlY29ubmVjdF9iYWNrb2ZmX21zJ10sXG4gICAgICAgICAgICBtYXhEZWxheTogY2hhbm5lbE9wdGlvbnNbJ2dycGMubWF4X3JlY29ubmVjdF9iYWNrb2ZmX21zJ10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQgPSBuZXcgYmFja29mZl90aW1lb3V0XzEuQmFja29mZlRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGludWVSZXNvbHZpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc29sdXRpb24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKHRoaXMubGF0ZXN0Q2hpbGRTdGF0ZSwgdGhpcy5sYXRlc3RDaGlsZFBpY2tlciwgdGhpcy5sYXRlc3RDaGlsZEVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGJhY2tvZmZPcHRpb25zKTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC51bnJlZigpO1xuICAgIH1cbiAgICB1cGRhdGVSZXNvbHV0aW9uKCkge1xuICAgICAgICB0aGlzLmlubmVyUmVzb2x2ZXIudXBkYXRlUmVzb2x1dGlvbigpO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpIHtcbiAgICAgICAgICAgIC8qIHRoaXMubGF0ZXN0Q2hpbGRQaWNrZXIgaXMgaW5pdGlhbGl6ZWQgYXMgbmV3IFF1ZXVlUGlja2VyKHRoaXMpLCB3aGljaFxuICAgICAgICAgICAgICogaXMgYW4gYXBwcm9wcmlhdGUgdmFsdWUgaGVyZSBpZiB0aGUgY2hpbGQgTEIgcG9saWN5IGlzIHVuc2V0LlxuICAgICAgICAgICAgICogT3RoZXJ3aXNlLCB3ZSB3YW50IHRvIGRlbGVnYXRlIHRvIHRoZSBjaGlsZCBoZXJlLCBpbiBjYXNlIHRoYXRcbiAgICAgICAgICAgICAqIHRyaWdnZXJzIHNvbWV0aGluZy4gKi9cbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORywgdGhpcy5sYXRlc3RDaGlsZFBpY2tlciwgdGhpcy5sYXRlc3RDaGlsZEVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5ydW5PbmNlKCk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIsIGVycm9yTWVzc2FnZSkge1xuICAgICAgICB0cmFjZSgoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCkgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3RoaXMuY3VycmVudFN0YXRlXSArXG4gICAgICAgICAgICAnIC0+ICcgK1xuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbY29ubmVjdGl2aXR5U3RhdGVdKTtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhpcy5leGl0SWRsZSgpIGlzIGNhbGxlZCBieSB0aGUgcGlja2VyXG4gICAgICAgIGlmIChjb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xuICAgICAgICAgICAgcGlja2VyID0gbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMsIHBpY2tlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBjb25uZWN0aXZpdHlTdGF0ZTtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgICBoYW5kbGVSZXNvbHV0aW9uRmFpbHVyZShlcnJvcikge1xuICAgICAgICBpZiAodGhpcy5sYXRlc3RDaGlsZFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFLCBuZXcgcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXIoZXJyb3IpLCBlcnJvci5kZXRhaWxzKTtcbiAgICAgICAgICAgIHRoaXMub25GYWlsZWRSZXNvbHV0aW9uKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleGl0SWRsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFIHx8XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJhY2tvZmZUaW1lb3V0LmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc29sdXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkTG9hZEJhbGFuY2VyLmV4aXRJZGxlKCk7XG4gICAgfVxuICAgIHVwZGF0ZUFkZHJlc3NMaXN0KGVuZHBvaW50TGlzdCwgbGJDb25maWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1cGRhdGVBZGRyZXNzTGlzdCBub3Qgc3VwcG9ydGVkIG9uIFJlc29sdmluZ0xvYWRCYWxhbmNlcicpO1xuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucmVzZXQoKTtcbiAgICAgICAgdGhpcy5jaGlsZExvYWRCYWxhbmNlci5yZXNldEJhY2tvZmYoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jaGlsZExvYWRCYWxhbmNlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaW5uZXJSZXNvbHZlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucmVzZXQoKTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5zdG9wKCk7XG4gICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRQaWNrZXIgPSBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcyk7XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgdGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWcgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGdldFR5cGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ3Jlc29sdmluZ19sb2FkX2JhbGFuY2VyJztcbiAgICB9XG59XG5leHBvcnRzLlJlc29sdmluZ0xvYWRCYWxhbmNlciA9IFJlc29sdmluZ0xvYWRCYWxhbmNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmluZy1sb2FkLWJhbGFuY2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlJlc29sdmluZ0xvYWRCYWxhbmNlciIsImxvYWRfYmFsYW5jZXJfMSIsInJlcXVpcmUiLCJzZXJ2aWNlX2NvbmZpZ18xIiwiY29ubmVjdGl2aXR5X3N0YXRlXzEiLCJyZXNvbHZlcl8xIiwicGlja2VyXzEiLCJiYWNrb2ZmX3RpbWVvdXRfMSIsImNvbnN0YW50c18xIiwibWV0YWRhdGFfMSIsImxvZ2dpbmciLCJjb25zdGFudHNfMiIsInVyaV9wYXJzZXJfMSIsImxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xIiwiVFJBQ0VSX05BTUUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIk5BTUVfTUFUQ0hfTEVWRUxfT1JERVIiLCJoYXNNYXRjaGluZ05hbWUiLCJzZXJ2aWNlIiwibWV0aG9kIiwibWV0aG9kQ29uZmlnIiwibWF0Y2hMZXZlbCIsIm5hbWUiLCJmaW5kTWF0Y2hpbmdDb25maWciLCJtZXRob2RDb25maWdzIiwiY29uZmlnIiwiZ2V0RGVmYXVsdENvbmZpZ1NlbGVjdG9yIiwic2VydmljZUNvbmZpZyIsImludm9rZSIsIm1ldGhvZE5hbWUiLCJtZXRhZGF0YSIsIl9hIiwiX2IiLCJzcGxpdE5hbWUiLCJzcGxpdCIsImZpbHRlciIsIngiLCJsZW5ndGgiLCJtYXRjaGluZ0NvbmZpZyIsInBpY2tJbmZvcm1hdGlvbiIsInN0YXR1cyIsIlN0YXR1cyIsIk9LIiwiZHluYW1pY0ZpbHRlckZhY3RvcmllcyIsInVucmVmIiwiY29uc3RydWN0b3IiLCJ0YXJnZXQiLCJjaGFubmVsQ29udHJvbEhlbHBlciIsImNoYW5uZWxPcHRpb25zIiwib25TdWNjZXNzZnVsUmVzb2x1dGlvbiIsIm9uRmFpbGVkUmVzb2x1dGlvbiIsImxhdGVzdENoaWxkU3RhdGUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIklETEUiLCJsYXRlc3RDaGlsZFBpY2tlciIsIlF1ZXVlUGlja2VyIiwibGF0ZXN0Q2hpbGRFcnJvck1lc3NhZ2UiLCJjdXJyZW50U3RhdGUiLCJwcmV2aW91c1NlcnZpY2VDb25maWciLCJjb250aW51ZVJlc29sdmluZyIsImRlZmF1bHRTZXJ2aWNlQ29uZmlnIiwidmFsaWRhdGVTZXJ2aWNlQ29uZmlnIiwiSlNPTiIsInBhcnNlIiwibG9hZEJhbGFuY2luZ0NvbmZpZyIsInVwZGF0ZVN0YXRlIiwiY2hpbGRMb2FkQmFsYW5jZXIiLCJDaGlsZExvYWRCYWxhbmNlckhhbmRsZXIiLCJjcmVhdGVTdWJjaGFubmVsIiwiYmluZCIsInJlcXVlc3RSZXJlc29sdXRpb24iLCJiYWNrb2ZmVGltZW91dCIsImlzUnVubmluZyIsImdldEVuZFRpbWUiLCJ0b0lTT1N0cmluZyIsInVwZGF0ZVJlc29sdXRpb24iLCJuZXdTdGF0ZSIsInBpY2tlciIsImVycm9yTWVzc2FnZSIsImFkZENoYW5uZWx6Q2hpbGQiLCJyZW1vdmVDaGFubmVsekNoaWxkIiwiaW5uZXJSZXNvbHZlciIsImNyZWF0ZVJlc29sdmVyIiwiZW5kcG9pbnRMaXN0Iiwic2VydmljZUNvbmZpZ0Vycm9yIiwiY29uZmlnU2VsZWN0b3IiLCJhdHRyaWJ1dGVzIiwic3RvcCIsInJlc2V0Iiwid29ya2luZ1NlcnZpY2VDb25maWciLCJoYW5kbGVSZXNvbHV0aW9uRmFpbHVyZSIsIndvcmtpbmdDb25maWdMaXN0Iiwic2VsZWN0TGJDb25maWdGcm9tTGlzdCIsImNvZGUiLCJVTkFWQUlMQUJMRSIsImRldGFpbHMiLCJNZXRhZGF0YSIsInVwZGF0ZUFkZHJlc3NMaXN0IiwiYXNzaWduIiwiZmluYWxTZXJ2aWNlQ29uZmlnIiwib25FcnJvciIsImVycm9yIiwiYmFja29mZk9wdGlvbnMiLCJpbml0aWFsRGVsYXkiLCJtYXhEZWxheSIsIkJhY2tvZmZUaW1lb3V0IiwiQ09OTkVDVElORyIsInJ1bk9uY2UiLCJjb25uZWN0aXZpdHlTdGF0ZSIsInVyaVRvU3RyaW5nIiwiVFJBTlNJRU5UX0ZBSUxVUkUiLCJVbmF2YWlsYWJsZVBpY2tlciIsImV4aXRJZGxlIiwibGJDb25maWciLCJFcnJvciIsInJlc2V0QmFja29mZiIsImRlc3Ryb3kiLCJnZXRUeXBlTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js":
/*!***************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/retrying-call.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RetryingCall = exports.MessageBufferTracker = exports.RetryThrottler = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = \"retrying_call\";\nclass RetryThrottler {\n    constructor(maxTokens, tokenRatio, previousRetryThrottler){\n        this.maxTokens = maxTokens;\n        this.tokenRatio = tokenRatio;\n        if (previousRetryThrottler) {\n            /* When carrying over tokens from a previous config, rescale them to the\n             * new max value */ this.tokens = previousRetryThrottler.tokens * (maxTokens / previousRetryThrottler.maxTokens);\n        } else {\n            this.tokens = maxTokens;\n        }\n    }\n    addCallSucceeded() {\n        this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);\n    }\n    addCallFailed() {\n        this.tokens = Math.min(this.tokens - 1, 0);\n    }\n    canRetryCall() {\n        return this.tokens > this.maxTokens / 2;\n    }\n}\nexports.RetryThrottler = RetryThrottler;\nclass MessageBufferTracker {\n    constructor(totalLimit, limitPerCall){\n        this.totalLimit = totalLimit;\n        this.limitPerCall = limitPerCall;\n        this.totalAllocated = 0;\n        this.allocatedPerCall = new Map();\n    }\n    allocate(size, callId) {\n        var _a;\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n        if (this.limitPerCall - currentPerCall < size || this.totalLimit - this.totalAllocated < size) {\n            return false;\n        }\n        this.allocatedPerCall.set(callId, currentPerCall + size);\n        this.totalAllocated += size;\n        return true;\n    }\n    free(size, callId) {\n        var _a;\n        if (this.totalAllocated < size) {\n            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);\n        }\n        this.totalAllocated -= size;\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n        if (currentPerCall < size) {\n            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);\n        }\n        this.allocatedPerCall.set(callId, currentPerCall - size);\n    }\n    freeAll(callId) {\n        var _a;\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n        if (this.totalAllocated < currentPerCall) {\n            throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);\n        }\n        this.totalAllocated -= currentPerCall;\n        this.allocatedPerCall.delete(callId);\n    }\n}\nexports.MessageBufferTracker = MessageBufferTracker;\nconst PREVIONS_RPC_ATTEMPTS_METADATA_KEY = \"grpc-previous-rpc-attempts\";\nconst DEFAULT_MAX_ATTEMPTS_LIMIT = 5;\nclass RetryingCall {\n    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber, bufferTracker, retryThrottler){\n        var _a;\n        this.channel = channel;\n        this.callConfig = callConfig;\n        this.methodName = methodName;\n        this.host = host;\n        this.credentials = credentials;\n        this.deadline = deadline;\n        this.callNumber = callNumber;\n        this.bufferTracker = bufferTracker;\n        this.retryThrottler = retryThrottler;\n        this.listener = null;\n        this.initialMetadata = null;\n        this.underlyingCalls = [];\n        this.writeBuffer = [];\n        /**\n         * The offset of message indices in the writeBuffer. For example, if\n         * writeBufferOffset is 10, message 10 is in writeBuffer[0] and message 15\n         * is in writeBuffer[5].\n         */ this.writeBufferOffset = 0;\n        /**\n         * Tracks whether a read has been started, so that we know whether to start\n         * reads on new child calls. This only matters for the first read, because\n         * once a message comes in the child call becomes committed and there will\n         * be no new child calls.\n         */ this.readStarted = false;\n        this.transparentRetryUsed = false;\n        /**\n         * Number of attempts so far\n         */ this.attempts = 0;\n        this.hedgingTimer = null;\n        this.committedCallIndex = null;\n        this.initialRetryBackoffSec = 0;\n        this.nextRetryBackoffSec = 0;\n        const maxAttemptsLimit = (_a = channel.getOptions()[\"grpc-node.retry_max_attempts_limit\"]) !== null && _a !== void 0 ? _a : DEFAULT_MAX_ATTEMPTS_LIMIT;\n        if (callConfig.methodConfig.retryPolicy) {\n            this.state = \"RETRY\";\n            const retryPolicy = callConfig.methodConfig.retryPolicy;\n            this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));\n            this.maxAttempts = Math.min(retryPolicy.maxAttempts, maxAttemptsLimit);\n        } else if (callConfig.methodConfig.hedgingPolicy) {\n            this.state = \"HEDGING\";\n            this.maxAttempts = Math.min(callConfig.methodConfig.hedgingPolicy.maxAttempts, maxAttemptsLimit);\n        } else if (channel.getOptions()[\"grpc.enable_retries\"] === 0) {\n            this.state = \"NO_RETRY\";\n            this.maxAttempts = 1;\n        } else {\n            this.state = \"TRANSPARENT_ONLY\";\n            this.maxAttempts = 1;\n        }\n        this.startTime = new Date();\n    }\n    getDeadlineInfo() {\n        if (this.underlyingCalls.length === 0) {\n            return [];\n        }\n        const deadlineInfo = [];\n        const latestCall = this.underlyingCalls[this.underlyingCalls.length - 1];\n        if (this.underlyingCalls.length > 1) {\n            deadlineInfo.push(`previous attempts: ${this.underlyingCalls.length - 1}`);\n        }\n        if (latestCall.startTime > this.startTime) {\n            deadlineInfo.push(`time to current attempt start: ${(0, deadline_1.formatDateDifference)(this.startTime, latestCall.startTime)}`);\n        }\n        deadlineInfo.push(...latestCall.call.getDeadlineInfo());\n        return deadlineInfo;\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"[\" + this.callNumber + \"] \" + text);\n    }\n    reportStatus(statusObject) {\n        this.trace(\"ended with status: code=\" + statusObject.code + ' details=\"' + statusObject.details + '\" start time=' + this.startTime.toISOString());\n        this.bufferTracker.freeAll(this.callNumber);\n        this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;\n        this.writeBuffer = [];\n        process.nextTick(()=>{\n            var _a;\n            // Explicitly construct status object to remove progress field\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus({\n                code: statusObject.code,\n                details: statusObject.details,\n                metadata: statusObject.metadata\n            });\n        });\n    }\n    cancelWithStatus(status, details) {\n        this.trace(\"cancelWithStatus code: \" + status + ' details: \"' + details + '\"');\n        this.reportStatus({\n            code: status,\n            details,\n            metadata: new metadata_1.Metadata()\n        });\n        for (const { call } of this.underlyingCalls){\n            call.cancelWithStatus(status, details);\n        }\n    }\n    getPeer() {\n        if (this.committedCallIndex !== null) {\n            return this.underlyingCalls[this.committedCallIndex].call.getPeer();\n        } else {\n            return \"unknown\";\n        }\n    }\n    getBufferEntry(messageIndex) {\n        var _a;\n        return (_a = this.writeBuffer[messageIndex - this.writeBufferOffset]) !== null && _a !== void 0 ? _a : {\n            entryType: \"FREED\",\n            allocated: false\n        };\n    }\n    getNextBufferIndex() {\n        return this.writeBufferOffset + this.writeBuffer.length;\n    }\n    clearSentMessages() {\n        if (this.state !== \"COMMITTED\") {\n            return;\n        }\n        let earliestNeededMessageIndex;\n        if (this.underlyingCalls[this.committedCallIndex].state === \"COMPLETED\") {\n            /* If the committed call is completed, clear all messages, even if some\n             * have not been sent. */ earliestNeededMessageIndex = this.getNextBufferIndex();\n        } else {\n            earliestNeededMessageIndex = this.underlyingCalls[this.committedCallIndex].nextMessageToSend;\n        }\n        for(let messageIndex = this.writeBufferOffset; messageIndex < earliestNeededMessageIndex; messageIndex++){\n            const bufferEntry = this.getBufferEntry(messageIndex);\n            if (bufferEntry.allocated) {\n                this.bufferTracker.free(bufferEntry.message.message.length, this.callNumber);\n            }\n        }\n        this.writeBuffer = this.writeBuffer.slice(earliestNeededMessageIndex - this.writeBufferOffset);\n        this.writeBufferOffset = earliestNeededMessageIndex;\n    }\n    commitCall(index) {\n        var _a, _b;\n        if (this.state === \"COMMITTED\") {\n            return;\n        }\n        this.trace(\"Committing call [\" + this.underlyingCalls[index].call.getCallNumber() + \"] at index \" + index);\n        this.state = \"COMMITTED\";\n        (_b = (_a = this.callConfig).onCommitted) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.committedCallIndex = index;\n        for(let i = 0; i < this.underlyingCalls.length; i++){\n            if (i === index) {\n                continue;\n            }\n            if (this.underlyingCalls[i].state === \"COMPLETED\") {\n                continue;\n            }\n            this.underlyingCalls[i].state = \"COMPLETED\";\n            this.underlyingCalls[i].call.cancelWithStatus(constants_1.Status.CANCELLED, \"Discarded in favor of other hedged attempt\");\n        }\n        this.clearSentMessages();\n    }\n    commitCallWithMostMessages() {\n        if (this.state === \"COMMITTED\") {\n            return;\n        }\n        let mostMessages = -1;\n        let callWithMostMessages = -1;\n        for (const [index, childCall] of this.underlyingCalls.entries()){\n            if (childCall.state === \"ACTIVE\" && childCall.nextMessageToSend > mostMessages) {\n                mostMessages = childCall.nextMessageToSend;\n                callWithMostMessages = index;\n            }\n        }\n        if (callWithMostMessages === -1) {\n            /* There are no active calls, disable retries to force the next call that\n             * is started to be committed. */ this.state = \"TRANSPARENT_ONLY\";\n        } else {\n            this.commitCall(callWithMostMessages);\n        }\n    }\n    isStatusCodeInList(list, code) {\n        return list.some((value)=>{\n            var _a;\n            return value === code || value.toString().toLowerCase() === ((_a = constants_1.Status[code]) === null || _a === void 0 ? void 0 : _a.toLowerCase());\n        });\n    }\n    getNextRetryBackoffMs() {\n        var _a;\n        const retryPolicy = (_a = this.callConfig) === null || _a === void 0 ? void 0 : _a.methodConfig.retryPolicy;\n        if (!retryPolicy) {\n            return 0;\n        }\n        const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;\n        const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));\n        this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);\n        return nextBackoffMs;\n    }\n    maybeRetryCall(pushback, callback) {\n        if (this.state !== \"RETRY\") {\n            callback(false);\n            return;\n        }\n        if (this.attempts >= this.maxAttempts) {\n            callback(false);\n            return;\n        }\n        let retryDelayMs;\n        if (pushback === null) {\n            retryDelayMs = this.getNextRetryBackoffMs();\n        } else if (pushback < 0) {\n            this.state = \"TRANSPARENT_ONLY\";\n            callback(false);\n            return;\n        } else {\n            retryDelayMs = pushback;\n            this.nextRetryBackoffSec = this.initialRetryBackoffSec;\n        }\n        setTimeout(()=>{\n            var _a, _b;\n            if (this.state !== \"RETRY\") {\n                callback(false);\n                return;\n            }\n            if ((_b = (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.canRetryCall()) !== null && _b !== void 0 ? _b : true) {\n                callback(true);\n                this.attempts += 1;\n                this.startNewAttempt();\n            }\n        }, retryDelayMs);\n    }\n    countActiveCalls() {\n        let count = 0;\n        for (const call of this.underlyingCalls){\n            if ((call === null || call === void 0 ? void 0 : call.state) === \"ACTIVE\") {\n                count += 1;\n            }\n        }\n        return count;\n    }\n    handleProcessedStatus(status, callIndex, pushback) {\n        var _a, _b, _c;\n        switch(this.state){\n            case \"COMMITTED\":\n            case \"NO_RETRY\":\n            case \"TRANSPARENT_ONLY\":\n                this.commitCall(callIndex);\n                this.reportStatus(status);\n                break;\n            case \"HEDGING\":\n                if (this.isStatusCodeInList((_a = this.callConfig.methodConfig.hedgingPolicy.nonFatalStatusCodes) !== null && _a !== void 0 ? _a : [], status.code)) {\n                    (_b = this.retryThrottler) === null || _b === void 0 ? void 0 : _b.addCallFailed();\n                    let delayMs;\n                    if (pushback === null) {\n                        delayMs = 0;\n                    } else if (pushback < 0) {\n                        this.state = \"TRANSPARENT_ONLY\";\n                        this.commitCall(callIndex);\n                        this.reportStatus(status);\n                        return;\n                    } else {\n                        delayMs = pushback;\n                    }\n                    setTimeout(()=>{\n                        this.maybeStartHedgingAttempt();\n                        // If after trying to start a call there are no active calls, this was the last one\n                        if (this.countActiveCalls() === 0) {\n                            this.commitCall(callIndex);\n                            this.reportStatus(status);\n                        }\n                    }, delayMs);\n                } else {\n                    this.commitCall(callIndex);\n                    this.reportStatus(status);\n                }\n                break;\n            case \"RETRY\":\n                if (this.isStatusCodeInList(this.callConfig.methodConfig.retryPolicy.retryableStatusCodes, status.code)) {\n                    (_c = this.retryThrottler) === null || _c === void 0 ? void 0 : _c.addCallFailed();\n                    this.maybeRetryCall(pushback, (retried)=>{\n                        if (!retried) {\n                            this.commitCall(callIndex);\n                            this.reportStatus(status);\n                        }\n                    });\n                } else {\n                    this.commitCall(callIndex);\n                    this.reportStatus(status);\n                }\n                break;\n        }\n    }\n    getPushback(metadata) {\n        const mdValue = metadata.get(\"grpc-retry-pushback-ms\");\n        if (mdValue.length === 0) {\n            return null;\n        }\n        try {\n            return parseInt(mdValue[0]);\n        } catch (e) {\n            return -1;\n        }\n    }\n    handleChildStatus(status, callIndex) {\n        var _a;\n        if (this.underlyingCalls[callIndex].state === \"COMPLETED\") {\n            return;\n        }\n        this.trace(\"state=\" + this.state + \" handling status with progress \" + status.progress + \" from child [\" + this.underlyingCalls[callIndex].call.getCallNumber() + \"] in state \" + this.underlyingCalls[callIndex].state);\n        this.underlyingCalls[callIndex].state = \"COMPLETED\";\n        if (status.code === constants_1.Status.OK) {\n            (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.addCallSucceeded();\n            this.commitCall(callIndex);\n            this.reportStatus(status);\n            return;\n        }\n        if (this.state === \"NO_RETRY\") {\n            this.commitCall(callIndex);\n            this.reportStatus(status);\n            return;\n        }\n        if (this.state === \"COMMITTED\") {\n            this.reportStatus(status);\n            return;\n        }\n        const pushback = this.getPushback(status.metadata);\n        switch(status.progress){\n            case \"NOT_STARTED\":\n                // RPC never leaves the client, always safe to retry\n                this.startNewAttempt();\n                break;\n            case \"REFUSED\":\n                // RPC reaches the server library, but not the server application logic\n                if (this.transparentRetryUsed) {\n                    this.handleProcessedStatus(status, callIndex, pushback);\n                } else {\n                    this.transparentRetryUsed = true;\n                    this.startNewAttempt();\n                }\n                break;\n            case \"DROP\":\n                this.commitCall(callIndex);\n                this.reportStatus(status);\n                break;\n            case \"PROCESSED\":\n                this.handleProcessedStatus(status, callIndex, pushback);\n                break;\n        }\n    }\n    maybeStartHedgingAttempt() {\n        if (this.state !== \"HEDGING\") {\n            return;\n        }\n        if (!this.callConfig.methodConfig.hedgingPolicy) {\n            return;\n        }\n        if (this.attempts >= this.maxAttempts) {\n            return;\n        }\n        this.attempts += 1;\n        this.startNewAttempt();\n        this.maybeStartHedgingTimer();\n    }\n    maybeStartHedgingTimer() {\n        var _a, _b, _c;\n        if (this.hedgingTimer) {\n            clearTimeout(this.hedgingTimer);\n        }\n        if (this.state !== \"HEDGING\") {\n            return;\n        }\n        if (!this.callConfig.methodConfig.hedgingPolicy) {\n            return;\n        }\n        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n        if (this.attempts >= this.maxAttempts) {\n            return;\n        }\n        const hedgingDelayString = (_a = hedgingPolicy.hedgingDelay) !== null && _a !== void 0 ? _a : \"0s\";\n        const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));\n        this.hedgingTimer = setTimeout(()=>{\n            this.maybeStartHedgingAttempt();\n        }, hedgingDelaySec * 1000);\n        (_c = (_b = this.hedgingTimer).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n    }\n    startNewAttempt() {\n        const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);\n        this.trace(\"Created child call [\" + child.getCallNumber() + \"] for attempt \" + this.attempts);\n        const index = this.underlyingCalls.length;\n        this.underlyingCalls.push({\n            state: \"ACTIVE\",\n            call: child,\n            nextMessageToSend: 0,\n            startTime: new Date()\n        });\n        const previousAttempts = this.attempts - 1;\n        const initialMetadata = this.initialMetadata.clone();\n        if (previousAttempts > 0) {\n            initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n        }\n        let receivedMetadata = false;\n        child.start(initialMetadata, {\n            onReceiveMetadata: (metadata)=>{\n                this.trace(\"Received metadata from child [\" + child.getCallNumber() + \"]\");\n                this.commitCall(index);\n                receivedMetadata = true;\n                if (previousAttempts > 0) {\n                    metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n                }\n                if (this.underlyingCalls[index].state === \"ACTIVE\") {\n                    this.listener.onReceiveMetadata(metadata);\n                }\n            },\n            onReceiveMessage: (message)=>{\n                this.trace(\"Received message from child [\" + child.getCallNumber() + \"]\");\n                this.commitCall(index);\n                if (this.underlyingCalls[index].state === \"ACTIVE\") {\n                    this.listener.onReceiveMessage(message);\n                }\n            },\n            onReceiveStatus: (status)=>{\n                this.trace(\"Received status from child [\" + child.getCallNumber() + \"]\");\n                if (!receivedMetadata && previousAttempts > 0) {\n                    status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n                }\n                this.handleChildStatus(status, index);\n            }\n        });\n        this.sendNextChildMessage(index);\n        if (this.readStarted) {\n            child.startRead();\n        }\n    }\n    start(metadata, listener) {\n        this.trace(\"start called\");\n        this.listener = listener;\n        this.initialMetadata = metadata;\n        this.attempts += 1;\n        this.startNewAttempt();\n        this.maybeStartHedgingTimer();\n    }\n    handleChildWriteCompleted(childIndex) {\n        var _a, _b;\n        const childCall = this.underlyingCalls[childIndex];\n        const messageIndex = childCall.nextMessageToSend;\n        (_b = (_a = this.getBufferEntry(messageIndex)).callback) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.clearSentMessages();\n        childCall.nextMessageToSend += 1;\n        this.sendNextChildMessage(childIndex);\n    }\n    sendNextChildMessage(childIndex) {\n        const childCall = this.underlyingCalls[childIndex];\n        if (childCall.state === \"COMPLETED\") {\n            return;\n        }\n        if (this.getBufferEntry(childCall.nextMessageToSend)) {\n            const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);\n            switch(bufferEntry.entryType){\n                case \"MESSAGE\":\n                    childCall.call.sendMessageWithContext({\n                        callback: (error)=>{\n                            // Ignore error\n                            this.handleChildWriteCompleted(childIndex);\n                        }\n                    }, bufferEntry.message.message);\n                    break;\n                case \"HALF_CLOSE\":\n                    childCall.nextMessageToSend += 1;\n                    childCall.call.halfClose();\n                    break;\n                case \"FREED\":\n                    break;\n            }\n        }\n    }\n    sendMessageWithContext(context, message) {\n        var _a;\n        this.trace(\"write() called with message of length \" + message.length);\n        const writeObj = {\n            message,\n            flags: context.flags\n        };\n        const messageIndex = this.getNextBufferIndex();\n        const bufferEntry = {\n            entryType: \"MESSAGE\",\n            message: writeObj,\n            allocated: this.bufferTracker.allocate(message.length, this.callNumber)\n        };\n        this.writeBuffer.push(bufferEntry);\n        if (bufferEntry.allocated) {\n            (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\n            for (const [callIndex, call] of this.underlyingCalls.entries()){\n                if (call.state === \"ACTIVE\" && call.nextMessageToSend === messageIndex) {\n                    call.call.sendMessageWithContext({\n                        callback: (error)=>{\n                            // Ignore error\n                            this.handleChildWriteCompleted(callIndex);\n                        }\n                    }, message);\n                }\n            }\n        } else {\n            this.commitCallWithMostMessages();\n            // commitCallWithMostMessages can fail if we are between ping attempts\n            if (this.committedCallIndex === null) {\n                return;\n            }\n            const call = this.underlyingCalls[this.committedCallIndex];\n            bufferEntry.callback = context.callback;\n            if (call.state === \"ACTIVE\" && call.nextMessageToSend === messageIndex) {\n                call.call.sendMessageWithContext({\n                    callback: (error)=>{\n                        // Ignore error\n                        this.handleChildWriteCompleted(this.committedCallIndex);\n                    }\n                }, message);\n            }\n        }\n    }\n    startRead() {\n        this.trace(\"startRead called\");\n        this.readStarted = true;\n        for (const underlyingCall of this.underlyingCalls){\n            if ((underlyingCall === null || underlyingCall === void 0 ? void 0 : underlyingCall.state) === \"ACTIVE\") {\n                underlyingCall.call.startRead();\n            }\n        }\n    }\n    halfClose() {\n        this.trace(\"halfClose called\");\n        const halfCloseIndex = this.getNextBufferIndex();\n        this.writeBuffer.push({\n            entryType: \"HALF_CLOSE\",\n            allocated: false\n        });\n        for (const call of this.underlyingCalls){\n            if ((call === null || call === void 0 ? void 0 : call.state) === \"ACTIVE\" && call.nextMessageToSend === halfCloseIndex) {\n                call.nextMessageToSend += 1;\n                call.call.halfClose();\n            }\n        }\n    }\n    setCredentials(newCredentials) {\n        throw new Error(\"Method not implemented.\");\n    }\n    getMethod() {\n        return this.methodName;\n    }\n    getHost() {\n        return this.host;\n    }\n}\nexports.RetryingCall = RetryingCall; //# sourceMappingURL=retrying-call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmV0cnlpbmctY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsb0JBQW9CLEdBQUdBLDRCQUE0QixHQUFHQSxzQkFBc0IsR0FBRyxLQUFLO0FBQ3BGLE1BQU1LLGNBQWNDLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1HLFVBQVVILG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1JLGNBQWM7QUFDcEIsTUFBTU47SUFDRk8sWUFBWUMsU0FBUyxFQUFFQyxVQUFVLEVBQUVDLHNCQUFzQixDQUFFO1FBQ3ZELElBQUksQ0FBQ0YsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDbEIsSUFBSUMsd0JBQXdCO1lBQ3hCOzZCQUNpQixHQUNqQixJQUFJLENBQUNDLE1BQU0sR0FDUEQsdUJBQXVCQyxNQUFNLEdBQ3hCSCxDQUFBQSxZQUFZRSx1QkFBdUJGLFNBQVM7UUFDekQsT0FDSztZQUNELElBQUksQ0FBQ0csTUFBTSxHQUFHSDtRQUNsQjtJQUNKO0lBQ0FJLG1CQUFtQjtRQUNmLElBQUksQ0FBQ0QsTUFBTSxHQUFHRSxLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDSCxNQUFNLEdBQUcsSUFBSSxDQUFDRixVQUFVLEVBQUUsSUFBSSxDQUFDRCxTQUFTO0lBQ3hFO0lBQ0FPLGdCQUFnQjtRQUNaLElBQUksQ0FBQ0osTUFBTSxHQUFHRSxLQUFLRyxHQUFHLENBQUMsSUFBSSxDQUFDTCxNQUFNLEdBQUcsR0FBRztJQUM1QztJQUNBTSxlQUFlO1FBQ1gsT0FBTyxJQUFJLENBQUNOLE1BQU0sR0FBRyxJQUFJLENB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LGVBQWUsQ0FBRTtZQUNyQyxJQUFJLENBQUM0QixTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBS2QsS0FBSyxNQUFNLFlBQzdEYyxLQUFLMEIsaUJBQWlCLEtBQUsyRSxnQkFBZ0I7Z0JBQzNDckcsS0FBSzBCLGlCQUFpQixJQUFJO2dCQUMxQjFCLEtBQUtBLElBQUksQ0FBQ2dHLFNBQVM7WUFDdkI7UUFDSjtJQUNKO0lBQ0FNLGVBQWVDLGNBQWMsRUFBRTtRQUMzQixNQUFNLElBQUluSixNQUFNO0lBQ3BCO0lBQ0FvSixZQUFZO1FBQ1IsT0FBTyxJQUFJLENBQUM3SSxVQUFVO0lBQzFCO0lBQ0E4SSxVQUFVO1FBQ04sT0FBTyxJQUFJLENBQUM3SSxJQUFJO0lBQ3BCO0FBQ0o7QUFDQTNDLG9CQUFvQixHQUFHRSxjQUN2Qix5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmV0cnlpbmctY2FsbC5qcz83Yzc4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJldHJ5aW5nQ2FsbCA9IGV4cG9ydHMuTWVzc2FnZUJ1ZmZlclRyYWNrZXIgPSBleHBvcnRzLlJldHJ5VGhyb3R0bGVyID0gdm9pZCAwO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBkZWFkbGluZV8xID0gcmVxdWlyZShcIi4vZGVhZGxpbmVcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3JldHJ5aW5nX2NhbGwnO1xuY2xhc3MgUmV0cnlUaHJvdHRsZXIge1xuICAgIGNvbnN0cnVjdG9yKG1heFRva2VucywgdG9rZW5SYXRpbywgcHJldmlvdXNSZXRyeVRocm90dGxlcikge1xuICAgICAgICB0aGlzLm1heFRva2VucyA9IG1heFRva2VucztcbiAgICAgICAgdGhpcy50b2tlblJhdGlvID0gdG9rZW5SYXRpbztcbiAgICAgICAgaWYgKHByZXZpb3VzUmV0cnlUaHJvdHRsZXIpIHtcbiAgICAgICAgICAgIC8qIFdoZW4gY2Fycnlpbmcgb3ZlciB0b2tlbnMgZnJvbSBhIHByZXZpb3VzIGNvbmZpZywgcmVzY2FsZSB0aGVtIHRvIHRoZVxuICAgICAgICAgICAgICogbmV3IG1heCB2YWx1ZSAqL1xuICAgICAgICAgICAgdGhpcy50b2tlbnMgPVxuICAgICAgICAgICAgICAgIHByZXZpb3VzUmV0cnlUaHJvdHRsZXIudG9rZW5zICpcbiAgICAgICAgICAgICAgICAgICAgKG1heFRva2VucyAvIHByZXZpb3VzUmV0cnlUaHJvdHRsZXIubWF4VG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW5zID0gbWF4VG9rZW5zO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZENhbGxTdWNjZWVkZWQoKSB7XG4gICAgICAgIHRoaXMudG9rZW5zID0gTWF0aC5tYXgodGhpcy50b2tlbnMgKyB0aGlzLnRva2VuUmF0aW8sIHRoaXMubWF4VG9rZW5zKTtcbiAgICB9XG4gICAgYWRkQ2FsbEZhaWxlZCgpIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBNYXRoLm1pbih0aGlzLnRva2VucyAtIDEsIDApO1xuICAgIH1cbiAgICBjYW5SZXRyeUNhbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2VucyA+IHRoaXMubWF4VG9rZW5zIC8gMjtcbiAgICB9XG59XG5leHBvcnRzLlJldHJ5VGhyb3R0bGVyID0gUmV0cnlUaHJvdHRsZXI7XG5jbGFzcyBNZXNzYWdlQnVmZmVyVHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IodG90YWxMaW1pdCwgbGltaXRQZXJDYWxsKSB7XG4gICAgICAgIHRoaXMudG90YWxMaW1pdCA9IHRvdGFsTGltaXQ7XG4gICAgICAgIHRoaXMubGltaXRQZXJDYWxsID0gbGltaXRQZXJDYWxsO1xuICAgICAgICB0aGlzLnRvdGFsQWxsb2NhdGVkID0gMDtcbiAgICAgICAgdGhpcy5hbGxvY2F0ZWRQZXJDYWxsID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBhbGxvY2F0ZShzaXplLCBjYWxsSWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjdXJyZW50UGVyQ2FsbCA9IChfYSA9IHRoaXMuYWxsb2NhdGVkUGVyQ2FsbC5nZXQoY2FsbElkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgaWYgKHRoaXMubGltaXRQZXJDYWxsIC0gY3VycmVudFBlckNhbGwgPCBzaXplIHx8XG4gICAgICAgICAgICB0aGlzLnRvdGFsTGltaXQgLSB0aGlzLnRvdGFsQWxsb2NhdGVkIDwgc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsb2NhdGVkUGVyQ2FsbC5zZXQoY2FsbElkLCBjdXJyZW50UGVyQ2FsbCArIHNpemUpO1xuICAgICAgICB0aGlzLnRvdGFsQWxsb2NhdGVkICs9IHNpemU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmcmVlKHNpemUsIGNhbGxJZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLnRvdGFsQWxsb2NhdGVkIDwgc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJ1ZmZlciBhbGxvY2F0aW9uIHN0YXRlOiBjYWxsICR7Y2FsbElkfSBmcmVlZCAke3NpemV9ID4gdG90YWwgYWxsb2NhdGVkICR7dGhpcy50b3RhbEFsbG9jYXRlZH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvdGFsQWxsb2NhdGVkIC09IHNpemU7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQZXJDYWxsID0gKF9hID0gdGhpcy5hbGxvY2F0ZWRQZXJDYWxsLmdldChjYWxsSWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBpZiAoY3VycmVudFBlckNhbGwgPCBzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYnVmZmVyIGFsbG9jYXRpb24gc3RhdGU6IGNhbGwgJHtjYWxsSWR9IGZyZWVkICR7c2l6ZX0gPiBhbGxvY2F0ZWQgZm9yIGNhbGwgJHtjdXJyZW50UGVyQ2FsbH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFsbG9jYXRlZFBlckNhbGwuc2V0KGNhbGxJZCwgY3VycmVudFBlckNhbGwgLSBzaXplKTtcbiAgICB9XG4gICAgZnJlZUFsbChjYWxsSWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjdXJyZW50UGVyQ2FsbCA9IChfYSA9IHRoaXMuYWxsb2NhdGVkUGVyQ2FsbC5nZXQoY2FsbElkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgaWYgKHRoaXMudG90YWxBbGxvY2F0ZWQgPCBjdXJyZW50UGVyQ2FsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJ1ZmZlciBhbGxvY2F0aW9uIHN0YXRlOiBjYWxsICR7Y2FsbElkfSBhbGxvY2F0ZWQgJHtjdXJyZW50UGVyQ2FsbH0gPiB0b3RhbCBhbGxvY2F0ZWQgJHt0aGlzLnRvdGFsQWxsb2NhdGVkfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG90YWxBbGxvY2F0ZWQgLT0gY3VycmVudFBlckNhbGw7XG4gICAgICAgIHRoaXMuYWxsb2NhdGVkUGVyQ2FsbC5kZWxldGUoY2FsbElkKTtcbiAgICB9XG59XG5leHBvcnRzLk1lc3NhZ2VCdWZmZXJUcmFja2VyID0gTWVzc2FnZUJ1ZmZlclRyYWNrZXI7XG5jb25zdCBQUkVWSU9OU19SUENfQVRURU1QVFNfTUVUQURBVEFfS0VZID0gJ2dycGMtcHJldmlvdXMtcnBjLWF0dGVtcHRzJztcbmNvbnN0IERFRkFVTFRfTUFYX0FUVEVNUFRTX0xJTUlUID0gNTtcbmNsYXNzIFJldHJ5aW5nQ2FsbCB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgY2FsbENvbmZpZywgbWV0aG9kTmFtZSwgaG9zdCwgY3JlZGVudGlhbHMsIGRlYWRsaW5lLCBjYWxsTnVtYmVyLCBidWZmZXJUcmFja2VyLCByZXRyeVRocm90dGxlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuY2FsbENvbmZpZyA9IGNhbGxDb25maWc7XG4gICAgICAgIHRoaXMubWV0aG9kTmFtZSA9IG1ldGhvZE5hbWU7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5kZWFkbGluZSA9IGRlYWRsaW5lO1xuICAgICAgICB0aGlzLmNhbGxOdW1iZXIgPSBjYWxsTnVtYmVyO1xuICAgICAgICB0aGlzLmJ1ZmZlclRyYWNrZXIgPSBidWZmZXJUcmFja2VyO1xuICAgICAgICB0aGlzLnJldHJ5VGhyb3R0bGVyID0gcmV0cnlUaHJvdHRsZXI7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmluaXRpYWxNZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMudW5kZXJseWluZ0NhbGxzID0gW107XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvZmZzZXQgb2YgbWVzc2FnZSBpbmRpY2VzIGluIHRoZSB3cml0ZUJ1ZmZlci4gRm9yIGV4YW1wbGUsIGlmXG4gICAgICAgICAqIHdyaXRlQnVmZmVyT2Zmc2V0IGlzIDEwLCBtZXNzYWdlIDEwIGlzIGluIHdyaXRlQnVmZmVyWzBdIGFuZCBtZXNzYWdlIDE1XG4gICAgICAgICAqIGlzIGluIHdyaXRlQnVmZmVyWzVdLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlck9mZnNldCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFja3Mgd2hldGhlciBhIHJlYWQgaGFzIGJlZW4gc3RhcnRlZCwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgdG8gc3RhcnRcbiAgICAgICAgICogcmVhZHMgb24gbmV3IGNoaWxkIGNhbGxzLiBUaGlzIG9ubHkgbWF0dGVycyBmb3IgdGhlIGZpcnN0IHJlYWQsIGJlY2F1c2VcbiAgICAgICAgICogb25jZSBhIG1lc3NhZ2UgY29tZXMgaW4gdGhlIGNoaWxkIGNhbGwgYmVjb21lcyBjb21taXR0ZWQgYW5kIHRoZXJlIHdpbGxcbiAgICAgICAgICogYmUgbm8gbmV3IGNoaWxkIGNhbGxzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyYW5zcGFyZW50UmV0cnlVc2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2YgYXR0ZW1wdHMgc28gZmFyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF0dGVtcHRzID0gMDtcbiAgICAgICAgdGhpcy5oZWRnaW5nVGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbW1pdHRlZENhbGxJbmRleCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5pdGlhbFJldHJ5QmFja29mZlNlYyA9IDA7XG4gICAgICAgIHRoaXMubmV4dFJldHJ5QmFja29mZlNlYyA9IDA7XG4gICAgICAgIGNvbnN0IG1heEF0dGVtcHRzTGltaXQgPSAoX2EgPSBjaGFubmVsLmdldE9wdGlvbnMoKVsnZ3JwYy1ub2RlLnJldHJ5X21heF9hdHRlbXB0c19saW1pdCddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBERUZBVUxUX01BWF9BVFRFTVBUU19MSU1JVDtcbiAgICAgICAgaWYgKGNhbGxDb25maWcubWV0aG9kQ29uZmlnLnJldHJ5UG9saWN5KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ1JFVFJZJztcbiAgICAgICAgICAgIGNvbnN0IHJldHJ5UG9saWN5ID0gY2FsbENvbmZpZy5tZXRob2RDb25maWcucmV0cnlQb2xpY3k7XG4gICAgICAgICAgICB0aGlzLm5leHRSZXRyeUJhY2tvZmZTZWMgPSB0aGlzLmluaXRpYWxSZXRyeUJhY2tvZmZTZWMgPSBOdW1iZXIocmV0cnlQb2xpY3kuaW5pdGlhbEJhY2tvZmYuc3Vic3RyaW5nKDAsIHJldHJ5UG9saWN5LmluaXRpYWxCYWNrb2ZmLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICAgIHRoaXMubWF4QXR0ZW1wdHMgPSBNYXRoLm1pbihyZXRyeVBvbGljeS5tYXhBdHRlbXB0cywgbWF4QXR0ZW1wdHNMaW1pdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FsbENvbmZpZy5tZXRob2RDb25maWcuaGVkZ2luZ1BvbGljeSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdIRURHSU5HJztcbiAgICAgICAgICAgIHRoaXMubWF4QXR0ZW1wdHMgPSBNYXRoLm1pbihjYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5oZWRnaW5nUG9saWN5Lm1heEF0dGVtcHRzLCBtYXhBdHRlbXB0c0xpbWl0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFubmVsLmdldE9wdGlvbnMoKVsnZ3JwYy5lbmFibGVfcmV0cmllcyddID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ05PX1JFVFJZJztcbiAgICAgICAgICAgIHRoaXMubWF4QXR0ZW1wdHMgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdUUkFOU1BBUkVOVF9PTkxZJztcbiAgICAgICAgICAgIHRoaXMubWF4QXR0ZW1wdHMgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgZ2V0RGVhZGxpbmVJbmZvKCkge1xuICAgICAgICBpZiAodGhpcy51bmRlcmx5aW5nQ2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVhZGxpbmVJbmZvID0gW107XG4gICAgICAgIGNvbnN0IGxhdGVzdENhbGwgPSB0aGlzLnVuZGVybHlpbmdDYWxsc1t0aGlzLnVuZGVybHlpbmdDYWxscy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMudW5kZXJseWluZ0NhbGxzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGRlYWRsaW5lSW5mby5wdXNoKGBwcmV2aW91cyBhdHRlbXB0czogJHt0aGlzLnVuZGVybHlpbmdDYWxscy5sZW5ndGggLSAxfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXRlc3RDYWxsLnN0YXJ0VGltZSA+IHRoaXMuc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICBkZWFkbGluZUluZm8ucHVzaChgdGltZSB0byBjdXJyZW50IGF0dGVtcHQgc3RhcnQ6ICR7KDAsIGRlYWRsaW5lXzEuZm9ybWF0RGF0ZURpZmZlcmVuY2UpKHRoaXMuc3RhcnRUaW1lLCBsYXRlc3RDYWxsLnN0YXJ0VGltZSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVhZGxpbmVJbmZvLnB1c2goLi4ubGF0ZXN0Q2FsbC5jYWxsLmdldERlYWRsaW5lSW5mbygpKTtcbiAgICAgICAgcmV0dXJuIGRlYWRsaW5lSW5mbztcbiAgICB9XG4gICAgZ2V0Q2FsbE51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbE51bWJlcjtcbiAgICB9XG4gICAgdHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICdbJyArIHRoaXMuY2FsbE51bWJlciArICddICcgKyB0ZXh0KTtcbiAgICB9XG4gICAgcmVwb3J0U3RhdHVzKHN0YXR1c09iamVjdCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdlbmRlZCB3aXRoIHN0YXR1czogY29kZT0nICtcbiAgICAgICAgICAgIHN0YXR1c09iamVjdC5jb2RlICtcbiAgICAgICAgICAgICcgZGV0YWlscz1cIicgK1xuICAgICAgICAgICAgc3RhdHVzT2JqZWN0LmRldGFpbHMgK1xuICAgICAgICAgICAgJ1wiIHN0YXJ0IHRpbWU9JyArXG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZS50b0lTT1N0cmluZygpKTtcbiAgICAgICAgdGhpcy5idWZmZXJUcmFja2VyLmZyZWVBbGwodGhpcy5jYWxsTnVtYmVyKTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlck9mZnNldCA9IHRoaXMud3JpdGVCdWZmZXJPZmZzZXQgKyB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aDtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgY29uc3RydWN0IHN0YXR1cyBvYmplY3QgdG8gcmVtb3ZlIHByb2dyZXNzIGZpZWxkXG4gICAgICAgICAgICAoX2EgPSB0aGlzLmxpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25SZWNlaXZlU3RhdHVzKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBzdGF0dXNPYmplY3QuY29kZSxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBzdGF0dXNPYmplY3QuZGV0YWlscyxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogc3RhdHVzT2JqZWN0Lm1ldGFkYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscykge1xuICAgICAgICB0aGlzLnRyYWNlKCdjYW5jZWxXaXRoU3RhdHVzIGNvZGU6ICcgKyBzdGF0dXMgKyAnIGRldGFpbHM6IFwiJyArIGRldGFpbHMgKyAnXCInKTtcbiAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoeyBjb2RlOiBzdGF0dXMsIGRldGFpbHMsIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IHsgY2FsbCB9IG9mIHRoaXMudW5kZXJseWluZ0NhbGxzKSB7XG4gICAgICAgICAgICBjYWxsLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICBpZiAodGhpcy5jb21taXR0ZWRDYWxsSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuZGVybHlpbmdDYWxsc1t0aGlzLmNvbW1pdHRlZENhbGxJbmRleF0uY2FsbC5nZXRQZWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ3Vua25vd24nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEJ1ZmZlckVudHJ5KG1lc3NhZ2VJbmRleCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy53cml0ZUJ1ZmZlclttZXNzYWdlSW5kZXggLSB0aGlzLndyaXRlQnVmZmVyT2Zmc2V0XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge1xuICAgICAgICAgICAgZW50cnlUeXBlOiAnRlJFRUQnLFxuICAgICAgICAgICAgYWxsb2NhdGVkOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldE5leHRCdWZmZXJJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVCdWZmZXJPZmZzZXQgKyB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aDtcbiAgICB9XG4gICAgY2xlYXJTZW50TWVzc2FnZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSAnQ09NTUlUVEVEJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlYXJsaWVzdE5lZWRlZE1lc3NhZ2VJbmRleDtcbiAgICAgICAgaWYgKHRoaXMudW5kZXJseWluZ0NhbGxzW3RoaXMuY29tbWl0dGVkQ2FsbEluZGV4XS5zdGF0ZSA9PT0gJ0NPTVBMRVRFRCcpIHtcbiAgICAgICAgICAgIC8qIElmIHRoZSBjb21taXR0ZWQgY2FsbCBpcyBjb21wbGV0ZWQsIGNsZWFyIGFsbCBtZXNzYWdlcywgZXZlbiBpZiBzb21lXG4gICAgICAgICAgICAgKiBoYXZlIG5vdCBiZWVuIHNlbnQuICovXG4gICAgICAgICAgICBlYXJsaWVzdE5lZWRlZE1lc3NhZ2VJbmRleCA9IHRoaXMuZ2V0TmV4dEJ1ZmZlckluZGV4KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlYXJsaWVzdE5lZWRlZE1lc3NhZ2VJbmRleCA9XG4gICAgICAgICAgICAgICAgdGhpcy51bmRlcmx5aW5nQ2FsbHNbdGhpcy5jb21taXR0ZWRDYWxsSW5kZXhdLm5leHRNZXNzYWdlVG9TZW5kO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG1lc3NhZ2VJbmRleCA9IHRoaXMud3JpdGVCdWZmZXJPZmZzZXQ7IG1lc3NhZ2VJbmRleCA8IGVhcmxpZXN0TmVlZGVkTWVzc2FnZUluZGV4OyBtZXNzYWdlSW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyRW50cnkgPSB0aGlzLmdldEJ1ZmZlckVudHJ5KG1lc3NhZ2VJbmRleCk7XG4gICAgICAgICAgICBpZiAoYnVmZmVyRW50cnkuYWxsb2NhdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJUcmFja2VyLmZyZWUoYnVmZmVyRW50cnkubWVzc2FnZS5tZXNzYWdlLmxlbmd0aCwgdGhpcy5jYWxsTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlQnVmZmVyID0gdGhpcy53cml0ZUJ1ZmZlci5zbGljZShlYXJsaWVzdE5lZWRlZE1lc3NhZ2VJbmRleCAtIHRoaXMud3JpdGVCdWZmZXJPZmZzZXQpO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyT2Zmc2V0ID0gZWFybGllc3ROZWVkZWRNZXNzYWdlSW5kZXg7XG4gICAgfVxuICAgIGNvbW1pdENhbGwoaW5kZXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdDT01NSVRURUQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZSgnQ29tbWl0dGluZyBjYWxsIFsnICtcbiAgICAgICAgICAgIHRoaXMudW5kZXJseWluZ0NhbGxzW2luZGV4XS5jYWxsLmdldENhbGxOdW1iZXIoKSArXG4gICAgICAgICAgICAnXSBhdCBpbmRleCAnICtcbiAgICAgICAgICAgIGluZGV4KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdDT01NSVRURUQnO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNhbGxDb25maWcpLm9uQ29tbWl0dGVkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIHRoaXMuY29tbWl0dGVkQ2FsbEluZGV4ID0gaW5kZXg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy51bmRlcmx5aW5nQ2FsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudW5kZXJseWluZ0NhbGxzW2ldLnN0YXRlID09PSAnQ09NUExFVEVEJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51bmRlcmx5aW5nQ2FsbHNbaV0uc3RhdGUgPSAnQ09NUExFVEVEJztcbiAgICAgICAgICAgIHRoaXMudW5kZXJseWluZ0NhbGxzW2ldLmNhbGwuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELCAnRGlzY2FyZGVkIGluIGZhdm9yIG9mIG90aGVyIGhlZGdlZCBhdHRlbXB0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhclNlbnRNZXNzYWdlcygpO1xuICAgIH1cbiAgICBjb21taXRDYWxsV2l0aE1vc3RNZXNzYWdlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdDT01NSVRURUQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1vc3RNZXNzYWdlcyA9IC0xO1xuICAgICAgICBsZXQgY2FsbFdpdGhNb3N0TWVzc2FnZXMgPSAtMTtcbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGNoaWxkQ2FsbF0gb2YgdGhpcy51bmRlcmx5aW5nQ2FsbHMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRDYWxsLnN0YXRlID09PSAnQUNUSVZFJyAmJlxuICAgICAgICAgICAgICAgIGNoaWxkQ2FsbC5uZXh0TWVzc2FnZVRvU2VuZCA+IG1vc3RNZXNzYWdlcykge1xuICAgICAgICAgICAgICAgIG1vc3RNZXNzYWdlcyA9IGNoaWxkQ2FsbC5uZXh0TWVzc2FnZVRvU2VuZDtcbiAgICAgICAgICAgICAgICBjYWxsV2l0aE1vc3RNZXNzYWdlcyA9IGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsV2l0aE1vc3RNZXNzYWdlcyA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8qIFRoZXJlIGFyZSBubyBhY3RpdmUgY2FsbHMsIGRpc2FibGUgcmV0cmllcyB0byBmb3JjZSB0aGUgbmV4dCBjYWxsIHRoYXRcbiAgICAgICAgICAgICAqIGlzIHN0YXJ0ZWQgdG8gYmUgY29tbWl0dGVkLiAqL1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdUUkFOU1BBUkVOVF9PTkxZJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsV2l0aE1vc3RNZXNzYWdlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNTdGF0dXNDb2RlSW5MaXN0KGxpc3QsIGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIGxpc3Quc29tZSh2YWx1ZSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IGNvZGUgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09ICgoX2EgPSBjb25zdGFudHNfMS5TdGF0dXNbY29kZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldE5leHRSZXRyeUJhY2tvZmZNcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCByZXRyeVBvbGljeSA9IChfYSA9IHRoaXMuY2FsbENvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1ldGhvZENvbmZpZy5yZXRyeVBvbGljeTtcbiAgICAgICAgaWYgKCFyZXRyeVBvbGljeSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dEJhY2tvZmZNcyA9IE1hdGgucmFuZG9tKCkgKiB0aGlzLm5leHRSZXRyeUJhY2tvZmZTZWMgKiAxMDAwO1xuICAgICAgICBjb25zdCBtYXhCYWNrb2ZmU2VjID0gTnVtYmVyKHJldHJ5UG9saWN5Lm1heEJhY2tvZmYuc3Vic3RyaW5nKDAsIHJldHJ5UG9saWN5Lm1heEJhY2tvZmYubGVuZ3RoIC0gMSkpO1xuICAgICAgICB0aGlzLm5leHRSZXRyeUJhY2tvZmZTZWMgPSBNYXRoLm1pbih0aGlzLm5leHRSZXRyeUJhY2tvZmZTZWMgKiByZXRyeVBvbGljeS5iYWNrb2ZmTXVsdGlwbGllciwgbWF4QmFja29mZlNlYyk7XG4gICAgICAgIHJldHVybiBuZXh0QmFja29mZk1zO1xuICAgIH1cbiAgICBtYXliZVJldHJ5Q2FsbChwdXNoYmFjaywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdSRVRSWScpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdHRlbXB0cyA+PSB0aGlzLm1heEF0dGVtcHRzKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJldHJ5RGVsYXlNcztcbiAgICAgICAgaWYgKHB1c2hiYWNrID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXRyeURlbGF5TXMgPSB0aGlzLmdldE5leHRSZXRyeUJhY2tvZmZNcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHB1c2hiYWNrIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdUUkFOU1BBUkVOVF9PTkxZJztcbiAgICAgICAgICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHJ5RGVsYXlNcyA9IHB1c2hiYWNrO1xuICAgICAgICAgICAgdGhpcy5uZXh0UmV0cnlCYWNrb2ZmU2VjID0gdGhpcy5pbml0aWFsUmV0cnlCYWNrb2ZmU2VjO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSAnUkVUUlknKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoX2IgPSAoX2EgPSB0aGlzLnJldHJ5VGhyb3R0bGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuUmV0cnlDYWxsKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGVtcHRzICs9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydE5ld0F0dGVtcHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgcmV0cnlEZWxheU1zKTtcbiAgICB9XG4gICAgY291bnRBY3RpdmVDYWxscygpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIHRoaXMudW5kZXJseWluZ0NhbGxzKSB7XG4gICAgICAgICAgICBpZiAoKGNhbGwgPT09IG51bGwgfHwgY2FsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbC5zdGF0ZSkgPT09ICdBQ1RJVkUnKSB7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIGhhbmRsZVByb2Nlc3NlZFN0YXR1cyhzdGF0dXMsIGNhbGxJbmRleCwgcHVzaGJhY2spIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnQ09NTUlUVEVEJzpcbiAgICAgICAgICAgIGNhc2UgJ05PX1JFVFJZJzpcbiAgICAgICAgICAgIGNhc2UgJ1RSQU5TUEFSRU5UX09OTFknOlxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsSW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdIRURHSU5HJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1N0YXR1c0NvZGVJbkxpc3QoKF9hID0gdGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5oZWRnaW5nUG9saWN5Lm5vbkZhdGFsU3RhdHVzQ29kZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLCBzdGF0dXMuY29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9iID0gdGhpcy5yZXRyeVRocm90dGxlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlbGF5TXM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwdXNoYmFjayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXlNcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHVzaGJhY2sgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gJ1RSQU5TUEFSRU5UX09OTFknO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXlNcyA9IHB1c2hiYWNrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0SGVkZ2luZ0F0dGVtcHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGFmdGVyIHRyeWluZyB0byBzdGFydCBhIGNhbGwgdGhlcmUgYXJlIG5vIGFjdGl2ZSBjYWxscywgdGhpcyB3YXMgdGhlIGxhc3Qgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb3VudEFjdGl2ZUNhbGxzKCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBkZWxheU1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1JFVFJZJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1N0YXR1c0NvZGVJbkxpc3QodGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5yZXRyeVBvbGljeS5yZXRyeWFibGVTdGF0dXNDb2Rlcywgc3RhdHVzLmNvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYyA9IHRoaXMucmV0cnlUaHJvdHRsZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF5YmVSZXRyeUNhbGwocHVzaGJhY2ssIHJldHJpZWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXRyaWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UHVzaGJhY2sobWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgbWRWYWx1ZSA9IG1ldGFkYXRhLmdldCgnZ3JwYy1yZXRyeS1wdXNoYmFjay1tcycpO1xuICAgICAgICBpZiAobWRWYWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobWRWYWx1ZVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDaGlsZFN0YXR1cyhzdGF0dXMsIGNhbGxJbmRleCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLnVuZGVybHlpbmdDYWxsc1tjYWxsSW5kZXhdLnN0YXRlID09PSAnQ09NUExFVEVEJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXRlPScgK1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSArXG4gICAgICAgICAgICAnIGhhbmRsaW5nIHN0YXR1cyB3aXRoIHByb2dyZXNzICcgK1xuICAgICAgICAgICAgc3RhdHVzLnByb2dyZXNzICtcbiAgICAgICAgICAgICcgZnJvbSBjaGlsZCBbJyArXG4gICAgICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxsc1tjYWxsSW5kZXhdLmNhbGwuZ2V0Q2FsbE51bWJlcigpICtcbiAgICAgICAgICAgICddIGluIHN0YXRlICcgK1xuICAgICAgICAgICAgdGhpcy51bmRlcmx5aW5nQ2FsbHNbY2FsbEluZGV4XS5zdGF0ZSk7XG4gICAgICAgIHRoaXMudW5kZXJseWluZ0NhbGxzW2NhbGxJbmRleF0uc3RhdGUgPSAnQ09NUExFVEVEJztcbiAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMucmV0cnlUaHJvdHRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdOT19SRVRSWScpIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsSW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ0NPTU1JVFRFRCcpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHVzaGJhY2sgPSB0aGlzLmdldFB1c2hiYWNrKHN0YXR1cy5tZXRhZGF0YSk7XG4gICAgICAgIHN3aXRjaCAoc3RhdHVzLnByb2dyZXNzKSB7XG4gICAgICAgICAgICBjYXNlICdOT1RfU1RBUlRFRCc6XG4gICAgICAgICAgICAgICAgLy8gUlBDIG5ldmVyIGxlYXZlcyB0aGUgY2xpZW50LCBhbHdheXMgc2FmZSB0byByZXRyeVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnROZXdBdHRlbXB0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdSRUZVU0VEJzpcbiAgICAgICAgICAgICAgICAvLyBSUEMgcmVhY2hlcyB0aGUgc2VydmVyIGxpYnJhcnksIGJ1dCBub3QgdGhlIHNlcnZlciBhcHBsaWNhdGlvbiBsb2dpY1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zcGFyZW50UmV0cnlVc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUHJvY2Vzc2VkU3RhdHVzKHN0YXR1cywgY2FsbEluZGV4LCBwdXNoYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW50UmV0cnlVc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydE5ld0F0dGVtcHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdEUk9QJzpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUFJPQ0VTU0VEJzpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVByb2Nlc3NlZFN0YXR1cyhzdGF0dXMsIGNhbGxJbmRleCwgcHVzaGJhY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1heWJlU3RhcnRIZWRnaW5nQXR0ZW1wdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdIRURHSU5HJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5oZWRnaW5nUG9saWN5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXR0ZW1wdHMgPj0gdGhpcy5tYXhBdHRlbXB0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXR0ZW1wdHMgKz0gMTtcbiAgICAgICAgdGhpcy5zdGFydE5ld0F0dGVtcHQoKTtcbiAgICAgICAgdGhpcy5tYXliZVN0YXJ0SGVkZ2luZ1RpbWVyKCk7XG4gICAgfVxuICAgIG1heWJlU3RhcnRIZWRnaW5nVGltZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBpZiAodGhpcy5oZWRnaW5nVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhlZGdpbmdUaW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdIRURHSU5HJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5oZWRnaW5nUG9saWN5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVkZ2luZ1BvbGljeSA9IHRoaXMuY2FsbENvbmZpZy5tZXRob2RDb25maWcuaGVkZ2luZ1BvbGljeTtcbiAgICAgICAgaWYgKHRoaXMuYXR0ZW1wdHMgPj0gdGhpcy5tYXhBdHRlbXB0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlZGdpbmdEZWxheVN0cmluZyA9IChfYSA9IGhlZGdpbmdQb2xpY3kuaGVkZ2luZ0RlbGF5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnMHMnO1xuICAgICAgICBjb25zdCBoZWRnaW5nRGVsYXlTZWMgPSBOdW1iZXIoaGVkZ2luZ0RlbGF5U3RyaW5nLnN1YnN0cmluZygwLCBoZWRnaW5nRGVsYXlTdHJpbmcubGVuZ3RoIC0gMSkpO1xuICAgICAgICB0aGlzLmhlZGdpbmdUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0SGVkZ2luZ0F0dGVtcHQoKTtcbiAgICAgICAgfSwgaGVkZ2luZ0RlbGF5U2VjICogMTAwMCk7XG4gICAgICAgIChfYyA9IChfYiA9IHRoaXMuaGVkZ2luZ1RpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IpO1xuICAgIH1cbiAgICBzdGFydE5ld0F0dGVtcHQoKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGFubmVsLmNyZWF0ZUxvYWRCYWxhbmNpbmdDYWxsKHRoaXMuY2FsbENvbmZpZywgdGhpcy5tZXRob2ROYW1lLCB0aGlzLmhvc3QsIHRoaXMuY3JlZGVudGlhbHMsIHRoaXMuZGVhZGxpbmUpO1xuICAgICAgICB0aGlzLnRyYWNlKCdDcmVhdGVkIGNoaWxkIGNhbGwgWycgK1xuICAgICAgICAgICAgY2hpbGQuZ2V0Q2FsbE51bWJlcigpICtcbiAgICAgICAgICAgICddIGZvciBhdHRlbXB0ICcgK1xuICAgICAgICAgICAgdGhpcy5hdHRlbXB0cyk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy51bmRlcmx5aW5nQ2FsbHMubGVuZ3RoO1xuICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxscy5wdXNoKHtcbiAgICAgICAgICAgIHN0YXRlOiAnQUNUSVZFJyxcbiAgICAgICAgICAgIGNhbGw6IGNoaWxkLFxuICAgICAgICAgICAgbmV4dE1lc3NhZ2VUb1NlbmQ6IDAsXG4gICAgICAgICAgICBzdGFydFRpbWU6IG5ldyBEYXRlKClcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzQXR0ZW1wdHMgPSB0aGlzLmF0dGVtcHRzIC0gMTtcbiAgICAgICAgY29uc3QgaW5pdGlhbE1ldGFkYXRhID0gdGhpcy5pbml0aWFsTWV0YWRhdGEuY2xvbmUoKTtcbiAgICAgICAgaWYgKHByZXZpb3VzQXR0ZW1wdHMgPiAwKSB7XG4gICAgICAgICAgICBpbml0aWFsTWV0YWRhdGEuc2V0KFBSRVZJT05TX1JQQ19BVFRFTVBUU19NRVRBREFUQV9LRVksIGAke3ByZXZpb3VzQXR0ZW1wdHN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlY2VpdmVkTWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgY2hpbGQuc3RhcnQoaW5pdGlhbE1ldGFkYXRhLCB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogbWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIG1ldGFkYXRhIGZyb20gY2hpbGQgWycgKyBjaGlsZC5nZXRDYWxsTnVtYmVyKCkgKyAnXScpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChpbmRleCk7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRNZXRhZGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzQXR0ZW1wdHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhLnNldChQUkVWSU9OU19SUENfQVRURU1QVFNfTUVUQURBVEFfS0VZLCBgJHtwcmV2aW91c0F0dGVtcHRzfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy51bmRlcmx5aW5nQ2FsbHNbaW5kZXhdLnN0YXRlID09PSAnQUNUSVZFJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogbWVzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgbWVzc2FnZSBmcm9tIGNoaWxkIFsnICsgY2hpbGQuZ2V0Q2FsbE51bWJlcigpICsgJ10nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVuZGVybHlpbmdDYWxsc1tpbmRleF0uc3RhdGUgPT09ICdBQ1RJVkUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiBzdGF0dXMgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIHN0YXR1cyBmcm9tIGNoaWxkIFsnICsgY2hpbGQuZ2V0Q2FsbE51bWJlcigpICsgJ10nKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlY2VpdmVkTWV0YWRhdGEgJiYgcHJldmlvdXNBdHRlbXB0cyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLm1ldGFkYXRhLnNldChQUkVWSU9OU19SUENfQVRURU1QVFNfTUVUQURBVEFfS0VZLCBgJHtwcmV2aW91c0F0dGVtcHRzfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNoaWxkU3RhdHVzKHN0YXR1cywgaW5kZXgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VuZE5leHRDaGlsZE1lc3NhZ2UoaW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5yZWFkU3RhcnRlZCkge1xuICAgICAgICAgICAgY2hpbGQuc3RhcnRSZWFkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQobWV0YWRhdGEsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXJ0IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMuaW5pdGlhbE1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIHRoaXMuYXR0ZW1wdHMgKz0gMTtcbiAgICAgICAgdGhpcy5zdGFydE5ld0F0dGVtcHQoKTtcbiAgICAgICAgdGhpcy5tYXliZVN0YXJ0SGVkZ2luZ1RpbWVyKCk7XG4gICAgfVxuICAgIGhhbmRsZUNoaWxkV3JpdGVDb21wbGV0ZWQoY2hpbGRJbmRleCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjaGlsZENhbGwgPSB0aGlzLnVuZGVybHlpbmdDYWxsc1tjaGlsZEluZGV4XTtcbiAgICAgICAgY29uc3QgbWVzc2FnZUluZGV4ID0gY2hpbGRDYWxsLm5leHRNZXNzYWdlVG9TZW5kO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmdldEJ1ZmZlckVudHJ5KG1lc3NhZ2VJbmRleCkpLmNhbGxiYWNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIHRoaXMuY2xlYXJTZW50TWVzc2FnZXMoKTtcbiAgICAgICAgY2hpbGRDYWxsLm5leHRNZXNzYWdlVG9TZW5kICs9IDE7XG4gICAgICAgIHRoaXMuc2VuZE5leHRDaGlsZE1lc3NhZ2UoY2hpbGRJbmRleCk7XG4gICAgfVxuICAgIHNlbmROZXh0Q2hpbGRNZXNzYWdlKGNoaWxkSW5kZXgpIHtcbiAgICAgICAgY29uc3QgY2hpbGRDYWxsID0gdGhpcy51bmRlcmx5aW5nQ2FsbHNbY2hpbGRJbmRleF07XG4gICAgICAgIGlmIChjaGlsZENhbGwuc3RhdGUgPT09ICdDT01QTEVURUQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2V0QnVmZmVyRW50cnkoY2hpbGRDYWxsLm5leHRNZXNzYWdlVG9TZW5kKSkge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyRW50cnkgPSB0aGlzLmdldEJ1ZmZlckVudHJ5KGNoaWxkQ2FsbC5uZXh0TWVzc2FnZVRvU2VuZCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGJ1ZmZlckVudHJ5LmVudHJ5VHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ01FU1NBR0UnOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZENhbGwuY2FsbC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDaGlsZFdyaXRlQ29tcGxldGVkKGNoaWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSwgYnVmZmVyRW50cnkubWVzc2FnZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnSEFMRl9DTE9TRSc6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQ2FsbC5uZXh0TWVzc2FnZVRvU2VuZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZENhbGwuY2FsbC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnRlJFRUQnOlxuICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQgbm90IGJlIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgbWVzc2FnZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMudHJhY2UoJ3dyaXRlKCkgY2FsbGVkIHdpdGggbWVzc2FnZSBvZiBsZW5ndGggJyArIG1lc3NhZ2UubGVuZ3RoKTtcbiAgICAgICAgY29uc3Qgd3JpdGVPYmogPSB7XG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgZmxhZ3M6IGNvbnRleHQuZmxhZ3MsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VJbmRleCA9IHRoaXMuZ2V0TmV4dEJ1ZmZlckluZGV4KCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlckVudHJ5ID0ge1xuICAgICAgICAgICAgZW50cnlUeXBlOiAnTUVTU0FHRScsXG4gICAgICAgICAgICBtZXNzYWdlOiB3cml0ZU9iaixcbiAgICAgICAgICAgIGFsbG9jYXRlZDogdGhpcy5idWZmZXJUcmFja2VyLmFsbG9jYXRlKG1lc3NhZ2UubGVuZ3RoLCB0aGlzLmNhbGxOdW1iZXIpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyLnB1c2goYnVmZmVyRW50cnkpO1xuICAgICAgICBpZiAoYnVmZmVyRW50cnkuYWxsb2NhdGVkKSB7XG4gICAgICAgICAgICAoX2EgPSBjb250ZXh0LmNhbGxiYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChjb250ZXh0KTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2NhbGxJbmRleCwgY2FsbF0gb2YgdGhpcy51bmRlcmx5aW5nQ2FsbHMuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGwuc3RhdGUgPT09ICdBQ1RJVkUnICYmXG4gICAgICAgICAgICAgICAgICAgIGNhbGwubmV4dE1lc3NhZ2VUb1NlbmQgPT09IG1lc3NhZ2VJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsLmNhbGwuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2hpbGRXcml0ZUNvbXBsZXRlZChjYWxsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsV2l0aE1vc3RNZXNzYWdlcygpO1xuICAgICAgICAgICAgLy8gY29tbWl0Q2FsbFdpdGhNb3N0TWVzc2FnZXMgY2FuIGZhaWwgaWYgd2UgYXJlIGJldHdlZW4gcGluZyBhdHRlbXB0c1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tbWl0dGVkQ2FsbEluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2FsbCA9IHRoaXMudW5kZXJseWluZ0NhbGxzW3RoaXMuY29tbWl0dGVkQ2FsbEluZGV4XTtcbiAgICAgICAgICAgIGJ1ZmZlckVudHJ5LmNhbGxiYWNrID0gY29udGV4dC5jYWxsYmFjaztcbiAgICAgICAgICAgIGlmIChjYWxsLnN0YXRlID09PSAnQUNUSVZFJyAmJiBjYWxsLm5leHRNZXNzYWdlVG9TZW5kID09PSBtZXNzYWdlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjYWxsLmNhbGwuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dCh7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2hpbGRXcml0ZUNvbXBsZXRlZCh0aGlzLmNvbW1pdHRlZENhbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRSZWFkKCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdzdGFydFJlYWQgY2FsbGVkJyk7XG4gICAgICAgIHRoaXMucmVhZFN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IHVuZGVybHlpbmdDYWxsIG9mIHRoaXMudW5kZXJseWluZ0NhbGxzKSB7XG4gICAgICAgICAgICBpZiAoKHVuZGVybHlpbmdDYWxsID09PSBudWxsIHx8IHVuZGVybHlpbmdDYWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1bmRlcmx5aW5nQ2FsbC5zdGF0ZSkgPT09ICdBQ1RJVkUnKSB7XG4gICAgICAgICAgICAgICAgdW5kZXJseWluZ0NhbGwuY2FsbC5zdGFydFJlYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoYWxmQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ2hhbGZDbG9zZSBjYWxsZWQnKTtcbiAgICAgICAgY29uc3QgaGFsZkNsb3NlSW5kZXggPSB0aGlzLmdldE5leHRCdWZmZXJJbmRleCgpO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyLnB1c2goe1xuICAgICAgICAgICAgZW50cnlUeXBlOiAnSEFMRl9DTE9TRScsXG4gICAgICAgICAgICBhbGxvY2F0ZWQ6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIHRoaXMudW5kZXJseWluZ0NhbGxzKSB7XG4gICAgICAgICAgICBpZiAoKGNhbGwgPT09IG51bGwgfHwgY2FsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbC5zdGF0ZSkgPT09ICdBQ1RJVkUnICYmXG4gICAgICAgICAgICAgICAgY2FsbC5uZXh0TWVzc2FnZVRvU2VuZCA9PT0gaGFsZkNsb3NlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjYWxsLm5leHRNZXNzYWdlVG9TZW5kICs9IDE7XG4gICAgICAgICAgICAgICAgY2FsbC5jYWxsLmhhbGZDbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldENyZWRlbnRpYWxzKG5ld0NyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG4gICAgZ2V0TWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2ROYW1lO1xuICAgIH1cbiAgICBnZXRIb3N0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3N0O1xuICAgIH1cbn1cbmV4cG9ydHMuUmV0cnlpbmdDYWxsID0gUmV0cnlpbmdDYWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cnlpbmctY2FsbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJSZXRyeWluZ0NhbGwiLCJNZXNzYWdlQnVmZmVyVHJhY2tlciIsIlJldHJ5VGhyb3R0bGVyIiwiY29uc3RhbnRzXzEiLCJyZXF1aXJlIiwiZGVhZGxpbmVfMSIsIm1ldGFkYXRhXzEiLCJsb2dnaW5nIiwiVFJBQ0VSX05BTUUiLCJjb25zdHJ1Y3RvciIsIm1heFRva2VucyIsInRva2VuUmF0aW8iLCJwcmV2aW91c1JldHJ5VGhyb3R0bGVyIiwidG9rZW5zIiwiYWRkQ2FsbFN1Y2NlZWRlZCIsIk1hdGgiLCJtYXgiLCJhZGRDYWxsRmFpbGVkIiwibWluIiwiY2FuUmV0cnlDYWxsIiwidG90YWxMaW1pdCIsImxpbWl0UGVyQ2FsbCIsInRvdGFsQWxsb2NhdGVkIiwiYWxsb2NhdGVkUGVyQ2FsbCIsIk1hcCIsImFsbG9jYXRlIiwic2l6ZSIsImNhbGxJZCIsIl9hIiwiY3VycmVudFBlckNhbGwiLCJnZXQiLCJzZXQiLCJmcmVlIiwiRXJyb3IiLCJmcmVlQWxsIiwiZGVsZXRlIiwiUFJFVklPTlNfUlBDX0FUVEVNUFRTX01FVEFEQVRBX0tFWSIsIkRFRkFVTFRfTUFYX0FUVEVNUFRTX0xJTUlUIiwiY2hhbm5lbCIsImNhbGxDb25maWciLCJtZXRob2ROYW1lIiwiaG9zdCIsImNyZWRlbnRpYWxzIiwiZGVhZGxpbmUiLCJjYWxsTnVtYmVyIiwiYnVmZmVyVHJhY2tlciIsInJldHJ5VGhyb3R0bGVyIiwibGlzdGVuZXIiLCJpbml0aWFsTWV0YWRhdGEiLCJ1bmRlcmx5aW5nQ2FsbHMiLCJ3cml0ZUJ1ZmZlciIsIndyaXRlQnVmZmVyT2Zmc2V0IiwicmVhZFN0YXJ0ZWQiLCJ0cmFuc3BhcmVudFJldHJ5VXNlZCIsImF0dGVtcHRzIiwiaGVkZ2luZ1RpbWVyIiwiY29tbWl0dGVkQ2FsbEluZGV4IiwiaW5pdGlhbFJldHJ5QmFja29mZlNlYyIsIm5leHRSZXRyeUJhY2tvZmZTZWMiLCJtYXhBdHRlbXB0c0xpbWl0IiwiZ2V0T3B0aW9ucyIsIm1ldGhvZENvbmZpZyIsInJldHJ5UG9saWN5Iiwic3RhdGUiLCJOdW1iZXIiLCJpbml0aWFsQmFja29mZiIsInN1YnN0cmluZyIsImxlbmd0aCIsIm1heEF0dGVtcHRzIiwiaGVkZ2luZ1BvbGljeSIsInN0YXJ0VGltZSIsIkRhdGUiLCJnZXREZWFkbGluZUluZm8iLCJkZWFkbGluZUluZm8iLCJsYXRlc3RDYWxsIiwicHVzaCIsImZvcm1hdERhdGVEaWZmZXJlbmNlIiwiY2FsbCIsImdldENhbGxOdW1iZXIiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsInJlcG9ydFN0YXR1cyIsInN0YXR1c09iamVjdCIsImNvZGUiLCJkZXRhaWxzIiwidG9JU09TdHJpbmciLCJwcm9jZXNzIiwibmV4dFRpY2siLCJvblJlY2VpdmVTdGF0dXMiLCJtZXRhZGF0YSIsImNhbmNlbFdpdGhTdGF0dXMiLCJzdGF0dXMiLCJNZXRhZGF0YSIsImdldFBlZXIiLCJnZXRCdWZmZXJFbnRyeSIsIm1lc3NhZ2VJbmRleCIsImVudHJ5VHlwZSIsImFsbG9jYXRlZCIsImdldE5leHRCdWZmZXJJbmRleCIsImNsZWFyU2VudE1lc3NhZ2VzIiwiZWFybGllc3ROZWVkZWRNZXNzYWdlSW5kZXgiLCJuZXh0TWVzc2FnZVRvU2VuZCIsImJ1ZmZlckVudHJ5IiwibWVzc2FnZSIsInNsaWNlIiwiY29tbWl0Q2FsbCIsImluZGV4IiwiX2IiLCJvbkNvbW1pdHRlZCIsImkiLCJTdGF0dXMiLCJDQU5DRUxMRUQiLCJjb21taXRDYWxsV2l0aE1vc3RNZXNzYWdlcyIsIm1vc3RNZXNzYWdlcyIsImNhbGxXaXRoTW9zdE1lc3NhZ2VzIiwiY2hpbGRDYWxsIiwiZW50cmllcyIsImlzU3RhdHVzQ29kZUluTGlzdCIsImxpc3QiLCJzb21lIiwidG9TdHJpbmciLCJ0b0xvd2VyQ2FzZSIsImdldE5leHRSZXRyeUJhY2tvZmZNcyIsIm5leHRCYWNrb2ZmTXMiLCJyYW5kb20iLCJtYXhCYWNrb2ZmU2VjIiwibWF4QmFja29mZiIsImJhY2tvZmZNdWx0aXBsaWVyIiwibWF5YmVSZXRyeUNhbGwiLCJwdXNoYmFjayIsImNhbGxiYWNrIiwicmV0cnlEZWxheU1zIiwic2V0VGltZW91dCIsInN0YXJ0TmV3QXR0ZW1wdCIsImNvdW50QWN0aXZlQ2FsbHMiLCJjb3VudCIsImhhbmRsZVByb2Nlc3NlZFN0YXR1cyIsImNhbGxJbmRleCIsIl9jIiwibm9uRmF0YWxTdGF0dXNDb2RlcyIsImRlbGF5TXMiLCJtYXliZVN0YXJ0SGVkZ2luZ0F0dGVtcHQiLCJyZXRyeWFibGVTdGF0dXNDb2RlcyIsInJldHJpZWQiLCJnZXRQdXNoYmFjayIsIm1kVmFsdWUiLCJwYXJzZUludCIsImUiLCJoYW5kbGVDaGlsZFN0YXR1cyIsInByb2dyZXNzIiwiT0siLCJtYXliZVN0YXJ0SGVkZ2luZ1RpbWVyIiwiY2xlYXJUaW1lb3V0IiwiaGVkZ2luZ0RlbGF5U3RyaW5nIiwiaGVkZ2luZ0RlbGF5IiwiaGVkZ2luZ0RlbGF5U2VjIiwidW5yZWYiLCJjaGlsZCIsImNyZWF0ZUxvYWRCYWxhbmNpbmdDYWxsIiwicHJldmlvdXNBdHRlbXB0cyIsImNsb25lIiwicmVjZWl2ZWRNZXRhZGF0YSIsInN0YXJ0Iiwib25SZWNlaXZlTWV0YWRhdGEiLCJvblJlY2VpdmVNZXNzYWdlIiwic2VuZE5leHRDaGlsZE1lc3NhZ2UiLCJzdGFydFJlYWQiLCJoYW5kbGVDaGlsZFdyaXRlQ29tcGxldGVkIiwiY2hpbGRJbmRleCIsInNlbmRNZXNzYWdlV2l0aENvbnRleHQiLCJlcnJvciIsImhhbGZDbG9zZSIsImNvbnRleHQiLCJ3cml0ZU9iaiIsImZsYWdzIiwidW5kZXJseWluZ0NhbGwiLCJoYWxmQ2xvc2VJbmRleCIsInNldENyZWRlbnRpYWxzIiwibmV3Q3JlZGVudGlhbHMiLCJnZXRNZXRob2QiLCJnZXRIb3N0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/server-call.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-call.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\nexports.serverErrorToStatus = serverErrorToStatus;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nfunction serverErrorToStatus(error, overrideTrailers) {\n    var _a;\n    const status = {\n        code: constants_1.Status.UNKNOWN,\n        details: \"message\" in error ? error.message : \"Unknown Error\",\n        metadata: (_a = overrideTrailers !== null && overrideTrailers !== void 0 ? overrideTrailers : error.metadata) !== null && _a !== void 0 ? _a : null\n    };\n    if (\"code\" in error && typeof error.code === \"number\" && Number.isInteger(error.code)) {\n        status.code = error.code;\n        if (\"details\" in error && typeof error.details === \"string\") {\n            status.details = error.details;\n        }\n    }\n    return status;\n}\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\n    constructor(path, call, metadata, request){\n        super();\n        this.path = path;\n        this.call = call;\n        this.metadata = metadata;\n        this.request = request;\n        this.cancelled = false;\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.path;\n    }\n    getHost() {\n        return this.call.getHost();\n    }\n}\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\nclass ServerReadableStreamImpl extends stream_1.Readable {\n    constructor(path, call, metadata){\n        super({\n            objectMode: true\n        });\n        this.path = path;\n        this.call = call;\n        this.metadata = metadata;\n        this.cancelled = false;\n    }\n    _read(size) {\n        this.call.startRead();\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.path;\n    }\n    getHost() {\n        return this.call.getHost();\n    }\n}\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\nclass ServerWritableStreamImpl extends stream_1.Writable {\n    constructor(path, call, metadata, request){\n        super({\n            objectMode: true\n        });\n        this.path = path;\n        this.call = call;\n        this.metadata = metadata;\n        this.request = request;\n        this.pendingStatus = {\n            code: constants_1.Status.OK,\n            details: \"OK\"\n        };\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.on(\"error\", (err)=>{\n            this.pendingStatus = serverErrorToStatus(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.path;\n    }\n    getHost() {\n        return this.call.getHost();\n    }\n    _write(chunk, encoding, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback) {\n        this.call.sendMessage(chunk, callback);\n    }\n    _final(callback) {\n        var _a;\n        callback(null);\n        this.call.sendStatus(Object.assign(Object.assign({}, this.pendingStatus), {\n            metadata: (_a = this.pendingStatus.metadata) !== null && _a !== void 0 ? _a : this.trailingMetadata\n        }));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        return super.end();\n    }\n}\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\n    constructor(path, call, metadata){\n        super({\n            objectMode: true\n        });\n        this.path = path;\n        this.call = call;\n        this.metadata = metadata;\n        this.pendingStatus = {\n            code: constants_1.Status.OK,\n            details: \"OK\"\n        };\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.on(\"error\", (err)=>{\n            this.pendingStatus = serverErrorToStatus(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.path;\n    }\n    getHost() {\n        return this.call.getHost();\n    }\n    _read(size) {\n        this.call.startRead();\n    }\n    _write(chunk, encoding, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback) {\n        this.call.sendMessage(chunk, callback);\n    }\n    _final(callback) {\n        var _a;\n        callback(null);\n        this.call.sendStatus(Object.assign(Object.assign({}, this.pendingStatus), {\n            metadata: (_a = this.pendingStatus.metadata) !== null && _a !== void 0 ? _a : this.trailingMetadata\n        }));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        return super.end();\n    }\n}\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl; //# sourceMappingURL=server-call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNhbGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDhCQUE4QixHQUFHQSxnQ0FBZ0MsR0FBR0EsZ0NBQWdDLEdBQUdBLDJCQUEyQixHQUFHLEtBQUs7QUFDMUlBLDJCQUEyQixHQUFHTTtBQUM5QixNQUFNQyxXQUFXQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRyxhQUFhSCxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxTQUFTRixvQkFBb0JNLEtBQUssRUFBRUMsZ0JBQWdCO0lBQ2hELElBQUlDO0lBQ0osTUFBTUMsU0FBUztRQUNYQyxNQUFNTixZQUFZTyxNQUFNLENBQUNDLE9BQU87UUFDaENDLFNBQVMsYUFBYVAsUUFBUUEsTUFBTVEsT0FBTyxHQUFHO1FBQzlDQyxVQUFVLENBQUNQLEtBQUtELHFCQUFxQixRQUFRQSxxQkFBcUIsS0FBSyxJQUFJQSxtQkFBbUJELE1BQU1TLFFBQVEsTUFBTSxRQUFRUCxPQUFPLEtBQUssSUFBSUEsS0FBSztJQUNuSjtJQUNBLElBQUksVUFBVUYsU0FDVixPQUFPQSxNQUFNSSxJQUFJLEtBQUssWUFDdEJNLE9BQU9DLFNBQVMsQ0FBQ1gsTUFBTUksSUFBSSxHQUFHO1FBQzlCRCxPQUFPQyxJQUFJLEdBQUdKLE1BQU1JLElBQUk7UUFDeEIsSUFBSSxhQUFhSixTQUFTLE9BQU9BLE1BQU1PLE9BQU8sS0FBSyxVQUFVO1lBQ3pESixPQUFPSSxPQUFPLEdBQUdQLE1BQU1PLE9BQU87UUFDbEM7SUFDSjtJQUNBLE9BQU9KO0FBQ1g7QUFDQSxNQUFNViw0QkFBNEJFLFNBQVNpQixZQUFZ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QUFVO1lBQ1YsSUFBSSxDQUFDdUIsZ0JBQWdCLEdBQUd2QjtRQUM1QjtRQUNBLE9BQU8sS0FBSyxDQUFDMkI7SUFDakI7QUFDSjtBQUNBaEQsOEJBQThCLEdBQUdFLHdCQUNqQyx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNhbGwuanM/NzIzYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsID0gZXhwb3J0cy5TZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwgPSBleHBvcnRzLlNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbCA9IGV4cG9ydHMuU2VydmVyVW5hcnlDYWxsSW1wbCA9IHZvaWQgMDtcbmV4cG9ydHMuc2VydmVyRXJyb3JUb1N0YXR1cyA9IHNlcnZlckVycm9yVG9TdGF0dXM7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmZ1bmN0aW9uIHNlcnZlckVycm9yVG9TdGF0dXMoZXJyb3IsIG92ZXJyaWRlVHJhaWxlcnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgc3RhdHVzID0ge1xuICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTixcbiAgICAgICAgZGV0YWlsczogJ21lc3NhZ2UnIGluIGVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIEVycm9yJyxcbiAgICAgICAgbWV0YWRhdGE6IChfYSA9IG92ZXJyaWRlVHJhaWxlcnMgIT09IG51bGwgJiYgb3ZlcnJpZGVUcmFpbGVycyAhPT0gdm9pZCAwID8gb3ZlcnJpZGVUcmFpbGVycyA6IGVycm9yLm1ldGFkYXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLFxuICAgIH07XG4gICAgaWYgKCdjb2RlJyBpbiBlcnJvciAmJlxuICAgICAgICB0eXBlb2YgZXJyb3IuY29kZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgTnVtYmVyLmlzSW50ZWdlcihlcnJvci5jb2RlKSkge1xuICAgICAgICBzdGF0dXMuY29kZSA9IGVycm9yLmNvZGU7XG4gICAgICAgIGlmICgnZGV0YWlscycgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yLmRldGFpbHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzdGF0dXMuZGV0YWlscyA9IGVycm9yLmRldGFpbHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXR1cztcbn1cbmNsYXNzIFNlcnZlclVuYXJ5Q2FsbEltcGwgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhdGgsIGNhbGwsIG1ldGFkYXRhLCByZXF1ZXN0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldERlYWRsaW5lKCk7XG4gICAgfVxuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGg7XG4gICAgfVxuICAgIGdldEhvc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0SG9zdCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyVW5hcnlDYWxsSW1wbCA9IFNlcnZlclVuYXJ5Q2FsbEltcGw7XG5jbGFzcyBTZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5SZWFkYWJsZSB7XG4gICAgY29uc3RydWN0b3IocGF0aCwgY2FsbCwgbWV0YWRhdGEpIHtcbiAgICAgICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLmNhbGwgPSBjYWxsO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgfVxuICAgIF9yZWFkKHNpemUpIHtcbiAgICAgICAgdGhpcy5jYWxsLnN0YXJ0UmVhZCgpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBlZXIoKTtcbiAgICB9XG4gICAgc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5jYWxsLnNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgZ2V0RGVhZGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0RGVhZGxpbmUoKTtcbiAgICB9XG4gICAgZ2V0UGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aDtcbiAgICB9XG4gICAgZ2V0SG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRIb3N0KCk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwgPSBTZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGw7XG5jbGFzcyBTZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5Xcml0YWJsZSB7XG4gICAgY29uc3RydWN0b3IocGF0aCwgY2FsbCwgbWV0YWRhdGEsIHJlcXVlc3QpIHtcbiAgICAgICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLmNhbGwgPSBjYWxsO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMucGVuZGluZ1N0YXR1cyA9IHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5PSyxcbiAgICAgICAgICAgIGRldGFpbHM6ICdPSycsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHJhaWxpbmdNZXRhZGF0YSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XG4gICAgICAgIHRoaXMub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1N0YXR1cyA9IHNlcnZlckVycm9yVG9TdGF0dXMoZXJyKTtcbiAgICAgICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBlZXIoKTtcbiAgICB9XG4gICAgc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5jYWxsLnNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgZ2V0RGVhZGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0RGVhZGxpbmUoKTtcbiAgICB9XG4gICAgZ2V0UGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aDtcbiAgICB9XG4gICAgZ2V0SG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRIb3N0KCk7XG4gICAgfVxuICAgIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsLnNlbmRNZXNzYWdlKGNodW5rLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIF9maW5hbChjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB0aGlzLmNhbGwuc2VuZFN0YXR1cyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucGVuZGluZ1N0YXR1cyksIHsgbWV0YWRhdGE6IChfYSA9IHRoaXMucGVuZGluZ1N0YXR1cy5tZXRhZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy50cmFpbGluZ01ldGFkYXRhIH0pKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBlbmQobWV0YWRhdGEpIHtcbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWlsaW5nTWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuZW5kKCk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwgPSBTZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGw7XG5jbGFzcyBTZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsIGV4dGVuZHMgc3RyZWFtXzEuRHVwbGV4IHtcbiAgICBjb25zdHJ1Y3RvcihwYXRoLCBjYWxsLCBtZXRhZGF0YSkge1xuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5wZW5kaW5nU3RhdHVzID0ge1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLk9LLFxuICAgICAgICAgICAgZGV0YWlsczogJ09LJyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50cmFpbGluZ01ldGFkYXRhID0gbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKTtcbiAgICAgICAgdGhpcy5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nU3RhdHVzID0gc2VydmVyRXJyb3JUb1N0YXR1cyhlcnIpO1xuICAgICAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGVlcigpO1xuICAgIH1cbiAgICBzZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSkge1xuICAgICAgICB0aGlzLmNhbGwuc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpO1xuICAgIH1cbiAgICBnZXREZWFkbGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXREZWFkbGluZSgpO1xuICAgIH1cbiAgICBnZXRQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRoO1xuICAgIH1cbiAgICBnZXRIb3N0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldEhvc3QoKTtcbiAgICB9XG4gICAgX3JlYWQoc2l6ZSkge1xuICAgICAgICB0aGlzLmNhbGwuc3RhcnRSZWFkKCk7XG4gICAgfVxuICAgIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsLnNlbmRNZXNzYWdlKGNodW5rLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIF9maW5hbChjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB0aGlzLmNhbGwuc2VuZFN0YXR1cyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucGVuZGluZ1N0YXR1cyksIHsgbWV0YWRhdGE6IChfYSA9IHRoaXMucGVuZGluZ1N0YXR1cy5tZXRhZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy50cmFpbGluZ01ldGFkYXRhIH0pKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBlbmQobWV0YWRhdGEpIHtcbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWlsaW5nTWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuZW5kKCk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsID0gU2VydmVyRHVwbGV4U3RyZWFtSW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZlci1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNlcnZlckR1cGxleFN0cmVhbUltcGwiLCJTZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwiLCJTZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwiLCJTZXJ2ZXJVbmFyeUNhbGxJbXBsIiwic2VydmVyRXJyb3JUb1N0YXR1cyIsImV2ZW50c18xIiwicmVxdWlyZSIsInN0cmVhbV8xIiwiY29uc3RhbnRzXzEiLCJtZXRhZGF0YV8xIiwiZXJyb3IiLCJvdmVycmlkZVRyYWlsZXJzIiwiX2EiLCJzdGF0dXMiLCJjb2RlIiwiU3RhdHVzIiwiVU5LTk9XTiIsImRldGFpbHMiLCJtZXNzYWdlIiwibWV0YWRhdGEiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJFdmVudEVtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsInBhdGgiLCJjYWxsIiwicmVxdWVzdCIsImNhbmNlbGxlZCIsImdldFBlZXIiLCJzZW5kTWV0YWRhdGEiLCJyZXNwb25zZU1ldGFkYXRhIiwiZ2V0RGVhZGxpbmUiLCJnZXRQYXRoIiwiZ2V0SG9zdCIsIlJlYWRhYmxlIiwib2JqZWN0TW9kZSIsIl9yZWFkIiwic2l6ZSIsInN0YXJ0UmVhZCIsIldyaXRhYmxlIiwicGVuZGluZ1N0YXR1cyIsIk9LIiwidHJhaWxpbmdNZXRhZGF0YSIsIk1ldGFkYXRhIiwib24iLCJlcnIiLCJlbmQiLCJfd3JpdGUiLCJjaHVuayIsImVuY29kaW5nIiwiY2FsbGJhY2siLCJzZW5kTWVzc2FnZSIsIl9maW5hbCIsInNlbmRTdGF0dXMiLCJhc3NpZ24iLCJEdXBsZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/server-call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-credentials.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ServerCredentials = void 0;\nexports.createCertificateProviderServerCredentials = createCertificateProviderServerCredentials;\nexports.createServerCredentialsWithInterceptors = createServerCredentialsWithInterceptors;\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\nclass ServerCredentials {\n    constructor(serverConstructorOptions, contextOptions){\n        this.serverConstructorOptions = serverConstructorOptions;\n        this.watchers = new Set();\n        this.latestContextOptions = null;\n        this.latestContextOptions = contextOptions !== null && contextOptions !== void 0 ? contextOptions : null;\n    }\n    _addWatcher(watcher) {\n        this.watchers.add(watcher);\n    }\n    _removeWatcher(watcher) {\n        this.watchers.delete(watcher);\n    }\n    getWatcherCount() {\n        return this.watchers.size;\n    }\n    updateSecureContextOptions(options) {\n        this.latestContextOptions = options;\n        for (const watcher of this.watchers){\n            watcher(this.latestContextOptions);\n        }\n    }\n    _isSecure() {\n        return this.serverConstructorOptions !== null;\n    }\n    _getSecureContextOptions() {\n        return this.latestContextOptions;\n    }\n    _getConstructorOptions() {\n        return this.serverConstructorOptions;\n    }\n    _getInterceptors() {\n        return [];\n    }\n    static createInsecure() {\n        return new InsecureServerCredentials();\n    }\n    static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {\n        var _a;\n        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {\n            throw new TypeError(\"rootCerts must be null or a Buffer\");\n        }\n        if (!Array.isArray(keyCertPairs)) {\n            throw new TypeError(\"keyCertPairs must be an array\");\n        }\n        if (typeof checkClientCertificate !== \"boolean\") {\n            throw new TypeError(\"checkClientCertificate must be a boolean\");\n        }\n        const cert = [];\n        const key = [];\n        for(let i = 0; i < keyCertPairs.length; i++){\n            const pair = keyCertPairs[i];\n            if (pair === null || typeof pair !== \"object\") {\n                throw new TypeError(`keyCertPair[${i}] must be an object`);\n            }\n            if (!Buffer.isBuffer(pair.private_key)) {\n                throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);\n            }\n            if (!Buffer.isBuffer(pair.cert_chain)) {\n                throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);\n            }\n            cert.push(pair.cert_chain);\n            key.push(pair.private_key);\n        }\n        return new SecureServerCredentials({\n            requestCert: checkClientCertificate,\n            ciphers: tls_helpers_1.CIPHER_SUITES\n        }, {\n            ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== void 0 ? _a : undefined,\n            cert,\n            key\n        });\n    }\n}\nexports.ServerCredentials = ServerCredentials;\nclass InsecureServerCredentials extends ServerCredentials {\n    constructor(){\n        super(null);\n    }\n    _getSettings() {\n        return null;\n    }\n    _equals(other) {\n        return other instanceof InsecureServerCredentials;\n    }\n}\nclass SecureServerCredentials extends ServerCredentials {\n    constructor(constructorOptions, contextOptions){\n        super(constructorOptions, contextOptions);\n        this.options = Object.assign(Object.assign({}, constructorOptions), contextOptions);\n    }\n    /**\n     * Checks equality by checking the options that are actually set by\n     * createSsl.\n     * @param other\n     * @returns\n     */ _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (!(other instanceof SecureServerCredentials)) {\n            return false;\n        }\n        // options.ca equality check\n        if (Buffer.isBuffer(this.options.ca) && Buffer.isBuffer(other.options.ca)) {\n            if (!this.options.ca.equals(other.options.ca)) {\n                return false;\n            }\n        } else {\n            if (this.options.ca !== other.options.ca) {\n                return false;\n            }\n        }\n        // options.cert equality check\n        if (Array.isArray(this.options.cert) && Array.isArray(other.options.cert)) {\n            if (this.options.cert.length !== other.options.cert.length) {\n                return false;\n            }\n            for(let i = 0; i < this.options.cert.length; i++){\n                const thisCert = this.options.cert[i];\n                const otherCert = other.options.cert[i];\n                if (Buffer.isBuffer(thisCert) && Buffer.isBuffer(otherCert)) {\n                    if (!thisCert.equals(otherCert)) {\n                        return false;\n                    }\n                } else {\n                    if (thisCert !== otherCert) {\n                        return false;\n                    }\n                }\n            }\n        } else {\n            if (this.options.cert !== other.options.cert) {\n                return false;\n            }\n        }\n        // options.key equality check\n        if (Array.isArray(this.options.key) && Array.isArray(other.options.key)) {\n            if (this.options.key.length !== other.options.key.length) {\n                return false;\n            }\n            for(let i = 0; i < this.options.key.length; i++){\n                const thisKey = this.options.key[i];\n                const otherKey = other.options.key[i];\n                if (Buffer.isBuffer(thisKey) && Buffer.isBuffer(otherKey)) {\n                    if (!thisKey.equals(otherKey)) {\n                        return false;\n                    }\n                } else {\n                    if (thisKey !== otherKey) {\n                        return false;\n                    }\n                }\n            }\n        } else {\n            if (this.options.key !== other.options.key) {\n                return false;\n            }\n        }\n        // options.requestCert equality check\n        if (this.options.requestCert !== other.options.requestCert) {\n            return false;\n        }\n        /* ciphers is derived from a value that is constant for the process, so no\n         * equality check is needed. */ return true;\n    }\n}\nclass CertificateProviderServerCredentials extends ServerCredentials {\n    constructor(identityCertificateProvider, caCertificateProvider, requireClientCertificate){\n        super({\n            requestCert: caCertificateProvider !== null,\n            rejectUnauthorized: requireClientCertificate,\n            ciphers: tls_helpers_1.CIPHER_SUITES\n        });\n        this.identityCertificateProvider = identityCertificateProvider;\n        this.caCertificateProvider = caCertificateProvider;\n        this.requireClientCertificate = requireClientCertificate;\n        this.latestCaUpdate = null;\n        this.latestIdentityUpdate = null;\n        this.caCertificateUpdateListener = this.handleCaCertificateUpdate.bind(this);\n        this.identityCertificateUpdateListener = this.handleIdentityCertitificateUpdate.bind(this);\n    }\n    _addWatcher(watcher) {\n        var _a;\n        if (this.getWatcherCount() === 0) {\n            (_a = this.caCertificateProvider) === null || _a === void 0 ? void 0 : _a.addCaCertificateListener(this.caCertificateUpdateListener);\n            this.identityCertificateProvider.addIdentityCertificateListener(this.identityCertificateUpdateListener);\n        }\n        super._addWatcher(watcher);\n    }\n    _removeWatcher(watcher) {\n        var _a;\n        super._removeWatcher(watcher);\n        if (this.getWatcherCount() === 0) {\n            (_a = this.caCertificateProvider) === null || _a === void 0 ? void 0 : _a.removeCaCertificateListener(this.caCertificateUpdateListener);\n            this.identityCertificateProvider.removeIdentityCertificateListener(this.identityCertificateUpdateListener);\n        }\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (!(other instanceof CertificateProviderServerCredentials)) {\n            return false;\n        }\n        return this.caCertificateProvider === other.caCertificateProvider && this.identityCertificateProvider === other.identityCertificateProvider && this.requireClientCertificate === other.requireClientCertificate;\n    }\n    calculateSecureContextOptions() {\n        var _a;\n        if (this.latestIdentityUpdate === null) {\n            return null;\n        }\n        if (this.caCertificateProvider !== null && this.latestCaUpdate === null) {\n            return null;\n        }\n        return {\n            ca: (_a = this.latestCaUpdate) === null || _a === void 0 ? void 0 : _a.caCertificate,\n            cert: [\n                this.latestIdentityUpdate.certificate\n            ],\n            key: [\n                this.latestIdentityUpdate.privateKey\n            ]\n        };\n    }\n    finalizeUpdate() {\n        const secureContextOptions = this.calculateSecureContextOptions();\n        this.updateSecureContextOptions(secureContextOptions);\n    }\n    handleCaCertificateUpdate(update) {\n        this.latestCaUpdate = update;\n        this.finalizeUpdate();\n    }\n    handleIdentityCertitificateUpdate(update) {\n        this.latestIdentityUpdate = update;\n        this.finalizeUpdate();\n    }\n}\nfunction createCertificateProviderServerCredentials(caCertificateProvider, identityCertificateProvider, requireClientCertificate) {\n    return new CertificateProviderServerCredentials(caCertificateProvider, identityCertificateProvider, requireClientCertificate);\n}\nclass InterceptorServerCredentials extends ServerCredentials {\n    constructor(childCredentials, interceptors){\n        super({});\n        this.childCredentials = childCredentials;\n        this.interceptors = interceptors;\n    }\n    _isSecure() {\n        return this.childCredentials._isSecure();\n    }\n    _equals(other) {\n        if (!(other instanceof InterceptorServerCredentials)) {\n            return false;\n        }\n        if (!this.childCredentials._equals(other.childCredentials)) {\n            return false;\n        }\n        if (this.interceptors.length !== other.interceptors.length) {\n            return false;\n        }\n        for(let i = 0; i < this.interceptors.length; i++){\n            if (this.interceptors[i] !== other.interceptors[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _getInterceptors() {\n        return this.interceptors;\n    }\n    _addWatcher(watcher) {\n        this.childCredentials._addWatcher(watcher);\n    }\n    _removeWatcher(watcher) {\n        this.childCredentials._removeWatcher(watcher);\n    }\n    _getConstructorOptions() {\n        return this.childCredentials._getConstructorOptions();\n    }\n    _getSecureContextOptions() {\n        return this.childCredentials._getSecureContextOptions();\n    }\n}\nfunction createServerCredentialsWithInterceptors(credentials, interceptors) {\n    return new InterceptorServerCredentials(credentials, interceptors);\n} //# sourceMappingURL=server-credentials.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNyZWRlbnRpYWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx5QkFBeUIsR0FBRyxLQUFLO0FBQ2pDQSxrREFBa0QsR0FBR0c7QUFDckRILCtDQUErQyxHQUFHSTtBQUNsRCxNQUFNQyxnQkFBZ0JDLG1CQUFPQSxDQUFDLGtGQUFlO0FBQzdDLE1BQU1KO0lBQ0ZLLFlBQVlDLHdCQUF3QixFQUFFQyxjQUFjLENBQUU7UUFDbEQsSUFBSSxDQUFDRCx3QkFBd0IsR0FBR0E7UUFDaEMsSUFBSSxDQUFDRSxRQUFRLEdBQUcsSUFBSUM7UUFDcEIsSUFBSSxDQUFDQyxvQkFBb0IsR0FBRztRQUM1QixJQUFJLENBQUNBLG9CQUFvQixHQUFHSCxtQkFBbUIsUUFBUUEsbUJBQW1CLEtBQUssSUFBSUEsaUJBQWlCO0lBQ3hHO0lBQ0FJLFlBQVlDLE9BQU8sRUFBRTtRQUNqQixJQUFJLENBQUNKLFFBQVEsQ0FBQ0ssR0FBRyxDQUFDRDtJQUN0QjtJQUNBRSxlQUFlRixPQUFPLEVBQUU7UUFDcEIsSUFBSSxDQUFDSixRQUFRLENBQUNPLE1BQU0sQ0FBQ0g7SUFDekI7SUFDQUksa0JBQWtCO1FBQ2QsT0FBTyxJQUFJLENBQUNSLFFBQVEsQ0FBQ1MsSUFBSTtJQUM3QjtJQUNBQywyQkFBMkJDLE9BQU8sRUFBRTtRQUNoQyxJQUFJLENBQUNULG9CQUFvQixHQUFHUztRQUM1QixLQUFLLE1BQU1QLFdBQVcsSUFBSSxDQUFDSixRQUFRLENBQUU7WUFDakNJLFFBQVEsSUFBSSxDQUFDRixvQkFBb0I7UUFDckM7SUFDSjtJQUNBVSxZQUFZO1FBQ1IsT0FBTyxJQUFJLENBQUNkLHdCQUF3QixLQUFLO0lBQzdDO0lBQ0FlLDJCQUEyQjtRQUN2QixPQUFPLElBQUksQ0FBQ1gsb0JB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SUFDQUUsZUFBZUYsT0FBTyxFQUFFO1FBQ3BCLElBQUksQ0FBQ3lFLGdCQUFnQixDQUFDdkUsY0FBYyxDQUFDRjtJQUN6QztJQUNBVSx5QkFBeUI7UUFDckIsT0FBTyxJQUFJLENBQUMrRCxnQkFBZ0IsQ0FBQy9ELHNCQUFzQjtJQUN2RDtJQUNBRCwyQkFBMkI7UUFDdkIsT0FBTyxJQUFJLENBQUNnRSxnQkFBZ0IsQ0FBQ2hFLHdCQUF3QjtJQUN6RDtBQUNKO0FBQ0EsU0FBU25CLHdDQUF3Q3FGLFdBQVcsRUFBRUQsWUFBWTtJQUN0RSxPQUFPLElBQUlGLDZCQUE2QkcsYUFBYUQ7QUFDekQsRUFDQSw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNyZWRlbnRpYWxzLmpzP2RjNzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2VydmVyQ3JlZGVudGlhbHMgPSB2b2lkIDA7XG5leHBvcnRzLmNyZWF0ZUNlcnRpZmljYXRlUHJvdmlkZXJTZXJ2ZXJDcmVkZW50aWFscyA9IGNyZWF0ZUNlcnRpZmljYXRlUHJvdmlkZXJTZXJ2ZXJDcmVkZW50aWFscztcbmV4cG9ydHMuY3JlYXRlU2VydmVyQ3JlZGVudGlhbHNXaXRoSW50ZXJjZXB0b3JzID0gY3JlYXRlU2VydmVyQ3JlZGVudGlhbHNXaXRoSW50ZXJjZXB0b3JzO1xuY29uc3QgdGxzX2hlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL3Rscy1oZWxwZXJzXCIpO1xuY2xhc3MgU2VydmVyQ3JlZGVudGlhbHMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZlckNvbnN0cnVjdG9yT3B0aW9ucywgY29udGV4dE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zZXJ2ZXJDb25zdHJ1Y3Rvck9wdGlvbnMgPSBzZXJ2ZXJDb25zdHJ1Y3Rvck9wdGlvbnM7XG4gICAgICAgIHRoaXMud2F0Y2hlcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMubGF0ZXN0Q29udGV4dE9wdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdENvbnRleHRPcHRpb25zID0gY29udGV4dE9wdGlvbnMgIT09IG51bGwgJiYgY29udGV4dE9wdGlvbnMgIT09IHZvaWQgMCA/IGNvbnRleHRPcHRpb25zIDogbnVsbDtcbiAgICB9XG4gICAgX2FkZFdhdGNoZXIod2F0Y2hlcikge1xuICAgICAgICB0aGlzLndhdGNoZXJzLmFkZCh3YXRjaGVyKTtcbiAgICB9XG4gICAgX3JlbW92ZVdhdGNoZXIod2F0Y2hlcikge1xuICAgICAgICB0aGlzLndhdGNoZXJzLmRlbGV0ZSh3YXRjaGVyKTtcbiAgICB9XG4gICAgZ2V0V2F0Y2hlckNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy53YXRjaGVycy5zaXplO1xuICAgIH1cbiAgICB1cGRhdGVTZWN1cmVDb250ZXh0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubGF0ZXN0Q29udGV4dE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBmb3IgKGNvbnN0IHdhdGNoZXIgb2YgdGhpcy53YXRjaGVycykge1xuICAgICAgICAgICAgd2F0Y2hlcih0aGlzLmxhdGVzdENvbnRleHRPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaXNTZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZlckNvbnN0cnVjdG9yT3B0aW9ucyAhPT0gbnVsbDtcbiAgICB9XG4gICAgX2dldFNlY3VyZUNvbnRleHRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXRlc3RDb250ZXh0T3B0aW9ucztcbiAgICB9XG4gICAgX2dldENvbnN0cnVjdG9yT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyQ29uc3RydWN0b3JPcHRpb25zO1xuICAgIH1cbiAgICBfZ2V0SW50ZXJjZXB0b3JzKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVJbnNlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnNlY3VyZVNlcnZlckNyZWRlbnRpYWxzKCk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVTc2wocm9vdENlcnRzLCBrZXlDZXJ0UGFpcnMsIGNoZWNrQ2xpZW50Q2VydGlmaWNhdGUgPSBmYWxzZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChyb290Q2VydHMgIT09IG51bGwgJiYgIUJ1ZmZlci5pc0J1ZmZlcihyb290Q2VydHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyb290Q2VydHMgbXVzdCBiZSBudWxsIG9yIGEgQnVmZmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGtleUNlcnRQYWlycykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2tleUNlcnRQYWlycyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja0NsaWVudENlcnRpZmljYXRlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NoZWNrQ2xpZW50Q2VydGlmaWNhdGUgbXVzdCBiZSBhIGJvb2xlYW4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjZXJ0ID0gW107XG4gICAgICAgIGNvbnN0IGtleSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleUNlcnRQYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGFpciA9IGtleUNlcnRQYWlyc1tpXTtcbiAgICAgICAgICAgIGlmIChwYWlyID09PSBudWxsIHx8IHR5cGVvZiBwYWlyICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGtleUNlcnRQYWlyWyR7aX1dIG11c3QgYmUgYW4gb2JqZWN0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYWlyLnByaXZhdGVfa2V5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGtleUNlcnRQYWlyWyR7aX1dLnByaXZhdGVfa2V5IG11c3QgYmUgYSBCdWZmZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHBhaXIuY2VydF9jaGFpbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBrZXlDZXJ0UGFpclske2l9XS5jZXJ0X2NoYWluIG11c3QgYmUgYSBCdWZmZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlcnQucHVzaChwYWlyLmNlcnRfY2hhaW4pO1xuICAgICAgICAgICAga2V5LnB1c2gocGFpci5wcml2YXRlX2tleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTZWN1cmVTZXJ2ZXJDcmVkZW50aWFscyh7XG4gICAgICAgICAgICByZXF1ZXN0Q2VydDogY2hlY2tDbGllbnRDZXJ0aWZpY2F0ZSxcbiAgICAgICAgICAgIGNpcGhlcnM6IHRsc19oZWxwZXJzXzEuQ0lQSEVSX1NVSVRFUyxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY2E6IChfYSA9IHJvb3RDZXJ0cyAhPT0gbnVsbCAmJiByb290Q2VydHMgIT09IHZvaWQgMCA/IHJvb3RDZXJ0cyA6ICgwLCB0bHNfaGVscGVyc18xLmdldERlZmF1bHRSb290c0RhdGEpKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNlcnQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyQ3JlZGVudGlhbHMgPSBTZXJ2ZXJDcmVkZW50aWFscztcbmNsYXNzIEluc2VjdXJlU2VydmVyQ3JlZGVudGlhbHMgZXh0ZW5kcyBTZXJ2ZXJDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKG51bGwpO1xuICAgIH1cbiAgICBfZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEluc2VjdXJlU2VydmVyQ3JlZGVudGlhbHM7XG4gICAgfVxufVxuY2xhc3MgU2VjdXJlU2VydmVyQ3JlZGVudGlhbHMgZXh0ZW5kcyBTZXJ2ZXJDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3IoY29uc3RydWN0b3JPcHRpb25zLCBjb250ZXh0T3B0aW9ucykge1xuICAgICAgICBzdXBlcihjb25zdHJ1Y3Rvck9wdGlvbnMsIGNvbnRleHRPcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25zdHJ1Y3Rvck9wdGlvbnMpLCBjb250ZXh0T3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBlcXVhbGl0eSBieSBjaGVja2luZyB0aGUgb3B0aW9ucyB0aGF0IGFyZSBhY3R1YWxseSBzZXQgYnlcbiAgICAgKiBjcmVhdGVTc2wuXG4gICAgICogQHBhcmFtIG90aGVyXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZWN1cmVTZXJ2ZXJDcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvcHRpb25zLmNhIGVxdWFsaXR5IGNoZWNrXG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodGhpcy5vcHRpb25zLmNhKSAmJiBCdWZmZXIuaXNCdWZmZXIob3RoZXIub3B0aW9ucy5jYSkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmNhLmVxdWFscyhvdGhlci5vcHRpb25zLmNhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2EgIT09IG90aGVyLm9wdGlvbnMuY2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3B0aW9ucy5jZXJ0IGVxdWFsaXR5IGNoZWNrXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5jZXJ0KSAmJiBBcnJheS5pc0FycmF5KG90aGVyLm9wdGlvbnMuY2VydCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2VydC5sZW5ndGggIT09IG90aGVyLm9wdGlvbnMuY2VydC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3B0aW9ucy5jZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGhpc0NlcnQgPSB0aGlzLm9wdGlvbnMuY2VydFtpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdGhlckNlcnQgPSBvdGhlci5vcHRpb25zLmNlcnRbaV07XG4gICAgICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0aGlzQ2VydCkgJiYgQnVmZmVyLmlzQnVmZmVyKG90aGVyQ2VydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzQ2VydC5lcXVhbHMob3RoZXJDZXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc0NlcnQgIT09IG90aGVyQ2VydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jZXJ0ICE9PSBvdGhlci5vcHRpb25zLmNlcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3B0aW9ucy5rZXkgZXF1YWxpdHkgY2hlY2tcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLmtleSkgJiYgQXJyYXkuaXNBcnJheShvdGhlci5vcHRpb25zLmtleSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2V5Lmxlbmd0aCAhPT0gb3RoZXIub3B0aW9ucy5rZXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMua2V5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGhpc0tleSA9IHRoaXMub3B0aW9ucy5rZXlbaV07XG4gICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJLZXkgPSBvdGhlci5vcHRpb25zLmtleVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHRoaXNLZXkpICYmIEJ1ZmZlci5pc0J1ZmZlcihvdGhlcktleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzS2V5LmVxdWFscyhvdGhlcktleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNLZXkgIT09IG90aGVyS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtleSAhPT0gb3RoZXIub3B0aW9ucy5rZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3B0aW9ucy5yZXF1ZXN0Q2VydCBlcXVhbGl0eSBjaGVja1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlcXVlc3RDZXJ0ICE9PSBvdGhlci5vcHRpb25zLnJlcXVlc3RDZXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyogY2lwaGVycyBpcyBkZXJpdmVkIGZyb20gYSB2YWx1ZSB0aGF0IGlzIGNvbnN0YW50IGZvciB0aGUgcHJvY2Vzcywgc28gbm9cbiAgICAgICAgICogZXF1YWxpdHkgY2hlY2sgaXMgbmVlZGVkLiAqL1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5jbGFzcyBDZXJ0aWZpY2F0ZVByb3ZpZGVyU2VydmVyQ3JlZGVudGlhbHMgZXh0ZW5kcyBTZXJ2ZXJDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3IoaWRlbnRpdHlDZXJ0aWZpY2F0ZVByb3ZpZGVyLCBjYUNlcnRpZmljYXRlUHJvdmlkZXIsIHJlcXVpcmVDbGllbnRDZXJ0aWZpY2F0ZSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICByZXF1ZXN0Q2VydDogY2FDZXJ0aWZpY2F0ZVByb3ZpZGVyICE9PSBudWxsLFxuICAgICAgICAgICAgcmVqZWN0VW5hdXRob3JpemVkOiByZXF1aXJlQ2xpZW50Q2VydGlmaWNhdGUsXG4gICAgICAgICAgICBjaXBoZXJzOiB0bHNfaGVscGVyc18xLkNJUEhFUl9TVUlURVNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaWRlbnRpdHlDZXJ0aWZpY2F0ZVByb3ZpZGVyID0gaWRlbnRpdHlDZXJ0aWZpY2F0ZVByb3ZpZGVyO1xuICAgICAgICB0aGlzLmNhQ2VydGlmaWNhdGVQcm92aWRlciA9IGNhQ2VydGlmaWNhdGVQcm92aWRlcjtcbiAgICAgICAgdGhpcy5yZXF1aXJlQ2xpZW50Q2VydGlmaWNhdGUgPSByZXF1aXJlQ2xpZW50Q2VydGlmaWNhdGU7XG4gICAgICAgIHRoaXMubGF0ZXN0Q2FVcGRhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdElkZW50aXR5VXBkYXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYUNlcnRpZmljYXRlVXBkYXRlTGlzdGVuZXIgPSB0aGlzLmhhbmRsZUNhQ2VydGlmaWNhdGVVcGRhdGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pZGVudGl0eUNlcnRpZmljYXRlVXBkYXRlTGlzdGVuZXIgPSB0aGlzLmhhbmRsZUlkZW50aXR5Q2VydGl0aWZpY2F0ZVVwZGF0ZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBfYWRkV2F0Y2hlcih3YXRjaGVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0V2F0Y2hlckNvdW50KCkgPT09IDApIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuY2FDZXJ0aWZpY2F0ZVByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkQ2FDZXJ0aWZpY2F0ZUxpc3RlbmVyKHRoaXMuY2FDZXJ0aWZpY2F0ZVVwZGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuaWRlbnRpdHlDZXJ0aWZpY2F0ZVByb3ZpZGVyLmFkZElkZW50aXR5Q2VydGlmaWNhdGVMaXN0ZW5lcih0aGlzLmlkZW50aXR5Q2VydGlmaWNhdGVVcGRhdGVMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuX2FkZFdhdGNoZXIod2F0Y2hlcik7XG4gICAgfVxuICAgIF9yZW1vdmVXYXRjaGVyKHdhdGNoZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlci5fcmVtb3ZlV2F0Y2hlcih3YXRjaGVyKTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0V2F0Y2hlckNvdW50KCkgPT09IDApIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuY2FDZXJ0aWZpY2F0ZVByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQ2FDZXJ0aWZpY2F0ZUxpc3RlbmVyKHRoaXMuY2FDZXJ0aWZpY2F0ZVVwZGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuaWRlbnRpdHlDZXJ0aWZpY2F0ZVByb3ZpZGVyLnJlbW92ZUlkZW50aXR5Q2VydGlmaWNhdGVMaXN0ZW5lcih0aGlzLmlkZW50aXR5Q2VydGlmaWNhdGVVcGRhdGVMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2VxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgQ2VydGlmaWNhdGVQcm92aWRlclNlcnZlckNyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5jYUNlcnRpZmljYXRlUHJvdmlkZXIgPT09IG90aGVyLmNhQ2VydGlmaWNhdGVQcm92aWRlciAmJlxuICAgICAgICAgICAgdGhpcy5pZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXIgPT09IG90aGVyLmlkZW50aXR5Q2VydGlmaWNhdGVQcm92aWRlciAmJlxuICAgICAgICAgICAgdGhpcy5yZXF1aXJlQ2xpZW50Q2VydGlmaWNhdGUgPT09IG90aGVyLnJlcXVpcmVDbGllbnRDZXJ0aWZpY2F0ZSk7XG4gICAgfVxuICAgIGNhbGN1bGF0ZVNlY3VyZUNvbnRleHRPcHRpb25zKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLmxhdGVzdElkZW50aXR5VXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYUNlcnRpZmljYXRlUHJvdmlkZXIgIT09IG51bGwgJiYgdGhpcy5sYXRlc3RDYVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhOiAoX2EgPSB0aGlzLmxhdGVzdENhVXBkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FDZXJ0aWZpY2F0ZSxcbiAgICAgICAgICAgIGNlcnQ6IFt0aGlzLmxhdGVzdElkZW50aXR5VXBkYXRlLmNlcnRpZmljYXRlXSxcbiAgICAgICAgICAgIGtleTogW3RoaXMubGF0ZXN0SWRlbnRpdHlVcGRhdGUucHJpdmF0ZUtleV0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZpbmFsaXplVXBkYXRlKCkge1xuICAgICAgICBjb25zdCBzZWN1cmVDb250ZXh0T3B0aW9ucyA9IHRoaXMuY2FsY3VsYXRlU2VjdXJlQ29udGV4dE9wdGlvbnMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTZWN1cmVDb250ZXh0T3B0aW9ucyhzZWN1cmVDb250ZXh0T3B0aW9ucyk7XG4gICAgfVxuICAgIGhhbmRsZUNhQ2VydGlmaWNhdGVVcGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHRoaXMubGF0ZXN0Q2FVcGRhdGUgPSB1cGRhdGU7XG4gICAgICAgIHRoaXMuZmluYWxpemVVcGRhdGUoKTtcbiAgICB9XG4gICAgaGFuZGxlSWRlbnRpdHlDZXJ0aXRpZmljYXRlVXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB0aGlzLmxhdGVzdElkZW50aXR5VXBkYXRlID0gdXBkYXRlO1xuICAgICAgICB0aGlzLmZpbmFsaXplVXBkYXRlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQ2VydGlmaWNhdGVQcm92aWRlclNlcnZlckNyZWRlbnRpYWxzKGNhQ2VydGlmaWNhdGVQcm92aWRlciwgaWRlbnRpdHlDZXJ0aWZpY2F0ZVByb3ZpZGVyLCByZXF1aXJlQ2xpZW50Q2VydGlmaWNhdGUpIHtcbiAgICByZXR1cm4gbmV3IENlcnRpZmljYXRlUHJvdmlkZXJTZXJ2ZXJDcmVkZW50aWFscyhjYUNlcnRpZmljYXRlUHJvdmlkZXIsIGlkZW50aXR5Q2VydGlmaWNhdGVQcm92aWRlciwgcmVxdWlyZUNsaWVudENlcnRpZmljYXRlKTtcbn1cbmNsYXNzIEludGVyY2VwdG9yU2VydmVyQ3JlZGVudGlhbHMgZXh0ZW5kcyBTZXJ2ZXJDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRDcmVkZW50aWFscywgaW50ZXJjZXB0b3JzKSB7XG4gICAgICAgIHN1cGVyKHt9KTtcbiAgICAgICAgdGhpcy5jaGlsZENyZWRlbnRpYWxzID0gY2hpbGRDcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRvcnMgPSBpbnRlcmNlcHRvcnM7XG4gICAgfVxuICAgIF9pc1NlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRDcmVkZW50aWFscy5faXNTZWN1cmUoKTtcbiAgICB9XG4gICAgX2VxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIEludGVyY2VwdG9yU2VydmVyQ3JlZGVudGlhbHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEodGhpcy5jaGlsZENyZWRlbnRpYWxzLl9lcXVhbHMob3RoZXIuY2hpbGRDcmVkZW50aWFscykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW50ZXJjZXB0b3JzLmxlbmd0aCAhPT0gb3RoZXIuaW50ZXJjZXB0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbnRlcmNlcHRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmludGVyY2VwdG9yc1tpXSAhPT0gb3RoZXIuaW50ZXJjZXB0b3JzW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfZ2V0SW50ZXJjZXB0b3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcmNlcHRvcnM7XG4gICAgfVxuICAgIF9hZGRXYXRjaGVyKHdhdGNoZXIpIHtcbiAgICAgICAgdGhpcy5jaGlsZENyZWRlbnRpYWxzLl9hZGRXYXRjaGVyKHdhdGNoZXIpO1xuICAgIH1cbiAgICBfcmVtb3ZlV2F0Y2hlcih3YXRjaGVyKSB7XG4gICAgICAgIHRoaXMuY2hpbGRDcmVkZW50aWFscy5fcmVtb3ZlV2F0Y2hlcih3YXRjaGVyKTtcbiAgICB9XG4gICAgX2dldENvbnN0cnVjdG9yT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRDcmVkZW50aWFscy5fZ2V0Q29uc3RydWN0b3JPcHRpb25zKCk7XG4gICAgfVxuICAgIF9nZXRTZWN1cmVDb250ZXh0T3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRDcmVkZW50aWFscy5fZ2V0U2VjdXJlQ29udGV4dE9wdGlvbnMoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVTZXJ2ZXJDcmVkZW50aWFsc1dpdGhJbnRlcmNlcHRvcnMoY3JlZGVudGlhbHMsIGludGVyY2VwdG9ycykge1xuICAgIHJldHVybiBuZXcgSW50ZXJjZXB0b3JTZXJ2ZXJDcmVkZW50aWFscyhjcmVkZW50aWFscywgaW50ZXJjZXB0b3JzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZlci1jcmVkZW50aWFscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTZXJ2ZXJDcmVkZW50aWFscyIsImNyZWF0ZUNlcnRpZmljYXRlUHJvdmlkZXJTZXJ2ZXJDcmVkZW50aWFscyIsImNyZWF0ZVNlcnZlckNyZWRlbnRpYWxzV2l0aEludGVyY2VwdG9ycyIsInRsc19oZWxwZXJzXzEiLCJyZXF1aXJlIiwiY29uc3RydWN0b3IiLCJzZXJ2ZXJDb25zdHJ1Y3Rvck9wdGlvbnMiLCJjb250ZXh0T3B0aW9ucyIsIndhdGNoZXJzIiwiU2V0IiwibGF0ZXN0Q29udGV4dE9wdGlvbnMiLCJfYWRkV2F0Y2hlciIsIndhdGNoZXIiLCJhZGQiLCJfcmVtb3ZlV2F0Y2hlciIsImRlbGV0ZSIsImdldFdhdGNoZXJDb3VudCIsInNpemUiLCJ1cGRhdGVTZWN1cmVDb250ZXh0T3B0aW9ucyIsIm9wdGlvbnMiLCJfaXNTZWN1cmUiLCJfZ2V0U2VjdXJlQ29udGV4dE9wdGlvbnMiLCJfZ2V0Q29uc3RydWN0b3JPcHRpb25zIiwiX2dldEludGVyY2VwdG9ycyIsImNyZWF0ZUluc2VjdXJlIiwiSW5zZWN1cmVTZXJ2ZXJDcmVkZW50aWFscyIsImNyZWF0ZVNzbCIsInJvb3RDZXJ0cyIsImtleUNlcnRQYWlycyIsImNoZWNrQ2xpZW50Q2VydGlmaWNhdGUiLCJfYSIsIkJ1ZmZlciIsImlzQnVmZmVyIiwiVHlwZUVycm9yIiwiQXJyYXkiLCJpc0FycmF5IiwiY2VydCIsImtleSIsImkiLCJsZW5ndGgiLCJwYWlyIiwicHJpdmF0ZV9rZXkiLCJjZXJ0X2NoYWluIiwicHVzaCIsIlNlY3VyZVNlcnZlckNyZWRlbnRpYWxzIiwicmVxdWVzdENlcnQiLCJjaXBoZXJzIiwiQ0lQSEVSX1NVSVRFUyIsImNhIiwiZ2V0RGVmYXVsdFJvb3RzRGF0YSIsInVuZGVmaW5lZCIsIl9nZXRTZXR0aW5ncyIsIl9lcXVhbHMiLCJvdGhlciIsImNvbnN0cnVjdG9yT3B0aW9ucyIsImFzc2lnbiIsImVxdWFscyIsInRoaXNDZXJ0Iiwib3RoZXJDZXJ0IiwidGhpc0tleSIsIm90aGVyS2V5IiwiQ2VydGlmaWNhdGVQcm92aWRlclNlcnZlckNyZWRlbnRpYWxzIiwiaWRlbnRpdHlDZXJ0aWZpY2F0ZVByb3ZpZGVyIiwiY2FDZXJ0aWZpY2F0ZVByb3ZpZGVyIiwicmVxdWlyZUNsaWVudENlcnRpZmljYXRlIiwicmVqZWN0VW5hdXRob3JpemVkIiwibGF0ZXN0Q2FVcGRhdGUiLCJsYXRlc3RJZGVudGl0eVVwZGF0ZSIsImNhQ2VydGlmaWNhdGVVcGRhdGVMaXN0ZW5lciIsImhhbmRsZUNhQ2VydGlmaWNhdGVVcGRhdGUiLCJiaW5kIiwiaWRlbnRpdHlDZXJ0aWZpY2F0ZVVwZGF0ZUxpc3RlbmVyIiwiaGFuZGxlSWRlbnRpdHlDZXJ0aXRpZmljYXRlVXBkYXRlIiwiYWRkQ2FDZXJ0aWZpY2F0ZUxpc3RlbmVyIiwiYWRkSWRlbnRpdHlDZXJ0aWZpY2F0ZUxpc3RlbmVyIiwicmVtb3ZlQ2FDZXJ0aWZpY2F0ZUxpc3RlbmVyIiwicmVtb3ZlSWRlbnRpdHlDZXJ0aWZpY2F0ZUxpc3RlbmVyIiwiY2FsY3VsYXRlU2VjdXJlQ29udGV4dE9wdGlvbnMiLCJjYUNlcnRpZmljYXRlIiwiY2VydGlmaWNhdGUiLCJwcml2YXRlS2V5IiwiZmluYWxpemVVcGRhdGUiLCJzZWN1cmVDb250ZXh0T3B0aW9ucyIsInVwZGF0ZSIsIkludGVyY2VwdG9yU2VydmVyQ3JlZGVudGlhbHMiLCJjaGlsZENyZWRlbnRpYWxzIiwiaW50ZXJjZXB0b3JzIiwiY3JlZGVudGlhbHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/server-interceptors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-interceptors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2024 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BaseServerInterceptingCall = exports.ServerInterceptingCall = exports.ResponderBuilder = exports.ServerListenerBuilder = void 0;\nexports.isInterceptingServerListener = isInterceptingServerListener;\nexports.getServerInterceptingCall = getServerInterceptingCall;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/error.js\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = \"server_call\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nclass ServerListenerBuilder {\n    constructor(){\n        this.metadata = undefined;\n        this.message = undefined;\n        this.halfClose = undefined;\n        this.cancel = undefined;\n    }\n    withOnReceiveMetadata(onReceiveMetadata) {\n        this.metadata = onReceiveMetadata;\n        return this;\n    }\n    withOnReceiveMessage(onReceiveMessage) {\n        this.message = onReceiveMessage;\n        return this;\n    }\n    withOnReceiveHalfClose(onReceiveHalfClose) {\n        this.halfClose = onReceiveHalfClose;\n        return this;\n    }\n    withOnCancel(onCancel) {\n        this.cancel = onCancel;\n        return this;\n    }\n    build() {\n        return {\n            onReceiveMetadata: this.metadata,\n            onReceiveMessage: this.message,\n            onReceiveHalfClose: this.halfClose,\n            onCancel: this.cancel\n        };\n    }\n}\nexports.ServerListenerBuilder = ServerListenerBuilder;\nfunction isInterceptingServerListener(listener) {\n    return listener.onReceiveMetadata !== undefined && listener.onReceiveMetadata.length === 1;\n}\nclass InterceptingServerListenerImpl {\n    constructor(listener, nextListener){\n        this.listener = listener;\n        this.nextListener = nextListener;\n        /**\n         * Once the call is cancelled, ignore all other events.\n         */ this.cancelled = false;\n        this.processingMetadata = false;\n        this.hasPendingMessage = false;\n        this.pendingMessage = null;\n        this.processingMessage = false;\n        this.hasPendingHalfClose = false;\n    }\n    processPendingMessage() {\n        if (this.hasPendingMessage) {\n            this.nextListener.onReceiveMessage(this.pendingMessage);\n            this.pendingMessage = null;\n            this.hasPendingMessage = false;\n        }\n    }\n    processPendingHalfClose() {\n        if (this.hasPendingHalfClose) {\n            this.nextListener.onReceiveHalfClose();\n            this.hasPendingHalfClose = false;\n        }\n    }\n    onReceiveMetadata(metadata) {\n        if (this.cancelled) {\n            return;\n        }\n        this.processingMetadata = true;\n        this.listener.onReceiveMetadata(metadata, (interceptedMetadata)=>{\n            this.processingMetadata = false;\n            if (this.cancelled) {\n                return;\n            }\n            this.nextListener.onReceiveMetadata(interceptedMetadata);\n            this.processPendingMessage();\n            this.processPendingHalfClose();\n        });\n    }\n    onReceiveMessage(message) {\n        if (this.cancelled) {\n            return;\n        }\n        this.processingMessage = true;\n        this.listener.onReceiveMessage(message, (msg)=>{\n            this.processingMessage = false;\n            if (this.cancelled) {\n                return;\n            }\n            if (this.processingMetadata) {\n                this.pendingMessage = msg;\n                this.hasPendingMessage = true;\n            } else {\n                this.nextListener.onReceiveMessage(msg);\n                this.processPendingHalfClose();\n            }\n        });\n    }\n    onReceiveHalfClose() {\n        if (this.cancelled) {\n            return;\n        }\n        this.listener.onReceiveHalfClose(()=>{\n            if (this.cancelled) {\n                return;\n            }\n            if (this.processingMetadata || this.processingMessage) {\n                this.hasPendingHalfClose = true;\n            } else {\n                this.nextListener.onReceiveHalfClose();\n            }\n        });\n    }\n    onCancel() {\n        this.cancelled = true;\n        this.listener.onCancel();\n        this.nextListener.onCancel();\n    }\n}\nclass ResponderBuilder {\n    constructor(){\n        this.start = undefined;\n        this.metadata = undefined;\n        this.message = undefined;\n        this.status = undefined;\n    }\n    withStart(start) {\n        this.start = start;\n        return this;\n    }\n    withSendMetadata(sendMetadata) {\n        this.metadata = sendMetadata;\n        return this;\n    }\n    withSendMessage(sendMessage) {\n        this.message = sendMessage;\n        return this;\n    }\n    withSendStatus(sendStatus) {\n        this.status = sendStatus;\n        return this;\n    }\n    build() {\n        return {\n            start: this.start,\n            sendMetadata: this.metadata,\n            sendMessage: this.message,\n            sendStatus: this.status\n        };\n    }\n}\nexports.ResponderBuilder = ResponderBuilder;\nconst defaultServerListener = {\n    onReceiveMetadata: (metadata, next)=>{\n        next(metadata);\n    },\n    onReceiveMessage: (message, next)=>{\n        next(message);\n    },\n    onReceiveHalfClose: (next)=>{\n        next();\n    },\n    onCancel: ()=>{}\n};\nconst defaultResponder = {\n    start: (next)=>{\n        next();\n    },\n    sendMetadata: (metadata, next)=>{\n        next(metadata);\n    },\n    sendMessage: (message, next)=>{\n        next(message);\n    },\n    sendStatus: (status, next)=>{\n        next(status);\n    }\n};\nclass ServerInterceptingCall {\n    constructor(nextCall, responder){\n        var _a, _b, _c, _d;\n        this.nextCall = nextCall;\n        this.processingMetadata = false;\n        this.sentMetadata = false;\n        this.processingMessage = false;\n        this.pendingMessage = null;\n        this.pendingMessageCallback = null;\n        this.pendingStatus = null;\n        this.responder = {\n            start: (_a = responder === null || responder === void 0 ? void 0 : responder.start) !== null && _a !== void 0 ? _a : defaultResponder.start,\n            sendMetadata: (_b = responder === null || responder === void 0 ? void 0 : responder.sendMetadata) !== null && _b !== void 0 ? _b : defaultResponder.sendMetadata,\n            sendMessage: (_c = responder === null || responder === void 0 ? void 0 : responder.sendMessage) !== null && _c !== void 0 ? _c : defaultResponder.sendMessage,\n            sendStatus: (_d = responder === null || responder === void 0 ? void 0 : responder.sendStatus) !== null && _d !== void 0 ? _d : defaultResponder.sendStatus\n        };\n    }\n    processPendingMessage() {\n        if (this.pendingMessageCallback) {\n            this.nextCall.sendMessage(this.pendingMessage, this.pendingMessageCallback);\n            this.pendingMessage = null;\n            this.pendingMessageCallback = null;\n        }\n    }\n    processPendingStatus() {\n        if (this.pendingStatus) {\n            this.nextCall.sendStatus(this.pendingStatus);\n            this.pendingStatus = null;\n        }\n    }\n    start(listener) {\n        this.responder.start((interceptedListener)=>{\n            var _a, _b, _c, _d;\n            const fullInterceptedListener = {\n                onReceiveMetadata: (_a = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultServerListener.onReceiveMetadata,\n                onReceiveMessage: (_b = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultServerListener.onReceiveMessage,\n                onReceiveHalfClose: (_c = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveHalfClose) !== null && _c !== void 0 ? _c : defaultServerListener.onReceiveHalfClose,\n                onCancel: (_d = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onCancel) !== null && _d !== void 0 ? _d : defaultServerListener.onCancel\n            };\n            const finalInterceptingListener = new InterceptingServerListenerImpl(fullInterceptedListener, listener);\n            this.nextCall.start(finalInterceptingListener);\n        });\n    }\n    sendMetadata(metadata) {\n        this.processingMetadata = true;\n        this.sentMetadata = true;\n        this.responder.sendMetadata(metadata, (interceptedMetadata)=>{\n            this.processingMetadata = false;\n            this.nextCall.sendMetadata(interceptedMetadata);\n            this.processPendingMessage();\n            this.processPendingStatus();\n        });\n    }\n    sendMessage(message, callback) {\n        this.processingMessage = true;\n        if (!this.sentMetadata) {\n            this.sendMetadata(new metadata_1.Metadata());\n        }\n        this.responder.sendMessage(message, (interceptedMessage)=>{\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessage = interceptedMessage;\n                this.pendingMessageCallback = callback;\n            } else {\n                this.nextCall.sendMessage(interceptedMessage, callback);\n            }\n        });\n    }\n    sendStatus(status) {\n        this.responder.sendStatus(status, (interceptedStatus)=>{\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingStatus = interceptedStatus;\n            } else {\n                this.nextCall.sendStatus(interceptedStatus);\n            }\n        });\n    }\n    startRead() {\n        this.nextCall.startRead();\n    }\n    getPeer() {\n        return this.nextCall.getPeer();\n    }\n    getDeadline() {\n        return this.nextCall.getDeadline();\n    }\n    getHost() {\n        return this.nextCall.getHost();\n    }\n}\nexports.ServerInterceptingCall = ServerInterceptingCall;\nconst GRPC_ACCEPT_ENCODING_HEADER = \"grpc-accept-encoding\";\nconst GRPC_ENCODING_HEADER = \"grpc-encoding\";\nconst GRPC_MESSAGE_HEADER = \"grpc-message\";\nconst GRPC_STATUS_HEADER = \"grpc-status\";\nconst GRPC_TIMEOUT_HEADER = \"grpc-timeout\";\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs = {\n    H: 3600000,\n    M: 60000,\n    S: 1000,\n    m: 1,\n    u: 0.001,\n    n: 0.000001\n};\nconst defaultCompressionHeaders = {\n    // TODO(cjihrig): Remove these encoding headers from the default response\n    // once compression is integrated.\n    [GRPC_ACCEPT_ENCODING_HEADER]: \"identity,deflate,gzip\",\n    [GRPC_ENCODING_HEADER]: \"identity\"\n};\nconst defaultResponseHeaders = {\n    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: \"application/grpc+proto\"\n};\nconst defaultResponseOptions = {\n    waitForTrailers: true\n};\nclass BaseServerInterceptingCall {\n    constructor(stream, headers, callEventTracker, handler, options){\n        var _a;\n        this.stream = stream;\n        this.callEventTracker = callEventTracker;\n        this.handler = handler;\n        this.listener = null;\n        this.deadlineTimer = null;\n        this.deadline = Infinity;\n        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        this.cancelled = false;\n        this.metadataSent = false;\n        this.wantTrailers = false;\n        this.cancelNotified = false;\n        this.incomingEncoding = \"identity\";\n        this.readQueue = [];\n        this.isReadPending = false;\n        this.receivedHalfClose = false;\n        this.streamEnded = false;\n        this.stream.once(\"error\", (err)=>{\n        /* We need an error handler to avoid uncaught error event exceptions, but\n             * there is nothing we can reasonably do here. Any error event should\n             * have a corresponding close event, which handles emitting the cancelled\n             * event. And the stream is now in a bad state, so we can't reasonably\n             * expect to be able to send an error over it. */ });\n        this.stream.once(\"close\", ()=>{\n            var _a;\n            trace(\"Request to method \" + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + \" stream closed with rstCode \" + this.stream.rstCode);\n            if (this.callEventTracker && !this.streamEnded) {\n                this.streamEnded = true;\n                this.callEventTracker.onStreamEnd(false);\n                this.callEventTracker.onCallEnd({\n                    code: constants_1.Status.CANCELLED,\n                    details: \"Stream closed before sending status\",\n                    metadata: null\n                });\n            }\n            this.notifyOnCancel();\n        });\n        this.stream.on(\"data\", (data)=>{\n            this.handleDataFrame(data);\n        });\n        this.stream.pause();\n        this.stream.on(\"end\", ()=>{\n            this.handleEndEvent();\n        });\n        if (\"grpc.max_send_message_length\" in options) {\n            this.maxSendMessageSize = options[\"grpc.max_send_message_length\"];\n        }\n        if (\"grpc.max_receive_message_length\" in options) {\n            this.maxReceiveMessageSize = options[\"grpc.max_receive_message_length\"];\n        }\n        this.host = (_a = headers[\":authority\"]) !== null && _a !== void 0 ? _a : headers.host;\n        this.decoder = new stream_decoder_1.StreamDecoder(this.maxReceiveMessageSize);\n        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        if (logging.isTracerEnabled(TRACER_NAME)) {\n            trace(\"Request to \" + this.handler.path + \" received headers \" + JSON.stringify(metadata.toJSON()));\n        }\n        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n        if (timeoutHeader.length > 0) {\n            this.handleTimeoutHeader(timeoutHeader[0]);\n        }\n        const encodingHeader = metadata.get(GRPC_ENCODING_HEADER);\n        if (encodingHeader.length > 0) {\n            this.incomingEncoding = encodingHeader[0];\n        }\n        // Remove several headers that should not be propagated to the application\n        metadata.remove(GRPC_TIMEOUT_HEADER);\n        metadata.remove(GRPC_ENCODING_HEADER);\n        metadata.remove(GRPC_ACCEPT_ENCODING_HEADER);\n        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n        metadata.remove(http2.constants.HTTP2_HEADER_TE);\n        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n        this.metadata = metadata;\n    }\n    handleTimeoutHeader(timeoutHeader) {\n        const match = timeoutHeader.toString().match(DEADLINE_REGEX);\n        if (match === null) {\n            const status = {\n                code: constants_1.Status.INTERNAL,\n                details: `Invalid ${GRPC_TIMEOUT_HEADER} value \"${timeoutHeader}\"`,\n                metadata: null\n            };\n            // Wait for the constructor to complete before sending the error.\n            process.nextTick(()=>{\n                this.sendStatus(status);\n            });\n            return;\n        }\n        const timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;\n        const now = new Date();\n        this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n        this.deadlineTimer = setTimeout(()=>{\n            const status = {\n                code: constants_1.Status.DEADLINE_EXCEEDED,\n                details: \"Deadline exceeded\",\n                metadata: null\n            };\n            this.sendStatus(status);\n        }, timeout);\n    }\n    checkCancelled() {\n        /* In some cases the stream can become destroyed before the close event\n         * fires. That creates a race condition that this check works around */ if (!this.cancelled && (this.stream.destroyed || this.stream.closed)) {\n            this.notifyOnCancel();\n            this.cancelled = true;\n        }\n        return this.cancelled;\n    }\n    notifyOnCancel() {\n        if (this.cancelNotified) {\n            return;\n        }\n        this.cancelNotified = true;\n        this.cancelled = true;\n        process.nextTick(()=>{\n            var _a;\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onCancel();\n        });\n        if (this.deadlineTimer) {\n            clearTimeout(this.deadlineTimer);\n        }\n        // Flush incoming data frames\n        this.stream.resume();\n    }\n    /**\n     * A server handler can start sending messages without explicitly sending\n     * metadata. In that case, we need to send headers before sending any\n     * messages. This function does that if necessary.\n     */ maybeSendMetadata() {\n        if (!this.metadataSent) {\n            this.sendMetadata(new metadata_1.Metadata());\n        }\n    }\n    /**\n     * Serialize a message to a length-delimited byte string.\n     * @param value\n     * @returns\n     */ serializeMessage(value) {\n        const messageBuffer = this.handler.serialize(value);\n        const byteLength = messageBuffer.byteLength;\n        const output = Buffer.allocUnsafe(byteLength + 5);\n        /* Note: response compression is currently not supported, so this\n         * compressed bit is always 0. */ output.writeUInt8(0, 0);\n        output.writeUInt32BE(byteLength, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    decompressMessage(message, encoding) {\n        const messageContents = message.subarray(5);\n        if (encoding === \"identity\") {\n            return messageContents;\n        } else if (encoding === \"deflate\" || encoding === \"gzip\") {\n            let decompresser;\n            if (encoding === \"deflate\") {\n                decompresser = zlib.createInflate();\n            } else {\n                decompresser = zlib.createGunzip();\n            }\n            return new Promise((resolve, reject)=>{\n                let totalLength = 0;\n                const messageParts = [];\n                decompresser.on(\"data\", (chunk)=>{\n                    messageParts.push(chunk);\n                    totalLength += chunk.byteLength;\n                    if (this.maxReceiveMessageSize !== -1 && totalLength > this.maxReceiveMessageSize) {\n                        decompresser.destroy();\n                        reject({\n                            code: constants_1.Status.RESOURCE_EXHAUSTED,\n                            details: `Received message that decompresses to a size larger than ${this.maxReceiveMessageSize}`\n                        });\n                    }\n                });\n                decompresser.on(\"end\", ()=>{\n                    resolve(Buffer.concat(messageParts));\n                });\n                decompresser.write(messageContents);\n                decompresser.end();\n            });\n        } else {\n            return Promise.reject({\n                code: constants_1.Status.UNIMPLEMENTED,\n                details: `Received message compressed with unsupported encoding \"${encoding}\"`\n            });\n        }\n    }\n    async decompressAndMaybePush(queueEntry) {\n        if (queueEntry.type !== \"COMPRESSED\") {\n            throw new Error(`Invalid queue entry type: ${queueEntry.type}`);\n        }\n        const compressed = queueEntry.compressedMessage.readUInt8(0) === 1;\n        const compressedMessageEncoding = compressed ? this.incomingEncoding : \"identity\";\n        let decompressedMessage;\n        try {\n            decompressedMessage = await this.decompressMessage(queueEntry.compressedMessage, compressedMessageEncoding);\n        } catch (err) {\n            this.sendStatus(err);\n            return;\n        }\n        try {\n            queueEntry.parsedMessage = this.handler.deserialize(decompressedMessage);\n        } catch (err) {\n            this.sendStatus({\n                code: constants_1.Status.INTERNAL,\n                details: `Error deserializing request: ${err.message}`\n            });\n            return;\n        }\n        queueEntry.type = \"READABLE\";\n        this.maybePushNextMessage();\n    }\n    maybePushNextMessage() {\n        if (this.listener && this.isReadPending && this.readQueue.length > 0 && this.readQueue[0].type !== \"COMPRESSED\") {\n            this.isReadPending = false;\n            const nextQueueEntry = this.readQueue.shift();\n            if (nextQueueEntry.type === \"READABLE\") {\n                this.listener.onReceiveMessage(nextQueueEntry.parsedMessage);\n            } else {\n                // nextQueueEntry.type === 'HALF_CLOSE'\n                this.listener.onReceiveHalfClose();\n            }\n        }\n    }\n    handleDataFrame(data) {\n        var _a;\n        if (this.checkCancelled()) {\n            return;\n        }\n        trace(\"Request to \" + this.handler.path + \" received data frame of size \" + data.length);\n        let rawMessages;\n        try {\n            rawMessages = this.decoder.write(data);\n        } catch (e) {\n            this.sendStatus({\n                code: constants_1.Status.RESOURCE_EXHAUSTED,\n                details: e.message\n            });\n            return;\n        }\n        for (const messageBytes of rawMessages){\n            this.stream.pause();\n            const queueEntry = {\n                type: \"COMPRESSED\",\n                compressedMessage: messageBytes,\n                parsedMessage: null\n            };\n            this.readQueue.push(queueEntry);\n            this.decompressAndMaybePush(queueEntry);\n            (_a = this.callEventTracker) === null || _a === void 0 ? void 0 : _a.addMessageReceived();\n        }\n    }\n    handleEndEvent() {\n        this.readQueue.push({\n            type: \"HALF_CLOSE\",\n            compressedMessage: null,\n            parsedMessage: null\n        });\n        this.receivedHalfClose = true;\n        this.maybePushNextMessage();\n    }\n    start(listener) {\n        trace(\"Request to \" + this.handler.path + \" start called\");\n        if (this.checkCancelled()) {\n            return;\n        }\n        this.listener = listener;\n        listener.onReceiveMetadata(this.metadata);\n    }\n    sendMetadata(metadata) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.metadataSent) {\n            return;\n        }\n        this.metadataSent = true;\n        const custom = metadata ? metadata.toHttp2Headers() : null;\n        const headers = Object.assign(Object.assign(Object.assign({}, defaultResponseHeaders), defaultCompressionHeaders), custom);\n        this.stream.respond(headers, defaultResponseOptions);\n    }\n    sendMessage(message, callback) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        let response;\n        try {\n            response = this.serializeMessage(message);\n        } catch (e) {\n            this.sendStatus({\n                code: constants_1.Status.INTERNAL,\n                details: `Error serializing response: ${(0, error_1.getErrorMessage)(e)}`,\n                metadata: null\n            });\n            return;\n        }\n        if (this.maxSendMessageSize !== -1 && response.length - 5 > this.maxSendMessageSize) {\n            this.sendStatus({\n                code: constants_1.Status.RESOURCE_EXHAUSTED,\n                details: `Sent message larger than max (${response.length} vs. ${this.maxSendMessageSize})`,\n                metadata: null\n            });\n            return;\n        }\n        this.maybeSendMetadata();\n        trace(\"Request to \" + this.handler.path + \" sent data frame of size \" + response.length);\n        this.stream.write(response, (error)=>{\n            var _a;\n            if (error) {\n                this.sendStatus({\n                    code: constants_1.Status.INTERNAL,\n                    details: `Error writing message: ${(0, error_1.getErrorMessage)(error)}`,\n                    metadata: null\n                });\n                return;\n            }\n            (_a = this.callEventTracker) === null || _a === void 0 ? void 0 : _a.addMessageSent();\n            callback();\n        });\n    }\n    sendStatus(status) {\n        var _a, _b;\n        if (this.checkCancelled()) {\n            return;\n        }\n        trace(\"Request to method \" + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + \" ended with status code: \" + constants_1.Status[status.code] + \" details: \" + status.details);\n        if (this.metadataSent) {\n            if (!this.wantTrailers) {\n                this.wantTrailers = true;\n                this.stream.once(\"wantTrailers\", ()=>{\n                    var _a;\n                    if (this.callEventTracker && !this.streamEnded) {\n                        this.streamEnded = true;\n                        this.callEventTracker.onStreamEnd(true);\n                        this.callEventTracker.onCallEnd(status);\n                    }\n                    const trailersToSend = Object.assign({\n                        [GRPC_STATUS_HEADER]: status.code,\n                        [GRPC_MESSAGE_HEADER]: encodeURI(status.details)\n                    }, (_a = status.metadata) === null || _a === void 0 ? void 0 : _a.toHttp2Headers());\n                    this.stream.sendTrailers(trailersToSend);\n                    this.notifyOnCancel();\n                });\n                this.stream.end();\n            } else {\n                this.notifyOnCancel();\n            }\n        } else {\n            if (this.callEventTracker && !this.streamEnded) {\n                this.streamEnded = true;\n                this.callEventTracker.onStreamEnd(true);\n                this.callEventTracker.onCallEnd(status);\n            }\n            // Trailers-only response\n            const trailersToSend = Object.assign(Object.assign({\n                [GRPC_STATUS_HEADER]: status.code,\n                [GRPC_MESSAGE_HEADER]: encodeURI(status.details)\n            }, defaultResponseHeaders), (_b = status.metadata) === null || _b === void 0 ? void 0 : _b.toHttp2Headers());\n            this.stream.respond(trailersToSend, {\n                endStream: true\n            });\n            this.notifyOnCancel();\n        }\n    }\n    startRead() {\n        trace(\"Request to \" + this.handler.path + \" startRead called\");\n        if (this.checkCancelled()) {\n            return;\n        }\n        this.isReadPending = true;\n        if (this.readQueue.length === 0) {\n            if (!this.receivedHalfClose) {\n                this.stream.resume();\n            }\n        } else {\n            this.maybePushNextMessage();\n        }\n    }\n    getPeer() {\n        var _a;\n        const socket = (_a = this.stream.session) === null || _a === void 0 ? void 0 : _a.socket;\n        if (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) {\n            if (socket.remotePort) {\n                return `${socket.remoteAddress}:${socket.remotePort}`;\n            } else {\n                return socket.remoteAddress;\n            }\n        } else {\n            return \"unknown\";\n        }\n    }\n    getDeadline() {\n        return this.deadline;\n    }\n    getHost() {\n        return this.host;\n    }\n}\nexports.BaseServerInterceptingCall = BaseServerInterceptingCall;\nfunction getServerInterceptingCall(interceptors, stream, headers, callEventTracker, handler, options) {\n    const methodDefinition = {\n        path: handler.path,\n        requestStream: handler.type === \"clientStream\" || handler.type === \"bidi\",\n        responseStream: handler.type === \"serverStream\" || handler.type === \"bidi\",\n        requestDeserialize: handler.deserialize,\n        responseSerialize: handler.serialize\n    };\n    const baseCall = new BaseServerInterceptingCall(stream, headers, callEventTracker, handler, options);\n    return interceptors.reduce((call, interceptor)=>{\n        return interceptor(methodDefinition, call);\n    }, baseCall);\n} //# sourceMappingURL=server-interceptors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWludGVyY2VwdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0NBQWtDLEdBQUdBLDhCQUE4QixHQUFHQSx3QkFBd0IsR0FBR0EsNkJBQTZCLEdBQUcsS0FBSztBQUN0SUEsb0NBQW9DLEdBQUdNO0FBQ3ZDTixpQ0FBaUMsR0FBR087QUFDcEMsTUFBTUMsYUFBYUMsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUUsUUFBUUYsbUJBQU9BLENBQUMsb0JBQU87QUFDN0IsTUFBTUcsVUFBVUgsbUJBQU9BLENBQUMsc0VBQVM7QUFDakMsTUFBTUksT0FBT0osbUJBQU9BLENBQUMsa0JBQU07QUFDM0IsTUFBTUssbUJBQW1CTCxtQkFBT0EsQ0FBQyx3RkFBa0I7QUFDbkQsTUFBTU0sVUFBVU4sbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTU8sY0FBYztBQUNwQixTQUFTQyxNQUFNQyxJQUFJO0lBQ2ZILFFBQVFFLEtBQUssQ0FBQ1AsWUFBWVMsWUFBWSxDQUFDQyxLQUFLLEVBQUVKLGFBQWFFO0FBQy9EO0FBQ0EsTUFBTWI7SUFDRmdCLGFBQWM7UUFDVixJQUFJLENBQUNDLFFBQVEsR0FBR0M7UUFDaEIsSUFBSSxDQUFDQyxPQUFPLEdBQUdEO1FBQ2YsSUFBSSxDQUFDRSxTQUFTLEdBQUdGO1FBQ2pCLElBQUksQ0FBQ0csTUFBTSxHQUFHSDtJQUNsQjtJQUNBSSxzQkFBc0JDLGlCQUFpQixFQUFFO1FBQ3JDLElBQUksQ0FBQ04sUUFBUSxHQUFHTTtRQUNoQixPQUFPLElBQUk7SUFDZjtJQUNBQyxxQkFBcUJDLGdCQUFnQixFQUFFO1FBQ25DLElBQUksQ0FBQ04sT0FBTyxHQUFHTTtRQUNmLE9BQU8sSUFBSTtJQUNmO0lBQ0FDLHVCQUF1QkMsa0JBQWtCLEVBQUU7UUFDdkMsSUFBSSxDQUFDUCxTQUFTLEdBQUdPO1FBQ2pCLE9BQU8sSUFBSTtJQUNmO0lBQ0FDLGFBQWFDLFFBQVEsRUFBRTtRQUNuQixJQUFJLENBQUNSLE1BQU0sR0FBR1E7UUFDZCxPQUFPLElBQUk7SUFDZjtJQUNBQyxRQUFRO1FBQ0osT0FBTztZQUNIUCxtQkFBbUIsSUFBSSxDQUFDTixRQUFRO1lBQ2hDUSxrQkFBa0IsSUFBSSxDQUFDTixPQUFPO1lBQzlCUSxvQkFBb0IsSUFBSSxDQUFDUCxTQUFTO1lBQ2xDUyxVQUFVLElBQUksQ0FBQ1IsTUFBTTtRQUN6QjtJQUNKO0FBQ0o7QUFDQTFCLDZCQUE2QixHQUFHSztBQUNoQyxTQUFTQyw2QkFBNkI4QixRQUFRO0lBQzFDLE9BQVFBLFNBQVNSLGlCQUFpQixLQUFLTCxhQUNuQ2EsU0FBU1IsaUJBQWlCLENBQUNTLE1BQU0sS0FBSztBQUM5QztBQUNBLE1BQU1DO0lBQ0ZqQixZQUFZZSxRQUFRLEVBQUVHLFlBQVksQ0FBRTtRQUNoQyxJQUFJLENBQUNILFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDRyxZQUFZLEdBQUdBO1FBQ3BCOztTQUVDLEdBQ0QsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztRQUMxQixJQUFJLENBQUNDLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRztJQUMvQjtJQUNBQyx3QkFBd0I7UUFDcEIsSUFBSSxJQUFJLENBQUNKLGlCQUFpQixFQUFFO1lBQ3hCLElBQUksQ0FBQ0gsWUFBWSxDQUFDVCxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNhLGNBQWM7WUFDdEQsSUFBSSxDQUFDQSxjQUFjLEdBQUc7WUFDdEIsSUFBSSxDQUFDRCxpQkFBaUIsR0FBRztRQUM3QjtJQUNKO0lBQ0FLLDBCQUEwQjtRQUN0QixJQUFJLElBQUksQ0FBQ0YsbUJBQW1CLEVBQUU7WUFDMUIsSUFBSSxDQUFDTixZQUFZLENBQUNQLGtCQUFrQjtZQUNwQyxJQUFJLENBQUNhLG1CQUFtQixHQUFHO1FBQy9CO0lBQ0o7SUFDQWpCLGtCQUFrQk4sUUFBUSxFQUFFO1FBQ3hCLElBQUksSUFBSSxDQUFDa0IsU0FBUyxFQUFFO1lBQ2hCO1FBQ0o7UUFDQSxJQUFJLENBQUNDLGtCQUFrQixHQUFHO1FBQzFCLElBQUksQ0FBQ0wsUUFBUSxDQUFDUixpQkFBaUIsQ0FBQ04sVUFBVTBCLENBQUFBO1lBQ3RDLElBQUksQ0FBQ1Asa0JBQWtCLEdBQUc7WUFDMUIsSUFBSSxJQUFJLENBQUNELFNBQVMsRUFBRTtnQkFDaEI7WUFDSjtZQUNBLElBQUksQ0FBQ0QsWUFBWSxDQUFDWCxpQkFBaUIsQ0FBQ29CO1lBQ3BDLElBQUksQ0FBQ0YscUJBQXFCO1lBQzFCLElBQUksQ0FBQ0MsdUJBQXVCO1FBQ2hDO0lBQ0o7SUFDQWpCLGlCQUFpQk4sT0FBTyxFQUFFO1FBQ3RCLElBQUksSUFBSSxDQUFDZ0IsU0FBUyxFQUFFO1lBQ2hCO1FBQ0o7UUFDQSxJQUFJLENBQUNJLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQ1IsUUFBUSxDQUFDTixnQkFBZ0IsQ0FBQ04sU0FBU3lCLENBQUFBO1lBQ3BDLElBQUksQ0FBQ0wsaUJBQWlCLEdBQUc7WUFDekIsSUFBSSxJQUFJLENBQUNKLFNBQVMsRUFBRTtnQkFDaEI7WUFDSjtZQUNBLElBQUksSUFBSSxDQUFDQyxrQkFBa0IsRUFBRTtnQkFDekIsSUFBSSxDQUFDRSxjQUFjLEdBQUdNO2dCQUN0QixJQUFJLENBQUNQLGlCQUFpQixHQUFHO1lBQzdCLE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDSCxZQUFZLENBQUNULGdCQUFnQixDQUFDbUI7Z0JBQ25DLElBQUksQ0FBQ0YsdUJBQXVCO1lBQ2hDO1FBQ0o7SUFDSjtJQUNBZixxQkFBcUI7UUFDakIsSUFBSSxJQUFJLENBQUNRLFNBQVMsRUFBRTtZQUNoQjtRQUNKO1FBQ0EsSUFBSSxDQUFDSixRQUFRLENBQUNKLGtCQUFrQixDQUFDO1lBQzdCLElBQUksSUFBSSxDQUFDUSxTQUFTLEVBQUU7Z0JBQ2hCO1lBQ0o7WUFDQSxJQUFJLElBQUksQ0FBQ0Msa0JBQWtCLElBQUksSUFBSSxDQUFDRyxpQkFBaUIsRUFBRTtnQkFDbkQsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRztZQUMvQixPQUNLO2dCQUNELElBQUksQ0FBQ04sWUFBWSxDQUFDUCxrQkFBa0I7WUFDeEM7UUFDSjtJQUNKO0lBQ0FFLFdBQVc7UUFDUCxJQUFJLENBQUNNLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNKLFFBQVEsQ0FBQ0YsUUFBUTtRQUN0QixJQUFJLENBQUNLLFlBQVksQ0FBQ0wsUUFBUTtJQUM5QjtBQUNKO0FBQ0EsTUFBTTlCO0lBQ0ZpQixhQUFjO1FBQ1YsSUFBSSxDQUFDNkIsS0FBSyxHQUFHM0I7UUFDYixJQUFJLENBQUNELFFBQVEsR0FBR0M7UUFDaEIsSUFBSSxDQUFDQyxPQUFPLEdBQUdEO1FBQ2YsSUFBSSxDQUFDNEIsTUFBTSxHQUFHNUI7SUFDbEI7SUFDQTZCLFVBQVVGLEtBQUssRUFBRTtRQUNiLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtRQUNiLE9BQU8sSUFBSTtJQUNmO0lBQ0FHLGlCQUFpQkMsWUFBWSxFQUFFO1FBQzNCLElBQUksQ0FBQ2hDLFFBQVEsR0FBR2dDO1FBQ2hCLE9BQU8sSUFBSTtJQUNmO0lBQ0FDLGdCQUFnQkMsV0FBVyxFQUFFO1FBQ3pCLElBQUksQ0FBQ2hDLE9BQU8sR0FBR2dDO1FBQ2YsT0FBTyxJQUFJO0lBQ2Y7SUFDQUMsZUFBZUMsVUFBVSxFQUFFO1FBQ3ZCLElBQUksQ0FBQ1AsTUFBTSxHQUFHTztRQUNkLE9BQU8sSUFBSTtJQUNmO0lBQ0F2QixRQUFRO1FBQ0osT0FBTztZQUNIZSxPQUFPLElBQUksQ0FBQ0EsS0FBSztZQUNqQkksY0FBYyxJQUFJLENBQUNoQyxRQUFRO1lBQzNCa0MsYUFBYSxJQUFJLENBQUNoQyxPQUFPO1lBQ3pCa0MsWUFBWSxJQUFJLENBQUNQLE1BQU07UUFDM0I7SUFDSjtBQUNKO0FBQ0FuRCx3QkFBd0IsR0FBR0k7QUFDM0IsTUFBTXVELHdCQUF3QjtJQUMxQi9CLG1CQUFtQixDQUFDTixVQUFVc0M7UUFDMUJBLEtBQUt0QztJQUNUO0lBQ0FRLGtCQUFrQixDQUFDTixTQUFTb0M7UUFDeEJBLEtBQUtwQztJQUNUO0lBQ0FRLG9CQUFvQjRCLENBQUFBO1FBQ2hCQTtJQUNKO0lBQ0ExQixVQUFVLEtBQVE7QUFDdEI7QUFDQSxNQUFNMkIsbUJBQW1CO0lBQ3JCWCxPQUFPVSxDQUFBQTtRQUNIQTtJQUNKO0lBQ0FOLGNBQWMsQ0FBQ2hDLFVBQVVzQztRQUNyQkEsS0FBS3RDO0lBQ1Q7SUFDQWtDLGFBQWEsQ0FBQ2hDLFNBQVNvQztRQUNuQkEsS0FBS3BDO0lBQ1Q7SUFDQWtDLFlBQVksQ0FBQ1AsUUFBUVM7UUFDakJBLEtBQUtUO0lBQ1Q7QUFDSjtBQUNBLE1BQU1oRDtJQUNGa0IsWUFBWXlDLFFBQVEsRUFBRUMsU0FBUyxDQUFFO1FBQzdCLElBQUlDLElBQUlDLElBQUlDLElBQUlDO1FBQ2hCLElBQUksQ0FBQ0wsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNyQixrQkFBa0IsR0FBRztRQUMxQixJQUFJLENBQUMyQixZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDeEIsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDRCxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDMEIsc0JBQXNCLEdBQUc7UUFDOUIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDUCxTQUFTLEdBQUc7WUFDYmIsT0FBTyxDQUFDYyxLQUFLRCxjQUFjLFFBQVFBLGNBQWMsS0FBSyxJQUFJLEtBQUssSUFBSUEsVUFBVWIsS0FBSyxNQUFNLFFBQVFjLE9BQU8sS0FBSyxJQUFJQSxLQUFLSCxpQkFBaUJYLEtBQUs7WUFDM0lJLGNBQWMsQ0FBQ1csS0FBS0YsY0FBYyxRQUFRQSxjQUFjLEtBQUssSUFBSSxLQUFLLElBQUlBLFVBQVVULFlBQVksTUFBTSxRQUFRVyxPQUFPLEtBQUssSUFBSUEsS0FBS0osaUJBQWlCUCxZQUFZO1lBQ2hLRSxhQUFhLENBQUNVLEtBQUtILGNBQWMsUUFBUUEsY0FBYyxLQUFLLElBQUksS0FBSyxJQUFJQSxVQUFVUCxXQUFXLE1BQU0sUUFBUVUsT0FBTyxLQUFLLElBQUlBLEtBQUtMLGlCQUFpQkwsV0FBVztZQUM3SkUsWUFBWSxDQUFDUyxLQUFLSixjQUFjLFFBQVFBLGNBQWMsS0FBSyxJQUFJLEtBQUssSUFBSUEsVUFBVUwsVUFBVSxNQUFNLFFBQVFTLE9BQU8sS0FBSyxJQUFJQSxLQUFLTixpQkFBaUJILFVBQVU7UUFDOUo7SUFDSjtJQUNBWix3QkFBd0I7UUFDcEIsSUFBSSxJQUFJLENBQUN1QixzQkFBc0IsRUFBRTtZQUM3QixJQUFJLENBQUNQLFFBQVEsQ0FBQ04sV0FBVyxDQUFDLElBQUksQ0FBQ2IsY0FBYyxFQUFFLElBQUksQ0FBQzBCLHNCQUFzQjtZQUMxRSxJQUFJLENBQUMxQixjQUFjLEdBQUc7WUFDdEIsSUFBSSxDQUFDMEIsc0JBQXNCLEdBQUc7UUFDbEM7SUFDSjtJQUNBRSx1QkFBdUI7UUFDbkIsSUFBSSxJQUFJLENBQUNELGFBQWEsRUFBRTtZQUNwQixJQUFJLENBQUNSLFFBQVEsQ0FBQ0osVUFBVSxDQUFDLElBQUksQ0FBQ1ksYUFBYTtZQUMzQyxJQUFJLENBQUNBLGFBQWEsR0FBRztRQUN6QjtJQUNKO0lBQ0FwQixNQUFNZCxRQUFRLEVBQUU7UUFDWixJQUFJLENBQUMyQixTQUFTLENBQUNiLEtBQUssQ0FBQ3NCLENBQUFBO1lBQ2pCLElBQUlSLElBQUlDLElBQUlDLElBQUlDO1lBQ2hCLE1BQU1NLDBCQUEwQjtnQkFDNUI3QyxtQkFBbUIsQ0FBQ29DLEtBQUtRLHdCQUF3QixRQUFRQSx3QkFBd0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsb0JBQW9CNUMsaUJBQWlCLE1BQU0sUUFBUW9DLE9BQU8sS0FBSyxJQUFJQSxLQUFLTCxzQkFBc0IvQixpQkFBaUI7Z0JBQ2xORSxrQkFBa0IsQ0FBQ21DLEtBQUtPLHdCQUF3QixRQUFRQSx3QkFBd0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsb0JBQW9CMUMsZ0JBQWdCLE1BQU0sUUFBUW1DLE9BQU8sS0FBSyxJQUFJQSxLQUFLTixzQkFBc0I3QixnQkFBZ0I7Z0JBQy9NRSxvQkFBb0IsQ0FBQ2tDLEtBQUtNLHdCQUF3QixRQUFRQSx3QkFBd0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsb0JBQW9CeEMsa0JBQWtCLE1BQU0sUUFBUWtDLE9BQU8sS0FBSyxJQUFJQSxLQUFLUCxzQkFBc0IzQixrQkFBa0I7Z0JBQ3JORSxVQUFVLENBQUNpQyxLQUFLSyx3QkFBd0IsUUFBUUEsd0JBQXdCLEtBQUssSUFBSSxLQUFLLElBQUlBLG9CQUFvQnRDLFFBQVEsTUFBTSxRQUFRaUMsT0FBTyxLQUFLLElBQUlBLEtBQUtSLHNCQUFzQnpCLFFBQVE7WUFDM0w7WUFDQSxNQUFNd0MsNEJBQTRCLElBQUlwQywrQkFBK0JtQyx5QkFBeUJyQztZQUM5RixJQUFJLENBQUMwQixRQUFRLENBQUNaLEtBQUssQ0FBQ3dCO1FBQ3hCO0lBQ0o7SUFDQXBCLGFBQWFoQyxRQUFRLEVBQUU7UUFDbkIsSUFBSSxDQUFDbUIsa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDMkIsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0wsU0FBUyxDQUFDVCxZQUFZLENBQUNoQyxVQUFVMEIsQ0FBQUE7WUFDbEMsSUFBSSxDQUFDUCxrQkFBa0IsR0FBRztZQUMxQixJQUFJLENBQUNxQixRQUFRLENBQUNSLFlBQVksQ0FBQ047WUFDM0IsSUFBSSxDQUFDRixxQkFBcUI7WUFDMUIsSUFBSSxDQUFDeUIsb0JBQW9CO1FBQzdCO0lBQ0o7SUFDQWYsWUFBWWhDLE9BQU8sRUFBRW1ELFFBQVEsRUFBRTtRQUMzQixJQUFJLENBQUMvQixpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUMsSUFBSSxDQUFDd0IsWUFBWSxFQUFFO1lBQ3BCLElBQUksQ0FBQ2QsWUFBWSxDQUFDLElBQUk5QyxXQUFXb0UsUUFBUTtRQUM3QztRQUNBLElBQUksQ0FBQ2IsU0FBUyxDQUFDUCxXQUFXLENBQUNoQyxTQUFTcUQsQ0FBQUE7WUFDaEMsSUFBSSxDQUFDakMsaUJBQWlCLEdBQUc7WUFDekIsSUFBSSxJQUFJLENBQUNILGtCQUFrQixFQUFFO2dCQUN6QixJQUFJLENBQUNFLGNBQWMsR0FBR2tDO2dCQUN0QixJQUFJLENBQUNSLHNCQUFzQixHQUFHTTtZQUNsQyxPQUNLO2dCQUNELElBQUksQ0FBQ2IsUUFBUSxDQUFDTixXQUFXLENBQUNxQixvQkFBb0JGO1lBQ2xEO1FBQ0o7SUFDSjtJQUNBakIsV0FBV1AsTUFBTSxFQUFFO1FBQ2YsSUFBSSxDQUFDWSxTQUFTLENBQUNMLFVBQVUsQ0FBQ1AsUUFBUTJCLENBQUFBO1lBQzlCLElBQUksSUFBSSxDQUFDckMsa0JBQWtCLElBQUksSUFBSSxDQUFDRyxpQkFBaUIsRUFBRTtnQkFDbkQsSUFBSSxDQUFDMEIsYUFBYSxHQUFHUTtZQUN6QixPQUNLO2dCQUNELElBQUksQ0FBQ2hCLFFBQVEsQ0FBQ0osVUFBVSxDQUFDb0I7WUFDN0I7UUFDSjtJQUNKO0lBQ0FDLFlBQVk7UUFDUixJQUFJLENBQUNqQixRQUFRLENBQUNpQixTQUFTO0lBQzNCO0lBQ0FDLFVBQVU7UUFDTixPQUFPLElBQUksQ0FBQ2xCLFFBQVEsQ0FBQ2tCLE9BQU87SUFDaEM7SUFDQUMsY0FBYztRQUNWLE9BQU8sSUFBSSxDQUFDbkIsUUFBUSxDQUFDbUIsV0FBVztJQUNwQztJQUNBQyxVQUFVO1FBQ04sT0FBTyxJQUFJLENBQUNwQixRQUFRLENBQUNvQixPQUFPO0lBQ2hDO0FBQ0o7QUFDQWxGLDhCQUE4QixHQUFHRztBQUNqQyxNQUFNZ0YsOEJBQThCO0FBQ3BDLE1BQU1DLHVCQUF1QjtBQUM3QixNQUFNQyxzQkFBc0I7QUFDNUIsTUFBTUMscUJBQXFCO0FBQzNCLE1BQU1DLHNCQUFzQjtBQUM1QixNQUFNQyxpQkFBaUI7QUFDdkIsTUFBTUMsb0JBQW9CO0lBQ3RCQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztBQUNQO0FBQ0EsTUFBTUMsNEJBQTRCO0lBQzlCLHlFQUF5RTtJQUN6RSxrQ0FBa0M7SUFDbEMsQ0FBQ2IsNEJBQTRCLEVBQUU7SUFDL0IsQ0FBQ0MscUJBQXFCLEVBQUU7QUFDNUI7QUFDQSxNQUFNYSx5QkFBeUI7SUFDM0IsQ0FBQ3RGLE1BQU11RixTQUFTLENBQUNDLG1CQUFtQixDQUFDLEVBQUV4RixNQUFNdUYsU0FBUyxDQUFDRSxjQUFjO0lBQ3JFLENBQUN6RixNQUFNdUYsU0FBUyxDQUFDRyx5QkFBeUIsQ0FBQyxFQUFFO0FBQ2pEO0FBQ0EsTUFBTUMseUJBQXlCO0lBQzNCQyxpQkFBaUI7QUFDckI7QUFDQSxNQUFNckc7SUFDRm1CLFlBQVltRixNQUFNLEVBQUVDLE9BQU8sRUFBRUMsZ0JBQWdCLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxDQUFFO1FBQzdELElBQUk1QztRQUNKLElBQUksQ0FBQ3dDLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNFLGdCQUFnQixHQUFHQTtRQUN4QixJQUFJLENBQUNDLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUN2RSxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDeUUsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0MsUUFBUSxHQUFHQztRQUNoQixJQUFJLENBQUNDLGtCQUFrQixHQUFHdEcsWUFBWXVHLCtCQUErQjtRQUNyRSxJQUFJLENBQUNDLHFCQUFxQixHQUFHeEcsWUFBWXlHLGtDQUFrQztRQUMzRSxJQUFJLENBQUMzRSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDNEUsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDQyxTQUFTLEdBQUcsRUFBRTtRQUNuQixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNDLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ25CLE1BQU0sQ0FBQ29CLElBQUksQ0FBQyxTQUFTLENBQUNDO1FBQ3ZCOzs7OzJEQUkrQyxHQUNuRDtRQUNBLElBQUksQ0FBQ3JCLE1BQU0sQ0FBQ29CLElBQUksQ0FBQyxTQUFTO1lBQ3RCLElBQUk1RDtZQUNKL0MsTUFBTSx1QkFDRCxFQUFDK0MsS0FBSyxJQUFJLENBQUMyQyxPQUFPLE1BQU0sUUFBUTNDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzhELElBQUksSUFDakUsaUNBQ0EsSUFBSSxDQUFDdEIsTUFBTSxDQUFDdUIsT0FBTztZQUN2QixJQUFJLElBQUksQ0FBQ3JCLGdCQUFnQixJQUFJLENBQUMsSUFBSSxDQUFDaUIsV0FBVyxFQUFFO2dCQUM1QyxJQUFJLENBQUNBLFdBQVcsR0FBRztnQkFDbkIsSUFBSSxDQUFDakIsZ0JBQWdCLENBQUNzQixXQUFXLENBQUM7Z0JBQ2xDLElBQUksQ0FBQ3RCLGdCQUFnQixDQUFDdUIsU0FBUyxDQUFDO29CQUM1QkMsTUFBTXhILFlBQVl5SCxNQUFNLENBQUNDLFNBQVM7b0JBQ2xDQyxTQUFTO29CQUNUL0csVUFBVTtnQkFDZDtZQUNKO1lBQ0EsSUFBSSxDQUFDZ0gsY0FBYztRQUN2QjtRQUNBLElBQUksQ0FBQzlCLE1BQU0sQ0FBQytCLEVBQUUsQ0FBQyxRQUFRLENBQUNDO1lBQ3BCLElBQUksQ0FBQ0MsZUFBZSxDQUFDRDtRQUN6QjtRQUNBLElBQUksQ0FBQ2hDLE1BQU0sQ0FBQ2tDLEtBQUs7UUFDakIsSUFBSSxDQUFDbEMsTUFBTSxDQUFDK0IsRUFBRSxDQUFDLE9BQU87WUFDbEIsSUFBSSxDQUFDSSxjQUFjO1FBQ3ZCO1FBQ0EsSUFBSSxrQ0FBa0MvQixTQUFTO1lBQzNDLElBQUksQ0FBQ0ksa0JBQWtCLEdBQUdKLE9BQU8sQ0FBQywrQkFBK0I7UUFDckU7UUFDQSxJQUFJLHFDQUFxQ0EsU0FBUztZQUM5QyxJQUFJLENBQUNNLHFCQUFxQixHQUFHTixPQUFPLENBQUMsa0NBQWtDO1FBQzNFO1FBQ0EsSUFBSSxDQUFDZ0MsSUFBSSxHQUFHLENBQUM1RSxLQUFLeUMsT0FBTyxDQUFDLGFBQWEsTUFBTSxRQUFRekMsT0FBTyxLQUFLLElBQUlBLEtBQUt5QyxRQUFRbUMsSUFBSTtRQUN0RixJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJL0gsaUJBQWlCZ0ksYUFBYSxDQUFDLElBQUksQ0FBQzVCLHFCQUFxQjtRQUM1RSxNQUFNNUYsV0FBV2QsV0FBV29FLFFBQVEsQ0FBQ21FLGdCQUFnQixDQUFDdEM7UUFDdEQsSUFBSTFGLFFBQVFpSSxlQUFlLENBQUNoSSxjQUFjO1lBQ3RDQyxNQUFNLGdCQUNGLElBQUksQ0FBQzBGLE9BQU8sQ0FBQ21CLElBQUksR0FDakIsdUJBQ0FtQixLQUFLQyxTQUFTLENBQUM1SCxTQUFTNkgsTUFBTTtRQUN0QztRQUNBLE1BQU1DLGdCQUFnQjlILFNBQVMrSCxHQUFHLENBQUM5RDtRQUNuQyxJQUFJNkQsY0FBYy9HLE1BQU0sR0FBRyxHQUFHO1lBQzFCLElBQUksQ0FBQ2lILG1CQUFtQixDQUFDRixhQUFhLENBQUMsRUFBRTtRQUM3QztRQUNBLE1BQU1HLGlCQUFpQmpJLFNBQVMrSCxHQUFHLENBQUNqRTtRQUNwQyxJQUFJbUUsZUFBZWxILE1BQU0sR0FBRyxHQUFHO1lBQzNCLElBQUksQ0FBQ2tGLGdCQUFnQixHQUFHZ0MsY0FBYyxDQUFDLEVBQUU7UUFDN0M7UUFDQSwwRUFBMEU7UUFDMUVqSSxTQUFTa0ksTUFBTSxDQUFDakU7UUFDaEJqRSxTQUFTa0ksTUFBTSxDQUFDcEU7UUFDaEI5RCxTQUFTa0ksTUFBTSxDQUFDckU7UUFDaEI3RCxTQUFTa0ksTUFBTSxDQUFDN0ksTUFBTXVGLFNBQVMsQ0FBQ3VELDRCQUE0QjtRQUM1RG5JLFNBQVNrSSxNQUFNLENBQUM3SSxNQUFNdUYsU0FBUyxDQUFDd0QsZUFBZTtRQUMvQ3BJLFNBQVNrSSxNQUFNLENBQUM3SSxNQUFNdUYsU0FBUyxDQUFDRyx5QkFBeUI7UUFDekQsSUFBSSxDQUFDL0UsUUFBUSxHQUFHQTtJQUNwQjtJQUNBZ0ksb0JBQW9CRixhQUFhLEVBQUU7UUFDL0IsTUFBTU8sUUFBUVAsY0FBY1EsUUFBUSxHQUFHRCxLQUFLLENBQUNuRTtRQUM3QyxJQUFJbUUsVUFBVSxNQUFNO1lBQ2hCLE1BQU14RyxTQUFTO2dCQUNYK0UsTUFBTXhILFlBQVl5SCxNQUFNLENBQUMwQixRQUFRO2dCQUNqQ3hCLFNBQVMsQ0FBQyxRQUFRLEVBQUU5QyxvQkFBb0IsUUFBUSxFQUFFNkQsY0FBYyxDQUFDLENBQUM7Z0JBQ2xFOUgsVUFBVTtZQUNkO1lBQ0EsaUVBQWlFO1lBQ2pFd0ksUUFBUUMsUUFBUSxDQUFDO2dCQUNiLElBQUksQ0FBQ3JHLFVBQVUsQ0FBQ1A7WUFDcEI7WUFDQTtRQUNKO1FBQ0EsTUFBTTZHLFVBQVUsQ0FBRUwsS0FBSyxDQUFDLEVBQUUsR0FBR2xFLGlCQUFpQixDQUFDa0UsS0FBSyxDQUFDLEVBQUUsQ0FBQyxHQUFJO1FBQzVELE1BQU1NLE1BQU0sSUFBSUM7UUFDaEIsSUFBSSxDQUFDcEQsUUFBUSxHQUFHbUQsSUFBSUUsZUFBZSxDQUFDRixJQUFJRyxlQUFlLEtBQUtKO1FBQzVELElBQUksQ0FBQ25ELGFBQWEsR0FBR3dELFdBQVc7WUFDNUIsTUFBTWxILFNBQVM7Z0JBQ1grRSxNQUFNeEgsWUFBWXlILE1BQU0sQ0FBQ21DLGlCQUFpQjtnQkFDMUNqQyxTQUFTO2dCQUNUL0csVUFBVTtZQUNkO1lBQ0EsSUFBSSxDQUFDb0MsVUFBVSxDQUFDUDtRQUNwQixHQUFHNkc7SUFDUDtJQUNBTyxpQkFBaUI7UUFDYjs2RUFDcUUsR0FDckUsSUFBSSxDQUFDLElBQUksQ0FBQy9ILFNBQVMsSUFBSyxLQUFJLENBQUNnRSxNQUFNLENBQUNnRSxTQUFTLElBQUksSUFBSSxDQUFDaEUsTUFBTSxDQUFDaUUsTUFBTSxHQUFHO1lBQ2xFLElBQUksQ0FBQ25DLGNBQWM7WUFDbkIsSUFBSSxDQUFDOUYsU0FBUyxHQUFHO1FBQ3JCO1FBQ0EsT0FBTyxJQUFJLENBQUNBLFNBQVM7SUFDekI7SUFDQThGLGlCQUFpQjtRQUNiLElBQUksSUFBSSxDQUFDaEIsY0FBYyxFQUFFO1lBQ3JCO1FBQ0o7UUFDQSxJQUFJLENBQUNBLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUM5RSxTQUFTLEdBQUc7UUFDakJzSCxRQUFRQyxRQUFRLENBQUM7WUFDYixJQUFJL0Y7WUFDSEEsQ0FBQUEsS0FBSyxJQUFJLENBQUM1QixRQUFRLE1BQU0sUUFBUTRCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzlCLFFBQVE7UUFDekU7UUFDQSxJQUFJLElBQUksQ0FBQzJFLGFBQWEsRUFBRTtZQUNwQjZELGFBQWEsSUFBSSxDQUFDN0QsYUFBYTtRQUNuQztRQUNBLDZCQUE2QjtRQUM3QixJQUFJLENBQUNMLE1BQU0sQ0FBQ21FLE1BQU07SUFDdEI7SUFDQTs7OztLQUlDLEdBQ0RDLG9CQUFvQjtRQUNoQixJQUFJLENBQUMsSUFBSSxDQUFDeEQsWUFBWSxFQUFFO1lBQ3BCLElBQUksQ0FBQzlELFlBQVksQ0FBQyxJQUFJOUMsV0FBV29FLFFBQVE7UUFDN0M7SUFDSjtJQUNBOzs7O0tBSUMsR0FDRGlHLGlCQUFpQjVLLEtBQUssRUFBRTtRQUNwQixNQUFNNkssZ0JBQWdCLElBQUksQ0FBQ25FLE9BQU8sQ0FBQ29FLFNBQVMsQ0FBQzlLO1FBQzdDLE1BQU0rSyxhQUFhRixjQUFjRSxVQUFVO1FBQzNDLE1BQU1DLFNBQVNDLE9BQU9DLFdBQVcsQ0FBQ0gsYUFBYTtRQUMvQzt1Q0FDK0IsR0FDL0JDLE9BQU9HLFVBQVUsQ0FBQyxHQUFHO1FBQ3JCSCxPQUFPSSxhQUFhLENBQUNMLFlBQVk7UUFDakNGLGNBQWNRLElBQUksQ0FBQ0wsUUFBUTtRQUMzQixPQUFPQTtJQUNYO0lBQ0FNLGtCQUFrQi9KLE9BQU8sRUFBRWdLLFFBQVEsRUFBRTtRQUNqQyxNQUFNQyxrQkFBa0JqSyxRQUFRa0ssUUFBUSxDQUFDO1FBQ3pDLElBQUlGLGFBQWEsWUFBWTtZQUN6QixPQUFPQztRQUNYLE9BQ0ssSUFBSUQsYUFBYSxhQUFhQSxhQUFhLFFBQVE7WUFDcEQsSUFBSUc7WUFDSixJQUFJSCxhQUFhLFdBQVc7Z0JBQ3hCRyxlQUFlOUssS0FBSytLLGFBQWE7WUFDckMsT0FDSztnQkFDREQsZUFBZTlLLEtBQUtnTCxZQUFZO1lBQ3BDO1lBQ0EsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO2dCQUN6QixJQUFJQyxjQUFjO2dCQUNsQixNQUFNQyxlQUFlLEVBQUU7Z0JBQ3ZCUCxhQUFhcEQsRUFBRSxDQUFDLFFBQVEsQ0FBQzREO29CQUNyQkQsYUFBYUUsSUFBSSxDQUFDRDtvQkFDbEJGLGVBQWVFLE1BQU1uQixVQUFVO29CQUMvQixJQUFJLElBQUksQ0FBQzlELHFCQUFxQixLQUFLLENBQUMsS0FBSytFLGNBQWMsSUFBSSxDQUFDL0UscUJBQXFCLEVBQUU7d0JBQy9FeUUsYUFBYVUsT0FBTzt3QkFDcEJMLE9BQU87NEJBQ0g5RCxNQUFNeEgsWUFBWXlILE1BQU0sQ0FBQ21FLGtCQUFrQjs0QkFDM0NqRSxTQUFTLENBQUMseURBQXlELEVBQUUsSUFBSSxDQUFDbkIscUJBQXFCLENBQUMsQ0FBQzt3QkFDckc7b0JBQ0o7Z0JBQ0o7Z0JBQ0F5RSxhQUFhcEQsRUFBRSxDQUFDLE9BQU87b0JBQ25Cd0QsUUFBUWIsT0FBT3FCLE1BQU0sQ0FBQ0w7Z0JBQzFCO2dCQUNBUCxhQUFhYSxLQUFLLENBQUNmO2dCQUNuQkUsYUFBYWMsR0FBRztZQUNwQjtRQUNKLE9BQ0s7WUFDRCxPQUFPWCxRQUFRRSxNQUFNLENBQUM7Z0JBQ2xCOUQsTUFBTXhILFlBQVl5SCxNQUFNLENBQUN1RSxhQUFhO2dCQUN0Q3JFLFNBQVMsQ0FBQyx1REFBdUQsRUFBRW1ELFNBQVMsQ0FBQyxDQUFDO1lBQ2xGO1FBQ0o7SUFDSjtJQUNBLE1BQU1tQix1QkFBdUJDLFVBQVUsRUFBRTtRQUNyQyxJQUFJQSxXQUFXQyxJQUFJLEtBQUssY0FBYztZQUNsQyxNQUFNLElBQUlDLE1BQU0sQ0FBQywwQkFBMEIsRUFBRUYsV0FBV0MsSUFBSSxDQUFDLENBQUM7UUFDbEU7UUFDQSxNQUFNRSxhQUFhSCxXQUFXSSxpQkFBaUIsQ0FBQ0MsU0FBUyxDQUFDLE9BQU87UUFDakUsTUFBTUMsNEJBQTRCSCxhQUM1QixJQUFJLENBQUN4RixnQkFBZ0IsR0FDckI7UUFDTixJQUFJNEY7UUFDSixJQUFJO1lBQ0FBLHNCQUFzQixNQUFNLElBQUksQ0FBQzVCLGlCQUFpQixDQUFDcUIsV0FBV0ksaUJBQWlCLEVBQUVFO1FBQ3JGLEVBQ0EsT0FBT3JGLEtBQUs7WUFDUixJQUFJLENBQUNuRSxVQUFVLENBQUNtRTtZQUNoQjtRQUNKO1FBQ0EsSUFBSTtZQUNBK0UsV0FBV1EsYUFBYSxHQUFHLElBQUksQ0FBQ3pHLE9BQU8sQ0FBQzBHLFdBQVcsQ0FBQ0Y7UUFDeEQsRUFDQSxPQUFPdEYsS0FBSztZQUNSLElBQUksQ0FBQ25FLFVBQVUsQ0FBQztnQkFDWndFLE1BQU14SCxZQUFZeUgsTUFBTSxDQUFDMEIsUUFBUTtnQkFDakN4QixTQUFTLENBQUMsNkJBQTZCLEVBQUVSLElBQUlyRyxPQUFPLENBQUMsQ0FBQztZQUMxRDtZQUNBO1FBQ0o7UUFDQW9MLFdBQVdDLElBQUksR0FBRztRQUNsQixJQUFJLENBQUNTLG9CQUFvQjtJQUM3QjtJQUNBQSx1QkFBdUI7UUFDbkIsSUFBSSxJQUFJLENBQUNsTCxRQUFRLElBQ2IsSUFBSSxDQUFDcUYsYUFBYSxJQUNsQixJQUFJLENBQUNELFNBQVMsQ0FBQ25GLE1BQU0sR0FBRyxLQUN4QixJQUFJLENBQUNtRixTQUFTLENBQUMsRUFBRSxDQUFDcUYsSUFBSSxLQUFLLGNBQWM7WUFDekMsSUFBSSxDQUFDcEYsYUFBYSxHQUFHO1lBQ3JCLE1BQU04RixpQkFBaUIsSUFBSSxDQUFDL0YsU0FBUyxDQUFDZ0csS0FBSztZQUMzQyxJQUFJRCxlQUFlVixJQUFJLEtBQUssWUFBWTtnQkFDcEMsSUFBSSxDQUFDekssUUFBUSxDQUFDTixnQkFBZ0IsQ0FBQ3lMLGVBQWVILGFBQWE7WUFDL0QsT0FDSztnQkFDRCx1Q0FBdUM7Z0JBQ3ZDLElBQUksQ0FBQ2hMLFFBQVEsQ0FBQ0osa0JBQWtCO1lBQ3BDO1FBQ0o7SUFDSjtJQUNBeUcsZ0JBQWdCRCxJQUFJLEVBQUU7UUFDbEIsSUFBSXhFO1FBQ0osSUFBSSxJQUFJLENBQUN1RyxjQUFjLElBQUk7WUFDdkI7UUFDSjtRQUNBdEosTUFBTSxnQkFDRixJQUFJLENBQUMwRixPQUFPLENBQUNtQixJQUFJLEdBQ2pCLGtDQUNBVSxLQUFLbkcsTUFBTTtRQUNmLElBQUlvTDtRQUNKLElBQUk7WUFDQUEsY0FBYyxJQUFJLENBQUM1RSxPQUFPLENBQUMyRCxLQUFLLENBQUNoRTtRQUNyQyxFQUNBLE9BQU9rRixHQUFHO1lBQ04sSUFBSSxDQUFDaEssVUFBVSxDQUFDO2dCQUFFd0UsTUFBTXhILFlBQVl5SCxNQUFNLENBQUNtRSxrQkFBa0I7Z0JBQUVqRSxTQUFTcUYsRUFBRWxNLE9BQU87WUFBQztZQUNsRjtRQUNKO1FBQ0EsS0FBSyxNQUFNbU0sZ0JBQWdCRixZQUFhO1lBQ3BDLElBQUksQ0FBQ2pILE1BQU0sQ0FBQ2tDLEtBQUs7WUFDakIsTUFBTWtFLGFBQWE7Z0JBQ2ZDLE1BQU07Z0JBQ05HLG1CQUFtQlc7Z0JBQ25CUCxlQUFlO1lBQ25CO1lBQ0EsSUFBSSxDQUFDNUYsU0FBUyxDQUFDNEUsSUFBSSxDQUFDUTtZQUNwQixJQUFJLENBQUNELHNCQUFzQixDQUFDQztZQUMzQjVJLENBQUFBLEtBQUssSUFBSSxDQUFDMEMsZ0JBQWdCLE1BQU0sUUFBUTFDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzRKLGtCQUFrQjtRQUMzRjtJQUNKO0lBQ0FqRixpQkFBaUI7UUFDYixJQUFJLENBQUNuQixTQUFTLENBQUM0RSxJQUFJLENBQUM7WUFDaEJTLE1BQU07WUFDTkcsbUJBQW1CO1lBQ25CSSxlQUFlO1FBQ25CO1FBQ0EsSUFBSSxDQUFDMUYsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDNEYsb0JBQW9CO0lBQzdCO0lBQ0FwSyxNQUFNZCxRQUFRLEVBQUU7UUFDWm5CLE1BQU0sZ0JBQWdCLElBQUksQ0FBQzBGLE9BQU8sQ0FBQ21CLElBQUksR0FBRztRQUMxQyxJQUFJLElBQUksQ0FBQ3lDLGNBQWMsSUFBSTtZQUN2QjtRQUNKO1FBQ0EsSUFBSSxDQUFDbkksUUFBUSxHQUFHQTtRQUNoQkEsU0FBU1IsaUJBQWlCLENBQUMsSUFBSSxDQUFDTixRQUFRO0lBQzVDO0lBQ0FnQyxhQUFhaEMsUUFBUSxFQUFFO1FBQ25CLElBQUksSUFBSSxDQUFDaUosY0FBYyxJQUFJO1lBQ3ZCO1FBQ0o7UUFDQSxJQUFJLElBQUksQ0FBQ25ELFlBQVksRUFBRTtZQUNuQjtRQUNKO1FBQ0EsSUFBSSxDQUFDQSxZQUFZLEdBQUc7UUFDcEIsTUFBTXlHLFNBQVN2TSxXQUFXQSxTQUFTd00sY0FBYyxLQUFLO1FBQ3RELE1BQU1ySCxVQUFVM0csT0FBT2lPLE1BQU0sQ0FBQ2pPLE9BQU9pTyxNQUFNLENBQUNqTyxPQUFPaU8sTUFBTSxDQUFDLENBQUMsR0FBRzlILHlCQUF5QkQsNEJBQTRCNkg7UUFDbkgsSUFBSSxDQUFDckgsTUFBTSxDQUFDd0gsT0FBTyxDQUFDdkgsU0FBU0g7SUFDakM7SUFDQTlDLFlBQVloQyxPQUFPLEVBQUVtRCxRQUFRLEVBQUU7UUFDM0IsSUFBSSxJQUFJLENBQUM0RixjQUFjLElBQUk7WUFDdkI7UUFDSjtRQUNBLElBQUkwRDtRQUNKLElBQUk7WUFDQUEsV0FBVyxJQUFJLENBQUNwRCxnQkFBZ0IsQ0FBQ3JKO1FBQ3JDLEVBQ0EsT0FBT2tNLEdBQUc7WUFDTixJQUFJLENBQUNoSyxVQUFVLENBQUM7Z0JBQ1p3RSxNQUFNeEgsWUFBWXlILE1BQU0sQ0FBQzBCLFFBQVE7Z0JBQ2pDeEIsU0FBUyxDQUFDLDRCQUE0QixFQUFFLENBQUMsR0FBR3pILFFBQVFzTixlQUFlLEVBQUVSLEdBQUcsQ0FBQztnQkFDekVwTSxVQUFVO1lBQ2Q7WUFDQTtRQUNKO1FBQ0EsSUFBSSxJQUFJLENBQUMwRixrQkFBa0IsS0FBSyxDQUFDLEtBQzdCaUgsU0FBUzVMLE1BQU0sR0FBRyxJQUFJLElBQUksQ0FBQzJFLGtCQUFrQixFQUFFO1lBQy9DLElBQUksQ0FBQ3RELFVBQVUsQ0FBQztnQkFDWndFLE1BQU14SCxZQUFZeUgsTUFBTSxDQUFDbUUsa0JBQWtCO2dCQUMzQ2pFLFNBQVMsQ0FBQyw4QkFBOEIsRUFBRTRGLFNBQVM1TCxNQUFNLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQzJFLGtCQUFrQixDQUFDLENBQUMsQ0FBQztnQkFDM0YxRixVQUFVO1lBQ2Q7WUFDQTtRQUNKO1FBQ0EsSUFBSSxDQUFDc0osaUJBQWlCO1FBQ3RCM0osTUFBTSxnQkFDRixJQUFJLENBQUMwRixPQUFPLENBQUNtQixJQUFJLEdBQ2pCLDhCQUNBbUcsU0FBUzVMLE1BQU07UUFDbkIsSUFBSSxDQUFDbUUsTUFBTSxDQUFDZ0csS0FBSyxDQUFDeUIsVUFBVUUsQ0FBQUE7WUFDeEIsSUFBSW5LO1lBQ0osSUFBSW1LLE9BQU87Z0JBQ1AsSUFBSSxDQUFDekssVUFBVSxDQUFDO29CQUNad0UsTUFBTXhILFlBQVl5SCxNQUFNLENBQUMwQixRQUFRO29CQUNqQ3hCLFNBQVMsQ0FBQyx1QkFBdUIsRUFBRSxDQUFDLEdBQUd6SCxRQUFRc04sZUFBZSxFQUFFQyxPQUFPLENBQUM7b0JBQ3hFN00sVUFBVTtnQkFDZDtnQkFDQTtZQUNKO1lBQ0MwQyxDQUFBQSxLQUFLLElBQUksQ0FBQzBDLGdCQUFnQixNQUFNLFFBQVExQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdvSyxjQUFjO1lBQ25Geko7UUFDSjtJQUNKO0lBQ0FqQixXQUFXUCxNQUFNLEVBQUU7UUFDZixJQUFJYSxJQUFJQztRQUNSLElBQUksSUFBSSxDQUFDc0csY0FBYyxJQUFJO1lBQ3ZCO1FBQ0o7UUFDQXRKLE1BQU0sdUJBQ0QsRUFBQytDLEtBQUssSUFBSSxDQUFDMkMsT0FBTyxNQUFNLFFBQVEzQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc4RCxJQUFJLElBQ2pFLDhCQUNBcEgsWUFBWXlILE1BQU0sQ0FBQ2hGLE9BQU8rRSxJQUFJLENBQUMsR0FDL0IsZUFDQS9FLE9BQU9rRixPQUFPO1FBQ2xCLElBQUksSUFBSSxDQUFDakIsWUFBWSxFQUFFO1lBQ25CLElBQUksQ0FBQyxJQUFJLENBQUNDLFlBQVksRUFBRTtnQkFDcEIsSUFBSSxDQUFDQSxZQUFZLEdBQUc7Z0JBQ3BCLElBQUksQ0FBQ2IsTUFBTSxDQUFDb0IsSUFBSSxDQUFDLGdCQUFnQjtvQkFDN0IsSUFBSTVEO29CQUNKLElBQUksSUFBSSxDQUFDMEMsZ0JBQWdCLElBQUksQ0FBQyxJQUFJLENBQUNpQixXQUFXLEVBQUU7d0JBQzVDLElBQUksQ0FBQ0EsV0FBVyxHQUFHO3dCQUNuQixJQUFJLENBQUNqQixnQkFBZ0IsQ0FBQ3NCLFdBQVcsQ0FBQzt3QkFDbEMsSUFBSSxDQUFDdEIsZ0JBQWdCLENBQUN1QixTQUFTLENBQUM5RTtvQkFDcEM7b0JBQ0EsTUFBTWtMLGlCQUFpQnZPLE9BQU9pTyxNQUFNLENBQUM7d0JBQUUsQ0FBQ3pJLG1CQUFtQixFQUFFbkMsT0FBTytFLElBQUk7d0JBQUUsQ0FBQzdDLG9CQUFvQixFQUFFaUosVUFBVW5MLE9BQU9rRixPQUFPO29CQUFFLEdBQUcsQ0FBQ3JFLEtBQUtiLE9BQU83QixRQUFRLE1BQU0sUUFBUTBDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzhKLGNBQWM7b0JBQzNNLElBQUksQ0FBQ3RILE1BQU0sQ0FBQytILFlBQVksQ0FBQ0Y7b0JBQ3pCLElBQUksQ0FBQy9GLGNBQWM7Z0JBQ3ZCO2dCQUNBLElBQUksQ0FBQzlCLE1BQU0sQ0FBQ2lHLEdBQUc7WUFDbkIsT0FDSztnQkFDRCxJQUFJLENBQUNuRSxjQUFjO1lBQ3ZCO1FBQ0osT0FDSztZQUNELElBQUksSUFBSSxDQUFDNUIsZ0JBQWdCLElBQUksQ0FBQyxJQUFJLENBQUNpQixXQUFXLEVBQUU7Z0JBQzVDLElBQUksQ0FBQ0EsV0FBVyxHQUFHO2dCQUNuQixJQUFJLENBQUNqQixnQkFBZ0IsQ0FBQ3NCLFdBQVcsQ0FBQztnQkFDbEMsSUFBSSxDQUFDdEIsZ0JBQWdCLENBQUN1QixTQUFTLENBQUM5RTtZQUNwQztZQUNBLHlCQUF5QjtZQUN6QixNQUFNa0wsaUJBQWlCdk8sT0FBT2lPLE1BQU0sQ0FBQ2pPLE9BQU9pTyxNQUFNLENBQUM7Z0JBQUUsQ0FBQ3pJLG1CQUFtQixFQUFFbkMsT0FBTytFLElBQUk7Z0JBQUUsQ0FBQzdDLG9CQUFvQixFQUFFaUosVUFBVW5MLE9BQU9rRixPQUFPO1lBQUUsR0FBR3BDLHlCQUF5QixDQUFDaEMsS0FBS2QsT0FBTzdCLFFBQVEsTUFBTSxRQUFRMkMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNkosY0FBYztZQUNsUCxJQUFJLENBQUN0SCxNQUFNLENBQUN3SCxPQUFPLENBQUNLLGdCQUFnQjtnQkFBRUcsV0FBVztZQUFLO1lBQ3RELElBQUksQ0FBQ2xHLGNBQWM7UUFDdkI7SUFDSjtJQUNBdkQsWUFBWTtRQUNSOUQsTUFBTSxnQkFBZ0IsSUFBSSxDQUFDMEYsT0FBTyxDQUFDbUIsSUFBSSxHQUFHO1FBQzFDLElBQUksSUFBSSxDQUFDeUMsY0FBYyxJQUFJO1lBQ3ZCO1FBQ0o7UUFDQSxJQUFJLENBQUM5QyxhQUFhLEdBQUc7UUFDckIsSUFBSSxJQUFJLENBQUNELFNBQVMsQ0FBQ25GLE1BQU0sS0FBSyxHQUFHO1lBQzdCLElBQUksQ0FBQyxJQUFJLENBQUNxRixpQkFBaUIsRUFBRTtnQkFDekIsSUFBSSxDQUFDbEIsTUFBTSxDQUFDbUUsTUFBTTtZQUN0QjtRQUNKLE9BQ0s7WUFDRCxJQUFJLENBQUMyQyxvQkFBb0I7UUFDN0I7SUFDSjtJQUNBdEksVUFBVTtRQUNOLElBQUloQjtRQUNKLE1BQU15SyxTQUFTLENBQUN6SyxLQUFLLElBQUksQ0FBQ3dDLE1BQU0sQ0FBQ2tJLE9BQU8sTUFBTSxRQUFRMUssT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeUssTUFBTTtRQUN4RixJQUFJQSxXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT0UsYUFBYSxFQUFFO1lBQ3RFLElBQUlGLE9BQU9HLFVBQVUsRUFBRTtnQkFDbkIsT0FBTyxDQUFDLEVBQUVILE9BQU9FLGFBQWEsQ0FBQyxDQUFDLEVBQUVGLE9BQU9HLFVBQVUsQ0FBQyxDQUFDO1lBQ3pELE9BQ0s7Z0JBQ0QsT0FBT0gsT0FBT0UsYUFBYTtZQUMvQjtRQUNKLE9BQ0s7WUFDRCxPQUFPO1FBQ1g7SUFDSjtJQUNBMUosY0FBYztRQUNWLE9BQU8sSUFBSSxDQUFDNkIsUUFBUTtJQUN4QjtJQUNBNUIsVUFBVTtRQUNOLE9BQU8sSUFBSSxDQUFDMEQsSUFBSTtJQUNwQjtBQUNKO0FBQ0E1SSxrQ0FBa0MsR0FBR0U7QUFDckMsU0FBU0ssMEJBQTBCc08sWUFBWSxFQUFFckksTUFBTSxFQUFFQyxPQUFPLEVBQUVDLGdCQUFnQixFQUFFQyxPQUFPLEVBQUVDLE9BQU87SUFDaEcsTUFBTWtJLG1CQUFtQjtRQUNyQmhILE1BQU1uQixRQUFRbUIsSUFBSTtRQUNsQmlILGVBQWVwSSxRQUFRa0csSUFBSSxLQUFLLGtCQUFrQmxHLFFBQVFrRyxJQUFJLEtBQUs7UUFDbkVtQyxnQkFBZ0JySSxRQUFRa0csSUFBSSxLQUFLLGtCQUFrQmxHLFFBQVFrRyxJQUFJLEtBQUs7UUFDcEVvQyxvQkFBb0J0SSxRQUFRMEcsV0FBVztRQUN2QzZCLG1CQUFtQnZJLFFBQVFvRSxTQUFTO0lBQ3hDO0lBQ0EsTUFBTW9FLFdBQVcsSUFBSWpQLDJCQUEyQnNHLFFBQVFDLFNBQVNDLGtCQUFrQkMsU0FBU0M7SUFDNUYsT0FBT2lJLGFBQWFPLE1BQU0sQ0FBQyxDQUFDQyxNQUFNQztRQUM5QixPQUFPQSxZQUFZUixrQkFBa0JPO0lBQ3pDLEdBQUdGO0FBQ1AsRUFDQSwrQ0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWludGVyY2VwdG9ycy5qcz9lM2EyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDI0IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2VTZXJ2ZXJJbnRlcmNlcHRpbmdDYWxsID0gZXhwb3J0cy5TZXJ2ZXJJbnRlcmNlcHRpbmdDYWxsID0gZXhwb3J0cy5SZXNwb25kZXJCdWlsZGVyID0gZXhwb3J0cy5TZXJ2ZXJMaXN0ZW5lckJ1aWxkZXIgPSB2b2lkIDA7XG5leHBvcnRzLmlzSW50ZXJjZXB0aW5nU2VydmVyTGlzdGVuZXIgPSBpc0ludGVyY2VwdGluZ1NlcnZlckxpc3RlbmVyO1xuZXhwb3J0cy5nZXRTZXJ2ZXJJbnRlcmNlcHRpbmdDYWxsID0gZ2V0U2VydmVySW50ZXJjZXB0aW5nQ2FsbDtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgaHR0cDIgPSByZXF1aXJlKFwiaHR0cDJcIik7XG5jb25zdCBlcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG5jb25zdCB6bGliID0gcmVxdWlyZShcInpsaWJcIik7XG5jb25zdCBzdHJlYW1fZGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vc3RyZWFtLWRlY29kZXJcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3NlcnZlcl9jYWxsJztcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xufVxuY2xhc3MgU2VydmVyTGlzdGVuZXJCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmhhbGZDbG9zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jYW5jZWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHdpdGhPblJlY2VpdmVNZXRhZGF0YShvblJlY2VpdmVNZXRhZGF0YSkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gb25SZWNlaXZlTWV0YWRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoT25SZWNlaXZlTWVzc2FnZShvblJlY2VpdmVNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG9uUmVjZWl2ZU1lc3NhZ2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoT25SZWNlaXZlSGFsZkNsb3NlKG9uUmVjZWl2ZUhhbGZDbG9zZSkge1xuICAgICAgICB0aGlzLmhhbGZDbG9zZSA9IG9uUmVjZWl2ZUhhbGZDbG9zZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhPbkNhbmNlbChvbkNhbmNlbCkge1xuICAgICAgICB0aGlzLmNhbmNlbCA9IG9uQ2FuY2VsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYnVpbGQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogdGhpcy5tZXRhZGF0YSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZUhhbGZDbG9zZTogdGhpcy5oYWxmQ2xvc2UsXG4gICAgICAgICAgICBvbkNhbmNlbDogdGhpcy5jYW5jZWwsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXJMaXN0ZW5lckJ1aWxkZXIgPSBTZXJ2ZXJMaXN0ZW5lckJ1aWxkZXI7XG5mdW5jdGlvbiBpc0ludGVyY2VwdGluZ1NlcnZlckxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIChsaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhLmxlbmd0aCA9PT0gMSk7XG59XG5jbGFzcyBJbnRlcmNlcHRpbmdTZXJ2ZXJMaXN0ZW5lckltcGwge1xuICAgIGNvbnN0cnVjdG9yKGxpc3RlbmVyLCBuZXh0TGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLm5leHRMaXN0ZW5lciA9IG5leHRMaXN0ZW5lcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9uY2UgdGhlIGNhbGwgaXMgY2FuY2VsbGVkLCBpZ25vcmUgYWxsIG90aGVyIGV2ZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzUGVuZGluZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNQZW5kaW5nSGFsZkNsb3NlID0gZmFsc2U7XG4gICAgfVxuICAgIHByb2Nlc3NQZW5kaW5nTWVzc2FnZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzUGVuZGluZ01lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UodGhpcy5wZW5kaW5nTWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaGFzUGVuZGluZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzUGVuZGluZ0hhbGZDbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzUGVuZGluZ0hhbGZDbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25SZWNlaXZlSGFsZkNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmhhc1BlbmRpbmdIYWxmQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IHRydWU7XG4gICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEsIGludGVyY2VwdGVkTWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKGludGVyY2VwdGVkTWV0YWRhdGEpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ01lc3NhZ2UoKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdIYWxmQ2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UsIG1zZyA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbXNnO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzUGVuZGluZ01lc3NhZ2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZShtc2cpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdIYWxmQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uUmVjZWl2ZUhhbGZDbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVIYWxmQ2xvc2UoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhIHx8IHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc1BlbmRpbmdIYWxmQ2xvc2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25SZWNlaXZlSGFsZkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbkNhbmNlbCgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmxpc3RlbmVyLm9uQ2FuY2VsKCk7XG4gICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uQ2FuY2VsKCk7XG4gICAgfVxufVxuY2xhc3MgUmVzcG9uZGVyQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHdpdGhTdGFydChzdGFydCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoU2VuZE1ldGFkYXRhKHNlbmRNZXRhZGF0YSkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gc2VuZE1ldGFkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2l0aFNlbmRNZXNzYWdlKHNlbmRNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHNlbmRNZXNzYWdlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2l0aFNlbmRTdGF0dXMoc2VuZFN0YXR1cykge1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHNlbmRTdGF0dXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBidWlsZCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0LFxuICAgICAgICAgICAgc2VuZE1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhLFxuICAgICAgICAgICAgc2VuZE1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgICAgIHNlbmRTdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuUmVzcG9uZGVyQnVpbGRlciA9IFJlc3BvbmRlckJ1aWxkZXI7XG5jb25zdCBkZWZhdWx0U2VydmVyTGlzdGVuZXIgPSB7XG4gICAgb25SZWNlaXZlTWV0YWRhdGE6IChtZXRhZGF0YSwgbmV4dCkgPT4ge1xuICAgICAgICBuZXh0KG1ldGFkYXRhKTtcbiAgICB9LFxuICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IChtZXNzYWdlLCBuZXh0KSA9PiB7XG4gICAgICAgIG5leHQobWVzc2FnZSk7XG4gICAgfSxcbiAgICBvblJlY2VpdmVIYWxmQ2xvc2U6IG5leHQgPT4ge1xuICAgICAgICBuZXh0KCk7XG4gICAgfSxcbiAgICBvbkNhbmNlbDogKCkgPT4geyB9LFxufTtcbmNvbnN0IGRlZmF1bHRSZXNwb25kZXIgPSB7XG4gICAgc3RhcnQ6IG5leHQgPT4ge1xuICAgICAgICBuZXh0KCk7XG4gICAgfSxcbiAgICBzZW5kTWV0YWRhdGE6IChtZXRhZGF0YSwgbmV4dCkgPT4ge1xuICAgICAgICBuZXh0KG1ldGFkYXRhKTtcbiAgICB9LFxuICAgIHNlbmRNZXNzYWdlOiAobWVzc2FnZSwgbmV4dCkgPT4ge1xuICAgICAgICBuZXh0KG1lc3NhZ2UpO1xuICAgIH0sXG4gICAgc2VuZFN0YXR1czogKHN0YXR1cywgbmV4dCkgPT4ge1xuICAgICAgICBuZXh0KHN0YXR1cyk7XG4gICAgfSxcbn07XG5jbGFzcyBTZXJ2ZXJJbnRlcmNlcHRpbmdDYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihuZXh0Q2FsbCwgcmVzcG9uZGVyKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgdGhpcy5uZXh0Q2FsbCA9IG5leHRDYWxsO1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbnRNZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdTdGF0dXMgPSBudWxsO1xuICAgICAgICB0aGlzLnJlc3BvbmRlciA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiAoX2EgPSByZXNwb25kZXIgPT09IG51bGwgfHwgcmVzcG9uZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25kZXIuc3RhcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZmF1bHRSZXNwb25kZXIuc3RhcnQsXG4gICAgICAgICAgICBzZW5kTWV0YWRhdGE6IChfYiA9IHJlc3BvbmRlciA9PT0gbnVsbCB8fCByZXNwb25kZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbmRlci5zZW5kTWV0YWRhdGEpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRlZmF1bHRSZXNwb25kZXIuc2VuZE1ldGFkYXRhLFxuICAgICAgICAgICAgc2VuZE1lc3NhZ2U6IChfYyA9IHJlc3BvbmRlciA9PT0gbnVsbCB8fCByZXNwb25kZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbmRlci5zZW5kTWVzc2FnZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZGVmYXVsdFJlc3BvbmRlci5zZW5kTWVzc2FnZSxcbiAgICAgICAgICAgIHNlbmRTdGF0dXM6IChfZCA9IHJlc3BvbmRlciA9PT0gbnVsbCB8fCByZXNwb25kZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbmRlci5zZW5kU3RhdHVzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBkZWZhdWx0UmVzcG9uZGVyLnNlbmRTdGF0dXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHByb2Nlc3NQZW5kaW5nTWVzc2FnZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ01lc3NhZ2VDYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5zZW5kTWVzc2FnZSh0aGlzLnBlbmRpbmdNZXNzYWdlLCB0aGlzLnBlbmRpbmdNZXNzYWdlQ2FsbGJhY2spO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NQZW5kaW5nU3RhdHVzKCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nU3RhdHVzKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRDYWxsLnNlbmRTdGF0dXModGhpcy5wZW5kaW5nU3RhdHVzKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1N0YXR1cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5yZXNwb25kZXIuc3RhcnQoaW50ZXJjZXB0ZWRMaXN0ZW5lciA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICBjb25zdCBmdWxsSW50ZXJjZXB0ZWRMaXN0ZW5lciA9IHtcbiAgICAgICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogKF9hID0gaW50ZXJjZXB0ZWRMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRlZExpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRlZExpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkZWZhdWx0U2VydmVyTGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogKF9iID0gaW50ZXJjZXB0ZWRMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRlZExpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRlZExpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRlZmF1bHRTZXJ2ZXJMaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlLFxuICAgICAgICAgICAgICAgIG9uUmVjZWl2ZUhhbGZDbG9zZTogKF9jID0gaW50ZXJjZXB0ZWRMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRlZExpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRlZExpc3RlbmVyLm9uUmVjZWl2ZUhhbGZDbG9zZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZGVmYXVsdFNlcnZlckxpc3RlbmVyLm9uUmVjZWl2ZUhhbGZDbG9zZSxcbiAgICAgICAgICAgICAgICBvbkNhbmNlbDogKF9kID0gaW50ZXJjZXB0ZWRMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRlZExpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRlZExpc3RlbmVyLm9uQ2FuY2VsKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBkZWZhdWx0U2VydmVyTGlzdGVuZXIub25DYW5jZWwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IG5ldyBJbnRlcmNlcHRpbmdTZXJ2ZXJMaXN0ZW5lckltcGwoZnVsbEludGVyY2VwdGVkTGlzdGVuZXIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMubmV4dENhbGwuc3RhcnQoZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSB0cnVlO1xuICAgICAgICB0aGlzLnNlbnRNZXRhZGF0YSA9IHRydWU7XG4gICAgICAgIHRoaXMucmVzcG9uZGVyLnNlbmRNZXRhZGF0YShtZXRhZGF0YSwgaW50ZXJjZXB0ZWRNZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5zZW5kTWV0YWRhdGEoaW50ZXJjZXB0ZWRNZXRhZGF0YSk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nTWVzc2FnZSgpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ1N0YXR1cygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZE1lc3NhZ2UobWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5zZW50TWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1ldGFkYXRhKG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzcG9uZGVyLnNlbmRNZXNzYWdlKG1lc3NhZ2UsIGludGVyY2VwdGVkTWVzc2FnZSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gaW50ZXJjZXB0ZWRNZXNzYWdlO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5zZW5kTWVzc2FnZShpbnRlcmNlcHRlZE1lc3NhZ2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIHRoaXMucmVzcG9uZGVyLnNlbmRTdGF0dXMoc3RhdHVzLCBpbnRlcmNlcHRlZFN0YXR1cyA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgfHwgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1N0YXR1cyA9IGludGVyY2VwdGVkU3RhdHVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5zZW5kU3RhdHVzKGludGVyY2VwdGVkU3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXJ0UmVhZCgpIHtcbiAgICAgICAgdGhpcy5uZXh0Q2FsbC5zdGFydFJlYWQoKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dENhbGwuZ2V0UGVlcigpO1xuICAgIH1cbiAgICBnZXREZWFkbGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dENhbGwuZ2V0RGVhZGxpbmUoKTtcbiAgICB9XG4gICAgZ2V0SG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dENhbGwuZ2V0SG9zdCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVySW50ZXJjZXB0aW5nQ2FsbCA9IFNlcnZlckludGVyY2VwdGluZ0NhbGw7XG5jb25zdCBHUlBDX0FDQ0VQVF9FTkNPRElOR19IRUFERVIgPSAnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnO1xuY29uc3QgR1JQQ19FTkNPRElOR19IRUFERVIgPSAnZ3JwYy1lbmNvZGluZyc7XG5jb25zdCBHUlBDX01FU1NBR0VfSEVBREVSID0gJ2dycGMtbWVzc2FnZSc7XG5jb25zdCBHUlBDX1NUQVRVU19IRUFERVIgPSAnZ3JwYy1zdGF0dXMnO1xuY29uc3QgR1JQQ19USU1FT1VUX0hFQURFUiA9ICdncnBjLXRpbWVvdXQnO1xuY29uc3QgREVBRExJTkVfUkVHRVggPSAvKFxcZHsxLDh9KVxccyooW0hNU211bl0pLztcbmNvbnN0IGRlYWRsaW5lVW5pdHNUb01zID0ge1xuICAgIEg6IDM2MDAwMDAsXG4gICAgTTogNjAwMDAsXG4gICAgUzogMTAwMCxcbiAgICBtOiAxLFxuICAgIHU6IDAuMDAxLFxuICAgIG46IDAuMDAwMDAxLFxufTtcbmNvbnN0IGRlZmF1bHRDb21wcmVzc2lvbkhlYWRlcnMgPSB7XG4gICAgLy8gVE9ETyhjamlocmlnKTogUmVtb3ZlIHRoZXNlIGVuY29kaW5nIGhlYWRlcnMgZnJvbSB0aGUgZGVmYXVsdCByZXNwb25zZVxuICAgIC8vIG9uY2UgY29tcHJlc3Npb24gaXMgaW50ZWdyYXRlZC5cbiAgICBbR1JQQ19BQ0NFUFRfRU5DT0RJTkdfSEVBREVSXTogJ2lkZW50aXR5LGRlZmxhdGUsZ3ppcCcsXG4gICAgW0dSUENfRU5DT0RJTkdfSEVBREVSXTogJ2lkZW50aXR5Jyxcbn07XG5jb25zdCBkZWZhdWx0UmVzcG9uc2VIZWFkZXJzID0ge1xuICAgIFtodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX1NUQVRVU106IGh0dHAyLmNvbnN0YW50cy5IVFRQX1NUQVRVU19PSyxcbiAgICBbaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEVdOiAnYXBwbGljYXRpb24vZ3JwYytwcm90bycsXG59O1xuY29uc3QgZGVmYXVsdFJlc3BvbnNlT3B0aW9ucyA9IHtcbiAgICB3YWl0Rm9yVHJhaWxlcnM6IHRydWUsXG59O1xuY2xhc3MgQmFzZVNlcnZlckludGVyY2VwdGluZ0NhbGwge1xuICAgIGNvbnN0cnVjdG9yKHN0cmVhbSwgaGVhZGVycywgY2FsbEV2ZW50VHJhY2tlciwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICB0aGlzLmNhbGxFdmVudFRyYWNrZXIgPSBjYWxsRXZlbnRUcmFja2VyO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZWFkbGluZVRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZWFkbGluZSA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSA9IGNvbnN0YW50c18xLkRFRkFVTFRfTUFYX1NFTkRfTUVTU0FHRV9MRU5HVEg7XG4gICAgICAgIHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplID0gY29uc3RhbnRzXzEuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSDtcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YVNlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy53YW50VHJhaWxlcnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5jZWxOb3RpZmllZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluY29taW5nRW5jb2RpbmcgPSAnaWRlbnRpdHknO1xuICAgICAgICB0aGlzLnJlYWRRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmlzUmVhZFBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWNlaXZlZEhhbGZDbG9zZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0cmVhbUVuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICAgICAgLyogV2UgbmVlZCBhbiBlcnJvciBoYW5kbGVyIHRvIGF2b2lkIHVuY2F1Z2h0IGVycm9yIGV2ZW50IGV4Y2VwdGlvbnMsIGJ1dFxuICAgICAgICAgICAgICogdGhlcmUgaXMgbm90aGluZyB3ZSBjYW4gcmVhc29uYWJseSBkbyBoZXJlLiBBbnkgZXJyb3IgZXZlbnQgc2hvdWxkXG4gICAgICAgICAgICAgKiBoYXZlIGEgY29ycmVzcG9uZGluZyBjbG9zZSBldmVudCwgd2hpY2ggaGFuZGxlcyBlbWl0dGluZyB0aGUgY2FuY2VsbGVkXG4gICAgICAgICAgICAgKiBldmVudC4gQW5kIHRoZSBzdHJlYW0gaXMgbm93IGluIGEgYmFkIHN0YXRlLCBzbyB3ZSBjYW4ndCByZWFzb25hYmx5XG4gICAgICAgICAgICAgKiBleHBlY3QgdG8gYmUgYWJsZSB0byBzZW5kIGFuIGVycm9yIG92ZXIgaXQuICovXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbS5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHRyYWNlKCdSZXF1ZXN0IHRvIG1ldGhvZCAnICtcbiAgICAgICAgICAgICAgICAoKF9hID0gdGhpcy5oYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF0aCkgK1xuICAgICAgICAgICAgICAgICcgc3RyZWFtIGNsb3NlZCB3aXRoIHJzdENvZGUgJyArXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ucnN0Q29kZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5jYWxsRXZlbnRUcmFja2VyICYmICF0aGlzLnN0cmVhbUVuZGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1FbmRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyLm9uU3RyZWFtRW5kKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxFdmVudFRyYWNrZXIub25DYWxsRW5kKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogJ1N0cmVhbSBjbG9zZWQgYmVmb3JlIHNlbmRpbmcgc3RhdHVzJyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5vdGlmeU9uQ2FuY2VsKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbS5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURhdGFGcmFtZShkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLnBhdXNlKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUVuZEV2ZW50KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoJ2dycGMubWF4X3NlbmRfbWVzc2FnZV9sZW5ndGgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubWF4U2VuZE1lc3NhZ2VTaXplID0gb3B0aW9uc1snZ3JwYy5tYXhfc2VuZF9tZXNzYWdlX2xlbmd0aCddO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZ3JwYy5tYXhfcmVjZWl2ZV9tZXNzYWdlX2xlbmd0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUgPSBvcHRpb25zWydncnBjLm1heF9yZWNlaXZlX21lc3NhZ2VfbGVuZ3RoJ107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ob3N0ID0gKF9hID0gaGVhZGVyc1snOmF1dGhvcml0eSddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBoZWFkZXJzLmhvc3Q7XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBzdHJlYW1fZGVjb2Rlcl8xLlN0cmVhbURlY29kZXIodGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUpO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IG1ldGFkYXRhXzEuTWV0YWRhdGEuZnJvbUh0dHAySGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgaWYgKGxvZ2dpbmcuaXNUcmFjZXJFbmFibGVkKFRSQUNFUl9OQU1FKSkge1xuICAgICAgICAgICAgdHJhY2UoJ1JlcXVlc3QgdG8gJyArXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVyLnBhdGggK1xuICAgICAgICAgICAgICAgICcgcmVjZWl2ZWQgaGVhZGVycyAnICtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShtZXRhZGF0YS50b0pTT04oKSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVvdXRIZWFkZXIgPSBtZXRhZGF0YS5nZXQoR1JQQ19USU1FT1VUX0hFQURFUik7XG4gICAgICAgIGlmICh0aW1lb3V0SGVhZGVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVGltZW91dEhlYWRlcih0aW1lb3V0SGVhZGVyWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmNvZGluZ0hlYWRlciA9IG1ldGFkYXRhLmdldChHUlBDX0VOQ09ESU5HX0hFQURFUik7XG4gICAgICAgIGlmIChlbmNvZGluZ0hlYWRlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmluY29taW5nRW5jb2RpbmcgPSBlbmNvZGluZ0hlYWRlclswXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgc2V2ZXJhbCBoZWFkZXJzIHRoYXQgc2hvdWxkIG5vdCBiZSBwcm9wYWdhdGVkIHRvIHRoZSBhcHBsaWNhdGlvblxuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoR1JQQ19USU1FT1VUX0hFQURFUik7XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZShHUlBDX0VOQ09ESU5HX0hFQURFUik7XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZShHUlBDX0FDQ0VQVF9FTkNPRElOR19IRUFERVIpO1xuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9BQ0NFUFRfRU5DT0RJTkcpO1xuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9URSk7XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZShodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRSk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICB9XG4gICAgaGFuZGxlVGltZW91dEhlYWRlcih0aW1lb3V0SGVhZGVyKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGltZW91dEhlYWRlci50b1N0cmluZygpLm1hdGNoKERFQURMSU5FX1JFR0VYKTtcbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSB7XG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGBJbnZhbGlkICR7R1JQQ19USU1FT1VUX0hFQURFUn0gdmFsdWUgXCIke3RpbWVvdXRIZWFkZXJ9XCJgLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBjb25zdHJ1Y3RvciB0byBjb21wbGV0ZSBiZWZvcmUgc2VuZGluZyB0aGUgZXJyb3IuXG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAoK21hdGNoWzFdICogZGVhZGxpbmVVbml0c1RvTXNbbWF0Y2hbMl1dKSB8IDA7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMuZGVhZGxpbmUgPSBub3cuc2V0TWlsbGlzZWNvbmRzKG5vdy5nZXRNaWxsaXNlY29uZHMoKSArIHRpbWVvdXQpO1xuICAgICAgICB0aGlzLmRlYWRsaW5lVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuREVBRExJTkVfRVhDRUVERUQsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogJ0RlYWRsaW5lIGV4Y2VlZGVkJyxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnNlbmRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgfVxuICAgIGNoZWNrQ2FuY2VsbGVkKCkge1xuICAgICAgICAvKiBJbiBzb21lIGNhc2VzIHRoZSBzdHJlYW0gY2FuIGJlY29tZSBkZXN0cm95ZWQgYmVmb3JlIHRoZSBjbG9zZSBldmVudFxuICAgICAgICAgKiBmaXJlcy4gVGhhdCBjcmVhdGVzIGEgcmFjZSBjb25kaXRpb24gdGhhdCB0aGlzIGNoZWNrIHdvcmtzIGFyb3VuZCAqL1xuICAgICAgICBpZiAoIXRoaXMuY2FuY2VsbGVkICYmICh0aGlzLnN0cmVhbS5kZXN0cm95ZWQgfHwgdGhpcy5zdHJlYW0uY2xvc2VkKSkge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlPbkNhbmNlbCgpO1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhbmNlbGxlZDtcbiAgICB9XG4gICAgbm90aWZ5T25DYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbE5vdGlmaWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5jZWxOb3RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmxpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25DYW5jZWwoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmRlYWRsaW5lVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYWRsaW5lVGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZsdXNoIGluY29taW5nIGRhdGEgZnJhbWVzXG4gICAgICAgIHRoaXMuc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHNlcnZlciBoYW5kbGVyIGNhbiBzdGFydCBzZW5kaW5nIG1lc3NhZ2VzIHdpdGhvdXQgZXhwbGljaXRseSBzZW5kaW5nXG4gICAgICogbWV0YWRhdGEuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byBzZW5kIGhlYWRlcnMgYmVmb3JlIHNlbmRpbmcgYW55XG4gICAgICogbWVzc2FnZXMuIFRoaXMgZnVuY3Rpb24gZG9lcyB0aGF0IGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBtYXliZVNlbmRNZXRhZGF0YSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1ldGFkYXRhU2VudCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kTWV0YWRhdGEobmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIGEgbWVzc2FnZSB0byBhIGxlbmd0aC1kZWxpbWl0ZWQgYnl0ZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzZXJpYWxpemVNZXNzYWdlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VCdWZmZXIgPSB0aGlzLmhhbmRsZXIuc2VyaWFsaXplKHZhbHVlKTtcbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IG1lc3NhZ2VCdWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJ5dGVMZW5ndGggKyA1KTtcbiAgICAgICAgLyogTm90ZTogcmVzcG9uc2UgY29tcHJlc3Npb24gaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQsIHNvIHRoaXNcbiAgICAgICAgICogY29tcHJlc3NlZCBiaXQgaXMgYWx3YXlzIDAuICovXG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQ4KDAsIDApO1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50MzJCRShieXRlTGVuZ3RoLCAxKTtcbiAgICAgICAgbWVzc2FnZUJ1ZmZlci5jb3B5KG91dHB1dCwgNSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGRlY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UsIGVuY29kaW5nKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VDb250ZW50cyA9IG1lc3NhZ2Uuc3ViYXJyYXkoNSk7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VDb250ZW50cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbmNvZGluZyA9PT0gJ2RlZmxhdGUnIHx8IGVuY29kaW5nID09PSAnZ3ppcCcpIHtcbiAgICAgICAgICAgIGxldCBkZWNvbXByZXNzZXI7XG4gICAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdkZWZsYXRlJykge1xuICAgICAgICAgICAgICAgIGRlY29tcHJlc3NlciA9IHpsaWIuY3JlYXRlSW5mbGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVjb21wcmVzc2VyID0gemxpYi5jcmVhdGVHdW56aXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlUGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB0b3RhbExlbmd0aCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUgIT09IC0xICYmIHRvdGFsTGVuZ3RoID4gdGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29tcHJlc3Nlci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFJlY2VpdmVkIG1lc3NhZ2UgdGhhdCBkZWNvbXByZXNzZXMgdG8gYSBzaXplIGxhcmdlciB0aGFuICR7dGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemV9YFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShCdWZmZXIuY29uY2F0KG1lc3NhZ2VQYXJ0cykpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRlY29tcHJlc3Nlci53cml0ZShtZXNzYWdlQ29udGVudHMpO1xuICAgICAgICAgICAgICAgIGRlY29tcHJlc3Nlci5lbmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRCxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgbWVzc2FnZSBjb21wcmVzc2VkIHdpdGggdW5zdXBwb3J0ZWQgZW5jb2RpbmcgXCIke2VuY29kaW5nfVwiYCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlY29tcHJlc3NBbmRNYXliZVB1c2gocXVldWVFbnRyeSkge1xuICAgICAgICBpZiAocXVldWVFbnRyeS50eXBlICE9PSAnQ09NUFJFU1NFRCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBxdWV1ZSBlbnRyeSB0eXBlOiAke3F1ZXVlRW50cnkudHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wcmVzc2VkID0gcXVldWVFbnRyeS5jb21wcmVzc2VkTWVzc2FnZS5yZWFkVUludDgoMCkgPT09IDE7XG4gICAgICAgIGNvbnN0IGNvbXByZXNzZWRNZXNzYWdlRW5jb2RpbmcgPSBjb21wcmVzc2VkXG4gICAgICAgICAgICA/IHRoaXMuaW5jb21pbmdFbmNvZGluZ1xuICAgICAgICAgICAgOiAnaWRlbnRpdHknO1xuICAgICAgICBsZXQgZGVjb21wcmVzc2VkTWVzc2FnZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlY29tcHJlc3NlZE1lc3NhZ2UgPSBhd2FpdCB0aGlzLmRlY29tcHJlc3NNZXNzYWdlKHF1ZXVlRW50cnkuY29tcHJlc3NlZE1lc3NhZ2UsIGNvbXByZXNzZWRNZXNzYWdlRW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZFN0YXR1cyhlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBxdWV1ZUVudHJ5LnBhcnNlZE1lc3NhZ2UgPSB0aGlzLmhhbmRsZXIuZGVzZXJpYWxpemUoZGVjb21wcmVzc2VkTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5zZW5kU3RhdHVzKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogYEVycm9yIGRlc2VyaWFsaXppbmcgcmVxdWVzdDogJHtlcnIubWVzc2FnZX1gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVFbnRyeS50eXBlID0gJ1JFQURBQkxFJztcbiAgICAgICAgdGhpcy5tYXliZVB1c2hOZXh0TWVzc2FnZSgpO1xuICAgIH1cbiAgICBtYXliZVB1c2hOZXh0TWVzc2FnZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXIgJiZcbiAgICAgICAgICAgIHRoaXMuaXNSZWFkUGVuZGluZyAmJlxuICAgICAgICAgICAgdGhpcy5yZWFkUXVldWUubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgdGhpcy5yZWFkUXVldWVbMF0udHlwZSAhPT0gJ0NPTVBSRVNTRUQnKSB7XG4gICAgICAgICAgICB0aGlzLmlzUmVhZFBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRRdWV1ZUVudHJ5ID0gdGhpcy5yZWFkUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChuZXh0UXVldWVFbnRyeS50eXBlID09PSAnUkVBREFCTEUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG5leHRRdWV1ZUVudHJ5LnBhcnNlZE1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbmV4dFF1ZXVlRW50cnkudHlwZSA9PT0gJ0hBTEZfQ0xPU0UnXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVIYWxmQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVEYXRhRnJhbWUoZGF0YSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnUmVxdWVzdCB0byAnICtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5wYXRoICtcbiAgICAgICAgICAgICcgcmVjZWl2ZWQgZGF0YSBmcmFtZSBvZiBzaXplICcgK1xuICAgICAgICAgICAgZGF0YS5sZW5ndGgpO1xuICAgICAgICBsZXQgcmF3TWVzc2FnZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByYXdNZXNzYWdlcyA9IHRoaXMuZGVjb2Rlci53cml0ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5zZW5kU3RhdHVzKHsgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCwgZGV0YWlsczogZS5tZXNzYWdlIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZUJ5dGVzIG9mIHJhd01lc3NhZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5wYXVzZSgpO1xuICAgICAgICAgICAgY29uc3QgcXVldWVFbnRyeSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ09NUFJFU1NFRCcsXG4gICAgICAgICAgICAgICAgY29tcHJlc3NlZE1lc3NhZ2U6IG1lc3NhZ2VCeXRlcyxcbiAgICAgICAgICAgICAgICBwYXJzZWRNZXNzYWdlOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucmVhZFF1ZXVlLnB1c2gocXVldWVFbnRyeSk7XG4gICAgICAgICAgICB0aGlzLmRlY29tcHJlc3NBbmRNYXliZVB1c2gocXVldWVFbnRyeSk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmNhbGxFdmVudFRyYWNrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRNZXNzYWdlUmVjZWl2ZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVFbmRFdmVudCgpIHtcbiAgICAgICAgdGhpcy5yZWFkUXVldWUucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnSEFMRl9DTE9TRScsXG4gICAgICAgICAgICBjb21wcmVzc2VkTWVzc2FnZTogbnVsbCxcbiAgICAgICAgICAgIHBhcnNlZE1lc3NhZ2U6IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlY2VpdmVkSGFsZkNsb3NlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYXliZVB1c2hOZXh0TWVzc2FnZSgpO1xuICAgIH1cbiAgICBzdGFydChsaXN0ZW5lcikge1xuICAgICAgICB0cmFjZSgnUmVxdWVzdCB0byAnICsgdGhpcy5oYW5kbGVyLnBhdGggKyAnIHN0YXJ0IGNhbGxlZCcpO1xuICAgICAgICBpZiAodGhpcy5jaGVja0NhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICBsaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSh0aGlzLm1ldGFkYXRhKTtcbiAgICB9XG4gICAgc2VuZE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YVNlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1ldGFkYXRhU2VudCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGN1c3RvbSA9IG1ldGFkYXRhID8gbWV0YWRhdGEudG9IdHRwMkhlYWRlcnMoKSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFJlc3BvbnNlSGVhZGVycyksIGRlZmF1bHRDb21wcmVzc2lvbkhlYWRlcnMpLCBjdXN0b20pO1xuICAgICAgICB0aGlzLnN0cmVhbS5yZXNwb25kKGhlYWRlcnMsIGRlZmF1bHRSZXNwb25zZU9wdGlvbnMpO1xuICAgIH1cbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5jaGVja0NhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLnNlcmlhbGl6ZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGBFcnJvciBzZXJpYWxpemluZyByZXNwb25zZTogJHsoMCwgZXJyb3JfMS5nZXRFcnJvck1lc3NhZ2UpKGUpfWAsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXhTZW5kTWVzc2FnZVNpemUgIT09IC0xICYmXG4gICAgICAgICAgICByZXNwb25zZS5sZW5ndGggLSA1ID4gdGhpcy5tYXhTZW5kTWVzc2FnZVNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBgU2VudCBtZXNzYWdlIGxhcmdlciB0aGFuIG1heCAoJHtyZXNwb25zZS5sZW5ndGh9IHZzLiAke3RoaXMubWF4U2VuZE1lc3NhZ2VTaXplfSlgLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXliZVNlbmRNZXRhZGF0YSgpO1xuICAgICAgICB0cmFjZSgnUmVxdWVzdCB0byAnICtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5wYXRoICtcbiAgICAgICAgICAgICcgc2VudCBkYXRhIGZyYW1lIG9mIHNpemUgJyArXG4gICAgICAgICAgICByZXNwb25zZS5sZW5ndGgpO1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZShyZXNwb25zZSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kU3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgRXJyb3Igd3JpdGluZyBtZXNzYWdlOiAkeygwLCBlcnJvcl8xLmdldEVycm9yTWVzc2FnZSkoZXJyb3IpfWAsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYSA9IHRoaXMuY2FsbEV2ZW50VHJhY2tlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZE1lc3NhZ2VTZW50KCk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZFN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tDYW5jZWxsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlKCdSZXF1ZXN0IHRvIG1ldGhvZCAnICtcbiAgICAgICAgICAgICgoX2EgPSB0aGlzLmhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXRoKSArXG4gICAgICAgICAgICAnIGVuZGVkIHdpdGggc3RhdHVzIGNvZGU6ICcgK1xuICAgICAgICAgICAgY29uc3RhbnRzXzEuU3RhdHVzW3N0YXR1cy5jb2RlXSArXG4gICAgICAgICAgICAnIGRldGFpbHM6ICcgK1xuICAgICAgICAgICAgc3RhdHVzLmRldGFpbHMpO1xuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YVNlbnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy53YW50VHJhaWxlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhbnRUcmFpbGVycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ub25jZSgnd2FudFRyYWlsZXJzJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbGxFdmVudFRyYWNrZXIgJiYgIXRoaXMuc3RyZWFtRW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtRW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyLm9uU3RyZWFtRW5kKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyLm9uQ2FsbEVuZChzdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYWlsZXJzVG9TZW5kID0gT2JqZWN0LmFzc2lnbih7IFtHUlBDX1NUQVRVU19IRUFERVJdOiBzdGF0dXMuY29kZSwgW0dSUENfTUVTU0FHRV9IRUFERVJdOiBlbmNvZGVVUkkoc3RhdHVzLmRldGFpbHMpIH0sIChfYSA9IHN0YXR1cy5tZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvSHR0cDJIZWFkZXJzKCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5zZW5kVHJhaWxlcnModHJhaWxlcnNUb1NlbmQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeU9uQ2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0uZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeU9uQ2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYWxsRXZlbnRUcmFja2VyICYmICF0aGlzLnN0cmVhbUVuZGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1FbmRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyLm9uU3RyZWFtRW5kKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlci5vbkNhbGxFbmQoc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRyYWlsZXJzLW9ubHkgcmVzcG9uc2VcbiAgICAgICAgICAgIGNvbnN0IHRyYWlsZXJzVG9TZW5kID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgW0dSUENfU1RBVFVTX0hFQURFUl06IHN0YXR1cy5jb2RlLCBbR1JQQ19NRVNTQUdFX0hFQURFUl06IGVuY29kZVVSSShzdGF0dXMuZGV0YWlscykgfSwgZGVmYXVsdFJlc3BvbnNlSGVhZGVycyksIChfYiA9IHN0YXR1cy5tZXRhZGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRvSHR0cDJIZWFkZXJzKCkpO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0ucmVzcG9uZCh0cmFpbGVyc1RvU2VuZCwgeyBlbmRTdHJlYW06IHRydWUgfSk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeU9uQ2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRSZWFkKCkge1xuICAgICAgICB0cmFjZSgnUmVxdWVzdCB0byAnICsgdGhpcy5oYW5kbGVyLnBhdGggKyAnIHN0YXJ0UmVhZCBjYWxsZWQnKTtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tDYW5jZWxsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNSZWFkUGVuZGluZyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnJlYWRRdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWNlaXZlZEhhbGZDbG9zZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnJlc3VtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYXliZVB1c2hOZXh0TWVzc2FnZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gKF9hID0gdGhpcy5zdHJlYW0uc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvY2tldDtcbiAgICAgICAgaWYgKHNvY2tldCA9PT0gbnVsbCB8fCBzb2NrZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvY2tldC5yZW1vdGVBZGRyZXNzKSB7XG4gICAgICAgICAgICBpZiAoc29ja2V0LnJlbW90ZVBvcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7c29ja2V0LnJlbW90ZUFkZHJlc3N9OiR7c29ja2V0LnJlbW90ZVBvcnR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBzb2NrZXQucmVtb3RlQWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAndW5rbm93bic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGVhZGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlYWRsaW5lO1xuICAgIH1cbiAgICBnZXRIb3N0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3N0O1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZVNlcnZlckludGVyY2VwdGluZ0NhbGwgPSBCYXNlU2VydmVySW50ZXJjZXB0aW5nQ2FsbDtcbmZ1bmN0aW9uIGdldFNlcnZlckludGVyY2VwdGluZ0NhbGwoaW50ZXJjZXB0b3JzLCBzdHJlYW0sIGhlYWRlcnMsIGNhbGxFdmVudFRyYWNrZXIsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtZXRob2REZWZpbml0aW9uID0ge1xuICAgICAgICBwYXRoOiBoYW5kbGVyLnBhdGgsXG4gICAgICAgIHJlcXVlc3RTdHJlYW06IGhhbmRsZXIudHlwZSA9PT0gJ2NsaWVudFN0cmVhbScgfHwgaGFuZGxlci50eXBlID09PSAnYmlkaScsXG4gICAgICAgIHJlc3BvbnNlU3RyZWFtOiBoYW5kbGVyLnR5cGUgPT09ICdzZXJ2ZXJTdHJlYW0nIHx8IGhhbmRsZXIudHlwZSA9PT0gJ2JpZGknLFxuICAgICAgICByZXF1ZXN0RGVzZXJpYWxpemU6IGhhbmRsZXIuZGVzZXJpYWxpemUsXG4gICAgICAgIHJlc3BvbnNlU2VyaWFsaXplOiBoYW5kbGVyLnNlcmlhbGl6ZSxcbiAgICB9O1xuICAgIGNvbnN0IGJhc2VDYWxsID0gbmV3IEJhc2VTZXJ2ZXJJbnRlcmNlcHRpbmdDYWxsKHN0cmVhbSwgaGVhZGVycywgY2FsbEV2ZW50VHJhY2tlciwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGludGVyY2VwdG9ycy5yZWR1Y2UoKGNhbGwsIGludGVyY2VwdG9yKSA9PiB7XG4gICAgICAgIHJldHVybiBpbnRlcmNlcHRvcihtZXRob2REZWZpbml0aW9uLCBjYWxsKTtcbiAgICB9LCBiYXNlQ2FsbCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2ZXItaW50ZXJjZXB0b3JzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkJhc2VTZXJ2ZXJJbnRlcmNlcHRpbmdDYWxsIiwiU2VydmVySW50ZXJjZXB0aW5nQ2FsbCIsIlJlc3BvbmRlckJ1aWxkZXIiLCJTZXJ2ZXJMaXN0ZW5lckJ1aWxkZXIiLCJpc0ludGVyY2VwdGluZ1NlcnZlckxpc3RlbmVyIiwiZ2V0U2VydmVySW50ZXJjZXB0aW5nQ2FsbCIsIm1ldGFkYXRhXzEiLCJyZXF1aXJlIiwiY29uc3RhbnRzXzEiLCJodHRwMiIsImVycm9yXzEiLCJ6bGliIiwic3RyZWFtX2RlY29kZXJfMSIsImxvZ2dpbmciLCJUUkFDRVJfTkFNRSIsInRyYWNlIiwidGV4dCIsIkxvZ1ZlcmJvc2l0eSIsIkRFQlVHIiwiY29uc3RydWN0b3IiLCJtZXRhZGF0YSIsInVuZGVmaW5lZCIsIm1lc3NhZ2UiLCJoYWxmQ2xvc2UiLCJjYW5jZWwiLCJ3aXRoT25SZWNlaXZlTWV0YWRhdGEiLCJvblJlY2VpdmVNZXRhZGF0YSIsIndpdGhPblJlY2VpdmVNZXNzYWdlIiwib25SZWNlaXZlTWVzc2FnZSIsIndpdGhPblJlY2VpdmVIYWxmQ2xvc2UiLCJvblJlY2VpdmVIYWxmQ2xvc2UiLCJ3aXRoT25DYW5jZWwiLCJvbkNhbmNlbCIsImJ1aWxkIiwibGlzdGVuZXIiLCJsZW5ndGgiLCJJbnRlcmNlcHRpbmdTZXJ2ZXJMaXN0ZW5lckltcGwiLCJuZXh0TGlzdGVuZXIiLCJjYW5jZWxsZWQiLCJwcm9jZXNzaW5nTWV0YWRhdGEiLCJoYXNQZW5kaW5nTWVzc2FnZSIsInBlbmRpbmdNZXNzYWdlIiwicHJvY2Vzc2luZ01lc3NhZ2UiLCJoYXNQZW5kaW5nSGFsZkNsb3NlIiwicHJvY2Vzc1BlbmRpbmdNZXNzYWdlIiwicHJvY2Vzc1BlbmRpbmdIYWxmQ2xvc2UiLCJpbnRlcmNlcHRlZE1ldGFkYXRhIiwibXNnIiwic3RhcnQiLCJzdGF0dXMiLCJ3aXRoU3RhcnQiLCJ3aXRoU2VuZE1ldGFkYXRhIiwic2VuZE1ldGFkYXRhIiwid2l0aFNlbmRNZXNzYWdlIiwic2VuZE1lc3NhZ2UiLCJ3aXRoU2VuZFN0YXR1cyIsInNlbmRTdGF0dXMiLCJkZWZhdWx0U2VydmVyTGlzdGVuZXIiLCJuZXh0IiwiZGVmYXVsdFJlc3BvbmRlciIsIm5leHRDYWxsIiwicmVzcG9uZGVyIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJzZW50TWV0YWRhdGEiLCJwZW5kaW5nTWVzc2FnZUNhbGxiYWNrIiwicGVuZGluZ1N0YXR1cyIsInByb2Nlc3NQZW5kaW5nU3RhdHVzIiwiaW50ZXJjZXB0ZWRMaXN0ZW5lciIsImZ1bGxJbnRlcmNlcHRlZExpc3RlbmVyIiwiZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lciIsImNhbGxiYWNrIiwiTWV0YWRhdGEiLCJpbnRlcmNlcHRlZE1lc3NhZ2UiLCJpbnRlcmNlcHRlZFN0YXR1cyIsInN0YXJ0UmVhZCIsImdldFBlZXIiLCJnZXREZWFkbGluZSIsImdldEhvc3QiLCJHUlBDX0FDQ0VQVF9FTkNPRElOR19IRUFERVIiLCJHUlBDX0VOQ09ESU5HX0hFQURFUiIsIkdSUENfTUVTU0FHRV9IRUFERVIiLCJHUlBDX1NUQVRVU19IRUFERVIiLCJHUlBDX1RJTUVPVVRfSEVBREVSIiwiREVBRExJTkVfUkVHRVgiLCJkZWFkbGluZVVuaXRzVG9NcyIsIkgiLCJNIiwiUyIsIm0iLCJ1IiwibiIsImRlZmF1bHRDb21wcmVzc2lvbkhlYWRlcnMiLCJkZWZhdWx0UmVzcG9uc2VIZWFkZXJzIiwiY29uc3RhbnRzIiwiSFRUUDJfSEVBREVSX1NUQVRVUyIsIkhUVFBfU1RBVFVTX09LIiwiSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRSIsImRlZmF1bHRSZXNwb25zZU9wdGlvbnMiLCJ3YWl0Rm9yVHJhaWxlcnMiLCJzdHJlYW0iLCJoZWFkZXJzIiwiY2FsbEV2ZW50VHJhY2tlciIsImhhbmRsZXIiLCJvcHRpb25zIiwiZGVhZGxpbmVUaW1lciIsImRlYWRsaW5lIiwiSW5maW5pdHkiLCJtYXhTZW5kTWVzc2FnZVNpemUiLCJERUZBVUxUX01BWF9TRU5EX01FU1NBR0VfTEVOR1RIIiwibWF4UmVjZWl2ZU1lc3NhZ2VTaXplIiwiREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSCIsIm1ldGFkYXRhU2VudCIsIndhbnRUcmFpbGVycyIsImNhbmNlbE5vdGlmaWVkIiwiaW5jb21pbmdFbmNvZGluZyIsInJlYWRRdWV1ZSIsImlzUmVhZFBlbmRpbmciLCJyZWNlaXZlZEhhbGZDbG9zZSIsInN0cmVhbUVuZGVkIiwib25jZSIsImVyciIsInBhdGgiLCJyc3RDb2RlIiwib25TdHJlYW1FbmQiLCJvbkNhbGxFbmQiLCJjb2RlIiwiU3RhdHVzIiwiQ0FOQ0VMTEVEIiwiZGV0YWlscyIsIm5vdGlmeU9uQ2FuY2VsIiwib24iLCJkYXRhIiwiaGFuZGxlRGF0YUZyYW1lIiwicGF1c2UiLCJoYW5kbGVFbmRFdmVudCIsImhvc3QiLCJkZWNvZGVyIiwiU3RyZWFtRGVjb2RlciIsImZyb21IdHRwMkhlYWRlcnMiLCJpc1RyYWNlckVuYWJsZWQiLCJKU09OIiwic3RyaW5naWZ5IiwidG9KU09OIiwidGltZW91dEhlYWRlciIsImdldCIsImhhbmRsZVRpbWVvdXRIZWFkZXIiLCJlbmNvZGluZ0hlYWRlciIsInJlbW92ZSIsIkhUVFAyX0hFQURFUl9BQ0NFUFRfRU5DT0RJTkciLCJIVFRQMl9IRUFERVJfVEUiLCJtYXRjaCIsInRvU3RyaW5nIiwiSU5URVJOQUwiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJ0aW1lb3V0Iiwibm93IiwiRGF0ZSIsInNldE1pbGxpc2Vjb25kcyIsImdldE1pbGxpc2Vjb25kcyIsInNldFRpbWVvdXQiLCJERUFETElORV9FWENFRURFRCIsImNoZWNrQ2FuY2VsbGVkIiwiZGVzdHJveWVkIiwiY2xvc2VkIiwiY2xlYXJUaW1lb3V0IiwicmVzdW1lIiwibWF5YmVTZW5kTWV0YWRhdGEiLCJzZXJpYWxpemVNZXNzYWdlIiwibWVzc2FnZUJ1ZmZlciIsInNlcmlhbGl6ZSIsImJ5dGVMZW5ndGgiLCJvdXRwdXQiLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsIndyaXRlVUludDgiLCJ3cml0ZVVJbnQzMkJFIiwiY29weSIsImRlY29tcHJlc3NNZXNzYWdlIiwiZW5jb2RpbmciLCJtZXNzYWdlQ29udGVudHMiLCJzdWJhcnJheSIsImRlY29tcHJlc3NlciIsImNyZWF0ZUluZmxhdGUiLCJjcmVhdGVHdW56aXAiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInRvdGFsTGVuZ3RoIiwibWVzc2FnZVBhcnRzIiwiY2h1bmsiLCJwdXNoIiwiZGVzdHJveSIsIlJFU09VUkNFX0VYSEFVU1RFRCIsImNvbmNhdCIsIndyaXRlIiwiZW5kIiwiVU5JTVBMRU1FTlRFRCIsImRlY29tcHJlc3NBbmRNYXliZVB1c2giLCJxdWV1ZUVudHJ5IiwidHlwZSIsIkVycm9yIiwiY29tcHJlc3NlZCIsImNvbXByZXNzZWRNZXNzYWdlIiwicmVhZFVJbnQ4IiwiY29tcHJlc3NlZE1lc3NhZ2VFbmNvZGluZyIsImRlY29tcHJlc3NlZE1lc3NhZ2UiLCJwYXJzZWRNZXNzYWdlIiwiZGVzZXJpYWxpemUiLCJtYXliZVB1c2hOZXh0TWVzc2FnZSIsIm5leHRRdWV1ZUVudHJ5Iiwic2hpZnQiLCJyYXdNZXNzYWdlcyIsImUiLCJtZXNzYWdlQnl0ZXMiLCJhZGRNZXNzYWdlUmVjZWl2ZWQiLCJjdXN0b20iLCJ0b0h0dHAySGVhZGVycyIsImFzc2lnbiIsInJlc3BvbmQiLCJyZXNwb25zZSIsImdldEVycm9yTWVzc2FnZSIsImVycm9yIiwiYWRkTWVzc2FnZVNlbnQiLCJ0cmFpbGVyc1RvU2VuZCIsImVuY29kZVVSSSIsInNlbmRUcmFpbGVycyIsImVuZFN0cmVhbSIsInNvY2tldCIsInNlc3Npb24iLCJyZW1vdGVBZGRyZXNzIiwicmVtb3RlUG9ydCIsImludGVyY2VwdG9ycyIsIm1ldGhvZERlZmluaXRpb24iLCJyZXF1ZXN0U3RyZWFtIiwicmVzcG9uc2VTdHJlYW0iLCJyZXF1ZXN0RGVzZXJpYWxpemUiLCJyZXNwb25zZVNlcmlhbGl6ZSIsImJhc2VDYWxsIiwicmVkdWNlIiwiY2FsbCIsImludGVyY2VwdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/server-interceptors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/server.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ var __runInitializers = (void 0) && (void 0).__runInitializers || function(thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for(var i = 0; i < initializers.length; i++){\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n};\nvar __esDecorate = (void 0) && (void 0).__esDecorate || function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) {\n        if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n        return f;\n    }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for(var i = decorators.length - 1; i >= 0; i--){\n        var context = {};\n        for(var p in contextIn)context[p] = p === \"access\" ? {} : contextIn[p];\n        for(var p in contextIn.access)context.access[p] = contextIn.access[p];\n        context.addInitializer = function(f) {\n            if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n            extraInitializers.push(accept(f || null));\n        };\n        var result = (0, decorators[i])(kind === \"accessor\" ? {\n            get: descriptor.get,\n            set: descriptor.set\n        } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        } else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Server = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst server_call_1 = __webpack_require__(/*! ./server-call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server-call.js\");\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst server_interceptors_1 = __webpack_require__(/*! ./server-interceptors */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server-interceptors.js\");\nconst UNLIMITED_CONNECTION_AGE_MS = ~(1 << 31);\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst MAX_CONNECTION_IDLE_MS = ~(1 << 31);\nconst { HTTP2_HEADER_PATH } = http2.constants;\nconst TRACER_NAME = \"server\";\nconst kMaxAge = Buffer.from(\"max_age\");\nfunction serverCallTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, \"server_call\", text);\n}\nfunction noop() {}\n/**\n * Decorator to wrap a class method with util.deprecate\n * @param message The message to output if the deprecated method is called\n * @returns\n */ function deprecate(message) {\n    return function(target, context) {\n        return util.deprecate(target, message);\n    };\n}\nfunction getUnimplementedStatusResponse(methodName) {\n    return {\n        code: constants_1.Status.UNIMPLEMENTED,\n        details: `The server does not implement the method ${methodName}`\n    };\n}\nfunction getDefaultHandler(handlerType, methodName) {\n    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n    switch(handlerType){\n        case \"unary\":\n            return (call, callback)=>{\n                callback(unimplementedStatusResponse, null);\n            };\n        case \"clientStream\":\n            return (call, callback)=>{\n                callback(unimplementedStatusResponse, null);\n            };\n        case \"serverStream\":\n            return (call)=>{\n                call.emit(\"error\", unimplementedStatusResponse);\n            };\n        case \"bidi\":\n            return (call)=>{\n                call.emit(\"error\", unimplementedStatusResponse);\n            };\n        default:\n            throw new Error(`Invalid handlerType ${handlerType}`);\n    }\n}\nlet Server = (()=>{\n    var _a;\n    let _instanceExtraInitializers = [];\n    let _start_decorators;\n    return _a = class Server {\n        constructor(options){\n            var _b, _c, _d, _e, _f, _g;\n            this.boundPorts = (__runInitializers(this, _instanceExtraInitializers), new Map());\n            this.http2Servers = new Map();\n            this.sessionIdleTimeouts = new Map();\n            this.handlers = new Map();\n            this.sessions = new Map();\n            /**\n                 * This field only exists to ensure that the start method throws an error if\n                 * it is called twice, as it did previously.\n                 */ this.started = false;\n            this.shutdown = false;\n            this.serverAddressString = \"null\";\n            // Channelz Info\n            this.channelzEnabled = true;\n            this.options = options !== null && options !== void 0 ? options : {};\n            if (this.options[\"grpc.enable_channelz\"] === 0) {\n                this.channelzEnabled = false;\n                this.channelzTrace = new channelz_1.ChannelzTraceStub();\n                this.callTracker = new channelz_1.ChannelzCallTrackerStub();\n                this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();\n                this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();\n            } else {\n                this.channelzTrace = new channelz_1.ChannelzTrace();\n                this.callTracker = new channelz_1.ChannelzCallTracker();\n                this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n                this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n            }\n            this.channelzRef = (0, channelz_1.registerChannelzServer)(\"server\", ()=>this.getChannelzInfo(), this.channelzEnabled);\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Server created\");\n            this.maxConnectionAgeMs = (_b = this.options[\"grpc.max_connection_age_ms\"]) !== null && _b !== void 0 ? _b : UNLIMITED_CONNECTION_AGE_MS;\n            this.maxConnectionAgeGraceMs = (_c = this.options[\"grpc.max_connection_age_grace_ms\"]) !== null && _c !== void 0 ? _c : UNLIMITED_CONNECTION_AGE_MS;\n            this.keepaliveTimeMs = (_d = this.options[\"grpc.keepalive_time_ms\"]) !== null && _d !== void 0 ? _d : KEEPALIVE_MAX_TIME_MS;\n            this.keepaliveTimeoutMs = (_e = this.options[\"grpc.keepalive_timeout_ms\"]) !== null && _e !== void 0 ? _e : KEEPALIVE_TIMEOUT_MS;\n            this.sessionIdleTimeout = (_f = this.options[\"grpc.max_connection_idle_ms\"]) !== null && _f !== void 0 ? _f : MAX_CONNECTION_IDLE_MS;\n            this.commonServerOptions = {\n                maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER\n            };\n            if (\"grpc-node.max_session_memory\" in this.options) {\n                this.commonServerOptions.maxSessionMemory = this.options[\"grpc-node.max_session_memory\"];\n            } else {\n                /* By default, set a very large max session memory limit, to effectively\n                     * disable enforcement of the limit. Some testing indicates that Node's\n                     * behavior degrades badly when this limit is reached, so we solve that\n                     * by disabling the check entirely. */ this.commonServerOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n            }\n            if (\"grpc.max_concurrent_streams\" in this.options) {\n                this.commonServerOptions.settings = {\n                    maxConcurrentStreams: this.options[\"grpc.max_concurrent_streams\"]\n                };\n            }\n            this.interceptors = (_g = this.options.interceptors) !== null && _g !== void 0 ? _g : [];\n            this.trace(\"Server constructed\");\n        }\n        getChannelzInfo() {\n            return {\n                trace: this.channelzTrace,\n                callTracker: this.callTracker,\n                listenerChildren: this.listenerChildrenTracker.getChildLists(),\n                sessionChildren: this.sessionChildrenTracker.getChildLists()\n            };\n        }\n        getChannelzSessionInfo(session) {\n            var _b, _c, _d;\n            const sessionInfo = this.sessions.get(session);\n            const sessionSocket = session.socket;\n            const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n            const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;\n            let tlsInfo;\n            if (session.encrypted) {\n                const tlsSocket = sessionSocket;\n                const cipherInfo = tlsSocket.getCipher();\n                const certificate = tlsSocket.getCertificate();\n                const peerCertificate = tlsSocket.getPeerCertificate();\n                tlsInfo = {\n                    cipherSuiteStandardName: (_b = cipherInfo.standardName) !== null && _b !== void 0 ? _b : null,\n                    cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n                    localCertificate: certificate && \"raw\" in certificate ? certificate.raw : null,\n                    remoteCertificate: peerCertificate && \"raw\" in peerCertificate ? peerCertificate.raw : null\n                };\n            } else {\n                tlsInfo = null;\n            }\n            const socketInfo = {\n                remoteAddress: remoteAddress,\n                localAddress: localAddress,\n                security: tlsInfo,\n                remoteName: null,\n                streamsStarted: sessionInfo.streamTracker.callsStarted,\n                streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n                streamsFailed: sessionInfo.streamTracker.callsFailed,\n                messagesSent: sessionInfo.messagesSent,\n                messagesReceived: sessionInfo.messagesReceived,\n                keepAlivesSent: sessionInfo.keepAlivesSent,\n                lastLocalStreamCreatedTimestamp: null,\n                lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,\n                lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n                lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n                localFlowControlWindow: (_c = session.state.localWindowSize) !== null && _c !== void 0 ? _c : null,\n                remoteFlowControlWindow: (_d = session.state.remoteWindowSize) !== null && _d !== void 0 ? _d : null\n            };\n            return socketInfo;\n        }\n        trace(text) {\n            logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"(\" + this.channelzRef.id + \") \" + text);\n        }\n        keepaliveTrace(text) {\n            logging.trace(constants_1.LogVerbosity.DEBUG, \"keepalive\", \"(\" + this.channelzRef.id + \") \" + text);\n        }\n        addProtoService() {\n            throw new Error(\"Not implemented. Use addService() instead\");\n        }\n        addService(service, implementation) {\n            if (service === null || typeof service !== \"object\" || implementation === null || typeof implementation !== \"object\") {\n                throw new Error(\"addService() requires two objects as arguments\");\n            }\n            const serviceKeys = Object.keys(service);\n            if (serviceKeys.length === 0) {\n                throw new Error(\"Cannot add an empty service to a server\");\n            }\n            serviceKeys.forEach((name)=>{\n                const attrs = service[name];\n                let methodType;\n                if (attrs.requestStream) {\n                    if (attrs.responseStream) {\n                        methodType = \"bidi\";\n                    } else {\n                        methodType = \"clientStream\";\n                    }\n                } else {\n                    if (attrs.responseStream) {\n                        methodType = \"serverStream\";\n                    } else {\n                        methodType = \"unary\";\n                    }\n                }\n                let implFn = implementation[name];\n                let impl;\n                if (implFn === undefined && typeof attrs.originalName === \"string\") {\n                    implFn = implementation[attrs.originalName];\n                }\n                if (implFn !== undefined) {\n                    impl = implFn.bind(implementation);\n                } else {\n                    impl = getDefaultHandler(methodType, name);\n                }\n                const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n                if (success === false) {\n                    throw new Error(`Method handler for ${attrs.path} already provided.`);\n                }\n            });\n        }\n        removeService(service) {\n            if (service === null || typeof service !== \"object\") {\n                throw new Error(\"removeService() requires object as argument\");\n            }\n            const serviceKeys = Object.keys(service);\n            serviceKeys.forEach((name)=>{\n                const attrs = service[name];\n                this.unregister(attrs.path);\n            });\n        }\n        bind(port, creds) {\n            throw new Error(\"Not implemented. Use bindAsync() instead\");\n        }\n        /**\n             * This API is experimental, so API stability is not guaranteed across minor versions.\n             * @param boundAddress\n             * @returns\n             */ experimentalRegisterListenerToChannelz(boundAddress) {\n            return (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundAddress), ()=>{\n                return {\n                    localAddress: boundAddress,\n                    remoteAddress: null,\n                    security: null,\n                    remoteName: null,\n                    streamsStarted: 0,\n                    streamsSucceeded: 0,\n                    streamsFailed: 0,\n                    messagesSent: 0,\n                    messagesReceived: 0,\n                    keepAlivesSent: 0,\n                    lastLocalStreamCreatedTimestamp: null,\n                    lastRemoteStreamCreatedTimestamp: null,\n                    lastMessageSentTimestamp: null,\n                    lastMessageReceivedTimestamp: null,\n                    localFlowControlWindow: null,\n                    remoteFlowControlWindow: null\n                };\n            }, this.channelzEnabled);\n        }\n        experimentalUnregisterListenerFromChannelz(channelzRef) {\n            (0, channelz_1.unregisterChannelzRef)(channelzRef);\n        }\n        createHttp2Server(credentials) {\n            let http2Server;\n            if (credentials._isSecure()) {\n                const constructorOptions = credentials._getConstructorOptions();\n                const contextOptions = credentials._getSecureContextOptions();\n                const secureServerOptions = Object.assign(Object.assign(Object.assign(Object.assign({}, this.commonServerOptions), constructorOptions), contextOptions), {\n                    enableTrace: this.options[\"grpc-node.tls_enable_trace\"] === 1\n                });\n                let areCredentialsValid = contextOptions !== null;\n                this.trace(\"Initial credentials valid: \" + areCredentialsValid);\n                http2Server = http2.createSecureServer(secureServerOptions);\n                http2Server.prependListener(\"connection\", (socket)=>{\n                    if (!areCredentialsValid) {\n                        this.trace(\"Dropped connection from \" + JSON.stringify(socket.address()) + \" due to unloaded credentials\");\n                        socket.destroy();\n                    }\n                });\n                http2Server.on(\"secureConnection\", (socket)=>{\n                    /* These errors need to be handled by the user of Http2SecureServer,\n                         * according to https://github.com/nodejs/node/issues/35824 */ socket.on(\"error\", (e)=>{\n                        this.trace(\"An incoming TLS connection closed with error: \" + e.message);\n                    });\n                });\n                const credsWatcher = (options)=>{\n                    if (options) {\n                        const secureServer = http2Server;\n                        try {\n                            secureServer.setSecureContext(options);\n                        } catch (e) {\n                            logging.log(constants_1.LogVerbosity.ERROR, \"Failed to set secure context with error \" + e.message);\n                            options = null;\n                        }\n                    }\n                    areCredentialsValid = options !== null;\n                    this.trace(\"Post-update credentials valid: \" + areCredentialsValid);\n                };\n                credentials._addWatcher(credsWatcher);\n                http2Server.on(\"close\", ()=>{\n                    credentials._removeWatcher(credsWatcher);\n                });\n            } else {\n                http2Server = http2.createServer(this.commonServerOptions);\n            }\n            http2Server.setTimeout(0, noop);\n            this._setupHandlers(http2Server, credentials._getInterceptors());\n            return http2Server;\n        }\n        bindOneAddress(address, boundPortObject) {\n            this.trace(\"Attempting to bind \" + (0, subchannel_address_1.subchannelAddressToString)(address));\n            const http2Server = this.createHttp2Server(boundPortObject.credentials);\n            return new Promise((resolve, reject)=>{\n                const onError = (err)=>{\n                    this.trace(\"Failed to bind \" + (0, subchannel_address_1.subchannelAddressToString)(address) + \" with error \" + err.message);\n                    resolve({\n                        port: \"port\" in address ? address.port : 1,\n                        error: err.message\n                    });\n                };\n                http2Server.once(\"error\", onError);\n                http2Server.listen(address, ()=>{\n                    const boundAddress = http2Server.address();\n                    let boundSubchannelAddress;\n                    if (typeof boundAddress === \"string\") {\n                        boundSubchannelAddress = {\n                            path: boundAddress\n                        };\n                    } else {\n                        boundSubchannelAddress = {\n                            host: boundAddress.address,\n                            port: boundAddress.port\n                        };\n                    }\n                    const channelzRef = this.experimentalRegisterListenerToChannelz(boundSubchannelAddress);\n                    this.listenerChildrenTracker.refChild(channelzRef);\n                    this.http2Servers.set(http2Server, {\n                        channelzRef: channelzRef,\n                        sessions: new Set(),\n                        ownsChannelzRef: true\n                    });\n                    boundPortObject.listeningServers.add(http2Server);\n                    this.trace(\"Successfully bound \" + (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));\n                    resolve({\n                        port: \"port\" in boundSubchannelAddress ? boundSubchannelAddress.port : 1\n                    });\n                    http2Server.removeListener(\"error\", onError);\n                });\n            });\n        }\n        async bindManyPorts(addressList, boundPortObject) {\n            if (addressList.length === 0) {\n                return {\n                    count: 0,\n                    port: 0,\n                    errors: []\n                };\n            }\n            if ((0, subchannel_address_1.isTcpSubchannelAddress)(addressList[0]) && addressList[0].port === 0) {\n                /* If binding to port 0, first try to bind the first address, then bind\n                     * the rest of the address list to the specific port that it binds. */ const firstAddressResult = await this.bindOneAddress(addressList[0], boundPortObject);\n                if (firstAddressResult.error) {\n                    /* If the first address fails to bind, try the same operation starting\n                         * from the second item in the list. */ const restAddressResult = await this.bindManyPorts(addressList.slice(1), boundPortObject);\n                    return Object.assign(Object.assign({}, restAddressResult), {\n                        errors: [\n                            firstAddressResult.error,\n                            ...restAddressResult.errors\n                        ]\n                    });\n                } else {\n                    const restAddresses = addressList.slice(1).map((address)=>(0, subchannel_address_1.isTcpSubchannelAddress)(address) ? {\n                            host: address.host,\n                            port: firstAddressResult.port\n                        } : address);\n                    const restAddressResult = await Promise.all(restAddresses.map((address)=>this.bindOneAddress(address, boundPortObject)));\n                    const allResults = [\n                        firstAddressResult,\n                        ...restAddressResult\n                    ];\n                    return {\n                        count: allResults.filter((result)=>result.error === undefined).length,\n                        port: firstAddressResult.port,\n                        errors: allResults.filter((result)=>result.error).map((result)=>result.error)\n                    };\n                }\n            } else {\n                const allResults = await Promise.all(addressList.map((address)=>this.bindOneAddress(address, boundPortObject)));\n                return {\n                    count: allResults.filter((result)=>result.error === undefined).length,\n                    port: allResults[0].port,\n                    errors: allResults.filter((result)=>result.error).map((result)=>result.error)\n                };\n            }\n        }\n        async bindAddressList(addressList, boundPortObject) {\n            const bindResult = await this.bindManyPorts(addressList, boundPortObject);\n            if (bindResult.count > 0) {\n                if (bindResult.count < addressList.length) {\n                    logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n                }\n                return bindResult.port;\n            } else {\n                const errorString = `No address added out of total ${addressList.length} resolved`;\n                logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                throw new Error(`${errorString} errors: [${bindResult.errors.join(\",\")}]`);\n            }\n        }\n        resolvePort(port) {\n            return new Promise((resolve, reject)=>{\n                const resolverListener = {\n                    onSuccessfulResolution: (endpointList, serviceConfig, serviceConfigError)=>{\n                        // We only want one resolution result. Discard all future results\n                        resolverListener.onSuccessfulResolution = ()=>{};\n                        const addressList = [].concat(...endpointList.map((endpoint)=>endpoint.addresses));\n                        if (addressList.length === 0) {\n                            reject(new Error(`No addresses resolved for port ${port}`));\n                            return;\n                        }\n                        resolve(addressList);\n                    },\n                    onError: (error)=>{\n                        reject(new Error(error.details));\n                    }\n                };\n                const resolver = (0, resolver_1.createResolver)(port, resolverListener, this.options);\n                resolver.updateResolution();\n            });\n        }\n        async bindPort(port, boundPortObject) {\n            const addressList = await this.resolvePort(port);\n            if (boundPortObject.cancelled) {\n                this.completeUnbind(boundPortObject);\n                throw new Error(\"bindAsync operation cancelled by unbind call\");\n            }\n            const portNumber = await this.bindAddressList(addressList, boundPortObject);\n            if (boundPortObject.cancelled) {\n                this.completeUnbind(boundPortObject);\n                throw new Error(\"bindAsync operation cancelled by unbind call\");\n            }\n            return portNumber;\n        }\n        normalizePort(port) {\n            const initialPortUri = (0, uri_parser_1.parseUri)(port);\n            if (initialPortUri === null) {\n                throw new Error(`Could not parse port \"${port}\"`);\n            }\n            const portUri = (0, resolver_1.mapUriDefaultScheme)(initialPortUri);\n            if (portUri === null) {\n                throw new Error(`Could not get a default scheme for port \"${port}\"`);\n            }\n            return portUri;\n        }\n        bindAsync(port, creds, callback) {\n            if (this.shutdown) {\n                throw new Error(\"bindAsync called after shutdown\");\n            }\n            if (typeof port !== \"string\") {\n                throw new TypeError(\"port must be a string\");\n            }\n            if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {\n                throw new TypeError(\"creds must be a ServerCredentials object\");\n            }\n            if (typeof callback !== \"function\") {\n                throw new TypeError(\"callback must be a function\");\n            }\n            this.trace(\"bindAsync port=\" + port);\n            const portUri = this.normalizePort(port);\n            const deferredCallback = (error, port)=>{\n                process.nextTick(()=>callback(error, port));\n            };\n            /* First, if this port is already bound or that bind operation is in\n                 * progress, use that result. */ let boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));\n            if (boundPortObject) {\n                if (!creds._equals(boundPortObject.credentials)) {\n                    deferredCallback(new Error(`${port} already bound with incompatible credentials`), 0);\n                    return;\n                }\n                /* If that operation has previously been cancelled by an unbind call,\n                     * uncancel it. */ boundPortObject.cancelled = false;\n                if (boundPortObject.completionPromise) {\n                    boundPortObject.completionPromise.then((portNum)=>callback(null, portNum), (error)=>callback(error, 0));\n                } else {\n                    deferredCallback(null, boundPortObject.portNumber);\n                }\n                return;\n            }\n            boundPortObject = {\n                mapKey: (0, uri_parser_1.uriToString)(portUri),\n                originalUri: portUri,\n                completionPromise: null,\n                cancelled: false,\n                portNumber: 0,\n                credentials: creds,\n                listeningServers: new Set()\n            };\n            const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);\n            const completionPromise = this.bindPort(portUri, boundPortObject);\n            boundPortObject.completionPromise = completionPromise;\n            /* If the port number is 0, defer populating the map entry until after the\n                 * bind operation completes and we have a specific port number. Otherwise,\n                 * populate it immediately. */ if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {\n                completionPromise.then((portNum)=>{\n                    const finalUri = {\n                        scheme: portUri.scheme,\n                        authority: portUri.authority,\n                        path: (0, uri_parser_1.combineHostPort)({\n                            host: splitPort.host,\n                            port: portNum\n                        })\n                    };\n                    boundPortObject.mapKey = (0, uri_parser_1.uriToString)(finalUri);\n                    boundPortObject.completionPromise = null;\n                    boundPortObject.portNumber = portNum;\n                    this.boundPorts.set(boundPortObject.mapKey, boundPortObject);\n                    callback(null, portNum);\n                }, (error)=>{\n                    callback(error, 0);\n                });\n            } else {\n                this.boundPorts.set(boundPortObject.mapKey, boundPortObject);\n                completionPromise.then((portNum)=>{\n                    boundPortObject.completionPromise = null;\n                    boundPortObject.portNumber = portNum;\n                    callback(null, portNum);\n                }, (error)=>{\n                    callback(error, 0);\n                });\n            }\n        }\n        registerInjectorToChannelz() {\n            return (0, channelz_1.registerChannelzSocket)(\"injector\", ()=>{\n                return {\n                    localAddress: null,\n                    remoteAddress: null,\n                    security: null,\n                    remoteName: null,\n                    streamsStarted: 0,\n                    streamsSucceeded: 0,\n                    streamsFailed: 0,\n                    messagesSent: 0,\n                    messagesReceived: 0,\n                    keepAlivesSent: 0,\n                    lastLocalStreamCreatedTimestamp: null,\n                    lastRemoteStreamCreatedTimestamp: null,\n                    lastMessageSentTimestamp: null,\n                    lastMessageReceivedTimestamp: null,\n                    localFlowControlWindow: null,\n                    remoteFlowControlWindow: null\n                };\n            }, this.channelzEnabled);\n        }\n        /**\n             * This API is experimental, so API stability is not guaranteed across minor versions.\n             * @param credentials\n             * @param channelzRef\n             * @returns\n             */ experimentalCreateConnectionInjectorWithChannelzRef(credentials, channelzRef, ownsChannelzRef = false) {\n            if (credentials === null || !(credentials instanceof server_credentials_1.ServerCredentials)) {\n                throw new TypeError(\"creds must be a ServerCredentials object\");\n            }\n            if (this.channelzEnabled) {\n                this.listenerChildrenTracker.refChild(channelzRef);\n            }\n            const server = this.createHttp2Server(credentials);\n            const sessionsSet = new Set();\n            this.http2Servers.set(server, {\n                channelzRef: channelzRef,\n                sessions: sessionsSet,\n                ownsChannelzRef\n            });\n            return {\n                injectConnection: (connection)=>{\n                    server.emit(\"connection\", connection);\n                },\n                drain: (graceTimeMs)=>{\n                    var _b, _c;\n                    for (const session of sessionsSet){\n                        this.closeSession(session);\n                    }\n                    (_c = (_b = setTimeout(()=>{\n                        for (const session of sessionsSet){\n                            session.destroy(http2.constants.NGHTTP2_CANCEL);\n                        }\n                    }, graceTimeMs)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n                },\n                destroy: ()=>{\n                    this.closeServer(server);\n                    for (const session of sessionsSet){\n                        this.closeSession(session);\n                    }\n                }\n            };\n        }\n        createConnectionInjector(credentials) {\n            if (credentials === null || !(credentials instanceof server_credentials_1.ServerCredentials)) {\n                throw new TypeError(\"creds must be a ServerCredentials object\");\n            }\n            const channelzRef = this.registerInjectorToChannelz();\n            return this.experimentalCreateConnectionInjectorWithChannelzRef(credentials, channelzRef, true);\n        }\n        closeServer(server, callback) {\n            this.trace(\"Closing server with address \" + JSON.stringify(server.address()));\n            const serverInfo = this.http2Servers.get(server);\n            server.close(()=>{\n                if (serverInfo && serverInfo.ownsChannelzRef) {\n                    this.listenerChildrenTracker.unrefChild(serverInfo.channelzRef);\n                    (0, channelz_1.unregisterChannelzRef)(serverInfo.channelzRef);\n                }\n                this.http2Servers.delete(server);\n                callback === null || callback === void 0 ? void 0 : callback();\n            });\n        }\n        closeSession(session, callback) {\n            var _b;\n            this.trace(\"Closing session initiated by \" + ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress));\n            const sessionInfo = this.sessions.get(session);\n            const closeCallback = ()=>{\n                if (sessionInfo) {\n                    this.sessionChildrenTracker.unrefChild(sessionInfo.ref);\n                    (0, channelz_1.unregisterChannelzRef)(sessionInfo.ref);\n                }\n                callback === null || callback === void 0 ? void 0 : callback();\n            };\n            if (session.closed) {\n                queueMicrotask(closeCallback);\n            } else {\n                session.close(closeCallback);\n            }\n        }\n        completeUnbind(boundPortObject) {\n            for (const server of boundPortObject.listeningServers){\n                const serverInfo = this.http2Servers.get(server);\n                this.closeServer(server, ()=>{\n                    boundPortObject.listeningServers.delete(server);\n                });\n                if (serverInfo) {\n                    for (const session of serverInfo.sessions){\n                        this.closeSession(session);\n                    }\n                }\n            }\n            this.boundPorts.delete(boundPortObject.mapKey);\n        }\n        /**\n             * Unbind a previously bound port, or cancel an in-progress bindAsync\n             * operation. If port 0 was bound, only the actual bound port can be\n             * unbound. For example, if bindAsync was called with \"localhost:0\" and the\n             * bound port result was 54321, it can be unbound as \"localhost:54321\".\n             * @param port\n             */ unbind(port) {\n            this.trace(\"unbind port=\" + port);\n            const portUri = this.normalizePort(port);\n            const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);\n            if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {\n                throw new Error(\"Cannot unbind port 0\");\n            }\n            const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));\n            if (boundPortObject) {\n                this.trace(\"unbinding \" + boundPortObject.mapKey + \" originally bound as \" + (0, uri_parser_1.uriToString)(boundPortObject.originalUri));\n                /* If the bind operation is pending, the cancelled flag will trigger\n                     * the unbind operation later. */ if (boundPortObject.completionPromise) {\n                    boundPortObject.cancelled = true;\n                } else {\n                    this.completeUnbind(boundPortObject);\n                }\n            }\n        }\n        /**\n             * Gracefully close all connections associated with a previously bound port.\n             * After the grace time, forcefully close all remaining open connections.\n             *\n             * If port 0 was bound, only the actual bound port can be\n             * drained. For example, if bindAsync was called with \"localhost:0\" and the\n             * bound port result was 54321, it can be drained as \"localhost:54321\".\n             * @param port\n             * @param graceTimeMs\n             * @returns\n             */ drain(port, graceTimeMs) {\n            var _b, _c;\n            this.trace(\"drain port=\" + port + \" graceTimeMs=\" + graceTimeMs);\n            const portUri = this.normalizePort(port);\n            const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);\n            if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {\n                throw new Error(\"Cannot drain port 0\");\n            }\n            const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));\n            if (!boundPortObject) {\n                return;\n            }\n            const allSessions = new Set();\n            for (const http2Server of boundPortObject.listeningServers){\n                const serverEntry = this.http2Servers.get(http2Server);\n                if (serverEntry) {\n                    for (const session of serverEntry.sessions){\n                        allSessions.add(session);\n                        this.closeSession(session, ()=>{\n                            allSessions.delete(session);\n                        });\n                    }\n                }\n            }\n            /* After the grace time ends, send another goaway to all remaining sessions\n                 * with the CANCEL code. */ (_c = (_b = setTimeout(()=>{\n                for (const session of allSessions){\n                    session.destroy(http2.constants.NGHTTP2_CANCEL);\n                }\n            }, graceTimeMs)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n        }\n        forceShutdown() {\n            for (const boundPortObject of this.boundPorts.values()){\n                boundPortObject.cancelled = true;\n            }\n            this.boundPorts.clear();\n            // Close the server if it is still running.\n            for (const server of this.http2Servers.keys()){\n                this.closeServer(server);\n            }\n            // Always destroy any available sessions. It's possible that one or more\n            // tryShutdown() calls are in progress. Don't wait on them to finish.\n            this.sessions.forEach((channelzInfo, session)=>{\n                this.closeSession(session);\n                // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n                // recognize destroy(code) as a valid signature.\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                session.destroy(http2.constants.NGHTTP2_CANCEL);\n            });\n            this.sessions.clear();\n            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n            this.shutdown = true;\n        }\n        register(name, handler, serialize, deserialize, type) {\n            if (this.handlers.has(name)) {\n                return false;\n            }\n            this.handlers.set(name, {\n                func: handler,\n                serialize,\n                deserialize,\n                type,\n                path: name\n            });\n            return true;\n        }\n        unregister(name) {\n            return this.handlers.delete(name);\n        }\n        /**\n             * @deprecated No longer needed as of version 1.10.x\n             */ start() {\n            if (this.http2Servers.size === 0 || [\n                ...this.http2Servers.keys()\n            ].every((server)=>!server.listening)) {\n                throw new Error(\"server must be bound in order to start\");\n            }\n            if (this.started === true) {\n                throw new Error(\"server is already started\");\n            }\n            this.started = true;\n        }\n        tryShutdown(callback) {\n            var _b;\n            const wrappedCallback = (error)=>{\n                (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n                callback(error);\n            };\n            let pendingChecks = 0;\n            function maybeCallback() {\n                pendingChecks--;\n                if (pendingChecks === 0) {\n                    wrappedCallback();\n                }\n            }\n            this.shutdown = true;\n            for (const [serverKey, server] of this.http2Servers.entries()){\n                pendingChecks++;\n                const serverString = server.channelzRef.name;\n                this.trace(\"Waiting for server \" + serverString + \" to close\");\n                this.closeServer(serverKey, ()=>{\n                    this.trace(\"Server \" + serverString + \" finished closing\");\n                    maybeCallback();\n                });\n                for (const session of server.sessions.keys()){\n                    pendingChecks++;\n                    const sessionString = (_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress;\n                    this.trace(\"Waiting for session \" + sessionString + \" to close\");\n                    this.closeSession(session, ()=>{\n                        this.trace(\"Session \" + sessionString + \" finished closing\");\n                        maybeCallback();\n                    });\n                }\n            }\n            if (pendingChecks === 0) {\n                wrappedCallback();\n            }\n        }\n        addHttp2Port() {\n            throw new Error(\"Not yet implemented\");\n        }\n        /**\n             * Get the channelz reference object for this server. The returned value is\n             * garbage if channelz is disabled for this server.\n             * @returns\n             */ getChannelzRef() {\n            return this.channelzRef;\n        }\n        _verifyContentType(stream, headers) {\n            const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n            if (typeof contentType !== \"string\" || !contentType.startsWith(\"application/grpc\")) {\n                stream.respond({\n                    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE\n                }, {\n                    endStream: true\n                });\n                return false;\n            }\n            return true;\n        }\n        _retrieveHandler(path) {\n            serverCallTrace(\"Received call to method \" + path + \" at address \" + this.serverAddressString);\n            const handler = this.handlers.get(path);\n            if (handler === undefined) {\n                serverCallTrace(\"No handler registered for method \" + path + \". Sending UNIMPLEMENTED status.\");\n                return null;\n            }\n            return handler;\n        }\n        _respondWithError(err, stream, channelzSessionInfo = null) {\n            var _b, _c;\n            const trailersToSend = Object.assign({\n                \"grpc-status\": (_b = err.code) !== null && _b !== void 0 ? _b : constants_1.Status.INTERNAL,\n                \"grpc-message\": err.details,\n                [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n                [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: \"application/grpc+proto\"\n            }, (_c = err.metadata) === null || _c === void 0 ? void 0 : _c.toHttp2Headers());\n            stream.respond(trailersToSend, {\n                endStream: true\n            });\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n        }\n        _channelzHandler(extraInterceptors, stream, headers) {\n            // for handling idle timeout\n            this.onStreamOpened(stream);\n            const channelzSessionInfo = this.sessions.get(stream.session);\n            this.callTracker.addCallStarted();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();\n            if (!this._verifyContentType(stream, headers)) {\n                this.callTracker.addCallFailed();\n                channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n                return;\n            }\n            const path = headers[HTTP2_HEADER_PATH];\n            const handler = this._retrieveHandler(path);\n            if (!handler) {\n                this._respondWithError(getUnimplementedStatusResponse(path), stream, channelzSessionInfo);\n                return;\n            }\n            const callEventTracker = {\n                addMessageSent: ()=>{\n                    if (channelzSessionInfo) {\n                        channelzSessionInfo.messagesSent += 1;\n                        channelzSessionInfo.lastMessageSentTimestamp = new Date();\n                    }\n                },\n                addMessageReceived: ()=>{\n                    if (channelzSessionInfo) {\n                        channelzSessionInfo.messagesReceived += 1;\n                        channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n                    }\n                },\n                onCallEnd: (status)=>{\n                    if (status.code === constants_1.Status.OK) {\n                        this.callTracker.addCallSucceeded();\n                    } else {\n                        this.callTracker.addCallFailed();\n                    }\n                },\n                onStreamEnd: (success)=>{\n                    if (channelzSessionInfo) {\n                        if (success) {\n                            channelzSessionInfo.streamTracker.addCallSucceeded();\n                        } else {\n                            channelzSessionInfo.streamTracker.addCallFailed();\n                        }\n                    }\n                }\n            };\n            const call = (0, server_interceptors_1.getServerInterceptingCall)([\n                ...extraInterceptors,\n                ...this.interceptors\n            ], stream, headers, callEventTracker, handler, this.options);\n            if (!this._runHandlerForCall(call, handler)) {\n                this.callTracker.addCallFailed();\n                channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n                call.sendStatus({\n                    code: constants_1.Status.INTERNAL,\n                    details: `Unknown handler type: ${handler.type}`\n                });\n            }\n        }\n        _streamHandler(extraInterceptors, stream, headers) {\n            // for handling idle timeout\n            this.onStreamOpened(stream);\n            if (this._verifyContentType(stream, headers) !== true) {\n                return;\n            }\n            const path = headers[HTTP2_HEADER_PATH];\n            const handler = this._retrieveHandler(path);\n            if (!handler) {\n                this._respondWithError(getUnimplementedStatusResponse(path), stream, null);\n                return;\n            }\n            const call = (0, server_interceptors_1.getServerInterceptingCall)([\n                ...extraInterceptors,\n                ...this.interceptors\n            ], stream, headers, null, handler, this.options);\n            if (!this._runHandlerForCall(call, handler)) {\n                call.sendStatus({\n                    code: constants_1.Status.INTERNAL,\n                    details: `Unknown handler type: ${handler.type}`\n                });\n            }\n        }\n        _runHandlerForCall(call, handler) {\n            const { type } = handler;\n            if (type === \"unary\") {\n                handleUnary(call, handler);\n            } else if (type === \"clientStream\") {\n                handleClientStreaming(call, handler);\n            } else if (type === \"serverStream\") {\n                handleServerStreaming(call, handler);\n            } else if (type === \"bidi\") {\n                handleBidiStreaming(call, handler);\n            } else {\n                return false;\n            }\n            return true;\n        }\n        _setupHandlers(http2Server, extraInterceptors) {\n            if (http2Server === null) {\n                return;\n            }\n            const serverAddress = http2Server.address();\n            let serverAddressString = \"null\";\n            if (serverAddress) {\n                if (typeof serverAddress === \"string\") {\n                    serverAddressString = serverAddress;\n                } else {\n                    serverAddressString = serverAddress.address + \":\" + serverAddress.port;\n                }\n            }\n            this.serverAddressString = serverAddressString;\n            const handler = this.channelzEnabled ? this._channelzHandler : this._streamHandler;\n            const sessionHandler = this.channelzEnabled ? this._channelzSessionHandler(http2Server) : this._sessionHandler(http2Server);\n            http2Server.on(\"stream\", handler.bind(this, extraInterceptors));\n            http2Server.on(\"session\", sessionHandler);\n        }\n        _sessionHandler(http2Server) {\n            return (session)=>{\n                var _b, _c;\n                (_b = this.http2Servers.get(http2Server)) === null || _b === void 0 ? void 0 : _b.sessions.add(session);\n                let connectionAgeTimer = null;\n                let connectionAgeGraceTimer = null;\n                let keepaliveTimer = null;\n                let sessionClosedByServer = false;\n                const idleTimeoutObj = this.enableIdleTimeout(session);\n                if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\n                    // Apply a random jitter within a +/-10% range\n                    const jitterMagnitude = this.maxConnectionAgeMs / 10;\n                    const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\n                    connectionAgeTimer = setTimeout(()=>{\n                        var _b, _c;\n                        sessionClosedByServer = true;\n                        this.trace(\"Connection dropped by max connection age: \" + ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress));\n                        try {\n                            session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);\n                        } catch (e) {\n                            // The goaway can't be sent because the session is already closed\n                            session.destroy();\n                            return;\n                        }\n                        session.close();\n                        /* Allow a grace period after sending the GOAWAY before forcibly\n                             * closing the connection. */ if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\n                            connectionAgeGraceTimer = setTimeout(()=>{\n                                session.destroy();\n                            }, this.maxConnectionAgeGraceMs);\n                            (_c = connectionAgeGraceTimer.unref) === null || _c === void 0 ? void 0 : _c.call(connectionAgeGraceTimer);\n                        }\n                    }, this.maxConnectionAgeMs + jitter);\n                    (_c = connectionAgeTimer.unref) === null || _c === void 0 ? void 0 : _c.call(connectionAgeTimer);\n                }\n                const clearKeepaliveTimeout = ()=>{\n                    if (keepaliveTimer) {\n                        clearTimeout(keepaliveTimer);\n                        keepaliveTimer = null;\n                    }\n                };\n                const canSendPing = ()=>{\n                    return !session.destroyed && this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS && this.keepaliveTimeMs > 0;\n                };\n                /* eslint-disable-next-line prefer-const */ let sendPing; // hoisted for use in maybeStartKeepalivePingTimer\n                const maybeStartKeepalivePingTimer = ()=>{\n                    var _b;\n                    if (!canSendPing()) {\n                        return;\n                    }\n                    this.keepaliveTrace(\"Starting keepalive timer for \" + this.keepaliveTimeMs + \"ms\");\n                    keepaliveTimer = setTimeout(()=>{\n                        clearKeepaliveTimeout();\n                        sendPing();\n                    }, this.keepaliveTimeMs);\n                    (_b = keepaliveTimer.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimer);\n                };\n                sendPing = ()=>{\n                    var _b;\n                    if (!canSendPing()) {\n                        return;\n                    }\n                    this.keepaliveTrace(\"Sending ping with timeout \" + this.keepaliveTimeoutMs + \"ms\");\n                    let pingSendError = \"\";\n                    try {\n                        const pingSentSuccessfully = session.ping((err, duration, payload)=>{\n                            clearKeepaliveTimeout();\n                            if (err) {\n                                this.keepaliveTrace(\"Ping failed with error: \" + err.message);\n                                sessionClosedByServer = true;\n                                session.close();\n                            } else {\n                                this.keepaliveTrace(\"Received ping response\");\n                                maybeStartKeepalivePingTimer();\n                            }\n                        });\n                        if (!pingSentSuccessfully) {\n                            pingSendError = \"Ping returned false\";\n                        }\n                    } catch (e) {\n                        // grpc/grpc-node#2139\n                        pingSendError = (e instanceof Error ? e.message : \"\") || \"Unknown error\";\n                    }\n                    if (pingSendError) {\n                        this.keepaliveTrace(\"Ping send failed: \" + pingSendError);\n                        this.trace(\"Connection dropped due to ping send error: \" + pingSendError);\n                        sessionClosedByServer = true;\n                        session.close();\n                        return;\n                    }\n                    keepaliveTimer = setTimeout(()=>{\n                        clearKeepaliveTimeout();\n                        this.keepaliveTrace(\"Ping timeout passed without response\");\n                        this.trace(\"Connection dropped by keepalive timeout\");\n                        sessionClosedByServer = true;\n                        session.close();\n                    }, this.keepaliveTimeoutMs);\n                    (_b = keepaliveTimer.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimer);\n                };\n                maybeStartKeepalivePingTimer();\n                session.on(\"close\", ()=>{\n                    var _b, _c;\n                    if (!sessionClosedByServer) {\n                        this.trace(`Connection dropped by client ${(_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress}`);\n                    }\n                    if (connectionAgeTimer) {\n                        clearTimeout(connectionAgeTimer);\n                    }\n                    if (connectionAgeGraceTimer) {\n                        clearTimeout(connectionAgeGraceTimer);\n                    }\n                    clearKeepaliveTimeout();\n                    if (idleTimeoutObj !== null) {\n                        clearTimeout(idleTimeoutObj.timeout);\n                        this.sessionIdleTimeouts.delete(session);\n                    }\n                    (_c = this.http2Servers.get(http2Server)) === null || _c === void 0 ? void 0 : _c.sessions.delete(session);\n                });\n            };\n        }\n        _channelzSessionHandler(http2Server) {\n            return (session)=>{\n                var _b, _c, _d, _e;\n                const channelzRef = (0, channelz_1.registerChannelzSocket)((_c = (_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress) !== null && _c !== void 0 ? _c : \"unknown\", this.getChannelzSessionInfo.bind(this, session), this.channelzEnabled);\n                const channelzSessionInfo = {\n                    ref: channelzRef,\n                    streamTracker: new channelz_1.ChannelzCallTracker(),\n                    messagesSent: 0,\n                    messagesReceived: 0,\n                    keepAlivesSent: 0,\n                    lastMessageSentTimestamp: null,\n                    lastMessageReceivedTimestamp: null\n                };\n                (_d = this.http2Servers.get(http2Server)) === null || _d === void 0 ? void 0 : _d.sessions.add(session);\n                this.sessions.set(session, channelzSessionInfo);\n                const clientAddress = `${session.socket.remoteAddress}:${session.socket.remotePort}`;\n                this.channelzTrace.addTrace(\"CT_INFO\", \"Connection established by client \" + clientAddress);\n                this.trace(\"Connection established by client \" + clientAddress);\n                this.sessionChildrenTracker.refChild(channelzRef);\n                let connectionAgeTimer = null;\n                let connectionAgeGraceTimer = null;\n                let keepaliveTimeout = null;\n                let sessionClosedByServer = false;\n                const idleTimeoutObj = this.enableIdleTimeout(session);\n                if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\n                    // Apply a random jitter within a +/-10% range\n                    const jitterMagnitude = this.maxConnectionAgeMs / 10;\n                    const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\n                    connectionAgeTimer = setTimeout(()=>{\n                        var _b;\n                        sessionClosedByServer = true;\n                        this.channelzTrace.addTrace(\"CT_INFO\", \"Connection dropped by max connection age from \" + clientAddress);\n                        try {\n                            session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);\n                        } catch (e) {\n                            // The goaway can't be sent because the session is already closed\n                            session.destroy();\n                            return;\n                        }\n                        session.close();\n                        /* Allow a grace period after sending the GOAWAY before forcibly\n                             * closing the connection. */ if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\n                            connectionAgeGraceTimer = setTimeout(()=>{\n                                session.destroy();\n                            }, this.maxConnectionAgeGraceMs);\n                            (_b = connectionAgeGraceTimer.unref) === null || _b === void 0 ? void 0 : _b.call(connectionAgeGraceTimer);\n                        }\n                    }, this.maxConnectionAgeMs + jitter);\n                    (_e = connectionAgeTimer.unref) === null || _e === void 0 ? void 0 : _e.call(connectionAgeTimer);\n                }\n                const clearKeepaliveTimeout = ()=>{\n                    if (keepaliveTimeout) {\n                        clearTimeout(keepaliveTimeout);\n                        keepaliveTimeout = null;\n                    }\n                };\n                const canSendPing = ()=>{\n                    return !session.destroyed && this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS && this.keepaliveTimeMs > 0;\n                };\n                /* eslint-disable-next-line prefer-const */ let sendPing; // hoisted for use in maybeStartKeepalivePingTimer\n                const maybeStartKeepalivePingTimer = ()=>{\n                    var _b;\n                    if (!canSendPing()) {\n                        return;\n                    }\n                    this.keepaliveTrace(\"Starting keepalive timer for \" + this.keepaliveTimeMs + \"ms\");\n                    keepaliveTimeout = setTimeout(()=>{\n                        clearKeepaliveTimeout();\n                        sendPing();\n                    }, this.keepaliveTimeMs);\n                    (_b = keepaliveTimeout.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimeout);\n                };\n                sendPing = ()=>{\n                    var _b;\n                    if (!canSendPing()) {\n                        return;\n                    }\n                    this.keepaliveTrace(\"Sending ping with timeout \" + this.keepaliveTimeoutMs + \"ms\");\n                    let pingSendError = \"\";\n                    try {\n                        const pingSentSuccessfully = session.ping((err, duration, payload)=>{\n                            clearKeepaliveTimeout();\n                            if (err) {\n                                this.keepaliveTrace(\"Ping failed with error: \" + err.message);\n                                this.channelzTrace.addTrace(\"CT_INFO\", \"Connection dropped due to error of a ping frame \" + err.message + \" return in \" + duration);\n                                sessionClosedByServer = true;\n                                session.close();\n                            } else {\n                                this.keepaliveTrace(\"Received ping response\");\n                                maybeStartKeepalivePingTimer();\n                            }\n                        });\n                        if (!pingSentSuccessfully) {\n                            pingSendError = \"Ping returned false\";\n                        }\n                    } catch (e) {\n                        // grpc/grpc-node#2139\n                        pingSendError = (e instanceof Error ? e.message : \"\") || \"Unknown error\";\n                    }\n                    if (pingSendError) {\n                        this.keepaliveTrace(\"Ping send failed: \" + pingSendError);\n                        this.channelzTrace.addTrace(\"CT_INFO\", \"Connection dropped due to ping send error: \" + pingSendError);\n                        sessionClosedByServer = true;\n                        session.close();\n                        return;\n                    }\n                    channelzSessionInfo.keepAlivesSent += 1;\n                    keepaliveTimeout = setTimeout(()=>{\n                        clearKeepaliveTimeout();\n                        this.keepaliveTrace(\"Ping timeout passed without response\");\n                        this.channelzTrace.addTrace(\"CT_INFO\", \"Connection dropped by keepalive timeout from \" + clientAddress);\n                        sessionClosedByServer = true;\n                        session.close();\n                    }, this.keepaliveTimeoutMs);\n                    (_b = keepaliveTimeout.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimeout);\n                };\n                maybeStartKeepalivePingTimer();\n                session.on(\"close\", ()=>{\n                    var _b;\n                    if (!sessionClosedByServer) {\n                        this.channelzTrace.addTrace(\"CT_INFO\", \"Connection dropped by client \" + clientAddress);\n                    }\n                    this.sessionChildrenTracker.unrefChild(channelzRef);\n                    (0, channelz_1.unregisterChannelzRef)(channelzRef);\n                    if (connectionAgeTimer) {\n                        clearTimeout(connectionAgeTimer);\n                    }\n                    if (connectionAgeGraceTimer) {\n                        clearTimeout(connectionAgeGraceTimer);\n                    }\n                    clearKeepaliveTimeout();\n                    if (idleTimeoutObj !== null) {\n                        clearTimeout(idleTimeoutObj.timeout);\n                        this.sessionIdleTimeouts.delete(session);\n                    }\n                    (_b = this.http2Servers.get(http2Server)) === null || _b === void 0 ? void 0 : _b.sessions.delete(session);\n                    this.sessions.delete(session);\n                });\n            };\n        }\n        enableIdleTimeout(session) {\n            var _b, _c;\n            if (this.sessionIdleTimeout >= MAX_CONNECTION_IDLE_MS) {\n                return null;\n            }\n            const idleTimeoutObj = {\n                activeStreams: 0,\n                lastIdle: Date.now(),\n                onClose: this.onStreamClose.bind(this, session),\n                timeout: setTimeout(this.onIdleTimeout, this.sessionIdleTimeout, this, session)\n            };\n            (_c = (_b = idleTimeoutObj.timeout).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n            this.sessionIdleTimeouts.set(session, idleTimeoutObj);\n            const { socket } = session;\n            this.trace(\"Enable idle timeout for \" + socket.remoteAddress + \":\" + socket.remotePort);\n            return idleTimeoutObj;\n        }\n        onIdleTimeout(ctx, session) {\n            const { socket } = session;\n            const sessionInfo = ctx.sessionIdleTimeouts.get(session);\n            // if it is called while we have activeStreams - timer will not be rescheduled\n            // until last active stream is closed, then it will call .refresh() on the timer\n            // important part is to not clearTimeout(timer) or it becomes unusable\n            // for future refreshes\n            if (sessionInfo !== undefined && sessionInfo.activeStreams === 0) {\n                if (Date.now() - sessionInfo.lastIdle >= ctx.sessionIdleTimeout) {\n                    ctx.trace(\"Session idle timeout triggered for \" + (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) + \":\" + (socket === null || socket === void 0 ? void 0 : socket.remotePort) + \" last idle at \" + sessionInfo.lastIdle);\n                    ctx.closeSession(session);\n                } else {\n                    sessionInfo.timeout.refresh();\n                }\n            }\n        }\n        onStreamOpened(stream) {\n            const session = stream.session;\n            const idleTimeoutObj = this.sessionIdleTimeouts.get(session);\n            if (idleTimeoutObj) {\n                idleTimeoutObj.activeStreams += 1;\n                stream.once(\"close\", idleTimeoutObj.onClose);\n            }\n        }\n        onStreamClose(session) {\n            var _b, _c;\n            const idleTimeoutObj = this.sessionIdleTimeouts.get(session);\n            if (idleTimeoutObj) {\n                idleTimeoutObj.activeStreams -= 1;\n                if (idleTimeoutObj.activeStreams === 0) {\n                    idleTimeoutObj.lastIdle = Date.now();\n                    idleTimeoutObj.timeout.refresh();\n                    this.trace(\"Session onStreamClose\" + ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress) + \":\" + ((_c = session.socket) === null || _c === void 0 ? void 0 : _c.remotePort) + \" at \" + idleTimeoutObj.lastIdle);\n                }\n            }\n        }\n    }, (()=>{\n        const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(null) : void 0;\n        _start_decorators = [\n            deprecate(\"Calling start() is no longer necessary. It can be safely omitted.\")\n        ];\n        __esDecorate(_a, null, _start_decorators, {\n            kind: \"method\",\n            name: \"start\",\n            static: false,\n            private: false,\n            access: {\n                has: (obj)=>\"start\" in obj,\n                get: (obj)=>obj.start\n            },\n            metadata: _metadata\n        }, null, _instanceExtraInitializers);\n        if (_metadata) Object.defineProperty(_a, Symbol.metadata, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: _metadata\n        });\n    })(), _a;\n})();\nexports.Server = Server;\nasync function handleUnary(call, handler) {\n    let stream;\n    function respond(err, value, trailer, flags) {\n        if (err) {\n            call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));\n            return;\n        }\n        call.sendMessage(value, ()=>{\n            call.sendStatus({\n                code: constants_1.Status.OK,\n                details: \"OK\",\n                metadata: trailer !== null && trailer !== void 0 ? trailer : null\n            });\n        });\n    }\n    let requestMetadata;\n    let requestMessage = null;\n    call.start({\n        onReceiveMetadata (metadata) {\n            requestMetadata = metadata;\n            call.startRead();\n        },\n        onReceiveMessage (message) {\n            if (requestMessage) {\n                call.sendStatus({\n                    code: constants_1.Status.UNIMPLEMENTED,\n                    details: `Received a second request message for server streaming method ${handler.path}`,\n                    metadata: null\n                });\n                return;\n            }\n            requestMessage = message;\n            call.startRead();\n        },\n        onReceiveHalfClose () {\n            if (!requestMessage) {\n                call.sendStatus({\n                    code: constants_1.Status.UNIMPLEMENTED,\n                    details: `Received no request message for server streaming method ${handler.path}`,\n                    metadata: null\n                });\n                return;\n            }\n            stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);\n            try {\n                handler.func(stream, respond);\n            } catch (err) {\n                call.sendStatus({\n                    code: constants_1.Status.UNKNOWN,\n                    details: `Server method handler threw error ${err.message}`,\n                    metadata: null\n                });\n            }\n        },\n        onCancel () {\n            if (stream) {\n                stream.cancelled = true;\n                stream.emit(\"cancelled\", \"cancelled\");\n            }\n        }\n    });\n}\nfunction handleClientStreaming(call, handler) {\n    let stream;\n    function respond(err, value, trailer, flags) {\n        if (err) {\n            call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));\n            return;\n        }\n        call.sendMessage(value, ()=>{\n            call.sendStatus({\n                code: constants_1.Status.OK,\n                details: \"OK\",\n                metadata: trailer !== null && trailer !== void 0 ? trailer : null\n            });\n        });\n    }\n    call.start({\n        onReceiveMetadata (metadata) {\n            stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);\n            try {\n                handler.func(stream, respond);\n            } catch (err) {\n                call.sendStatus({\n                    code: constants_1.Status.UNKNOWN,\n                    details: `Server method handler threw error ${err.message}`,\n                    metadata: null\n                });\n            }\n        },\n        onReceiveMessage (message) {\n            stream.push(message);\n        },\n        onReceiveHalfClose () {\n            stream.push(null);\n        },\n        onCancel () {\n            if (stream) {\n                stream.cancelled = true;\n                stream.emit(\"cancelled\", \"cancelled\");\n                stream.destroy();\n            }\n        }\n    });\n}\nfunction handleServerStreaming(call, handler) {\n    let stream;\n    let requestMetadata;\n    let requestMessage = null;\n    call.start({\n        onReceiveMetadata (metadata) {\n            requestMetadata = metadata;\n            call.startRead();\n        },\n        onReceiveMessage (message) {\n            if (requestMessage) {\n                call.sendStatus({\n                    code: constants_1.Status.UNIMPLEMENTED,\n                    details: `Received a second request message for server streaming method ${handler.path}`,\n                    metadata: null\n                });\n                return;\n            }\n            requestMessage = message;\n            call.startRead();\n        },\n        onReceiveHalfClose () {\n            if (!requestMessage) {\n                call.sendStatus({\n                    code: constants_1.Status.UNIMPLEMENTED,\n                    details: `Received no request message for server streaming method ${handler.path}`,\n                    metadata: null\n                });\n                return;\n            }\n            stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);\n            try {\n                handler.func(stream);\n            } catch (err) {\n                call.sendStatus({\n                    code: constants_1.Status.UNKNOWN,\n                    details: `Server method handler threw error ${err.message}`,\n                    metadata: null\n                });\n            }\n        },\n        onCancel () {\n            if (stream) {\n                stream.cancelled = true;\n                stream.emit(\"cancelled\", \"cancelled\");\n                stream.destroy();\n            }\n        }\n    });\n}\nfunction handleBidiStreaming(call, handler) {\n    let stream;\n    call.start({\n        onReceiveMetadata (metadata) {\n            stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);\n            try {\n                handler.func(stream);\n            } catch (err) {\n                call.sendStatus({\n                    code: constants_1.Status.UNKNOWN,\n                    details: `Server method handler threw error ${err.message}`,\n                    metadata: null\n                });\n            }\n        },\n        onReceiveMessage (message) {\n            stream.push(message);\n        },\n        onReceiveHalfClose () {\n            stream.push(null);\n        },\n        onCancel () {\n            if (stream) {\n                stream.cancelled = true;\n                stream.emit(\"cancelled\", \"cancelled\");\n                stream.destroy();\n            }\n        }\n    });\n} //# sourceMappingURL=server.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsSUFBSUEsb0JBQW9CLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsaUJBQWlCLElBQUssU0FBVUMsT0FBTyxFQUFFQyxZQUFZLEVBQUVDLEtBQUs7SUFDOUYsSUFBSUMsV0FBV0MsVUFBVUMsTUFBTSxHQUFHO0lBQ2xDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTCxhQUFhSSxNQUFNLEVBQUVDLElBQUs7UUFDMUNKLFFBQVFDLFdBQVdGLFlBQVksQ0FBQ0ssRUFBRSxDQUFDQyxJQUFJLENBQUNQLFNBQVNFLFNBQVNELFlBQVksQ0FBQ0ssRUFBRSxDQUFDQyxJQUFJLENBQUNQO0lBQ25GO0lBQ0EsT0FBT0csV0FBV0QsUUFBUSxLQUFLO0FBQ25DO0FBQ0EsSUFBSU0sZUFBZSxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLFlBQVksSUFBSyxTQUFVQyxJQUFJLEVBQUVDLFlBQVksRUFBRUMsVUFBVSxFQUFFQyxTQUFTLEVBQUVYLFlBQVksRUFBRVksaUJBQWlCO0lBQ2xJLFNBQVNDLE9BQU9DLENBQUM7UUFBSSxJQUFJQSxNQUFNLEtBQUssS0FBSyxPQUFPQSxNQUFNLFlBQVksTUFBTSxJQUFJQyxVQUFVO1FBQXNCLE9BQU9EO0lBQUc7SUFDdEgsSUFBSUUsT0FBT0wsVUFBVUssSUFBSSxFQUFFQyxNQUFNRCxTQUFTLFdBQVcsUUFBUUEsU0FBUyxXQUFXLFFBQVE7SUFDekYsSUFBSUUsU0FBUyxDQUFDVCxnQkFBZ0JELE9BQU9HLFNBQVMsQ0FBQyxTQUFTLEdBQUdILE9BQU9BLEtBQUtXLFNBQVMsR0FBRztJQUNuRixJQUFJQyxhQUFhWCxnQkFBaUJTLENBQUFBLFNBQVNHLE9BQU9DLHdCQUF3QixDQUFDSixRQUFRUCxVQUFVWSxJQUFJLElBQUksQ0FBQztJQUN0RyxJQUFJQyxH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Z0wsb0JBQW9CaFosSUFBSSxFQUFFcVYsT0FBTztJQUN0QyxJQUFJcUI7SUFDSjFXLEtBQUsyVixLQUFLLENBQUM7UUFDUDJHLG1CQUFrQjdFLFFBQVE7WUFDdEJmLFNBQVMsSUFBSXJVLGNBQWN3YSxzQkFBc0IsQ0FBQ3hILFFBQVFuSixJQUFJLEVBQUVsTSxNQUFNeVg7WUFDdEUsSUFBSTtnQkFDQXBDLFFBQVFLLElBQUksQ0FBQ2dCO1lBQ2pCLEVBQ0EsT0FBT3RILEtBQUs7Z0JBQ1JwUCxLQUFLMlksVUFBVSxDQUFDO29CQUNaMVUsTUFBTTdCLFlBQVk4QixNQUFNLENBQUN5WSxPQUFPO29CQUNoQ3ZZLFNBQVMsQ0FBQyxrQ0FBa0MsRUFBRWdMLElBQUl0TCxPQUFPLENBQUMsQ0FBQztvQkFDM0QyVCxVQUFVO2dCQUNkO1lBQ0o7UUFDSjtRQUNBK0Usa0JBQWlCMVksT0FBTztZQUNwQjRTLE9BQU9sVixJQUFJLENBQUNzQztRQUNoQjtRQUNBMlk7WUFDSS9GLE9BQU9sVixJQUFJLENBQUM7UUFDaEI7UUFDQW9iO1lBQ0ksSUFBSWxHLFFBQVE7Z0JBQ1JBLE9BQU8zRSxTQUFTLEdBQUc7Z0JBQ25CMkUsT0FBT2pTLElBQUksQ0FBQyxhQUFhO2dCQUN6QmlTLE9BQU8xSSxPQUFPO1lBQ2xCO1FBQ0o7SUFDSjtBQUNKLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnljLWhvdXNpbmctYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3NlcnZlci5qcz9hODgyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG52YXIgX19ydW5Jbml0aWFsaXplcnMgPSAodGhpcyAmJiB0aGlzLl9fcnVuSW5pdGlhbGl6ZXJzKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgaW5pdGlhbGl6ZXJzLCB2YWx1ZSkge1xuICAgIHZhciB1c2VWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdGlhbGl6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gdXNlVmFsdWUgPyBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnLCB2YWx1ZSkgOiBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZVZhbHVlID8gdmFsdWUgOiB2b2lkIDA7XG59O1xudmFyIF9fZXNEZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19lc0RlY29yYXRlKSB8fCBmdW5jdGlvbiAoY3RvciwgZGVzY3JpcHRvckluLCBkZWNvcmF0b3JzLCBjb250ZXh0SW4sIGluaXRpYWxpemVycywgZXh0cmFJbml0aWFsaXplcnMpIHtcbiAgICBmdW5jdGlvbiBhY2NlcHQoZikgeyBpZiAoZiAhPT0gdm9pZCAwICYmIHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbiBleHBlY3RlZFwiKTsgcmV0dXJuIGY7IH1cbiAgICB2YXIga2luZCA9IGNvbnRleHRJbi5raW5kLCBrZXkgPSBraW5kID09PSBcImdldHRlclwiID8gXCJnZXRcIiA6IGtpbmQgPT09IFwic2V0dGVyXCIgPyBcInNldFwiIDogXCJ2YWx1ZVwiO1xuICAgIHZhciB0YXJnZXQgPSAhZGVzY3JpcHRvckluICYmIGN0b3IgPyBjb250ZXh0SW5bXCJzdGF0aWNcIl0gPyBjdG9yIDogY3Rvci5wcm90b3R5cGUgOiBudWxsO1xuICAgIHZhciBkZXNjcmlwdG9yID0gZGVzY3JpcHRvckluIHx8ICh0YXJnZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgY29udGV4dEluLm5hbWUpIDoge30pO1xuICAgIHZhciBfLCBkb25lID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4pIGNvbnRleHRbcF0gPSBwID09PSBcImFjY2Vzc1wiID8ge30gOiBjb250ZXh0SW5bcF07XG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluLmFjY2VzcykgY29udGV4dC5hY2Nlc3NbcF0gPSBjb250ZXh0SW4uYWNjZXNzW3BdO1xuICAgICAgICBjb250ZXh0LmFkZEluaXRpYWxpemVyID0gZnVuY3Rpb24gKGYpIHsgaWYgKGRvbmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIGluaXRpYWxpemVycyBhZnRlciBkZWNvcmF0aW9uIGhhcyBjb21wbGV0ZWRcIik7IGV4dHJhSW5pdGlhbGl6ZXJzLnB1c2goYWNjZXB0KGYgfHwgbnVsbCkpOyB9O1xuICAgICAgICB2YXIgcmVzdWx0ID0gKDAsIGRlY29yYXRvcnNbaV0pKGtpbmQgPT09IFwiYWNjZXNzb3JcIiA/IHsgZ2V0OiBkZXNjcmlwdG9yLmdldCwgc2V0OiBkZXNjcmlwdG9yLnNldCB9IDogZGVzY3JpcHRvcltrZXldLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYWNjZXNzb3JcIikge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgdHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5nZXQpKSBkZXNjcmlwdG9yLmdldCA9IF87XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuc2V0KSkgZGVzY3JpcHRvci5zZXQgPSBfO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmluaXQpKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfID0gYWNjZXB0KHJlc3VsdCkpIHtcbiAgICAgICAgICAgIGlmIChraW5kID09PSBcImZpZWxkXCIpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICAgICAgZWxzZSBkZXNjcmlwdG9yW2tleV0gPSBfO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0YXJnZXQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbnRleHRJbi5uYW1lLCBkZXNjcmlwdG9yKTtcbiAgICBkb25lID0gdHJ1ZTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlcnZlciA9IHZvaWQgMDtcbmNvbnN0IGh0dHAyID0gcmVxdWlyZShcImh0dHAyXCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBzZXJ2ZXJfY2FsbF8xID0gcmVxdWlyZShcIi4vc2VydmVyLWNhbGxcIik7XG5jb25zdCBzZXJ2ZXJfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL3NlcnZlci1jcmVkZW50aWFsc1wiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgY2hhbm5lbHpfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xuY29uc3Qgc2VydmVyX2ludGVyY2VwdG9yc18xID0gcmVxdWlyZShcIi4vc2VydmVyLWludGVyY2VwdG9yc1wiKTtcbmNvbnN0IFVOTElNSVRFRF9DT05ORUNUSU9OX0FHRV9NUyA9IH4oMSA8PCAzMSk7XG5jb25zdCBLRUVQQUxJVkVfTUFYX1RJTUVfTVMgPSB+KDEgPDwgMzEpO1xuY29uc3QgS0VFUEFMSVZFX1RJTUVPVVRfTVMgPSAyMDAwMDtcbmNvbnN0IE1BWF9DT05ORUNUSU9OX0lETEVfTVMgPSB+KDEgPDwgMzEpO1xuY29uc3QgeyBIVFRQMl9IRUFERVJfUEFUSCB9ID0gaHR0cDIuY29uc3RhbnRzO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnc2VydmVyJztcbmNvbnN0IGtNYXhBZ2UgPSBCdWZmZXIuZnJvbSgnbWF4X2FnZScpO1xuZnVuY3Rpb24gc2VydmVyQ2FsbFRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ3NlcnZlcl9jYWxsJywgdGV4dCk7XG59XG5mdW5jdGlvbiBub29wKCkgeyB9XG4vKipcbiAqIERlY29yYXRvciB0byB3cmFwIGEgY2xhc3MgbWV0aG9kIHdpdGggdXRpbC5kZXByZWNhdGVcbiAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIG91dHB1dCBpZiB0aGUgZGVwcmVjYXRlZCBtZXRob2QgaXMgY2FsbGVkXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBkZXByZWNhdGUobWVzc2FnZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB1dGlsLmRlcHJlY2F0ZSh0YXJnZXQsIG1lc3NhZ2UpO1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRVbmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UobWV0aG9kTmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTklNUExFTUVOVEVELFxuICAgICAgICBkZXRhaWxzOiBgVGhlIHNlcnZlciBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIG1ldGhvZCAke21ldGhvZE5hbWV9YCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdEhhbmRsZXIoaGFuZGxlclR5cGUsIG1ldGhvZE5hbWUpIHtcbiAgICBjb25zdCB1bmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UgPSBnZXRVbmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UobWV0aG9kTmFtZSk7XG4gICAgc3dpdGNoIChoYW5kbGVyVHlwZSkge1xuICAgICAgICBjYXNlICd1bmFyeSc6XG4gICAgICAgICAgICByZXR1cm4gKGNhbGwsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlLCBudWxsKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ2NsaWVudFN0cmVhbSc6XG4gICAgICAgICAgICByZXR1cm4gKGNhbGwsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlLCBudWxsKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ3NlcnZlclN0cmVhbSc6XG4gICAgICAgICAgICByZXR1cm4gKGNhbGwpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsLmVtaXQoJ2Vycm9yJywgdW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ2JpZGknOlxuICAgICAgICAgICAgcmV0dXJuIChjYWxsKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbC5lbWl0KCdlcnJvcicsIHVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGhhbmRsZXJUeXBlICR7aGFuZGxlclR5cGV9YCk7XG4gICAgfVxufVxubGV0IFNlcnZlciA9ICgoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyA9IFtdO1xuICAgIGxldCBfc3RhcnRfZGVjb3JhdG9ycztcbiAgICByZXR1cm4gX2EgPSBjbGFzcyBTZXJ2ZXIge1xuICAgICAgICAgICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRQb3J0cyA9IChfX3J1bkluaXRpYWxpemVycyh0aGlzLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyksIG5ldyBNYXAoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5odHRwMlNlcnZlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uSWRsZVRpbWVvdXRzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGlzIGZpZWxkIG9ubHkgZXhpc3RzIHRvIGVuc3VyZSB0aGF0IHRoZSBzdGFydCBtZXRob2QgdGhyb3dzIGFuIGVycm9yIGlmXG4gICAgICAgICAgICAgICAgICogaXQgaXMgY2FsbGVkIHR3aWNlLCBhcyBpdCBkaWQgcHJldmlvdXNseS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNodXRkb3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXJBZGRyZXNzU3RyaW5nID0gJ251bGwnO1xuICAgICAgICAgICAgICAgIC8vIENoYW5uZWx6IEluZm9cbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge307XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc1snZ3JwYy5lbmFibGVfY2hhbm5lbHonXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVselRyYWNlU3R1YigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlclN0dWIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lckNoaWxkcmVuVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyU3R1YigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25DaGlsZHJlblRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNoaWxkcmVuVHJhY2tlclN0dWIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZSA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6VHJhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lckNoaWxkcmVuVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbkNoaWxkcmVuVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYgPSAoMCwgY2hhbm5lbHpfMS5yZWdpc3RlckNoYW5uZWx6U2VydmVyKSgnc2VydmVyJywgKCkgPT4gdGhpcy5nZXRDaGFubmVsekluZm8oKSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdTZXJ2ZXIgY3JlYXRlZCcpO1xuICAgICAgICAgICAgICAgIHRoaXMubWF4Q29ubmVjdGlvbkFnZU1zID1cbiAgICAgICAgICAgICAgICAgICAgKF9iID0gdGhpcy5vcHRpb25zWydncnBjLm1heF9jb25uZWN0aW9uX2FnZV9tcyddKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBVTkxJTUlURURfQ09OTkVDVElPTl9BR0VfTVM7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXhDb25uZWN0aW9uQWdlR3JhY2VNcyA9XG4gICAgICAgICAgICAgICAgICAgIChfYyA9IHRoaXMub3B0aW9uc1snZ3JwYy5tYXhfY29ubmVjdGlvbl9hZ2VfZ3JhY2VfbXMnXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogVU5MSU1JVEVEX0NPTk5FQ1RJT05fQUdFX01TO1xuICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZU1zID1cbiAgICAgICAgICAgICAgICAgICAgKF9kID0gdGhpcy5vcHRpb25zWydncnBjLmtlZXBhbGl2ZV90aW1lX21zJ10pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IEtFRVBBTElWRV9NQVhfVElNRV9NUztcbiAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyA9XG4gICAgICAgICAgICAgICAgICAgIChfZSA9IHRoaXMub3B0aW9uc1snZ3JwYy5rZWVwYWxpdmVfdGltZW91dF9tcyddKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBLRUVQQUxJVkVfVElNRU9VVF9NUztcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25JZGxlVGltZW91dCA9XG4gICAgICAgICAgICAgICAgICAgIChfZiA9IHRoaXMub3B0aW9uc1snZ3JwYy5tYXhfY29ubmVjdGlvbl9pZGxlX21zJ10pICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IE1BWF9DT05ORUNUSU9OX0lETEVfTVM7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21tb25TZXJ2ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBtYXhTZW5kSGVhZGVyQmxvY2tMZW5ndGg6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKCdncnBjLW5vZGUubWF4X3Nlc3Npb25fbWVtb3J5JyBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tb25TZXJ2ZXJPcHRpb25zLm1heFNlc3Npb25NZW1vcnkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zWydncnBjLW5vZGUubWF4X3Nlc3Npb25fbWVtb3J5J107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKiBCeSBkZWZhdWx0LCBzZXQgYSB2ZXJ5IGxhcmdlIG1heCBzZXNzaW9uIG1lbW9yeSBsaW1pdCwgdG8gZWZmZWN0aXZlbHlcbiAgICAgICAgICAgICAgICAgICAgICogZGlzYWJsZSBlbmZvcmNlbWVudCBvZiB0aGUgbGltaXQuIFNvbWUgdGVzdGluZyBpbmRpY2F0ZXMgdGhhdCBOb2RlJ3NcbiAgICAgICAgICAgICAgICAgICAgICogYmVoYXZpb3IgZGVncmFkZXMgYmFkbHkgd2hlbiB0aGlzIGxpbWl0IGlzIHJlYWNoZWQsIHNvIHdlIHNvbHZlIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICogYnkgZGlzYWJsaW5nIHRoZSBjaGVjayBlbnRpcmVseS4gKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tb25TZXJ2ZXJPcHRpb25zLm1heFNlc3Npb25NZW1vcnkgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCdncnBjLm1heF9jb25jdXJyZW50X3N0cmVhbXMnIGluIHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1vblNlcnZlck9wdGlvbnMuc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhDb25jdXJyZW50U3RyZWFtczogdGhpcy5vcHRpb25zWydncnBjLm1heF9jb25jdXJyZW50X3N0cmVhbXMnXSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcmNlcHRvcnMgPSAoX2cgPSB0aGlzLm9wdGlvbnMuaW50ZXJjZXB0b3JzKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdTZXJ2ZXIgY29uc3RydWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldENoYW5uZWx6SW5mbygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZTogdGhpcy5jaGFubmVselRyYWNlLFxuICAgICAgICAgICAgICAgICAgICBjYWxsVHJhY2tlcjogdGhpcy5jYWxsVHJhY2tlcixcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJDaGlsZHJlbjogdGhpcy5saXN0ZW5lckNoaWxkcmVuVHJhY2tlci5nZXRDaGlsZExpc3RzKCksXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25DaGlsZHJlbjogdGhpcy5zZXNzaW9uQ2hpbGRyZW5UcmFja2VyLmdldENoaWxkTGlzdHMoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2V0Q2hhbm5lbHpTZXNzaW9uSW5mbyhzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbkluZm8gPSB0aGlzLnNlc3Npb25zLmdldChzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uU29ja2V0ID0gc2Vzc2lvbi5zb2NrZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3RlQWRkcmVzcyA9IHNlc3Npb25Tb2NrZXQucmVtb3RlQWRkcmVzc1xuICAgICAgICAgICAgICAgICAgICA/ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzKShzZXNzaW9uU29ja2V0LnJlbW90ZUFkZHJlc3MsIHNlc3Npb25Tb2NrZXQucmVtb3RlUG9ydClcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsQWRkcmVzcyA9IHNlc3Npb25Tb2NrZXQubG9jYWxBZGRyZXNzXG4gICAgICAgICAgICAgICAgICAgID8gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3MpKHNlc3Npb25Tb2NrZXQubG9jYWxBZGRyZXNzLCBzZXNzaW9uU29ja2V0LmxvY2FsUG9ydClcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCB0bHNJbmZvO1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uLmVuY3J5cHRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0bHNTb2NrZXQgPSBzZXNzaW9uU29ja2V0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaXBoZXJJbmZvID0gdGxzU29ja2V0LmdldENpcGhlcigpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZXJ0aWZpY2F0ZSA9IHRsc1NvY2tldC5nZXRDZXJ0aWZpY2F0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwZWVyQ2VydGlmaWNhdGUgPSB0bHNTb2NrZXQuZ2V0UGVlckNlcnRpZmljYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRsc0luZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaXBoZXJTdWl0ZVN0YW5kYXJkTmFtZTogKF9iID0gY2lwaGVySW5mby5zdGFuZGFyZE5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaXBoZXJTdWl0ZU90aGVyTmFtZTogY2lwaGVySW5mby5zdGFuZGFyZE5hbWUgPyBudWxsIDogY2lwaGVySW5mby5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxDZXJ0aWZpY2F0ZTogY2VydGlmaWNhdGUgJiYgJ3JhdycgaW4gY2VydGlmaWNhdGUgPyBjZXJ0aWZpY2F0ZS5yYXcgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlQ2VydGlmaWNhdGU6IHBlZXJDZXJ0aWZpY2F0ZSAmJiAncmF3JyBpbiBwZWVyQ2VydGlmaWNhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHBlZXJDZXJ0aWZpY2F0ZS5yYXdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0bHNJbmZvID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc29ja2V0SW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlQWRkcmVzczogcmVtb3RlQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxBZGRyZXNzOiBsb2NhbEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIHNlY3VyaXR5OiB0bHNJbmZvLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVOYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzdHJlYW1zU3RhcnRlZDogc2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5jYWxsc1N0YXJ0ZWQsXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbXNTdWNjZWVkZWQ6IHNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuY2FsbHNTdWNjZWVkZWQsXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbXNGYWlsZWQ6IHNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuY2FsbHNGYWlsZWQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzU2VudDogc2Vzc2lvbkluZm8ubWVzc2FnZXNTZW50LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1JlY2VpdmVkOiBzZXNzaW9uSW5mby5tZXNzYWdlc1JlY2VpdmVkLFxuICAgICAgICAgICAgICAgICAgICBrZWVwQWxpdmVzU2VudDogc2Vzc2lvbkluZm8ua2VlcEFsaXZlc1NlbnQsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RMb2NhbFN0cmVhbUNyZWF0ZWRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBzZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wOiBzZXNzaW9uSW5mby5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXA6IHNlc3Npb25JbmZvLmxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsRmxvd0NvbnRyb2xXaW5kb3c6IChfYyA9IHNlc3Npb24uc3RhdGUubG9jYWxXaW5kb3dTaXplKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVGbG93Q29udHJvbFdpbmRvdzogKF9kID0gc2Vzc2lvbi5zdGF0ZS5yZW1vdGVXaW5kb3dTaXplKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZSh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnKCcgKyB0aGlzLmNoYW5uZWx6UmVmLmlkICsgJykgJyArIHRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2VlcGFsaXZlVHJhY2UodGV4dCkge1xuICAgICAgICAgICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAna2VlcGFsaXZlJywgJygnICsgdGhpcy5jaGFubmVselJlZi5pZCArICcpICcgKyB0ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFByb3RvU2VydmljZSgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZC4gVXNlIGFkZFNlcnZpY2UoKSBpbnN0ZWFkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRTZXJ2aWNlKHNlcnZpY2UsIGltcGxlbWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlcnZpY2UgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHNlcnZpY2UgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbXBsZW1lbnRhdGlvbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRTZXJ2aWNlKCkgcmVxdWlyZXMgdHdvIG9iamVjdHMgYXMgYXJndW1lbnRzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VLZXlzID0gT2JqZWN0LmtleXMoc2VydmljZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlcnZpY2VLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgYW4gZW1wdHkgc2VydmljZSB0byBhIHNlcnZlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXJ2aWNlS2V5cy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRycyA9IHNlcnZpY2VbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBtZXRob2RUeXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cnMucmVxdWVzdFN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJzLnJlc3BvbnNlU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICdiaWRpJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAnY2xpZW50U3RyZWFtJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRycy5yZXNwb25zZVN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAnc2VydmVyU3RyZWFtJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAndW5hcnknO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbXBsRm4gPSBpbXBsZW1lbnRhdGlvbltuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGltcGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbXBsRm4gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgYXR0cnMub3JpZ2luYWxOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1wbEZuID0gaW1wbGVtZW50YXRpb25bYXR0cnMub3JpZ2luYWxOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW1wbEZuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcGwgPSBpbXBsRm4uYmluZChpbXBsZW1lbnRhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBsID0gZ2V0RGVmYXVsdEhhbmRsZXIobWV0aG9kVHlwZSwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IHRoaXMucmVnaXN0ZXIoYXR0cnMucGF0aCwgaW1wbCwgYXR0cnMucmVzcG9uc2VTZXJpYWxpemUsIGF0dHJzLnJlcXVlc3REZXNlcmlhbGl6ZSwgbWV0aG9kVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXRob2QgaGFuZGxlciBmb3IgJHthdHRycy5wYXRofSBhbHJlYWR5IHByb3ZpZGVkLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdmVTZXJ2aWNlKHNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VydmljZSA9PT0gbnVsbCB8fCB0eXBlb2Ygc2VydmljZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVTZXJ2aWNlKCkgcmVxdWlyZXMgb2JqZWN0IGFzIGFyZ3VtZW50Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VLZXlzID0gT2JqZWN0LmtleXMoc2VydmljZSk7XG4gICAgICAgICAgICAgICAgc2VydmljZUtleXMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBzZXJ2aWNlW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXIoYXR0cnMucGF0aCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaW5kKHBvcnQsIGNyZWRzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQuIFVzZSBiaW5kQXN5bmMoKSBpbnN0ZWFkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCwgc28gQVBJIHN0YWJpbGl0eSBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgbWlub3IgdmVyc2lvbnMuXG4gICAgICAgICAgICAgKiBAcGFyYW0gYm91bmRBZGRyZXNzXG4gICAgICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBleHBlcmltZW50YWxSZWdpc3Rlckxpc3RlbmVyVG9DaGFubmVseihib3VuZEFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselNvY2tldCkoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGJvdW5kQWRkcmVzcyksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQWRkcmVzczogYm91bmRBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlQWRkcmVzczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY3VyaXR5OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlTmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbXNTdGFydGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtc1N1Y2NlZWRlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbXNGYWlsZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1NlbnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1JlY2VpdmVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAga2VlcEFsaXZlc1NlbnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFJlbW90ZVN0cmVhbUNyZWF0ZWRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxGbG93Q29udHJvbFdpbmRvdzogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUZsb3dDb250cm9sV2luZG93OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sIHRoaXMuY2hhbm5lbHpFbmFibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbFVucmVnaXN0ZXJMaXN0ZW5lckZyb21DaGFubmVseihjaGFubmVselJlZikge1xuICAgICAgICAgICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikoY2hhbm5lbHpSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3JlYXRlSHR0cDJTZXJ2ZXIoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaHR0cDJTZXJ2ZXI7XG4gICAgICAgICAgICAgICAgaWYgKGNyZWRlbnRpYWxzLl9pc1NlY3VyZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yT3B0aW9ucyA9IGNyZWRlbnRpYWxzLl9nZXRDb25zdHJ1Y3Rvck9wdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dE9wdGlvbnMgPSBjcmVkZW50aWFscy5fZ2V0U2VjdXJlQ29udGV4dE9wdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VjdXJlU2VydmVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29tbW9uU2VydmVyT3B0aW9ucyksIGNvbnN0cnVjdG9yT3B0aW9ucyksIGNvbnRleHRPcHRpb25zKSwgeyBlbmFibGVUcmFjZTogdGhpcy5vcHRpb25zWydncnBjLW5vZGUudGxzX2VuYWJsZV90cmFjZSddID09PSAxIH0pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXJlQ3JlZGVudGlhbHNWYWxpZCA9IGNvbnRleHRPcHRpb25zICE9PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdJbml0aWFsIGNyZWRlbnRpYWxzIHZhbGlkOiAnICsgYXJlQ3JlZGVudGlhbHNWYWxpZCk7XG4gICAgICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyID0gaHR0cDIuY3JlYXRlU2VjdXJlU2VydmVyKHNlY3VyZVNlcnZlck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5wcmVwZW5kTGlzdGVuZXIoJ2Nvbm5lY3Rpb24nLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFyZUNyZWRlbnRpYWxzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdEcm9wcGVkIGNvbm5lY3Rpb24gZnJvbSAnICsgSlNPTi5zdHJpbmdpZnkoc29ja2V0LmFkZHJlc3MoKSkgKyAnIGR1ZSB0byB1bmxvYWRlZCBjcmVkZW50aWFscycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5vbignc2VjdXJlQ29ubmVjdGlvbicsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRoZXNlIGVycm9ycyBuZWVkIHRvIGJlIGhhbmRsZWQgYnkgdGhlIHVzZXIgb2YgSHR0cDJTZWN1cmVTZXJ2ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBhY2NvcmRpbmcgdG8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zNTgyNCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uKCdlcnJvcicsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnQW4gaW5jb21pbmcgVExTIGNvbm5lY3Rpb24gY2xvc2VkIHdpdGggZXJyb3I6ICcgKyBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjcmVkc1dhdGNoZXIgPSBvcHRpb25zID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VjdXJlU2VydmVyID0gaHR0cDJTZXJ2ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VjdXJlU2VydmVyLnNldFNlY3VyZUNvbnRleHQob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dpbmcubG9nKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgJ0ZhaWxlZCB0byBzZXQgc2VjdXJlIGNvbnRleHQgd2l0aCBlcnJvciAnICsgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJlQ3JlZGVudGlhbHNWYWxpZCA9IG9wdGlvbnMgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdQb3N0LXVwZGF0ZSBjcmVkZW50aWFscyB2YWxpZDogJyArIGFyZUNyZWRlbnRpYWxzVmFsaWQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFscy5fYWRkV2F0Y2hlcihjcmVkc1dhdGNoZXIpO1xuICAgICAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFscy5fcmVtb3ZlV2F0Y2hlcihjcmVkc1dhdGNoZXIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyID0gaHR0cDIuY3JlYXRlU2VydmVyKHRoaXMuY29tbW9uU2VydmVyT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLnNldFRpbWVvdXQoMCwgbm9vcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0dXBIYW5kbGVycyhodHRwMlNlcnZlciwgY3JlZGVudGlhbHMuX2dldEludGVyY2VwdG9ycygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cDJTZXJ2ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaW5kT25lQWRkcmVzcyhhZGRyZXNzLCBib3VuZFBvcnRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdBdHRlbXB0aW5nIHRvIGJpbmQgJyArICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShhZGRyZXNzKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaHR0cDJTZXJ2ZXIgPSB0aGlzLmNyZWF0ZUh0dHAyU2VydmVyKGJvdW5kUG9ydE9iamVjdC5jcmVkZW50aWFscyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0ZhaWxlZCB0byBiaW5kICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShhZGRyZXNzKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB3aXRoIGVycm9yICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6ICdwb3J0JyBpbiBhZGRyZXNzID8gYWRkcmVzcy5wb3J0IDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIub25jZSgnZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIubGlzdGVuKGFkZHJlc3MsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kQWRkcmVzcyA9IGh0dHAyU2VydmVyLmFkZHJlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBib3VuZFN1YmNoYW5uZWxBZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBib3VuZEFkZHJlc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRTdWJjaGFubmVsQWRkcmVzcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogYm91bmRBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZFN1YmNoYW5uZWxBZGRyZXNzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBib3VuZEFkZHJlc3MuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogYm91bmRBZGRyZXNzLnBvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWx6UmVmID0gdGhpcy5leHBlcmltZW50YWxSZWdpc3Rlckxpc3RlbmVyVG9DaGFubmVseihib3VuZFN1YmNoYW5uZWxBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJDaGlsZHJlblRyYWNrZXIucmVmQ2hpbGQoY2hhbm5lbHpSZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5odHRwMlNlcnZlcnMuc2V0KGh0dHAyU2VydmVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpSZWY6IGNoYW5uZWx6UmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25zOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duc0NoYW5uZWx6UmVmOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kUG9ydE9iamVjdC5saXN0ZW5pbmdTZXJ2ZXJzLmFkZChodHRwMlNlcnZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdTdWNjZXNzZnVsbHkgYm91bmQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGJvdW5kU3ViY2hhbm5lbEFkZHJlc3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6ICdwb3J0JyBpbiBib3VuZFN1YmNoYW5uZWxBZGRyZXNzID8gYm91bmRTdWJjaGFubmVsQWRkcmVzcy5wb3J0IDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXN5bmMgYmluZE1hbnlQb3J0cyhhZGRyZXNzTGlzdCwgYm91bmRQb3J0T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFkZHJlc3NMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzKShhZGRyZXNzTGlzdFswXSkgJiYgYWRkcmVzc0xpc3RbMF0ucG9ydCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvKiBJZiBiaW5kaW5nIHRvIHBvcnQgMCwgZmlyc3QgdHJ5IHRvIGJpbmQgdGhlIGZpcnN0IGFkZHJlc3MsIHRoZW4gYmluZFxuICAgICAgICAgICAgICAgICAgICAgKiB0aGUgcmVzdCBvZiB0aGUgYWRkcmVzcyBsaXN0IHRvIHRoZSBzcGVjaWZpYyBwb3J0IHRoYXQgaXQgYmluZHMuICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0QWRkcmVzc1Jlc3VsdCA9IGF3YWl0IHRoaXMuYmluZE9uZUFkZHJlc3MoYWRkcmVzc0xpc3RbMF0sIGJvdW5kUG9ydE9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdEFkZHJlc3NSZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIElmIHRoZSBmaXJzdCBhZGRyZXNzIGZhaWxzIHRvIGJpbmQsIHRyeSB0aGUgc2FtZSBvcGVyYXRpb24gc3RhcnRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGZyb20gdGhlIHNlY29uZCBpdGVtIGluIHRoZSBsaXN0LiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdEFkZHJlc3NSZXN1bHQgPSBhd2FpdCB0aGlzLmJpbmRNYW55UG9ydHMoYWRkcmVzc0xpc3Quc2xpY2UoMSksIGJvdW5kUG9ydE9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0QWRkcmVzc1Jlc3VsdCksIHsgZXJyb3JzOiBbZmlyc3RBZGRyZXNzUmVzdWx0LmVycm9yLCAuLi5yZXN0QWRkcmVzc1Jlc3VsdC5lcnJvcnNdIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdEFkZHJlc3NlcyA9IGFkZHJlc3NMaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChhZGRyZXNzID0+ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzKShhZGRyZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geyBob3N0OiBhZGRyZXNzLmhvc3QsIHBvcnQ6IGZpcnN0QWRkcmVzc1Jlc3VsdC5wb3J0IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdEFkZHJlc3NSZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChyZXN0QWRkcmVzc2VzLm1hcChhZGRyZXNzID0+IHRoaXMuYmluZE9uZUFkZHJlc3MoYWRkcmVzcywgYm91bmRQb3J0T2JqZWN0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsUmVzdWx0cyA9IFtmaXJzdEFkZHJlc3NSZXN1bHQsIC4uLnJlc3RBZGRyZXNzUmVzdWx0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IGFsbFJlc3VsdHMuZmlsdGVyKHJlc3VsdCA9PiByZXN1bHQuZXJyb3IgPT09IHVuZGVmaW5lZCkubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6IGZpcnN0QWRkcmVzc1Jlc3VsdC5wb3J0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yczogYWxsUmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHJlc3VsdCA9PiByZXN1bHQuZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAocmVzdWx0ID0+IHJlc3VsdC5lcnJvciksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoYWRkcmVzc0xpc3QubWFwKGFkZHJlc3MgPT4gdGhpcy5iaW5kT25lQWRkcmVzcyhhZGRyZXNzLCBib3VuZFBvcnRPYmplY3QpKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDogYWxsUmVzdWx0cy5maWx0ZXIocmVzdWx0ID0+IHJlc3VsdC5lcnJvciA9PT0gdW5kZWZpbmVkKS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiBhbGxSZXN1bHRzWzBdLnBvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGFsbFJlc3VsdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHJlc3VsdCA9PiByZXN1bHQuZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChyZXN1bHQgPT4gcmVzdWx0LmVycm9yKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3luYyBiaW5kQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGJvdW5kUG9ydE9iamVjdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpbmRSZXN1bHQgPSBhd2FpdCB0aGlzLmJpbmRNYW55UG9ydHMoYWRkcmVzc0xpc3QsIGJvdW5kUG9ydE9iamVjdCk7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRSZXN1bHQuY291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaW5kUmVzdWx0LmNvdW50IDwgYWRkcmVzc0xpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnaW5nLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuSU5GTywgYFdBUk5JTkcgT25seSAke2JpbmRSZXN1bHQuY291bnR9IGFkZHJlc3NlcyBhZGRlZCBvdXQgb2YgdG90YWwgJHthZGRyZXNzTGlzdC5sZW5ndGh9IHJlc29sdmVkYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmRSZXN1bHQucG9ydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yU3RyaW5nID0gYE5vIGFkZHJlc3MgYWRkZWQgb3V0IG9mIHRvdGFsICR7YWRkcmVzc0xpc3QubGVuZ3RofSByZXNvbHZlZGA7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dpbmcubG9nKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgZXJyb3JTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZXJyb3JTdHJpbmd9IGVycm9yczogWyR7YmluZFJlc3VsdC5lcnJvcnMuam9pbignLCcpfV1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlUG9ydChwb3J0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXJMaXN0ZW5lciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzc2Z1bFJlc29sdXRpb246IChlbmRwb2ludExpc3QsIHNlcnZpY2VDb25maWcsIHNlcnZpY2VDb25maWdFcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCBvbmUgcmVzb2x1dGlvbiByZXN1bHQuIERpc2NhcmQgYWxsIGZ1dHVyZSByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXJMaXN0ZW5lci5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uID0gKCkgPT4geyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NMaXN0ID0gW10uY29uY2F0KC4uLmVuZHBvaW50TGlzdC5tYXAoZW5kcG9pbnQgPT4gZW5kcG9pbnQuYWRkcmVzc2VzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3NMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBObyBhZGRyZXNzZXMgcmVzb2x2ZWQgZm9yIHBvcnQgJHtwb3J0fWApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGFkZHJlc3NMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJvci5kZXRhaWxzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlciA9ICgwLCByZXNvbHZlcl8xLmNyZWF0ZVJlc29sdmVyKShwb3J0LCByZXNvbHZlckxpc3RlbmVyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlci51cGRhdGVSZXNvbHV0aW9uKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3luYyBiaW5kUG9ydChwb3J0LCBib3VuZFBvcnRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzTGlzdCA9IGF3YWl0IHRoaXMucmVzb2x2ZVBvcnQocG9ydCk7XG4gICAgICAgICAgICAgICAgaWYgKGJvdW5kUG9ydE9iamVjdC5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZVVuYmluZChib3VuZFBvcnRPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBc3luYyBvcGVyYXRpb24gY2FuY2VsbGVkIGJ5IHVuYmluZCBjYWxsJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBvcnROdW1iZXIgPSBhd2FpdCB0aGlzLmJpbmRBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgYm91bmRQb3J0T2JqZWN0KTtcbiAgICAgICAgICAgICAgICBpZiAoYm91bmRQb3J0T2JqZWN0LmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlVW5iaW5kKGJvdW5kUG9ydE9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmluZEFzeW5jIG9wZXJhdGlvbiBjYW5jZWxsZWQgYnkgdW5iaW5kIGNhbGwnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcnROdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3JtYWxpemVQb3J0KHBvcnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbml0aWFsUG9ydFVyaSA9ICgwLCB1cmlfcGFyc2VyXzEucGFyc2VVcmkpKHBvcnQpO1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsUG9ydFVyaSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSBwb3J0IFwiJHtwb3J0fVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBvcnRVcmkgPSAoMCwgcmVzb2x2ZXJfMS5tYXBVcmlEZWZhdWx0U2NoZW1lKShpbml0aWFsUG9ydFVyaSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcnRVcmkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZ2V0IGEgZGVmYXVsdCBzY2hlbWUgZm9yIHBvcnQgXCIke3BvcnR9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcnRVcmk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaW5kQXN5bmMocG9ydCwgY3JlZHMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2h1dGRvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaW5kQXN5bmMgY2FsbGVkIGFmdGVyIHNodXRkb3duJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9ydCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncG9ydCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjcmVkcyA9PT0gbnVsbCB8fCAhKGNyZWRzIGluc3RhbmNlb2Ygc2VydmVyX2NyZWRlbnRpYWxzXzEuU2VydmVyQ3JlZGVudGlhbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NyZWRzIG11c3QgYmUgYSBTZXJ2ZXJDcmVkZW50aWFscyBvYmplY3QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnYmluZEFzeW5jIHBvcnQ9JyArIHBvcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvcnRVcmkgPSB0aGlzLm5vcm1hbGl6ZVBvcnQocG9ydCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVmZXJyZWRDYWxsYmFjayA9IChlcnJvciwgcG9ydCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IGNhbGxiYWNrKGVycm9yLCBwb3J0KSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvKiBGaXJzdCwgaWYgdGhpcyBwb3J0IGlzIGFscmVhZHkgYm91bmQgb3IgdGhhdCBiaW5kIG9wZXJhdGlvbiBpcyBpblxuICAgICAgICAgICAgICAgICAqIHByb2dyZXNzLCB1c2UgdGhhdCByZXN1bHQuICovXG4gICAgICAgICAgICAgICAgbGV0IGJvdW5kUG9ydE9iamVjdCA9IHRoaXMuYm91bmRQb3J0cy5nZXQoKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykocG9ydFVyaSkpO1xuICAgICAgICAgICAgICAgIGlmIChib3VuZFBvcnRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjcmVkcy5fZXF1YWxzKGJvdW5kUG9ydE9iamVjdC5jcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkQ2FsbGJhY2sobmV3IEVycm9yKGAke3BvcnR9IGFscmVhZHkgYm91bmQgd2l0aCBpbmNvbXBhdGlibGUgY3JlZGVudGlhbHNgKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLyogSWYgdGhhdCBvcGVyYXRpb24gaGFzIHByZXZpb3VzbHkgYmVlbiBjYW5jZWxsZWQgYnkgYW4gdW5iaW5kIGNhbGwsXG4gICAgICAgICAgICAgICAgICAgICAqIHVuY2FuY2VsIGl0LiAqL1xuICAgICAgICAgICAgICAgICAgICBib3VuZFBvcnRPYmplY3QuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChib3VuZFBvcnRPYmplY3QuY29tcGxldGlvblByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kUG9ydE9iamVjdC5jb21wbGV0aW9uUHJvbWlzZS50aGVuKHBvcnROdW0gPT4gY2FsbGJhY2sobnVsbCwgcG9ydE51bSksIGVycm9yID0+IGNhbGxiYWNrKGVycm9yLCAwKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZENhbGxiYWNrKG51bGwsIGJvdW5kUG9ydE9iamVjdC5wb3J0TnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJvdW5kUG9ydE9iamVjdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbWFwS2V5OiAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKShwb3J0VXJpKSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxVcmk6IHBvcnRVcmksXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Qcm9taXNlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBwb3J0TnVtYmVyOiAwLFxuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsczogY3JlZHMsXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmluZ1NlcnZlcnM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwbGl0UG9ydCA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkocG9ydFVyaS5wYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wbGV0aW9uUHJvbWlzZSA9IHRoaXMuYmluZFBvcnQocG9ydFVyaSwgYm91bmRQb3J0T2JqZWN0KTtcbiAgICAgICAgICAgICAgICBib3VuZFBvcnRPYmplY3QuY29tcGxldGlvblByb21pc2UgPSBjb21wbGV0aW9uUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAvKiBJZiB0aGUgcG9ydCBudW1iZXIgaXMgMCwgZGVmZXIgcG9wdWxhdGluZyB0aGUgbWFwIGVudHJ5IHVudGlsIGFmdGVyIHRoZVxuICAgICAgICAgICAgICAgICAqIGJpbmQgb3BlcmF0aW9uIGNvbXBsZXRlcyBhbmQgd2UgaGF2ZSBhIHNwZWNpZmljIHBvcnQgbnVtYmVyLiBPdGhlcndpc2UsXG4gICAgICAgICAgICAgICAgICogcG9wdWxhdGUgaXQgaW1tZWRpYXRlbHkuICovXG4gICAgICAgICAgICAgICAgaWYgKChzcGxpdFBvcnQgPT09IG51bGwgfHwgc3BsaXRQb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGxpdFBvcnQucG9ydCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGlvblByb21pc2UudGhlbihwb3J0TnVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsVXJpID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtZTogcG9ydFVyaS5zY2hlbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aG9yaXR5OiBwb3J0VXJpLmF1dGhvcml0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAoMCwgdXJpX3BhcnNlcl8xLmNvbWJpbmVIb3N0UG9ydCkoeyBob3N0OiBzcGxpdFBvcnQuaG9zdCwgcG9ydDogcG9ydE51bSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZFBvcnRPYmplY3QubWFwS2V5ID0gKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykoZmluYWxVcmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRQb3J0T2JqZWN0LmNvbXBsZXRpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kUG9ydE9iamVjdC5wb3J0TnVtYmVyID0gcG9ydE51bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYm91bmRQb3J0cy5zZXQoYm91bmRQb3J0T2JqZWN0Lm1hcEtleSwgYm91bmRQb3J0T2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHBvcnROdW0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ib3VuZFBvcnRzLnNldChib3VuZFBvcnRPYmplY3QubWFwS2V5LCBib3VuZFBvcnRPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0aW9uUHJvbWlzZS50aGVuKHBvcnROdW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRQb3J0T2JqZWN0LmNvbXBsZXRpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kUG9ydE9iamVjdC5wb3J0TnVtYmVyID0gcG9ydE51bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHBvcnROdW0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZ2lzdGVySW5qZWN0b3JUb0NoYW5uZWx6KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY2hhbm5lbHpfMS5yZWdpc3RlckNoYW5uZWx6U29ja2V0KSgnaW5qZWN0b3InLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEFkZHJlc3M6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVBZGRyZXNzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdXJpdHk6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVOYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtc1N0YXJ0ZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1zU3VjY2VlZGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtc0ZhaWxlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzU2VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzUmVjZWl2ZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZWVwQWxpdmVzU2VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RMb2NhbFN0cmVhbUNyZWF0ZWRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UmVtb3RlU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZsb3dDb250cm9sV2luZG93OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlRmxvd0NvbnRyb2xXaW5kb3c6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwsIHNvIEFQSSBzdGFiaWxpdHkgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIG1pbm9yIHZlcnNpb25zLlxuICAgICAgICAgICAgICogQHBhcmFtIGNyZWRlbnRpYWxzXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2hhbm5lbHpSZWZcbiAgICAgICAgICAgICAqIEByZXR1cm5zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbENyZWF0ZUNvbm5lY3Rpb25JbmplY3RvcldpdGhDaGFubmVselJlZihjcmVkZW50aWFscywgY2hhbm5lbHpSZWYsIG93bnNDaGFubmVselJlZiA9IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNyZWRlbnRpYWxzID09PSBudWxsIHx8ICEoY3JlZGVudGlhbHMgaW5zdGFuY2VvZiBzZXJ2ZXJfY3JlZGVudGlhbHNfMS5TZXJ2ZXJDcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY3JlZHMgbXVzdCBiZSBhIFNlcnZlckNyZWRlbnRpYWxzIG9iamVjdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lckNoaWxkcmVuVHJhY2tlci5yZWZDaGlsZChjaGFubmVselJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlciA9IHRoaXMuY3JlYXRlSHR0cDJTZXJ2ZXIoY3JlZGVudGlhbHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25zU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaHR0cDJTZXJ2ZXJzLnNldChzZXJ2ZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpSZWY6IGNoYW5uZWx6UmVmLFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uczogc2Vzc2lvbnNTZXQsXG4gICAgICAgICAgICAgICAgICAgIG93bnNDaGFubmVselJlZlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGluamVjdENvbm5lY3Rpb246IChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIuZW1pdCgnY29ubmVjdGlvbicsIGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkcmFpbjogKGdyYWNlVGltZU1zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzZXNzaW9uIG9mIHNlc3Npb25zU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2MgPSAoX2IgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNlc3Npb24gb2Ygc2Vzc2lvbnNTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5kZXN0cm95KGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0NBTkNFTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZ3JhY2VUaW1lTXMpKS51bnJlZikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlU2VydmVyKHNlcnZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNlc3Npb24gb2Ygc2Vzc2lvbnNTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjcmVhdGVDb25uZWN0aW9uSW5qZWN0b3IoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3JlZGVudGlhbHMgPT09IG51bGwgfHwgIShjcmVkZW50aWFscyBpbnN0YW5jZW9mIHNlcnZlcl9jcmVkZW50aWFsc18xLlNlcnZlckNyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjcmVkcyBtdXN0IGJlIGEgU2VydmVyQ3JlZGVudGlhbHMgb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWx6UmVmID0gdGhpcy5yZWdpc3RlckluamVjdG9yVG9DaGFubmVseigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGVyaW1lbnRhbENyZWF0ZUNvbm5lY3Rpb25JbmplY3RvcldpdGhDaGFubmVselJlZihjcmVkZW50aWFscywgY2hhbm5lbHpSZWYsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xvc2VTZXJ2ZXIoc2VydmVyLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0Nsb3Npbmcgc2VydmVyIHdpdGggYWRkcmVzcyAnICsgSlNPTi5zdHJpbmdpZnkoc2VydmVyLmFkZHJlc3MoKSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlckluZm8gPSB0aGlzLmh0dHAyU2VydmVycy5nZXQoc2VydmVyKTtcbiAgICAgICAgICAgICAgICBzZXJ2ZXIuY2xvc2UoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VydmVySW5mbyAmJiBzZXJ2ZXJJbmZvLm93bnNDaGFubmVselJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lckNoaWxkcmVuVHJhY2tlci51bnJlZkNoaWxkKHNlcnZlckluZm8uY2hhbm5lbHpSZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKShzZXJ2ZXJJbmZvLmNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmh0dHAyU2VydmVycy5kZWxldGUoc2VydmVyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbG9zZVNlc3Npb24oc2Vzc2lvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgX2I7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnQ2xvc2luZyBzZXNzaW9uIGluaXRpYXRlZCBieSAnICsgKChfYiA9IHNlc3Npb24uc29ja2V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVtb3RlQWRkcmVzcykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JbmZvID0gdGhpcy5zZXNzaW9ucy5nZXQoc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlc3Npb25JbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25DaGlsZHJlblRyYWNrZXIudW5yZWZDaGlsZChzZXNzaW9uSW5mby5yZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKShzZXNzaW9uSW5mby5yZWYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb24uY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKGNsb3NlQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZShjbG9zZUNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wbGV0ZVVuYmluZChib3VuZFBvcnRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNlcnZlciBvZiBib3VuZFBvcnRPYmplY3QubGlzdGVuaW5nU2VydmVycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJJbmZvID0gdGhpcy5odHRwMlNlcnZlcnMuZ2V0KHNlcnZlcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VTZXJ2ZXIoc2VydmVyLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZFBvcnRPYmplY3QubGlzdGVuaW5nU2VydmVycy5kZWxldGUoc2VydmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXJ2ZXJJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNlc3Npb24gb2Ygc2VydmVySW5mby5zZXNzaW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRQb3J0cy5kZWxldGUoYm91bmRQb3J0T2JqZWN0Lm1hcEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVuYmluZCBhIHByZXZpb3VzbHkgYm91bmQgcG9ydCwgb3IgY2FuY2VsIGFuIGluLXByb2dyZXNzIGJpbmRBc3luY1xuICAgICAgICAgICAgICogb3BlcmF0aW9uLiBJZiBwb3J0IDAgd2FzIGJvdW5kLCBvbmx5IHRoZSBhY3R1YWwgYm91bmQgcG9ydCBjYW4gYmVcbiAgICAgICAgICAgICAqIHVuYm91bmQuIEZvciBleGFtcGxlLCBpZiBiaW5kQXN5bmMgd2FzIGNhbGxlZCB3aXRoIFwibG9jYWxob3N0OjBcIiBhbmQgdGhlXG4gICAgICAgICAgICAgKiBib3VuZCBwb3J0IHJlc3VsdCB3YXMgNTQzMjEsIGl0IGNhbiBiZSB1bmJvdW5kIGFzIFwibG9jYWxob3N0OjU0MzIxXCIuXG4gICAgICAgICAgICAgKiBAcGFyYW0gcG9ydFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB1bmJpbmQocG9ydCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ3VuYmluZCBwb3J0PScgKyBwb3J0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3J0VXJpID0gdGhpcy5ub3JtYWxpemVQb3J0KHBvcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwbGl0UG9ydCA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkocG9ydFVyaS5wYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoKHNwbGl0UG9ydCA9PT0gbnVsbCB8fCBzcGxpdFBvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwbGl0UG9ydC5wb3J0KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1bmJpbmQgcG9ydCAwJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kUG9ydE9iamVjdCA9IHRoaXMuYm91bmRQb3J0cy5nZXQoKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykocG9ydFVyaSkpO1xuICAgICAgICAgICAgICAgIGlmIChib3VuZFBvcnRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgndW5iaW5kaW5nICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRQb3J0T2JqZWN0Lm1hcEtleSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIG9yaWdpbmFsbHkgYm91bmQgYXMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKShib3VuZFBvcnRPYmplY3Qub3JpZ2luYWxVcmkpKTtcbiAgICAgICAgICAgICAgICAgICAgLyogSWYgdGhlIGJpbmQgb3BlcmF0aW9uIGlzIHBlbmRpbmcsIHRoZSBjYW5jZWxsZWQgZmxhZyB3aWxsIHRyaWdnZXJcbiAgICAgICAgICAgICAgICAgICAgICogdGhlIHVuYmluZCBvcGVyYXRpb24gbGF0ZXIuICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChib3VuZFBvcnRPYmplY3QuY29tcGxldGlvblByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kUG9ydE9iamVjdC5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZVVuYmluZChib3VuZFBvcnRPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHcmFjZWZ1bGx5IGNsb3NlIGFsbCBjb25uZWN0aW9ucyBhc3NvY2lhdGVkIHdpdGggYSBwcmV2aW91c2x5IGJvdW5kIHBvcnQuXG4gICAgICAgICAgICAgKiBBZnRlciB0aGUgZ3JhY2UgdGltZSwgZm9yY2VmdWxseSBjbG9zZSBhbGwgcmVtYWluaW5nIG9wZW4gY29ubmVjdGlvbnMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSWYgcG9ydCAwIHdhcyBib3VuZCwgb25seSB0aGUgYWN0dWFsIGJvdW5kIHBvcnQgY2FuIGJlXG4gICAgICAgICAgICAgKiBkcmFpbmVkLiBGb3IgZXhhbXBsZSwgaWYgYmluZEFzeW5jIHdhcyBjYWxsZWQgd2l0aCBcImxvY2FsaG9zdDowXCIgYW5kIHRoZVxuICAgICAgICAgICAgICogYm91bmQgcG9ydCByZXN1bHQgd2FzIDU0MzIxLCBpdCBjYW4gYmUgZHJhaW5lZCBhcyBcImxvY2FsaG9zdDo1NDMyMVwiLlxuICAgICAgICAgICAgICogQHBhcmFtIHBvcnRcbiAgICAgICAgICAgICAqIEBwYXJhbSBncmFjZVRpbWVNc1xuICAgICAgICAgICAgICogQHJldHVybnNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZHJhaW4ocG9ydCwgZ3JhY2VUaW1lTXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2IsIF9jO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ2RyYWluIHBvcnQ9JyArIHBvcnQgKyAnIGdyYWNlVGltZU1zPScgKyBncmFjZVRpbWVNcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9ydFVyaSA9IHRoaXMubm9ybWFsaXplUG9ydChwb3J0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzcGxpdFBvcnQgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHBvcnRVcmkucGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKChzcGxpdFBvcnQgPT09IG51bGwgfHwgc3BsaXRQb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGxpdFBvcnQucG9ydCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZHJhaW4gcG9ydCAwJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kUG9ydE9iamVjdCA9IHRoaXMuYm91bmRQb3J0cy5nZXQoKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykocG9ydFVyaSkpO1xuICAgICAgICAgICAgICAgIGlmICghYm91bmRQb3J0T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsU2Vzc2lvbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBodHRwMlNlcnZlciBvZiBib3VuZFBvcnRPYmplY3QubGlzdGVuaW5nU2VydmVycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJFbnRyeSA9IHRoaXMuaHR0cDJTZXJ2ZXJzLmdldChodHRwMlNlcnZlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXJ2ZXJFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzZXNzaW9uIG9mIHNlcnZlckVudHJ5LnNlc3Npb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsU2Vzc2lvbnMuYWRkKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VTZXNzaW9uKHNlc3Npb24sICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsU2Vzc2lvbnMuZGVsZXRlKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIEFmdGVyIHRoZSBncmFjZSB0aW1lIGVuZHMsIHNlbmQgYW5vdGhlciBnb2F3YXkgdG8gYWxsIHJlbWFpbmluZyBzZXNzaW9uc1xuICAgICAgICAgICAgICAgICAqIHdpdGggdGhlIENBTkNFTCBjb2RlLiAqL1xuICAgICAgICAgICAgICAgIChfYyA9IChfYiA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNlc3Npb24gb2YgYWxsU2Vzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uZGVzdHJveShodHRwMi5jb25zdGFudHMuTkdIVFRQMl9DQU5DRUwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZ3JhY2VUaW1lTXMpKS51bnJlZikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yY2VTaHV0ZG93bigpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJvdW5kUG9ydE9iamVjdCBvZiB0aGlzLmJvdW5kUG9ydHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYm91bmRQb3J0T2JqZWN0LmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRQb3J0cy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIC8vIENsb3NlIHRoZSBzZXJ2ZXIgaWYgaXQgaXMgc3RpbGwgcnVubmluZy5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNlcnZlciBvZiB0aGlzLmh0dHAyU2VydmVycy5rZXlzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVNlcnZlcihzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgZGVzdHJveSBhbnkgYXZhaWxhYmxlIHNlc3Npb25zLiBJdCdzIHBvc3NpYmxlIHRoYXQgb25lIG9yIG1vcmVcbiAgICAgICAgICAgICAgICAvLyB0cnlTaHV0ZG93bigpIGNhbGxzIGFyZSBpbiBwcm9ncmVzcy4gRG9uJ3Qgd2FpdCBvbiB0aGVtIHRvIGZpbmlzaC5cbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25zLmZvckVhY2goKGNoYW5uZWx6SW5mbywgc2Vzc2lvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FzdCBOR0hUVFAyX0NBTkNFTCB0byBhbnkgYmVjYXVzZSBUeXBlU2NyaXB0IGRvZXNuJ3Qgc2VlbSB0b1xuICAgICAgICAgICAgICAgICAgICAvLyByZWNvZ25pemUgZGVzdHJveShjb2RlKSBhcyBhIHZhbGlkIHNpZ25hdHVyZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5kZXN0cm95KGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0NBTkNFTCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9ucy5jbGVhcigpO1xuICAgICAgICAgICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikodGhpcy5jaGFubmVselJlZik7XG4gICAgICAgICAgICAgICAgdGhpcy5zaHV0ZG93biA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWdpc3RlcihuYW1lLCBoYW5kbGVyLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCB0eXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFuZGxlcnMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVycy5zZXQobmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBmdW5jOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemUsXG4gICAgICAgICAgICAgICAgICAgIGRlc2VyaWFsaXplLFxuICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBuYW1lLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5yZWdpc3RlcihuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlcnMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZCBObyBsb25nZXIgbmVlZGVkIGFzIG9mIHZlcnNpb24gMS4xMC54XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHN0YXJ0KCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmh0dHAyU2VydmVycy5zaXplID09PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgIFsuLi50aGlzLmh0dHAyU2VydmVycy5rZXlzKCldLmV2ZXJ5KHNlcnZlciA9PiAhc2VydmVyLmxpc3RlbmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXJ2ZXIgbXVzdCBiZSBib3VuZCBpbiBvcmRlciB0byBzdGFydCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFydGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2VydmVyIGlzIGFscmVhZHkgc3RhcnRlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5U2h1dGRvd24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgX2I7XG4gICAgICAgICAgICAgICAgY29uc3Qgd3JhcHBlZENhbGxiYWNrID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikodGhpcy5jaGFubmVselJlZik7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxldCBwZW5kaW5nQ2hlY2tzID0gMDtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBtYXliZUNhbGxiYWNrKCkge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQ2hlY2tzLS07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nQ2hlY2tzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNodXRkb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtzZXJ2ZXJLZXksIHNlcnZlcl0gb2YgdGhpcy5odHRwMlNlcnZlcnMuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdDaGVja3MrKztcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyU3RyaW5nID0gc2VydmVyLmNoYW5uZWx6UmVmLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1dhaXRpbmcgZm9yIHNlcnZlciAnICsgc2VydmVyU3RyaW5nICsgJyB0byBjbG9zZScpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlU2VydmVyKHNlcnZlcktleSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnU2VydmVyICcgKyBzZXJ2ZXJTdHJpbmcgKyAnIGZpbmlzaGVkIGNsb3NpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2Vzc2lvbiBvZiBzZXJ2ZXIuc2Vzc2lvbnMua2V5cygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQ2hlY2tzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uU3RyaW5nID0gKF9iID0gc2Vzc2lvbi5zb2NrZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZW1vdGVBZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnV2FpdGluZyBmb3Igc2Vzc2lvbiAnICsgc2Vzc2lvblN0cmluZyArICcgdG8gY2xvc2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VTZXNzaW9uKHNlc3Npb24sICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdTZXNzaW9uICcgKyBzZXNzaW9uU3RyaW5nICsgJyBmaW5pc2hlZCBjbG9zaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdDaGVja3MgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlZENhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkSHR0cDJQb3J0KCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIGNoYW5uZWx6IHJlZmVyZW5jZSBvYmplY3QgZm9yIHRoaXMgc2VydmVyLiBUaGUgcmV0dXJuZWQgdmFsdWUgaXNcbiAgICAgICAgICAgICAqIGdhcmJhZ2UgaWYgY2hhbm5lbHogaXMgZGlzYWJsZWQgZm9yIHRoaXMgc2VydmVyLlxuICAgICAgICAgICAgICogQHJldHVybnNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0Q2hhbm5lbHpSZWYoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHpSZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdmVyaWZ5Q29udGVudFR5cGUoc3RyZWFtLCBoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSBoZWFkZXJzW2h0dHAyLmNvbnN0YW50cy5IVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnRUeXBlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgICAgICAhY29udGVudFR5cGUuc3RhcnRzV2l0aCgnYXBwbGljYXRpb24vZ3JwYycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5yZXNwb25kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX1NUQVRVU106IGh0dHAyLmNvbnN0YW50cy5IVFRQX1NUQVRVU19VTlNVUFBPUlRFRF9NRURJQV9UWVBFLFxuICAgICAgICAgICAgICAgICAgICB9LCB7IGVuZFN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9yZXRyaWV2ZUhhbmRsZXIocGF0aCkge1xuICAgICAgICAgICAgICAgIHNlcnZlckNhbGxUcmFjZSgnUmVjZWl2ZWQgY2FsbCB0byBtZXRob2QgJyArXG4gICAgICAgICAgICAgICAgICAgIHBhdGggK1xuICAgICAgICAgICAgICAgICAgICAnIGF0IGFkZHJlc3MgJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmVyQWRkcmVzc1N0cmluZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuaGFuZGxlcnMuZ2V0KHBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyQ2FsbFRyYWNlKCdObyBoYW5kbGVyIHJlZ2lzdGVyZWQgZm9yIG1ldGhvZCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggK1xuICAgICAgICAgICAgICAgICAgICAgICAgJy4gU2VuZGluZyBVTklNUExFTUVOVEVEIHN0YXR1cy4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3Jlc3BvbmRXaXRoRXJyb3IoZXJyLCBzdHJlYW0sIGNoYW5uZWx6U2Vzc2lvbkluZm8gPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iLCBfYztcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFpbGVyc1RvU2VuZCA9IE9iamVjdC5hc3NpZ24oeyAnZ3JwYy1zdGF0dXMnOiAoX2IgPSBlcnIuY29kZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCAnZ3JwYy1tZXNzYWdlJzogZXJyLmRldGFpbHMsIFtodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX1NUQVRVU106IGh0dHAyLmNvbnN0YW50cy5IVFRQX1NUQVRVU19PSywgW2h0dHAyLmNvbnN0YW50cy5IVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFXTogJ2FwcGxpY2F0aW9uL2dycGMrcHJvdG8nIH0sIChfYyA9IGVyci5tZXRhZGF0YSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvSHR0cDJIZWFkZXJzKCkpO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5yZXNwb25kKHRyYWlsZXJzVG9TZW5kLCB7IGVuZFN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvID09PSBudWxsIHx8IGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5uZWx6U2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfY2hhbm5lbHpIYW5kbGVyKGV4dHJhSW50ZXJjZXB0b3JzLCBzdHJlYW0sIGhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgaGFuZGxpbmcgaWRsZSB0aW1lb3V0XG4gICAgICAgICAgICAgICAgdGhpcy5vblN0cmVhbU9wZW5lZChzdHJlYW0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWx6U2Vzc2lvbkluZm8gPSB0aGlzLnNlc3Npb25zLmdldChzdHJlYW0uc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xuICAgICAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IG51bGwgfHwgY2hhbm5lbHpTZXNzaW9uSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbm5lbHpTZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmFkZENhbGxTdGFydGVkKCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlDb250ZW50VHlwZShzdHJlYW0sIGhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvID09PSBudWxsIHx8IGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5uZWx6U2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGhlYWRlcnNbSFRUUDJfSEVBREVSX1BBVEhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLl9yZXRyaWV2ZUhhbmRsZXIocGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRXaXRoRXJyb3IoZ2V0VW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlKHBhdGgpLCBzdHJlYW0sIGNoYW5uZWx6U2Vzc2lvbkluZm8pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxFdmVudFRyYWNrZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZE1lc3NhZ2VTZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbHpTZXNzaW9uSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8ubWVzc2FnZXNTZW50ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mby5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhZGRNZXNzYWdlUmVjZWl2ZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFubmVselNlc3Npb25JbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mby5tZXNzYWdlc1JlY2VpdmVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mby5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25DYWxsRW5kOiBzdGF0dXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxTdWNjZWVkZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvblN0cmVhbUVuZDogc3VjY2VzcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbHpTZXNzaW9uSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGwgPSAoMCwgc2VydmVyX2ludGVyY2VwdG9yc18xLmdldFNlcnZlckludGVyY2VwdGluZ0NhbGwpKFsuLi5leHRyYUludGVyY2VwdG9ycywgLi4udGhpcy5pbnRlcmNlcHRvcnNdLCBzdHJlYW0sIGhlYWRlcnMsIGNhbGxFdmVudFRyYWNrZXIsIGhhbmRsZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9ydW5IYW5kbGVyRm9yQ2FsbChjYWxsLCBoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mbyA9PT0gbnVsbCB8fCBjaGFubmVselNlc3Npb25JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGFubmVselNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsLnNlbmRTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFVua25vd24gaGFuZGxlciB0eXBlOiAke2hhbmRsZXIudHlwZX1gLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfc3RyZWFtSGFuZGxlcihleHRyYUludGVyY2VwdG9ycywgc3RyZWFtLCBoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGhhbmRsaW5nIGlkbGUgdGltZW91dFxuICAgICAgICAgICAgICAgIHRoaXMub25TdHJlYW1PcGVuZWQoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdmVyaWZ5Q29udGVudFR5cGUoc3RyZWFtLCBoZWFkZXJzKSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBoZWFkZXJzW0hUVFAyX0hFQURFUl9QQVRIXTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5fcmV0cmlldmVIYW5kbGVyKHBhdGgpO1xuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kV2l0aEVycm9yKGdldFVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZShwYXRoKSwgc3RyZWFtLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsID0gKDAsIHNlcnZlcl9pbnRlcmNlcHRvcnNfMS5nZXRTZXJ2ZXJJbnRlcmNlcHRpbmdDYWxsKShbLi4uZXh0cmFJbnRlcmNlcHRvcnMsIC4uLnRoaXMuaW50ZXJjZXB0b3JzXSwgc3RyZWFtLCBoZWFkZXJzLCBudWxsLCBoYW5kbGVyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcnVuSGFuZGxlckZvckNhbGwoY2FsbCwgaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5zZW5kU3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBVbmtub3duIGhhbmRsZXIgdHlwZTogJHtoYW5kbGVyLnR5cGV9YCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3J1bkhhbmRsZXJGb3JDYWxsKGNhbGwsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHR5cGUgfSA9IGhhbmRsZXI7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICd1bmFyeScpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlVW5hcnkoY2FsbCwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdjbGllbnRTdHJlYW0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUNsaWVudFN0cmVhbWluZyhjYWxsLCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3NlcnZlclN0cmVhbScpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlU2VydmVyU3RyZWFtaW5nKGNhbGwsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnYmlkaScpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQmlkaVN0cmVhbWluZyhjYWxsLCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfc2V0dXBIYW5kbGVycyhodHRwMlNlcnZlciwgZXh0cmFJbnRlcmNlcHRvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaHR0cDJTZXJ2ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJBZGRyZXNzID0gaHR0cDJTZXJ2ZXIuYWRkcmVzcygpO1xuICAgICAgICAgICAgICAgIGxldCBzZXJ2ZXJBZGRyZXNzU3RyaW5nID0gJ251bGwnO1xuICAgICAgICAgICAgICAgIGlmIChzZXJ2ZXJBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VydmVyQWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckFkZHJlc3NTdHJpbmcgPSBzZXJ2ZXJBZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyQWRkcmVzc1N0cmluZyA9IHNlcnZlckFkZHJlc3MuYWRkcmVzcyArICc6JyArIHNlcnZlckFkZHJlc3MucG9ydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZlckFkZHJlc3NTdHJpbmcgPSBzZXJ2ZXJBZGRyZXNzU3RyaW5nO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmNoYW5uZWx6RW5hYmxlZFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuX2NoYW5uZWx6SGFuZGxlclxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX3N0cmVhbUhhbmRsZXI7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbkhhbmRsZXIgPSB0aGlzLmNoYW5uZWx6RW5hYmxlZFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuX2NoYW5uZWx6U2Vzc2lvbkhhbmRsZXIoaHR0cDJTZXJ2ZXIpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fc2Vzc2lvbkhhbmRsZXIoaHR0cDJTZXJ2ZXIpO1xuICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLm9uKCdzdHJlYW0nLCBoYW5kbGVyLmJpbmQodGhpcywgZXh0cmFJbnRlcmNlcHRvcnMpKTtcbiAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5vbignc2Vzc2lvbicsIHNlc3Npb25IYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9zZXNzaW9uSGFuZGxlcihodHRwMlNlcnZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoc2Vzc2lvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLmh0dHAyU2VydmVycy5nZXQoaHR0cDJTZXJ2ZXIpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2Vzc2lvbnMuYWRkKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29ubmVjdGlvbkFnZVRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbm5lY3Rpb25BZ2VHcmFjZVRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGtlZXBhbGl2ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlc3Npb25DbG9zZWRCeVNlcnZlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZGxlVGltZW91dE9iaiA9IHRoaXMuZW5hYmxlSWRsZVRpbWVvdXQoc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heENvbm5lY3Rpb25BZ2VNcyAhPT0gVU5MSU1JVEVEX0NPTk5FQ1RJT05fQUdFX01TKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBhIHJhbmRvbSBqaXR0ZXIgd2l0aGluIGEgKy8tMTAlIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqaXR0ZXJNYWduaXR1ZGUgPSB0aGlzLm1heENvbm5lY3Rpb25BZ2VNcyAvIDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgaml0dGVyID0gTWF0aC5yYW5kb20oKSAqIGppdHRlck1hZ25pdHVkZSAqIDIgLSBqaXR0ZXJNYWduaXR1ZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQWdlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25DbG9zZWRCeVNlcnZlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnQ29ubmVjdGlvbiBkcm9wcGVkIGJ5IG1heCBjb25uZWN0aW9uIGFnZTogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2IgPSBzZXNzaW9uLnNvY2tldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlbW90ZUFkZHJlc3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmdvYXdheShodHRwMi5jb25zdGFudHMuTkdIVFRQMl9OT19FUlJPUiwgfigxIDw8IDMxKSwga01heEFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBnb2F3YXkgY2FuJ3QgYmUgc2VudCBiZWNhdXNlIHRoZSBzZXNzaW9uIGlzIGFscmVhZHkgY2xvc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBBbGxvdyBhIGdyYWNlIHBlcmlvZCBhZnRlciBzZW5kaW5nIHRoZSBHT0FXQVkgYmVmb3JlIGZvcmNpYmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogY2xvc2luZyB0aGUgY29ubmVjdGlvbi4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhDb25uZWN0aW9uQWdlR3JhY2VNcyAhPT0gVU5MSU1JVEVEX0NPTk5FQ1RJT05fQUdFX01TKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25BZ2VHcmFjZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5tYXhDb25uZWN0aW9uQWdlR3JhY2VNcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYyA9IGNvbm5lY3Rpb25BZ2VHcmFjZVRpbWVyLnVucmVmKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChjb25uZWN0aW9uQWdlR3JhY2VUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5tYXhDb25uZWN0aW9uQWdlTXMgKyBqaXR0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9jID0gY29ubmVjdGlvbkFnZVRpbWVyLnVucmVmKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChjb25uZWN0aW9uQWdlVGltZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFyS2VlcGFsaXZlVGltZW91dCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZWVwYWxpdmVUaW1lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChrZWVwYWxpdmVUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2VlcGFsaXZlVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW5TZW5kUGluZyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoIXNlc3Npb24uZGVzdHJveWVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lTXMgPCBLRUVQQUxJVkVfTUFYX1RJTUVfTVMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVNcyA+IDApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0ICovXG4gICAgICAgICAgICAgICAgICAgIGxldCBzZW5kUGluZzsgLy8gaG9pc3RlZCBmb3IgdXNlIGluIG1heWJlU3RhcnRLZWVwYWxpdmVQaW5nVGltZXJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF5YmVTdGFydEtlZXBhbGl2ZVBpbmdUaW1lciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuU2VuZFBpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1N0YXJ0aW5nIGtlZXBhbGl2ZSB0aW1lciBmb3IgJyArIHRoaXMua2VlcGFsaXZlVGltZU1zICsgJ21zJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZWVwYWxpdmVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyS2VlcGFsaXZlVGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRQaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLmtlZXBhbGl2ZVRpbWVNcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2IgPSBrZWVwYWxpdmVUaW1lci51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoa2VlcGFsaXZlVGltZXIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzZW5kUGluZyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuU2VuZFBpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1NlbmRpbmcgcGluZyB3aXRoIHRpbWVvdXQgJyArIHRoaXMua2VlcGFsaXZlVGltZW91dE1zICsgJ21zJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGluZ1NlbmRFcnJvciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwaW5nU2VudFN1Y2Nlc3NmdWxseSA9IHNlc3Npb24ucGluZygoZXJyLCBkdXJhdGlvbiwgcGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhcktlZXBhbGl2ZVRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnUGluZyBmYWlsZWQgd2l0aCBlcnJvcjogJyArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25DbG9zZWRCeVNlcnZlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdSZWNlaXZlZCBwaW5nIHJlc3BvbnNlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXliZVN0YXJ0S2VlcGFsaXZlUGluZ1RpbWVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBpbmdTZW50U3VjY2Vzc2Z1bGx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpbmdTZW5kRXJyb3IgPSAnUGluZyByZXR1cm5lZCBmYWxzZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBncnBjL2dycGMtbm9kZSMyMTM5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGluZ1NlbmRFcnJvciA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiAnJykgfHwgJ1Vua25vd24gZXJyb3InO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBpbmdTZW5kRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdQaW5nIHNlbmQgZmFpbGVkOiAnICsgcGluZ1NlbmRFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnQ29ubmVjdGlvbiBkcm9wcGVkIGR1ZSB0byBwaW5nIHNlbmQgZXJyb3I6ICcgKyBwaW5nU2VuZEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uQ2xvc2VkQnlTZXJ2ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBrZWVwYWxpdmVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyS2VlcGFsaXZlVGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1BpbmcgdGltZW91dCBwYXNzZWQgd2l0aG91dCByZXNwb25zZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0Nvbm5lY3Rpb24gZHJvcHBlZCBieSBrZWVwYWxpdmUgdGltZW91dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25DbG9zZWRCeVNlcnZlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5rZWVwYWxpdmVUaW1lb3V0TXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0ga2VlcGFsaXZlVGltZXIudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGtlZXBhbGl2ZVRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVTdGFydEtlZXBhbGl2ZVBpbmdUaW1lcigpO1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYiwgX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb25DbG9zZWRCeVNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoYENvbm5lY3Rpb24gZHJvcHBlZCBieSBjbGllbnQgJHsoX2IgPSBzZXNzaW9uLnNvY2tldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlbW90ZUFkZHJlc3N9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbkFnZVRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb25BZ2VUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbkFnZUdyYWNlVGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoY29ubmVjdGlvbkFnZUdyYWNlVGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJLZWVwYWxpdmVUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWRsZVRpbWVvdXRPYmogIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaWRsZVRpbWVvdXRPYmoudGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uSWRsZVRpbWVvdXRzLmRlbGV0ZShzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIChfYyA9IHRoaXMuaHR0cDJTZXJ2ZXJzLmdldChodHRwMlNlcnZlcikpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zZXNzaW9ucy5kZWxldGUoc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfY2hhbm5lbHpTZXNzaW9uSGFuZGxlcihodHRwMlNlcnZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoc2Vzc2lvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWx6UmVmID0gKDAsIGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselNvY2tldCkoKF9jID0gKF9iID0gc2Vzc2lvbi5zb2NrZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZW1vdGVBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAndW5rbm93bicsIHRoaXMuZ2V0Q2hhbm5lbHpTZXNzaW9uSW5mby5iaW5kKHRoaXMsIHNlc3Npb24pLCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWx6U2Vzc2lvbkluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWY6IGNoYW5uZWx6UmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtVHJhY2tlcjogbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNTZW50OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNSZWNlaXZlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBBbGl2ZXNTZW50OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgKF9kID0gdGhpcy5odHRwMlNlcnZlcnMuZ2V0KGh0dHAyU2VydmVyKSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnNlc3Npb25zLmFkZChzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9ucy5zZXQoc2Vzc2lvbiwgY2hhbm5lbHpTZXNzaW9uSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudEFkZHJlc3MgPSBgJHtzZXNzaW9uLnNvY2tldC5yZW1vdGVBZGRyZXNzfToke3Nlc3Npb24uc29ja2V0LnJlbW90ZVBvcnR9YDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0Nvbm5lY3Rpb24gZXN0YWJsaXNoZWQgYnkgY2xpZW50ICcgKyBjbGllbnRBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnQ29ubmVjdGlvbiBlc3RhYmxpc2hlZCBieSBjbGllbnQgJyArIGNsaWVudEFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25DaGlsZHJlblRyYWNrZXIucmVmQ2hpbGQoY2hhbm5lbHpSZWYpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29ubmVjdGlvbkFnZVRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbm5lY3Rpb25BZ2VHcmFjZVRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGtlZXBhbGl2ZVRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2Vzc2lvbkNsb3NlZEJ5U2VydmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkbGVUaW1lb3V0T2JqID0gdGhpcy5lbmFibGVJZGxlVGltZW91dChzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4Q29ubmVjdGlvbkFnZU1zICE9PSBVTkxJTUlURURfQ09OTkVDVElPTl9BR0VfTVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGEgcmFuZG9tIGppdHRlciB3aXRoaW4gYSArLy0xMCUgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGppdHRlck1hZ25pdHVkZSA9IHRoaXMubWF4Q29ubmVjdGlvbkFnZU1zIC8gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqaXR0ZXIgPSBNYXRoLnJhbmRvbSgpICogaml0dGVyTWFnbml0dWRlICogMiAtIGppdHRlck1hZ25pdHVkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25BZ2VUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uQ2xvc2VkQnlTZXJ2ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDb25uZWN0aW9uIGRyb3BwZWQgYnkgbWF4IGNvbm5lY3Rpb24gYWdlIGZyb20gJyArIGNsaWVudEFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uZ29hd2F5KGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX05PX0VSUk9SLCB+KDEgPDwgMzEpLCBrTWF4QWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGdvYXdheSBjYW4ndCBiZSBzZW50IGJlY2F1c2UgdGhlIHNlc3Npb24gaXMgYWxyZWFkeSBjbG9zZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEFsbG93IGEgZ3JhY2UgcGVyaW9kIGFmdGVyIHNlbmRpbmcgdGhlIEdPQVdBWSBiZWZvcmUgZm9yY2libHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBjbG9zaW5nIHRoZSBjb25uZWN0aW9uLiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heENvbm5lY3Rpb25BZ2VHcmFjZU1zICE9PSBVTkxJTUlURURfQ09OTkVDVElPTl9BR0VfTVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkFnZUdyYWNlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm1heENvbm5lY3Rpb25BZ2VHcmFjZU1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gY29ubmVjdGlvbkFnZUdyYWNlVGltZXIudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGNvbm5lY3Rpb25BZ2VHcmFjZVRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm1heENvbm5lY3Rpb25BZ2VNcyArIGppdHRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2UgPSBjb25uZWN0aW9uQWdlVGltZXIudW5yZWYpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKGNvbm5lY3Rpb25BZ2VUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xlYXJLZWVwYWxpdmVUaW1lb3V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtlZXBhbGl2ZVRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoa2VlcGFsaXZlVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2VlcGFsaXZlVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhblNlbmRQaW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICghc2Vzc2lvbi5kZXN0cm95ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVNcyA8IEtFRVBBTElWRV9NQVhfVElNRV9NUyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZU1zID4gMCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3QgKi9cbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlbmRQaW5nOyAvLyBob2lzdGVkIGZvciB1c2UgaW4gbWF5YmVTdGFydEtlZXBhbGl2ZVBpbmdUaW1lclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXliZVN0YXJ0S2VlcGFsaXZlUGluZ1RpbWVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5TZW5kUGluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnU3RhcnRpbmcga2VlcGFsaXZlIHRpbWVyIGZvciAnICsgdGhpcy5rZWVwYWxpdmVUaW1lTXMgKyAnbXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBhbGl2ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhcktlZXBhbGl2ZVRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kUGluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5rZWVwYWxpdmVUaW1lTXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0ga2VlcGFsaXZlVGltZW91dC51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoa2VlcGFsaXZlVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNlbmRQaW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5TZW5kUGluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnU2VuZGluZyBwaW5nIHdpdGggdGltZW91dCAnICsgdGhpcy5rZWVwYWxpdmVUaW1lb3V0TXMgKyAnbXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwaW5nU2VuZEVycm9yID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpbmdTZW50U3VjY2Vzc2Z1bGx5ID0gc2Vzc2lvbi5waW5nKChlcnIsIGR1cmF0aW9uLCBwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyS2VlcGFsaXZlVGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdQaW5nIGZhaWxlZCB3aXRoIGVycm9yOiAnICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0Nvbm5lY3Rpb24gZHJvcHBlZCBkdWUgdG8gZXJyb3Igb2YgYSBwaW5nIGZyYW1lICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHJldHVybiBpbiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uQ2xvc2VkQnlTZXJ2ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnUmVjZWl2ZWQgcGluZyByZXNwb25zZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVTdGFydEtlZXBhbGl2ZVBpbmdUaW1lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwaW5nU2VudFN1Y2Nlc3NmdWxseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaW5nU2VuZEVycm9yID0gJ1BpbmcgcmV0dXJuZWQgZmFsc2UnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ3JwYy9ncnBjLW5vZGUjMjEzOVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpbmdTZW5kRXJyb3IgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogJycpIHx8ICdVbmtub3duIGVycm9yJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwaW5nU2VuZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnUGluZyBzZW5kIGZhaWxlZDogJyArIHBpbmdTZW5kRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDb25uZWN0aW9uIGRyb3BwZWQgZHVlIHRvIHBpbmcgc2VuZCBlcnJvcjogJyArIHBpbmdTZW5kRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25DbG9zZWRCeVNlcnZlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8ua2VlcEFsaXZlc1NlbnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBhbGl2ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhcktlZXBhbGl2ZVRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdQaW5nIHRpbWVvdXQgcGFzc2VkIHdpdGhvdXQgcmVzcG9uc2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQ29ubmVjdGlvbiBkcm9wcGVkIGJ5IGtlZXBhbGl2ZSB0aW1lb3V0IGZyb20gJyArIGNsaWVudEFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25DbG9zZWRCeVNlcnZlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5rZWVwYWxpdmVUaW1lb3V0TXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0ga2VlcGFsaXZlVGltZW91dC51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoa2VlcGFsaXZlVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG1heWJlU3RhcnRLZWVwYWxpdmVQaW5nVGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb25DbG9zZWRCeVNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDb25uZWN0aW9uIGRyb3BwZWQgYnkgY2xpZW50ICcgKyBjbGllbnRBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbkNoaWxkcmVuVHJhY2tlci51bnJlZkNoaWxkKGNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikoY2hhbm5lbHpSZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb25BZ2VUaW1lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0aW9uQWdlVGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb25BZ2VHcmFjZVRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb25BZ2VHcmFjZVRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyS2VlcGFsaXZlVGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkbGVUaW1lb3V0T2JqICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGlkbGVUaW1lb3V0T2JqLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbklkbGVUaW1lb3V0cy5kZWxldGUoc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLmh0dHAyU2VydmVycy5nZXQoaHR0cDJTZXJ2ZXIpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2Vzc2lvbnMuZGVsZXRlKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9ucy5kZWxldGUoc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmFibGVJZGxlVGltZW91dChzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iLCBfYztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXNzaW9uSWRsZVRpbWVvdXQgPj0gTUFYX0NPTk5FQ1RJT05fSURMRV9NUykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaWRsZVRpbWVvdXRPYmogPSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbXM6IDAsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RJZGxlOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgICAgICBvbkNsb3NlOiB0aGlzLm9uU3RyZWFtQ2xvc2UuYmluZCh0aGlzLCBzZXNzaW9uKSxcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dDogc2V0VGltZW91dCh0aGlzLm9uSWRsZVRpbWVvdXQsIHRoaXMuc2Vzc2lvbklkbGVUaW1lb3V0LCB0aGlzLCBzZXNzaW9uKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIChfYyA9IChfYiA9IGlkbGVUaW1lb3V0T2JqLnRpbWVvdXQpLnVucmVmKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYik7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uSWRsZVRpbWVvdXRzLnNldChzZXNzaW9uLCBpZGxlVGltZW91dE9iaik7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzb2NrZXQgfSA9IHNlc3Npb247XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnRW5hYmxlIGlkbGUgdGltZW91dCBmb3IgJyArXG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdGVBZGRyZXNzICtcbiAgICAgICAgICAgICAgICAgICAgJzonICtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW90ZVBvcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpZGxlVGltZW91dE9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uSWRsZVRpbWVvdXQoY3R4LCBzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzb2NrZXQgfSA9IHNlc3Npb247XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbkluZm8gPSBjdHguc2Vzc2lvbklkbGVUaW1lb3V0cy5nZXQoc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgaXMgY2FsbGVkIHdoaWxlIHdlIGhhdmUgYWN0aXZlU3RyZWFtcyAtIHRpbWVyIHdpbGwgbm90IGJlIHJlc2NoZWR1bGVkXG4gICAgICAgICAgICAgICAgLy8gdW50aWwgbGFzdCBhY3RpdmUgc3RyZWFtIGlzIGNsb3NlZCwgdGhlbiBpdCB3aWxsIGNhbGwgLnJlZnJlc2goKSBvbiB0aGUgdGltZXJcbiAgICAgICAgICAgICAgICAvLyBpbXBvcnRhbnQgcGFydCBpcyB0byBub3QgY2xlYXJUaW1lb3V0KHRpbWVyKSBvciBpdCBiZWNvbWVzIHVudXNhYmxlXG4gICAgICAgICAgICAgICAgLy8gZm9yIGZ1dHVyZSByZWZyZXNoZXNcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkluZm8gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSW5mby5hY3RpdmVTdHJlYW1zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gc2Vzc2lvbkluZm8ubGFzdElkbGUgPj0gY3R4LnNlc3Npb25JZGxlVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYWNlKCdTZXNzaW9uIGlkbGUgdGltZW91dCB0cmlnZ2VyZWQgZm9yICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzb2NrZXQgPT09IG51bGwgfHwgc29ja2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb2NrZXQucmVtb3RlQWRkcmVzcykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc6JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNvY2tldCA9PT0gbnVsbCB8fCBzb2NrZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvY2tldC5yZW1vdGVQb3J0KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBsYXN0IGlkbGUgYXQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbkluZm8ubGFzdElkbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JbmZvLnRpbWVvdXQucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25TdHJlYW1PcGVuZWQoc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHN0cmVhbS5zZXNzaW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkbGVUaW1lb3V0T2JqID0gdGhpcy5zZXNzaW9uSWRsZVRpbWVvdXRzLmdldChzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoaWRsZVRpbWVvdXRPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgaWRsZVRpbWVvdXRPYmouYWN0aXZlU3RyZWFtcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ub25jZSgnY2xvc2UnLCBpZGxlVGltZW91dE9iai5vbkNsb3NlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvblN0cmVhbUNsb3NlKHNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgX2IsIF9jO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkbGVUaW1lb3V0T2JqID0gdGhpcy5zZXNzaW9uSWRsZVRpbWVvdXRzLmdldChzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoaWRsZVRpbWVvdXRPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgaWRsZVRpbWVvdXRPYmouYWN0aXZlU3RyZWFtcyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWRsZVRpbWVvdXRPYmouYWN0aXZlU3RyZWFtcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRsZVRpbWVvdXRPYmoubGFzdElkbGUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRsZVRpbWVvdXRPYmoudGltZW91dC5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdTZXNzaW9uIG9uU3RyZWFtQ2xvc2UnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9iID0gc2Vzc2lvbi5zb2NrZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZW1vdGVBZGRyZXNzKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzonICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9jID0gc2Vzc2lvbi5zb2NrZXQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZW1vdGVQb3J0KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBhdCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGxlVGltZW91dE9iai5sYXN0SWRsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBfbWV0YWRhdGEgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLm1ldGFkYXRhID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIF9zdGFydF9kZWNvcmF0b3JzID0gW2RlcHJlY2F0ZSgnQ2FsbGluZyBzdGFydCgpIGlzIG5vIGxvbmdlciBuZWNlc3NhcnkuIEl0IGNhbiBiZSBzYWZlbHkgb21pdHRlZC4nKV07XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUoX2EsIG51bGwsIF9zdGFydF9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwic3RhcnRcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcInN0YXJ0XCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouc3RhcnQgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBpZiAoX21ldGFkYXRhKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2EsIFN5bWJvbC5tZXRhZGF0YSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogX21ldGFkYXRhIH0pO1xuICAgICAgICB9KSgpLFxuICAgICAgICBfYTtcbn0pKCk7XG5leHBvcnRzLlNlcnZlciA9IFNlcnZlcjtcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVVuYXJ5KGNhbGwsIGhhbmRsZXIpIHtcbiAgICBsZXQgc3RyZWFtO1xuICAgIGZ1bmN0aW9uIHJlc3BvbmQoZXJyLCB2YWx1ZSwgdHJhaWxlciwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY2FsbC5zZW5kU3RhdHVzKCgwLCBzZXJ2ZXJfY2FsbF8xLnNlcnZlckVycm9yVG9TdGF0dXMpKGVyciwgdHJhaWxlcikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhbGwuc2VuZE1lc3NhZ2UodmFsdWUsICgpID0+IHtcbiAgICAgICAgICAgIGNhbGwuc2VuZFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLk9LLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6ICdPSycsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHRyYWlsZXIgIT09IG51bGwgJiYgdHJhaWxlciAhPT0gdm9pZCAwID8gdHJhaWxlciA6IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldCByZXF1ZXN0TWV0YWRhdGE7XG4gICAgbGV0IHJlcXVlc3RNZXNzYWdlID0gbnVsbDtcbiAgICBjYWxsLnN0YXJ0KHtcbiAgICAgICAgb25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHJlcXVlc3RNZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICAgICAgY2FsbC5zdGFydFJlYWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBjYWxsLnNlbmRTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRCxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFJlY2VpdmVkIGEgc2Vjb25kIHJlcXVlc3QgbWVzc2FnZSBmb3Igc2VydmVyIHN0cmVhbWluZyBtZXRob2QgJHtoYW5kbGVyLnBhdGh9YCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdE1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgY2FsbC5zdGFydFJlYWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25SZWNlaXZlSGFsZkNsb3NlKCkge1xuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0TWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGNhbGwuc2VuZFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTklNUExFTUVOVEVELFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgbm8gcmVxdWVzdCBtZXNzYWdlIGZvciBzZXJ2ZXIgc3RyZWFtaW5nIG1ldGhvZCAke2hhbmRsZXIucGF0aH1gLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJlYW0gPSBuZXcgc2VydmVyX2NhbGxfMS5TZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwoaGFuZGxlci5wYXRoLCBjYWxsLCByZXF1ZXN0TWV0YWRhdGEsIHJlcXVlc3RNZXNzYWdlKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5mdW5jKHN0cmVhbSwgcmVzcG9uZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbC5zZW5kU3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV04sXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBTZXJ2ZXIgbWV0aG9kIGhhbmRsZXIgdGhyZXcgZXJyb3IgJHtlcnIubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25DYW5jZWwoKSB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2NhbmNlbGxlZCcsICdjYW5jZWxsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNsaWVudFN0cmVhbWluZyhjYWxsLCBoYW5kbGVyKSB7XG4gICAgbGV0IHN0cmVhbTtcbiAgICBmdW5jdGlvbiByZXNwb25kKGVyciwgdmFsdWUsIHRyYWlsZXIsIGZsYWdzKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGwuc2VuZFN0YXR1cygoMCwgc2VydmVyX2NhbGxfMS5zZXJ2ZXJFcnJvclRvU3RhdHVzKShlcnIsIHRyYWlsZXIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYWxsLnNlbmRNZXNzYWdlKHZhbHVlLCAoKSA9PiB7XG4gICAgICAgICAgICBjYWxsLnNlbmRTdGF0dXMoe1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5PSyxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiAnT0snLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB0cmFpbGVyICE9PSBudWxsICYmIHRyYWlsZXIgIT09IHZvaWQgMCA/IHRyYWlsZXIgOiBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYWxsLnN0YXJ0KHtcbiAgICAgICAgb25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHN0cmVhbSA9IG5ldyBzZXJ2ZXJfY2FsbF8xLlNlcnZlckR1cGxleFN0cmVhbUltcGwoaGFuZGxlci5wYXRoLCBjYWxsLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuZnVuYyhzdHJlYW0sIHJlc3BvbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGwuc2VuZFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgU2VydmVyIG1ldGhvZCBoYW5kbGVyIHRocmV3IGVycm9yICR7ZXJyLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAgICAgc3RyZWFtLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVjZWl2ZUhhbGZDbG9zZSgpIHtcbiAgICAgICAgICAgIHN0cmVhbS5wdXNoKG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBvbkNhbmNlbCgpIHtcbiAgICAgICAgICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0uY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnY2FuY2VsbGVkJywgJ2NhbmNlbGxlZCcpO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVTZXJ2ZXJTdHJlYW1pbmcoY2FsbCwgaGFuZGxlcikge1xuICAgIGxldCBzdHJlYW07XG4gICAgbGV0IHJlcXVlc3RNZXRhZGF0YTtcbiAgICBsZXQgcmVxdWVzdE1lc3NhZ2UgPSBudWxsO1xuICAgIGNhbGwuc3RhcnQoe1xuICAgICAgICBvblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICAgICAgcmVxdWVzdE1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgICAgICBjYWxsLnN0YXJ0UmVhZCgpO1xuICAgICAgICB9LFxuICAgICAgICBvblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0TWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGNhbGwuc2VuZFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTklNUExFTUVOVEVELFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgYSBzZWNvbmQgcmVxdWVzdCBtZXNzYWdlIGZvciBzZXJ2ZXIgc3RyZWFtaW5nIG1ldGhvZCAke2hhbmRsZXIucGF0aH1gLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0TWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBjYWxsLnN0YXJ0UmVhZCgpO1xuICAgICAgICB9LFxuICAgICAgICBvblJlY2VpdmVIYWxmQ2xvc2UoKSB7XG4gICAgICAgICAgICBpZiAoIXJlcXVlc3RNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgY2FsbC5zZW5kU3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOSU1QTEVNRU5URUQsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBubyByZXF1ZXN0IG1lc3NhZ2UgZm9yIHNlcnZlciBzdHJlYW1pbmcgbWV0aG9kICR7aGFuZGxlci5wYXRofWAsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmVhbSA9IG5ldyBzZXJ2ZXJfY2FsbF8xLlNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbChoYW5kbGVyLnBhdGgsIGNhbGwsIHJlcXVlc3RNZXRhZGF0YSwgcmVxdWVzdE1lc3NhZ2UpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmZ1bmMoc3RyZWFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsLnNlbmRTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTixcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFNlcnZlciBtZXRob2QgaGFuZGxlciB0aHJldyBlcnJvciAke2Vyci5tZXNzYWdlfWAsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkNhbmNlbCgpIHtcbiAgICAgICAgICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0uY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnY2FuY2VsbGVkJywgJ2NhbmNlbGxlZCcpO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVCaWRpU3RyZWFtaW5nKGNhbGwsIGhhbmRsZXIpIHtcbiAgICBsZXQgc3RyZWFtO1xuICAgIGNhbGwuc3RhcnQoe1xuICAgICAgICBvblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICAgICAgc3RyZWFtID0gbmV3IHNlcnZlcl9jYWxsXzEuU2VydmVyRHVwbGV4U3RyZWFtSW1wbChoYW5kbGVyLnBhdGgsIGNhbGwsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5mdW5jKHN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbC5zZW5kU3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV04sXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBTZXJ2ZXIgbWV0aG9kIGhhbmRsZXIgdGhyZXcgZXJyb3IgJHtlcnIubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICBzdHJlYW0ucHVzaChtZXNzYWdlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25SZWNlaXZlSGFsZkNsb3NlKCkge1xuICAgICAgICAgICAgc3RyZWFtLnB1c2gobnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2FuY2VsKCkge1xuICAgICAgICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdjYW5jZWxsZWQnLCAnY2FuY2VsbGVkJyk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZlci5qcy5tYXAiXSwibmFtZXMiOlsiX19ydW5Jbml0aWFsaXplcnMiLCJ0aGlzQXJnIiwiaW5pdGlhbGl6ZXJzIiwidmFsdWUiLCJ1c2VWYWx1ZSIsImFyZ3VtZW50cyIsImxlbmd0aCIsImkiLCJjYWxsIiwiX19lc0RlY29yYXRlIiwiY3RvciIsImRlc2NyaXB0b3JJbiIsImRlY29yYXRvcnMiLCJjb250ZXh0SW4iLCJleHRyYUluaXRpYWxpemVycyIsImFjY2VwdCIsImYiLCJUeXBlRXJyb3IiLCJraW5kIiwia2V5IiwidGFyZ2V0IiwicHJvdG90eXBlIiwiZGVzY3JpcHRvciIsIk9iamVjdCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIm5hbWUiLCJfIiwiZG9uZSIsImNvbnRleHQiLCJwIiwiYWNjZXNzIiwiYWRkSW5pdGlhbGl6ZXIiLCJwdXNoIiwicmVzdWx0IiwiZ2V0Iiwic2V0IiwiaW5pdCIsInVuc2hpZnQiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJTZXJ2ZXIiLCJodHRwMiIsInJlcXVpcmUiLCJ1dGlsIiwiY29uc3RhbnRzXzEiLCJzZXJ2ZXJfY2FsbF8xIiwic2VydmVyX2NyZWRlbnRpYWxzXzEiLCJyZXNvbHZlcl8xIiwibG9nZ2luZyIsInN1YmNoYW5uZWxfYWRkcmVzc18xIiwidXJpX3BhcnNlcl8xIiwiY2hhbm5lbHpfMSIsInNlcnZlcl9pbnRlcmNlcHRvcnNfMSIsIlVOTElNSVRFRF9DT05ORUNUSU9OX0FHRV9NUyIsIktFRVBBTElWRV9NQVhfVElNRV9NUyIsIktFRVBBTElWRV9USU1FT1VUX01TIiwiTUFYX0NPTk5FQ1RJT05fSURMRV9NUyIsIkhUVFAyX0hFQURFUl9QQVRIIiwiY29uc3RhbnRzIiwiVFJBQ0VSX05BTUUiLCJrTWF4QWdlIiwiQnVmZmVyIiwiZnJvbSIsInNlcnZlckNhbGxUcmFjZSIsInRleHQiLCJ0cmFjZSIsIkxvZ1ZlcmJvc2l0eSIsIkRFQlVHIiwibm9vcCIsImRlcHJlY2F0ZSIsIm1lc3NhZ2UiLCJnZXRVbmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UiLCJtZXRob2ROYW1lIiwiY29kZSIsIlN0YXR1cyIsIlVOSU1QTEVNRU5URUQiLCJkZXRhaWxzIiwiZ2V0RGVmYXVsdEhhbmRsZXIiLCJoYW5kbGVyVHlwZSIsInVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZSIsImNhbGxiYWNrIiwiZW1pdCIsIkVycm9yIiwiX2EiLCJfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyIsIl9zdGFydF9kZWNvcmF0b3JzIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiX2IiLCJfYyIsIl9kIiwiX2UiLCJfZiIsIl9nIiwiYm91bmRQb3J0cyIsIk1hcCIsImh0dHAyU2VydmVycyIsInNlc3Npb25JZGxlVGltZW91dHMiLCJoYW5kbGVycyIsInNlc3Npb25zIiwic3RhcnRlZCIsInNodXRkb3duIiwic2VydmVyQWRkcmVzc1N0cmluZyIsImNoYW5uZWx6RW5hYmxlZCIsImNoYW5uZWx6VHJhY2UiLCJDaGFubmVselRyYWNlU3R1YiIsImNhbGxUcmFja2VyIiwiQ2hhbm5lbHpDYWxsVHJhY2tlclN0dWIiLCJsaXN0ZW5lckNoaWxkcmVuVHJhY2tlciIsIkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyU3R1YiIsInNlc3Npb25DaGlsZHJlblRyYWNrZXIiLCJDaGFubmVselRyYWNlIiwiQ2hhbm5lbHpDYWxsVHJhY2tlciIsIkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyIiwiY2hhbm5lbHpSZWYiLCJyZWdpc3RlckNoYW5uZWx6U2VydmVyIiwiZ2V0Q2hhbm5lbHpJbmZvIiwiYWRkVHJhY2UiLCJtYXhDb25uZWN0aW9uQWdlTXMiLCJtYXhDb25uZWN0aW9uQWdlR3JhY2VNcyIsImtlZXBhbGl2ZVRpbWVNcyIsImtlZXBhbGl2ZVRpbWVvdXRNcyIsInNlc3Npb25JZGxlVGltZW91dCIsImNvbW1vblNlcnZlck9wdGlvbnMiLCJtYXhTZW5kSGVhZGVyQmxvY2tMZW5ndGgiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwibWF4U2Vzc2lvbk1lbW9yeSIsInNldHRpbmdzIiwibWF4Q29uY3VycmVudFN0cmVhbXMiLCJpbnRlcmNlcHRvcnMiLCJsaXN0ZW5lckNoaWxkcmVuIiwiZ2V0Q2hpbGRMaXN0cyIsInNlc3Npb25DaGlsZHJlbiIsImdldENoYW5uZWx6U2Vzc2lvbkluZm8iLCJzZXNzaW9uIiwic2Vzc2lvbkluZm8iLCJzZXNzaW9uU29ja2V0Iiwic29ja2V0IiwicmVtb3RlQWRkcmVzcyIsInN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3MiLCJyZW1vdGVQb3J0IiwibG9jYWxBZGRyZXNzIiwibG9jYWxQb3J0IiwidGxzSW5mbyIsImVuY3J5cHRlZCIsInRsc1NvY2tldCIsImNpcGhlckluZm8iLCJnZXRDaXBoZXIiLCJjZXJ0aWZpY2F0ZSIsImdldENlcnRpZmljYXRlIiwicGVlckNlcnRpZmljYXRlIiwiZ2V0UGVlckNlcnRpZmljYXRlIiwiY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWUiLCJzdGFuZGFyZE5hbWUiLCJjaXBoZXJTdWl0ZU90aGVyTmFtZSIsImxvY2FsQ2VydGlmaWNhdGUiLCJyYXciLCJyZW1vdGVDZXJ0aWZpY2F0ZSIsInNvY2tldEluZm8iLCJzZWN1cml0eSIsInJlbW90ZU5hbWUiLCJzdHJlYW1zU3RhcnRlZCIsInN0cmVhbVRyYWNrZXIiLCJjYWxsc1N0YXJ0ZWQiLCJzdHJlYW1zU3VjY2VlZGVkIiwiY2FsbHNTdWNjZWVkZWQiLCJzdHJlYW1zRmFpbGVkIiwiY2FsbHNGYWlsZWQiLCJtZXNzYWdlc1NlbnQiLCJtZXNzYWdlc1JlY2VpdmVkIiwia2VlcEFsaXZlc1NlbnQiLCJsYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wIiwibGFzdFJlbW90ZVN0cmVhbUNyZWF0ZWRUaW1lc3RhbXAiLCJsYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXAiLCJsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAiLCJsYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wIiwibG9jYWxGbG93Q29udHJvbFdpbmRvdyIsInN0YXRlIiwibG9jYWxXaW5kb3dTaXplIiwicmVtb3RlRmxvd0NvbnRyb2xXaW5kb3ciLCJyZW1vdGVXaW5kb3dTaXplIiwiaWQiLCJrZWVwYWxpdmVUcmFjZSIsImFkZFByb3RvU2VydmljZSIsImFkZFNlcnZpY2UiLCJzZXJ2aWNlIiwiaW1wbGVtZW50YXRpb24iLCJzZXJ2aWNlS2V5cyIsImtleXMiLCJmb3JFYWNoIiwiYXR0cnMiLCJtZXRob2RUeXBlIiwicmVxdWVzdFN0cmVhbSIsInJlc3BvbnNlU3RyZWFtIiwiaW1wbEZuIiwiaW1wbCIsInVuZGVmaW5lZCIsIm9yaWdpbmFsTmFtZSIsImJpbmQiLCJzdWNjZXNzIiwicmVnaXN0ZXIiLCJwYXRoIiwicmVzcG9uc2VTZXJpYWxpemUiLCJyZXF1ZXN0RGVzZXJpYWxpemUiLCJyZW1vdmVTZXJ2aWNlIiwidW5yZWdpc3RlciIsInBvcnQiLCJjcmVkcyIsImV4cGVyaW1lbnRhbFJlZ2lzdGVyTGlzdGVuZXJUb0NoYW5uZWx6IiwiYm91bmRBZGRyZXNzIiwicmVnaXN0ZXJDaGFubmVselNvY2tldCIsInN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmciLCJleHBlcmltZW50YWxVbnJlZ2lzdGVyTGlzdGVuZXJGcm9tQ2hhbm5lbHoiLCJ1bnJlZ2lzdGVyQ2hhbm5lbHpSZWYiLCJjcmVhdGVIdHRwMlNlcnZlciIsImNyZWRlbnRpYWxzIiwiaHR0cDJTZXJ2ZXIiLCJfaXNTZWN1cmUiLCJjb25zdHJ1Y3Rvck9wdGlvbnMiLCJfZ2V0Q29uc3RydWN0b3JPcHRpb25zIiwiY29udGV4dE9wdGlvbnMiLCJfZ2V0U2VjdXJlQ29udGV4dE9wdGlvbnMiLCJzZWN1cmVTZXJ2ZXJPcHRpb25zIiwiYXNzaWduIiwiZW5hYmxlVHJhY2UiLCJhcmVDcmVkZW50aWFsc1ZhbGlkIiwiY3JlYXRlU2VjdXJlU2VydmVyIiwicHJlcGVuZExpc3RlbmVyIiwiSlNPTiIsInN0cmluZ2lmeSIsImFkZHJlc3MiLCJkZXN0cm95Iiwib24iLCJlIiwiY3JlZHNXYXRjaGVyIiwic2VjdXJlU2VydmVyIiwic2V0U2VjdXJlQ29udGV4dCIsImxvZyIsIkVSUk9SIiwiX2FkZFdhdGNoZXIiLCJfcmVtb3ZlV2F0Y2hlciIsImNyZWF0ZVNlcnZlciIsInNldFRpbWVvdXQiLCJfc2V0dXBIYW5kbGVycyIsIl9nZXRJbnRlcmNlcHRvcnMiLCJiaW5kT25lQWRkcmVzcyIsImJvdW5kUG9ydE9iamVjdCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwib25FcnJvciIsImVyciIsImVycm9yIiwib25jZSIsImxpc3RlbiIsImJvdW5kU3ViY2hhbm5lbEFkZHJlc3MiLCJob3N0IiwicmVmQ2hpbGQiLCJTZXQiLCJvd25zQ2hhbm5lbHpSZWYiLCJsaXN0ZW5pbmdTZXJ2ZXJzIiwiYWRkIiwicmVtb3ZlTGlzdGVuZXIiLCJiaW5kTWFueVBvcnRzIiwiYWRkcmVzc0xpc3QiLCJjb3VudCIsImVycm9ycyIsImlzVGNwU3ViY2hhbm5lbEFkZHJlc3MiLCJmaXJzdEFkZHJlc3NSZXN1bHQiLCJyZXN0QWRkcmVzc1Jlc3VsdCIsInNsaWNlIiwicmVzdEFkZHJlc3NlcyIsIm1hcCIsImFsbCIsImFsbFJlc3VsdHMiLCJmaWx0ZXIiLCJiaW5kQWRkcmVzc0xpc3QiLCJiaW5kUmVzdWx0IiwiSU5GTyIsImVycm9yU3RyaW5nIiwiam9pbiIsInJlc29sdmVQb3J0IiwicmVzb2x2ZXJMaXN0ZW5lciIsIm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24iLCJlbmRwb2ludExpc3QiLCJzZXJ2aWNlQ29uZmlnIiwic2VydmljZUNvbmZpZ0Vycm9yIiwiY29uY2F0IiwiZW5kcG9pbnQiLCJhZGRyZXNzZXMiLCJyZXNvbHZlciIsImNyZWF0ZVJlc29sdmVyIiwidXBkYXRlUmVzb2x1dGlvbiIsImJpbmRQb3J0IiwiY2FuY2VsbGVkIiwiY29tcGxldGVVbmJpbmQiLCJwb3J0TnVtYmVyIiwibm9ybWFsaXplUG9ydCIsImluaXRpYWxQb3J0VXJpIiwicGFyc2VVcmkiLCJwb3J0VXJpIiwibWFwVXJpRGVmYXVsdFNjaGVtZSIsImJpbmRBc3luYyIsIlNlcnZlckNyZWRlbnRpYWxzIiwiZGVmZXJyZWRDYWxsYmFjayIsInByb2Nlc3MiLCJuZXh0VGljayIsInVyaVRvU3RyaW5nIiwiX2VxdWFscyIsImNvbXBsZXRpb25Qcm9taXNlIiwidGhlbiIsInBvcnROdW0iLCJtYXBLZXkiLCJvcmlnaW5hbFVyaSIsInNwbGl0UG9ydCIsInNwbGl0SG9zdFBvcnQiLCJmaW5hbFVyaSIsInNjaGVtZSIsImF1dGhvcml0eSIsImNvbWJpbmVIb3N0UG9ydCIsInJlZ2lzdGVySW5qZWN0b3JUb0NoYW5uZWx6IiwiZXhwZXJpbWVudGFsQ3JlYXRlQ29ubmVjdGlvbkluamVjdG9yV2l0aENoYW5uZWx6UmVmIiwic2VydmVyIiwic2Vzc2lvbnNTZXQiLCJpbmplY3RDb25uZWN0aW9uIiwiY29ubmVjdGlvbiIsImRyYWluIiwiZ3JhY2VUaW1lTXMiLCJjbG9zZVNlc3Npb24iLCJOR0hUVFAyX0NBTkNFTCIsInVucmVmIiwiY2xvc2VTZXJ2ZXIiLCJjcmVhdGVDb25uZWN0aW9uSW5qZWN0b3IiLCJzZXJ2ZXJJbmZvIiwiY2xvc2UiLCJ1bnJlZkNoaWxkIiwiZGVsZXRlIiwiY2xvc2VDYWxsYmFjayIsInJlZiIsImNsb3NlZCIsInF1ZXVlTWljcm90YXNrIiwidW5iaW5kIiwiYWxsU2Vzc2lvbnMiLCJzZXJ2ZXJFbnRyeSIsImZvcmNlU2h1dGRvd24iLCJ2YWx1ZXMiLCJjbGVhciIsImNoYW5uZWx6SW5mbyIsImhhbmRsZXIiLCJzZXJpYWxpemUiLCJkZXNlcmlhbGl6ZSIsInR5cGUiLCJoYXMiLCJmdW5jIiwic3RhcnQiLCJzaXplIiwiZXZlcnkiLCJsaXN0ZW5pbmciLCJ0cnlTaHV0ZG93biIsIndyYXBwZWRDYWxsYmFjayIsInBlbmRpbmdDaGVja3MiLCJtYXliZUNhbGxiYWNrIiwic2VydmVyS2V5IiwiZW50cmllcyIsInNlcnZlclN0cmluZyIsInNlc3Npb25TdHJpbmciLCJhZGRIdHRwMlBvcnQiLCJnZXRDaGFubmVselJlZiIsIl92ZXJpZnlDb250ZW50VHlwZSIsInN0cmVhbSIsImhlYWRlcnMiLCJjb250ZW50VHlwZSIsIkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEUiLCJzdGFydHNXaXRoIiwicmVzcG9uZCIsIkhUVFAyX0hFQURFUl9TVEFUVVMiLCJIVFRQX1NUQVRVU19VTlNVUFBPUlRFRF9NRURJQV9UWVBFIiwiZW5kU3RyZWFtIiwiX3JldHJpZXZlSGFuZGxlciIsIl9yZXNwb25kV2l0aEVycm9yIiwiY2hhbm5lbHpTZXNzaW9uSW5mbyIsInRyYWlsZXJzVG9TZW5kIiwiSU5URVJOQUwiLCJIVFRQX1NUQVRVU19PSyIsIm1ldGFkYXRhIiwidG9IdHRwMkhlYWRlcnMiLCJhZGRDYWxsRmFpbGVkIiwiX2NoYW5uZWx6SGFuZGxlciIsImV4dHJhSW50ZXJjZXB0b3JzIiwib25TdHJlYW1PcGVuZWQiLCJhZGRDYWxsU3RhcnRlZCIsImNhbGxFdmVudFRyYWNrZXIiLCJhZGRNZXNzYWdlU2VudCIsIkRhdGUiLCJhZGRNZXNzYWdlUmVjZWl2ZWQiLCJvbkNhbGxFbmQiLCJzdGF0dXMiLCJPSyIsImFkZENhbGxTdWNjZWVkZWQiLCJvblN0cmVhbUVuZCIsImdldFNlcnZlckludGVyY2VwdGluZ0NhbGwiLCJfcnVuSGFuZGxlckZvckNhbGwiLCJzZW5kU3RhdHVzIiwiX3N0cmVhbUhhbmRsZXIiLCJoYW5kbGVVbmFyeSIsImhhbmRsZUNsaWVudFN0cmVhbWluZyIsImhhbmRsZVNlcnZlclN0cmVhbWluZyIsImhhbmRsZUJpZGlTdHJlYW1pbmciLCJzZXJ2ZXJBZGRyZXNzIiwic2Vzc2lvbkhhbmRsZXIiLCJfY2hhbm5lbHpTZXNzaW9uSGFuZGxlciIsIl9zZXNzaW9uSGFuZGxlciIsImNvbm5lY3Rpb25BZ2VUaW1lciIsImNvbm5lY3Rpb25BZ2VHcmFjZVRpbWVyIiwia2VlcGFsaXZlVGltZXIiLCJzZXNzaW9uQ2xvc2VkQnlTZXJ2ZXIiLCJpZGxlVGltZW91dE9iaiIsImVuYWJsZUlkbGVUaW1lb3V0Iiwiaml0dGVyTWFnbml0dWRlIiwiaml0dGVyIiwiTWF0aCIsInJhbmRvbSIsImdvYXdheSIsIk5HSFRUUDJfTk9fRVJST1IiLCJjbGVhcktlZXBhbGl2ZVRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJjYW5TZW5kUGluZyIsImRlc3Ryb3llZCIsInNlbmRQaW5nIiwibWF5YmVTdGFydEtlZXBhbGl2ZVBpbmdUaW1lciIsInBpbmdTZW5kRXJyb3IiLCJwaW5nU2VudFN1Y2Nlc3NmdWxseSIsInBpbmciLCJkdXJhdGlvbiIsInBheWxvYWQiLCJ0aW1lb3V0IiwiY2xpZW50QWRkcmVzcyIsImtlZXBhbGl2ZVRpbWVvdXQiLCJhY3RpdmVTdHJlYW1zIiwibGFzdElkbGUiLCJub3ciLCJvbkNsb3NlIiwib25TdHJlYW1DbG9zZSIsIm9uSWRsZVRpbWVvdXQiLCJjdHgiLCJyZWZyZXNoIiwiX21ldGFkYXRhIiwiU3ltYm9sIiwiY3JlYXRlIiwic3RhdGljIiwicHJpdmF0ZSIsIm9iaiIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInRyYWlsZXIiLCJmbGFncyIsInNlcnZlckVycm9yVG9TdGF0dXMiLCJzZW5kTWVzc2FnZSIsInJlcXVlc3RNZXRhZGF0YSIsInJlcXVlc3RNZXNzYWdlIiwib25SZWNlaXZlTWV0YWRhdGEiLCJzdGFydFJlYWQiLCJvblJlY2VpdmVNZXNzYWdlIiwib25SZWNlaXZlSGFsZkNsb3NlIiwiU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsIiwiVU5LTk9XTiIsIm9uQ2FuY2VsIiwiU2VydmVyRHVwbGV4U3RyZWFtSW1wbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/service-config.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/service-config.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.validateRetryThrottling = validateRetryThrottling;\nexports.validateServiceConfig = validateServiceConfig;\nexports.extractAndSelectServiceConfig = extractAndSelectServiceConfig;\n/* This file implements gRFC A2 and the service config spec:\n * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md\n * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each\n * function here takes an object with unknown structure and returns its\n * specific object type if the input has the right structure, and throws an\n * error otherwise. */ /* The any type is purposely used here. All functions validate their input at\n * runtime */ /* eslint-disable @typescript-eslint/no-explicit-any */ const os = __webpack_require__(/*! os */ \"os\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\n/**\n * Recognizes a number with up to 9 digits after the decimal point, followed by\n * an \"s\", representing a number of seconds.\n */ const DURATION_REGEX = /^\\d+(\\.\\d{1,9})?s$/;\n/**\n * Client language name used for determining whether this client matches a\n * `ServiceConfigCanaryConfig`'s `clientLanguage` list.\n */ const CLIENT_LANGUAGE_STRING = \"node\";\nfunction validateName(obj) {\n    // In this context, and unset field and '' are considered the same\n    if (\"service\" in obj && obj.service !== \"\") {\n        if (typeof obj.service !== \"string\") {\n            throw new Error(`Invalid method config name: invalid service: expected type string, got ${typeof obj.service}`);\n        }\n        if (\"method\" in obj && obj.method !== \"\") {\n            if (typeof obj.method !== \"string\") {\n                throw new Error(`Invalid method config name: invalid method: expected type string, got ${typeof obj.service}`);\n            }\n            return {\n                service: obj.service,\n                method: obj.method\n            };\n        } else {\n            return {\n                service: obj.service\n            };\n        }\n    } else {\n        if (\"method\" in obj && obj.method !== undefined) {\n            throw new Error(`Invalid method config name: method set with empty or unset service`);\n        }\n        return {};\n    }\n}\nfunction validateRetryPolicy(obj) {\n    if (!(\"maxAttempts\" in obj) || !Number.isInteger(obj.maxAttempts) || obj.maxAttempts < 2) {\n        throw new Error(\"Invalid method config retry policy: maxAttempts must be an integer at least 2\");\n    }\n    if (!(\"initialBackoff\" in obj) || typeof obj.initialBackoff !== \"string\" || !DURATION_REGEX.test(obj.initialBackoff)) {\n        throw new Error(\"Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer or decimal followed by s\");\n    }\n    if (!(\"maxBackoff\" in obj) || typeof obj.maxBackoff !== \"string\" || !DURATION_REGEX.test(obj.maxBackoff)) {\n        throw new Error(\"Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer or decimal followed by s\");\n    }\n    if (!(\"backoffMultiplier\" in obj) || typeof obj.backoffMultiplier !== \"number\" || obj.backoffMultiplier <= 0) {\n        throw new Error(\"Invalid method config retry policy: backoffMultiplier must be a number greater than 0\");\n    }\n    if (!(\"retryableStatusCodes\" in obj && Array.isArray(obj.retryableStatusCodes))) {\n        throw new Error(\"Invalid method config retry policy: retryableStatusCodes is required\");\n    }\n    if (obj.retryableStatusCodes.length === 0) {\n        throw new Error(\"Invalid method config retry policy: retryableStatusCodes must be non-empty\");\n    }\n    for (const value of obj.retryableStatusCodes){\n        if (typeof value === \"number\") {\n            if (!Object.values(constants_1.Status).includes(value)) {\n                throw new Error(\"Invalid method config retry policy: retryableStatusCodes value not in status code range\");\n            }\n        } else if (typeof value === \"string\") {\n            if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {\n                throw new Error(\"Invalid method config retry policy: retryableStatusCodes value not a status code name\");\n            }\n        } else {\n            throw new Error(\"Invalid method config retry policy: retryableStatusCodes value must be a string or number\");\n        }\n    }\n    return {\n        maxAttempts: obj.maxAttempts,\n        initialBackoff: obj.initialBackoff,\n        maxBackoff: obj.maxBackoff,\n        backoffMultiplier: obj.backoffMultiplier,\n        retryableStatusCodes: obj.retryableStatusCodes\n    };\n}\nfunction validateHedgingPolicy(obj) {\n    if (!(\"maxAttempts\" in obj) || !Number.isInteger(obj.maxAttempts) || obj.maxAttempts < 2) {\n        throw new Error(\"Invalid method config hedging policy: maxAttempts must be an integer at least 2\");\n    }\n    if (\"hedgingDelay\" in obj && (typeof obj.hedgingDelay !== \"string\" || !DURATION_REGEX.test(obj.hedgingDelay))) {\n        throw new Error(\"Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s\");\n    }\n    if (\"nonFatalStatusCodes\" in obj && Array.isArray(obj.nonFatalStatusCodes)) {\n        for (const value of obj.nonFatalStatusCodes){\n            if (typeof value === \"number\") {\n                if (!Object.values(constants_1.Status).includes(value)) {\n                    throw new Error(\"Invalid method config hedging policy: nonFatalStatusCodes value not in status code range\");\n                }\n            } else if (typeof value === \"string\") {\n                if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {\n                    throw new Error(\"Invalid method config hedging policy: nonFatalStatusCodes value not a status code name\");\n                }\n            } else {\n                throw new Error(\"Invalid method config hedging policy: nonFatalStatusCodes value must be a string or number\");\n            }\n        }\n    }\n    const result = {\n        maxAttempts: obj.maxAttempts\n    };\n    if (obj.hedgingDelay) {\n        result.hedgingDelay = obj.hedgingDelay;\n    }\n    if (obj.nonFatalStatusCodes) {\n        result.nonFatalStatusCodes = obj.nonFatalStatusCodes;\n    }\n    return result;\n}\nfunction validateMethodConfig(obj) {\n    var _a;\n    const result = {\n        name: []\n    };\n    if (!(\"name\" in obj) || !Array.isArray(obj.name)) {\n        throw new Error(\"Invalid method config: invalid name array\");\n    }\n    for (const name of obj.name){\n        result.name.push(validateName(name));\n    }\n    if (\"waitForReady\" in obj) {\n        if (typeof obj.waitForReady !== \"boolean\") {\n            throw new Error(\"Invalid method config: invalid waitForReady\");\n        }\n        result.waitForReady = obj.waitForReady;\n    }\n    if (\"timeout\" in obj) {\n        if (typeof obj.timeout === \"object\") {\n            if (!(\"seconds\" in obj.timeout) || !(typeof obj.timeout.seconds === \"number\")) {\n                throw new Error(\"Invalid method config: invalid timeout.seconds\");\n            }\n            if (!(\"nanos\" in obj.timeout) || !(typeof obj.timeout.nanos === \"number\")) {\n                throw new Error(\"Invalid method config: invalid timeout.nanos\");\n            }\n            result.timeout = obj.timeout;\n        } else if (typeof obj.timeout === \"string\" && DURATION_REGEX.test(obj.timeout)) {\n            const timeoutParts = obj.timeout.substring(0, obj.timeout.length - 1).split(\".\");\n            result.timeout = {\n                seconds: timeoutParts[0] | 0,\n                nanos: ((_a = timeoutParts[1]) !== null && _a !== void 0 ? _a : 0) | 0\n            };\n        } else {\n            throw new Error(\"Invalid method config: invalid timeout\");\n        }\n    }\n    if (\"maxRequestBytes\" in obj) {\n        if (typeof obj.maxRequestBytes !== \"number\") {\n            throw new Error(\"Invalid method config: invalid maxRequestBytes\");\n        }\n        result.maxRequestBytes = obj.maxRequestBytes;\n    }\n    if (\"maxResponseBytes\" in obj) {\n        if (typeof obj.maxResponseBytes !== \"number\") {\n            throw new Error(\"Invalid method config: invalid maxRequestBytes\");\n        }\n        result.maxResponseBytes = obj.maxResponseBytes;\n    }\n    if (\"retryPolicy\" in obj) {\n        if (\"hedgingPolicy\" in obj) {\n            throw new Error(\"Invalid method config: retryPolicy and hedgingPolicy cannot both be specified\");\n        } else {\n            result.retryPolicy = validateRetryPolicy(obj.retryPolicy);\n        }\n    } else if (\"hedgingPolicy\" in obj) {\n        result.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);\n    }\n    return result;\n}\nfunction validateRetryThrottling(obj) {\n    if (!(\"maxTokens\" in obj) || typeof obj.maxTokens !== \"number\" || obj.maxTokens <= 0 || obj.maxTokens > 1000) {\n        throw new Error(\"Invalid retryThrottling: maxTokens must be a number in (0, 1000]\");\n    }\n    if (!(\"tokenRatio\" in obj) || typeof obj.tokenRatio !== \"number\" || obj.tokenRatio <= 0) {\n        throw new Error(\"Invalid retryThrottling: tokenRatio must be a number greater than 0\");\n    }\n    return {\n        maxTokens: +obj.maxTokens.toFixed(3),\n        tokenRatio: +obj.tokenRatio.toFixed(3)\n    };\n}\nfunction validateLoadBalancingConfig(obj) {\n    if (!(typeof obj === \"object\" && obj !== null)) {\n        throw new Error(`Invalid loadBalancingConfig: unexpected type ${typeof obj}`);\n    }\n    const keys = Object.keys(obj);\n    if (keys.length > 1) {\n        throw new Error(`Invalid loadBalancingConfig: unexpected multiple keys ${keys}`);\n    }\n    if (keys.length === 0) {\n        throw new Error(\"Invalid loadBalancingConfig: load balancing policy name required\");\n    }\n    return {\n        [keys[0]]: obj[keys[0]]\n    };\n}\nfunction validateServiceConfig(obj) {\n    const result = {\n        loadBalancingConfig: [],\n        methodConfig: []\n    };\n    if (\"loadBalancingPolicy\" in obj) {\n        if (typeof obj.loadBalancingPolicy === \"string\") {\n            result.loadBalancingPolicy = obj.loadBalancingPolicy;\n        } else {\n            throw new Error(\"Invalid service config: invalid loadBalancingPolicy\");\n        }\n    }\n    if (\"loadBalancingConfig\" in obj) {\n        if (Array.isArray(obj.loadBalancingConfig)) {\n            for (const config of obj.loadBalancingConfig){\n                result.loadBalancingConfig.push(validateLoadBalancingConfig(config));\n            }\n        } else {\n            throw new Error(\"Invalid service config: invalid loadBalancingConfig\");\n        }\n    }\n    if (\"methodConfig\" in obj) {\n        if (Array.isArray(obj.methodConfig)) {\n            for (const methodConfig of obj.methodConfig){\n                result.methodConfig.push(validateMethodConfig(methodConfig));\n            }\n        }\n    }\n    if (\"retryThrottling\" in obj) {\n        result.retryThrottling = validateRetryThrottling(obj.retryThrottling);\n    }\n    // Validate method name uniqueness\n    const seenMethodNames = [];\n    for (const methodConfig of result.methodConfig){\n        for (const name of methodConfig.name){\n            for (const seenName of seenMethodNames){\n                if (name.service === seenName.service && name.method === seenName.method) {\n                    throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);\n                }\n            }\n            seenMethodNames.push(name);\n        }\n    }\n    return result;\n}\nfunction validateCanaryConfig(obj) {\n    if (!(\"serviceConfig\" in obj)) {\n        throw new Error(\"Invalid service config choice: missing service config\");\n    }\n    const result = {\n        serviceConfig: validateServiceConfig(obj.serviceConfig)\n    };\n    if (\"clientLanguage\" in obj) {\n        if (Array.isArray(obj.clientLanguage)) {\n            result.clientLanguage = [];\n            for (const lang of obj.clientLanguage){\n                if (typeof lang === \"string\") {\n                    result.clientLanguage.push(lang);\n                } else {\n                    throw new Error(\"Invalid service config choice: invalid clientLanguage\");\n                }\n            }\n        } else {\n            throw new Error(\"Invalid service config choice: invalid clientLanguage\");\n        }\n    }\n    if (\"clientHostname\" in obj) {\n        if (Array.isArray(obj.clientHostname)) {\n            result.clientHostname = [];\n            for (const lang of obj.clientHostname){\n                if (typeof lang === \"string\") {\n                    result.clientHostname.push(lang);\n                } else {\n                    throw new Error(\"Invalid service config choice: invalid clientHostname\");\n                }\n            }\n        } else {\n            throw new Error(\"Invalid service config choice: invalid clientHostname\");\n        }\n    }\n    if (\"percentage\" in obj) {\n        if (typeof obj.percentage === \"number\" && 0 <= obj.percentage && obj.percentage <= 100) {\n            result.percentage = obj.percentage;\n        } else {\n            throw new Error(\"Invalid service config choice: invalid percentage\");\n        }\n    }\n    // Validate that no unexpected fields are present\n    const allowedFields = [\n        \"clientLanguage\",\n        \"percentage\",\n        \"clientHostname\",\n        \"serviceConfig\"\n    ];\n    for(const field in obj){\n        if (!allowedFields.includes(field)) {\n            throw new Error(`Invalid service config choice: unexpected field ${field}`);\n        }\n    }\n    return result;\n}\nfunction validateAndSelectCanaryConfig(obj, percentage) {\n    if (!Array.isArray(obj)) {\n        throw new Error(\"Invalid service config list\");\n    }\n    for (const config of obj){\n        const validatedConfig = validateCanaryConfig(config);\n        /* For each field, we check if it is present, then only discard the\n         * config if the field value does not match the current client */ if (typeof validatedConfig.percentage === \"number\" && percentage > validatedConfig.percentage) {\n            continue;\n        }\n        if (Array.isArray(validatedConfig.clientHostname)) {\n            let hostnameMatched = false;\n            for (const hostname of validatedConfig.clientHostname){\n                if (hostname === os.hostname()) {\n                    hostnameMatched = true;\n                }\n            }\n            if (!hostnameMatched) {\n                continue;\n            }\n        }\n        if (Array.isArray(validatedConfig.clientLanguage)) {\n            let languageMatched = false;\n            for (const language of validatedConfig.clientLanguage){\n                if (language === CLIENT_LANGUAGE_STRING) {\n                    languageMatched = true;\n                }\n            }\n            if (!languageMatched) {\n                continue;\n            }\n        }\n        return validatedConfig.serviceConfig;\n    }\n    throw new Error(\"No matching service config found\");\n}\n/**\n * Find the \"grpc_config\" record among the TXT records, parse its value as JSON, validate its contents,\n * and select a service config with selection fields that all match this client. Most of these steps\n * can fail with an error; the caller must handle any errors thrown this way.\n * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt\n * @param percentage A number chosen from the range [0, 100) that is used to select which config to use\n * @return The service configuration to use, given the percentage value, or null if the service config\n *     data has a valid format but none of the options match the current client.\n */ function extractAndSelectServiceConfig(txtRecord, percentage) {\n    for (const record of txtRecord){\n        if (record.length > 0 && record[0].startsWith(\"grpc_config=\")) {\n            /* Treat the list of strings in this record as a single string and remove\n             * \"grpc_config=\" from the beginning. The rest should be a JSON string */ const recordString = record.join(\"\").substring(\"grpc_config=\".length);\n            const recordJson = JSON.parse(recordString);\n            return validateAndSelectCanaryConfig(recordJson, percentage);\n        }\n    }\n    return null;\n} //# sourceMappingURL=service-config.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmljZS1jb25maWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELCtCQUErQixHQUFHRTtBQUNsQ0YsNkJBQTZCLEdBQUdHO0FBQ2hDSCxxQ0FBcUMsR0FBR0k7QUFDeEM7Ozs7O29CQUtvQixHQUNwQjtXQUNXLEdBQ1gscURBQXFELEdBQ3JELE1BQU1DLEtBQUtDLG1CQUFPQSxDQUFDLGNBQUk7QUFDdkIsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsOEVBQWE7QUFDekM7OztDQUdDLEdBQ0QsTUFBTUUsaUJBQWlCO0FBQ3ZCOzs7Q0FHQyxHQUNELE1BQU1DLHlCQUF5QjtBQUMvQixTQUFTQyxhQUFhQyxHQUFHO0lBQ3JCLGtFQUFrRTtJQUNsRSxJQUFJLGFBQWFBLE9BQU9BLElBQUlDLE9BQU8sS0FBSyxJQUFJO1FBQ3hDLElBQUksT0FBT0QsSUFBSUMsT0FBTyxLQUFLLFVBQVU7WUFDakMsTUFBTSxJQUFJQyxNQUFNLENBQUMsdUVBQXVFLEVBQUUsT0FBT0YsSUFBSUMsT0FBTyxDQUFDLENBQUM7UUFDbEg7UUFDQSxJQUFJLFlBQVlELE9BQU9BLElBQUlHLE1BQU0sS0FBSyxJQUFJO1lBQ3RDLElBQUksT0FBT0gsSUFBSUcsTUFBTSxLQUFLLFVBQVU7Z0JBQ2hDLE1BQU0sSUFBSUQsTUFBTSxDQUFDLHNFQUFzRSxFQUFFLE9BQU9GLElBQUlDLE9BQU8sQ0FBQyxDQUFDO1lBQ2pIO1lBQ0EsT0FBTztnQkFDSEEsU0FBU0QsSUFBSUMsT0FBTztnQkFDcEJFLFFBQVFILElBQUlHLE1BQU07WUFDdEI7UUFDSixPQUNLO1lBQ0QsT0FBTztnQkFDSEYsU0FBU0QsSUFBSUMsT0FBTztZQUN4QjtRQUNKO0lBQ0osT0FDSztRQUNELElBQUksWUFBWUQsT0FBT0EsSUFBSUcs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WUFBWUYsZ0JBQWdCTCxjQUFjLENBQUU7Z0JBQ25ELElBQUlPLGFBQWFyRSxHQUFHcUUsUUFBUSxJQUFJO29CQUM1QkQsa0JBQWtCO2dCQUN0QjtZQUNKO1lBQ0EsSUFBSSxDQUFDQSxpQkFBaUI7Z0JBQ2xCO1lBQ0o7UUFDSjtRQUNBLElBQUlqRCxNQUFNQyxPQUFPLENBQUMrQyxnQkFBZ0JQLGNBQWMsR0FBRztZQUMvQyxJQUFJVSxrQkFBa0I7WUFDdEIsS0FBSyxNQUFNQyxZQUFZSixnQkFBZ0JQLGNBQWMsQ0FBRTtnQkFDbkQsSUFBSVcsYUFBYW5FLHdCQUF3QjtvQkFDckNrRSxrQkFBa0I7Z0JBQ3RCO1lBQ0o7WUFDQSxJQUFJLENBQUNBLGlCQUFpQjtnQkFDbEI7WUFDSjtRQUNKO1FBQ0EsT0FBT0gsZ0JBQWdCUixhQUFhO0lBQ3hDO0lBQ0EsTUFBTSxJQUFJbkQsTUFBTTtBQUNwQjtBQUNBOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU1QsOEJBQThCeUUsU0FBUyxFQUFFVCxVQUFVO0lBQ3hELEtBQUssTUFBTVUsVUFBVUQsVUFBVztRQUM1QixJQUFJQyxPQUFPbkQsTUFBTSxHQUFHLEtBQUttRCxNQUFNLENBQUMsRUFBRSxDQUFDQyxVQUFVLENBQUMsaUJBQWlCO1lBQzNEO21GQUN1RSxHQUN2RSxNQUFNQyxlQUFlRixPQUFPRyxJQUFJLENBQUMsSUFBSXBDLFNBQVMsQ0FBQyxlQUFlbEIsTUFBTTtZQUNwRSxNQUFNdUQsYUFBYUMsS0FBS0MsS0FBSyxDQUFDSjtZQUM5QixPQUFPVCw4QkFBOEJXLFlBQVlkO1FBQ3JEO0lBQ0o7SUFDQSxPQUFPO0FBQ1gsRUFDQSwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmljZS1jb25maWcuanM/NmM0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZVJldHJ5VGhyb3R0bGluZyA9IHZhbGlkYXRlUmV0cnlUaHJvdHRsaW5nO1xuZXhwb3J0cy52YWxpZGF0ZVNlcnZpY2VDb25maWcgPSB2YWxpZGF0ZVNlcnZpY2VDb25maWc7XG5leHBvcnRzLmV4dHJhY3RBbmRTZWxlY3RTZXJ2aWNlQ29uZmlnID0gZXh0cmFjdEFuZFNlbGVjdFNlcnZpY2VDb25maWc7XG4vKiBUaGlzIGZpbGUgaW1wbGVtZW50cyBnUkZDIEEyIGFuZCB0aGUgc2VydmljZSBjb25maWcgc3BlYzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL3Byb3Bvc2FsL2Jsb2IvbWFzdGVyL0EyLXNlcnZpY2UtY29uZmlncy1pbi1kbnMubWRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMvYmxvYi9tYXN0ZXIvZG9jL3NlcnZpY2VfY29uZmlnLm1kLiBFYWNoXG4gKiBmdW5jdGlvbiBoZXJlIHRha2VzIGFuIG9iamVjdCB3aXRoIHVua25vd24gc3RydWN0dXJlIGFuZCByZXR1cm5zIGl0c1xuICogc3BlY2lmaWMgb2JqZWN0IHR5cGUgaWYgdGhlIGlucHV0IGhhcyB0aGUgcmlnaHQgc3RydWN0dXJlLCBhbmQgdGhyb3dzIGFuXG4gKiBlcnJvciBvdGhlcndpc2UuICovXG4vKiBUaGUgYW55IHR5cGUgaXMgcHVycG9zZWx5IHVzZWQgaGVyZS4gQWxsIGZ1bmN0aW9ucyB2YWxpZGF0ZSB0aGVpciBpbnB1dCBhdFxuICogcnVudGltZSAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbi8qKlxuICogUmVjb2duaXplcyBhIG51bWJlciB3aXRoIHVwIHRvIDkgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LCBmb2xsb3dlZCBieVxuICogYW4gXCJzXCIsIHJlcHJlc2VudGluZyBhIG51bWJlciBvZiBzZWNvbmRzLlxuICovXG5jb25zdCBEVVJBVElPTl9SRUdFWCA9IC9eXFxkKyhcXC5cXGR7MSw5fSk/cyQvO1xuLyoqXG4gKiBDbGllbnQgbGFuZ3VhZ2UgbmFtZSB1c2VkIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoaXMgY2xpZW50IG1hdGNoZXMgYVxuICogYFNlcnZpY2VDb25maWdDYW5hcnlDb25maWdgJ3MgYGNsaWVudExhbmd1YWdlYCBsaXN0LlxuICovXG5jb25zdCBDTElFTlRfTEFOR1VBR0VfU1RSSU5HID0gJ25vZGUnO1xuZnVuY3Rpb24gdmFsaWRhdGVOYW1lKG9iaikge1xuICAgIC8vIEluIHRoaXMgY29udGV4dCwgYW5kIHVuc2V0IGZpZWxkIGFuZCAnJyBhcmUgY29uc2lkZXJlZCB0aGUgc2FtZVxuICAgIGlmICgnc2VydmljZScgaW4gb2JqICYmIG9iai5zZXJ2aWNlICE9PSAnJykge1xuICAgICAgICBpZiAodHlwZW9mIG9iai5zZXJ2aWNlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1ldGhvZCBjb25maWcgbmFtZTogaW52YWxpZCBzZXJ2aWNlOiBleHBlY3RlZCB0eXBlIHN0cmluZywgZ290ICR7dHlwZW9mIG9iai5zZXJ2aWNlfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnbWV0aG9kJyBpbiBvYmogJiYgb2JqLm1ldGhvZCAhPT0gJycpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqLm1ldGhvZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWV0aG9kIGNvbmZpZyBuYW1lOiBpbnZhbGlkIG1ldGhvZDogZXhwZWN0ZWQgdHlwZSBzdHJpbmcsIGdvdCAke3R5cGVvZiBvYmouc2VydmljZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2VydmljZTogb2JqLnNlcnZpY2UsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBvYmoubWV0aG9kLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2VydmljZTogb2JqLnNlcnZpY2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoJ21ldGhvZCcgaW4gb2JqICYmIG9iai5tZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1ldGhvZCBjb25maWcgbmFtZTogbWV0aG9kIHNldCB3aXRoIGVtcHR5IG9yIHVuc2V0IHNlcnZpY2VgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVSZXRyeVBvbGljeShvYmopIHtcbiAgICBpZiAoISgnbWF4QXR0ZW1wdHMnIGluIG9iaikgfHxcbiAgICAgICAgIU51bWJlci5pc0ludGVnZXIob2JqLm1heEF0dGVtcHRzKSB8fFxuICAgICAgICBvYmoubWF4QXR0ZW1wdHMgPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogbWF4QXR0ZW1wdHMgbXVzdCBiZSBhbiBpbnRlZ2VyIGF0IGxlYXN0IDInKTtcbiAgICB9XG4gICAgaWYgKCEoJ2luaXRpYWxCYWNrb2ZmJyBpbiBvYmopIHx8XG4gICAgICAgIHR5cGVvZiBvYmouaW5pdGlhbEJhY2tvZmYgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICFEVVJBVElPTl9SRUdFWC50ZXN0KG9iai5pbml0aWFsQmFja29mZikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiBpbml0aWFsQmFja29mZiBtdXN0IGJlIGEgc3RyaW5nIGNvbnNpc3Rpbmcgb2YgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIGRlY2ltYWwgZm9sbG93ZWQgYnkgcycpO1xuICAgIH1cbiAgICBpZiAoISgnbWF4QmFja29mZicgaW4gb2JqKSB8fFxuICAgICAgICB0eXBlb2Ygb2JqLm1heEJhY2tvZmYgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICFEVVJBVElPTl9SRUdFWC50ZXN0KG9iai5tYXhCYWNrb2ZmKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IG1heEJhY2tvZmYgbXVzdCBiZSBhIHN0cmluZyBjb25zaXN0aW5nIG9mIGEgcG9zaXRpdmUgaW50ZWdlciBvciBkZWNpbWFsIGZvbGxvd2VkIGJ5IHMnKTtcbiAgICB9XG4gICAgaWYgKCEoJ2JhY2tvZmZNdWx0aXBsaWVyJyBpbiBvYmopIHx8XG4gICAgICAgIHR5cGVvZiBvYmouYmFja29mZk11bHRpcGxpZXIgIT09ICdudW1iZXInIHx8XG4gICAgICAgIG9iai5iYWNrb2ZmTXVsdGlwbGllciA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogYmFja29mZk11bHRpcGxpZXIgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMCcpO1xuICAgIH1cbiAgICBpZiAoISgncmV0cnlhYmxlU3RhdHVzQ29kZXMnIGluIG9iaiAmJiBBcnJheS5pc0FycmF5KG9iai5yZXRyeWFibGVTdGF0dXNDb2RlcykpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogcmV0cnlhYmxlU3RhdHVzQ29kZXMgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKG9iai5yZXRyeWFibGVTdGF0dXNDb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiByZXRyeWFibGVTdGF0dXNDb2RlcyBtdXN0IGJlIG5vbi1lbXB0eScpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIG9iai5yZXRyeWFibGVTdGF0dXNDb2Rlcykge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKCFPYmplY3QudmFsdWVzKGNvbnN0YW50c18xLlN0YXR1cykuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiByZXRyeWFibGVTdGF0dXNDb2RlcyB2YWx1ZSBub3QgaW4gc3RhdHVzIGNvZGUgcmFuZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC52YWx1ZXMoY29uc3RhbnRzXzEuU3RhdHVzKS5pbmNsdWRlcyh2YWx1ZS50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogcmV0cnlhYmxlU3RhdHVzQ29kZXMgdmFsdWUgbm90IGEgc3RhdHVzIGNvZGUgbmFtZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiByZXRyeWFibGVTdGF0dXNDb2RlcyB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG1heEF0dGVtcHRzOiBvYmoubWF4QXR0ZW1wdHMsXG4gICAgICAgIGluaXRpYWxCYWNrb2ZmOiBvYmouaW5pdGlhbEJhY2tvZmYsXG4gICAgICAgIG1heEJhY2tvZmY6IG9iai5tYXhCYWNrb2ZmLFxuICAgICAgICBiYWNrb2ZmTXVsdGlwbGllcjogb2JqLmJhY2tvZmZNdWx0aXBsaWVyLFxuICAgICAgICByZXRyeWFibGVTdGF0dXNDb2Rlczogb2JqLnJldHJ5YWJsZVN0YXR1c0NvZGVzLFxuICAgIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUhlZGdpbmdQb2xpY3kob2JqKSB7XG4gICAgaWYgKCEoJ21heEF0dGVtcHRzJyBpbiBvYmopIHx8XG4gICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKG9iai5tYXhBdHRlbXB0cykgfHxcbiAgICAgICAgb2JqLm1heEF0dGVtcHRzIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyBoZWRnaW5nIHBvbGljeTogbWF4QXR0ZW1wdHMgbXVzdCBiZSBhbiBpbnRlZ2VyIGF0IGxlYXN0IDInKTtcbiAgICB9XG4gICAgaWYgKCdoZWRnaW5nRGVsYXknIGluIG9iaiAmJlxuICAgICAgICAodHlwZW9mIG9iai5oZWRnaW5nRGVsYXkgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAhRFVSQVRJT05fUkVHRVgudGVzdChvYmouaGVkZ2luZ0RlbGF5KSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgaGVkZ2luZyBwb2xpY3k6IGhlZGdpbmdEZWxheSBtdXN0IGJlIGEgc3RyaW5nIGNvbnNpc3Rpbmcgb2YgYSBwb3NpdGl2ZSBpbnRlZ2VyIGZvbGxvd2VkIGJ5IHMnKTtcbiAgICB9XG4gICAgaWYgKCdub25GYXRhbFN0YXR1c0NvZGVzJyBpbiBvYmogJiYgQXJyYXkuaXNBcnJheShvYmoubm9uRmF0YWxTdGF0dXNDb2RlcykpIHtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBvYmoubm9uRmF0YWxTdGF0dXNDb2Rlcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC52YWx1ZXMoY29uc3RhbnRzXzEuU3RhdHVzKS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgaGVkZ2luZyBwb2xpY3k6IG5vbkZhdGFsU3RhdHVzQ29kZXMgdmFsdWUgbm90IGluIHN0YXR1cyBjb2RlIHJhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LnZhbHVlcyhjb25zdGFudHNfMS5TdGF0dXMpLmluY2x1ZGVzKHZhbHVlLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIGhlZGdpbmcgcG9saWN5OiBub25GYXRhbFN0YXR1c0NvZGVzIHZhbHVlIG5vdCBhIHN0YXR1cyBjb2RlIG5hbWUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyBoZWRnaW5nIHBvbGljeTogbm9uRmF0YWxTdGF0dXNDb2RlcyB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgbWF4QXR0ZW1wdHM6IG9iai5tYXhBdHRlbXB0cyxcbiAgICB9O1xuICAgIGlmIChvYmouaGVkZ2luZ0RlbGF5KSB7XG4gICAgICAgIHJlc3VsdC5oZWRnaW5nRGVsYXkgPSBvYmouaGVkZ2luZ0RlbGF5O1xuICAgIH1cbiAgICBpZiAob2JqLm5vbkZhdGFsU3RhdHVzQ29kZXMpIHtcbiAgICAgICAgcmVzdWx0Lm5vbkZhdGFsU3RhdHVzQ29kZXMgPSBvYmoubm9uRmF0YWxTdGF0dXNDb2RlcztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kQ29uZmlnKG9iaikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6IFtdLFxuICAgIH07XG4gICAgaWYgKCEoJ25hbWUnIGluIG9iaikgfHwgIUFycmF5LmlzQXJyYXkob2JqLm5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIG5hbWUgYXJyYXknKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIG9iai5uYW1lKSB7XG4gICAgICAgIHJlc3VsdC5uYW1lLnB1c2godmFsaWRhdGVOYW1lKG5hbWUpKTtcbiAgICB9XG4gICAgaWYgKCd3YWl0Rm9yUmVhZHknIGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iai53YWl0Rm9yUmVhZHkgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgd2FpdEZvclJlYWR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LndhaXRGb3JSZWFkeSA9IG9iai53YWl0Rm9yUmVhZHk7XG4gICAgfVxuICAgIGlmICgndGltZW91dCcgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLnRpbWVvdXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoISgnc2Vjb25kcycgaW4gb2JqLnRpbWVvdXQpIHx8XG4gICAgICAgICAgICAgICAgISh0eXBlb2Ygb2JqLnRpbWVvdXQuc2Vjb25kcyA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgdGltZW91dC5zZWNvbmRzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISgnbmFub3MnIGluIG9iai50aW1lb3V0KSB8fFxuICAgICAgICAgICAgICAgICEodHlwZW9mIG9iai50aW1lb3V0Lm5hbm9zID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCB0aW1lb3V0Lm5hbm9zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQudGltZW91dCA9IG9iai50aW1lb3V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmoudGltZW91dCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIERVUkFUSU9OX1JFR0VYLnRlc3Qob2JqLnRpbWVvdXQpKSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0UGFydHMgPSBvYmoudGltZW91dFxuICAgICAgICAgICAgICAgIC5zdWJzdHJpbmcoMCwgb2JqLnRpbWVvdXQubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHJlc3VsdC50aW1lb3V0ID0ge1xuICAgICAgICAgICAgICAgIHNlY29uZHM6IHRpbWVvdXRQYXJ0c1swXSB8IDAsXG4gICAgICAgICAgICAgICAgbmFub3M6ICgoX2EgPSB0aW1lb3V0UGFydHNbMV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApIHwgMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCB0aW1lb3V0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdtYXhSZXF1ZXN0Qnl0ZXMnIGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iai5tYXhSZXF1ZXN0Qnl0ZXMgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCBtYXhSZXF1ZXN0Qnl0ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQubWF4UmVxdWVzdEJ5dGVzID0gb2JqLm1heFJlcXVlc3RCeXRlcztcbiAgICB9XG4gICAgaWYgKCdtYXhSZXNwb25zZUJ5dGVzJyBpbiBvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoubWF4UmVzcG9uc2VCeXRlcyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIG1heFJlcXVlc3RCeXRlcycpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5tYXhSZXNwb25zZUJ5dGVzID0gb2JqLm1heFJlc3BvbnNlQnl0ZXM7XG4gICAgfVxuICAgIGlmICgncmV0cnlQb2xpY3knIGluIG9iaikge1xuICAgICAgICBpZiAoJ2hlZGdpbmdQb2xpY3knIGluIG9iaikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IHJldHJ5UG9saWN5IGFuZCBoZWRnaW5nUG9saWN5IGNhbm5vdCBib3RoIGJlIHNwZWNpZmllZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnJldHJ5UG9saWN5ID0gdmFsaWRhdGVSZXRyeVBvbGljeShvYmoucmV0cnlQb2xpY3kpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCdoZWRnaW5nUG9saWN5JyBpbiBvYmopIHtcbiAgICAgICAgcmVzdWx0LmhlZGdpbmdQb2xpY3kgPSB2YWxpZGF0ZUhlZGdpbmdQb2xpY3kob2JqLmhlZGdpbmdQb2xpY3kpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVSZXRyeVRocm90dGxpbmcob2JqKSB7XG4gICAgaWYgKCEoJ21heFRva2VucycgaW4gb2JqKSB8fFxuICAgICAgICB0eXBlb2Ygb2JqLm1heFRva2VucyAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgb2JqLm1heFRva2VucyA8PSAwIHx8XG4gICAgICAgIG9iai5tYXhUb2tlbnMgPiAxMDAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXRyeVRocm90dGxpbmc6IG1heFRva2VucyBtdXN0IGJlIGEgbnVtYmVyIGluICgwLCAxMDAwXScpO1xuICAgIH1cbiAgICBpZiAoISgndG9rZW5SYXRpbycgaW4gb2JqKSB8fFxuICAgICAgICB0eXBlb2Ygb2JqLnRva2VuUmF0aW8gIT09ICdudW1iZXInIHx8XG4gICAgICAgIG9iai50b2tlblJhdGlvIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJldHJ5VGhyb3R0bGluZzogdG9rZW5SYXRpbyBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG1heFRva2VuczogK29iai5tYXhUb2tlbnMudG9GaXhlZCgzKSxcbiAgICAgICAgdG9rZW5SYXRpbzogK29iai50b2tlblJhdGlvLnRvRml4ZWQoMyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZyhvYmopIHtcbiAgICBpZiAoISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBsb2FkQmFsYW5jaW5nQ29uZmlnOiB1bmV4cGVjdGVkIHR5cGUgJHt0eXBlb2Ygb2JqfWApO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBpZiAoa2V5cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBsb2FkQmFsYW5jaW5nQ29uZmlnOiB1bmV4cGVjdGVkIG11bHRpcGxlIGtleXMgJHtrZXlzfWApO1xuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxvYWRCYWxhbmNpbmdDb25maWc6IGxvYWQgYmFsYW5jaW5nIHBvbGljeSBuYW1lIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIFtrZXlzWzBdXTogb2JqW2tleXNbMF1dLFxuICAgIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVNlcnZpY2VDb25maWcob2JqKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBsb2FkQmFsYW5jaW5nQ29uZmlnOiBbXSxcbiAgICAgICAgbWV0aG9kQ29uZmlnOiBbXSxcbiAgICB9O1xuICAgIGlmICgnbG9hZEJhbGFuY2luZ1BvbGljeScgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLmxvYWRCYWxhbmNpbmdQb2xpY3kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXN1bHQubG9hZEJhbGFuY2luZ1BvbGljeSA9IG9iai5sb2FkQmFsYW5jaW5nUG9saWN5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnOiBpbnZhbGlkIGxvYWRCYWxhbmNpbmdQb2xpY3knKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ2xvYWRCYWxhbmNpbmdDb25maWcnIGluIG9iaikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmoubG9hZEJhbGFuY2luZ0NvbmZpZykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29uZmlnIG9mIG9iai5sb2FkQmFsYW5jaW5nQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmxvYWRCYWxhbmNpbmdDb25maWcucHVzaCh2YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWcoY29uZmlnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWc6IGludmFsaWQgbG9hZEJhbGFuY2luZ0NvbmZpZycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgnbWV0aG9kQ29uZmlnJyBpbiBvYmopIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLm1ldGhvZENvbmZpZykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWV0aG9kQ29uZmlnIG9mIG9iai5tZXRob2RDb25maWcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubWV0aG9kQ29uZmlnLnB1c2godmFsaWRhdGVNZXRob2RDb25maWcobWV0aG9kQ29uZmlnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdyZXRyeVRocm90dGxpbmcnIGluIG9iaikge1xuICAgICAgICByZXN1bHQucmV0cnlUaHJvdHRsaW5nID0gdmFsaWRhdGVSZXRyeVRocm90dGxpbmcob2JqLnJldHJ5VGhyb3R0bGluZyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIG1ldGhvZCBuYW1lIHVuaXF1ZW5lc3NcbiAgICBjb25zdCBzZWVuTWV0aG9kTmFtZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG1ldGhvZENvbmZpZyBvZiByZXN1bHQubWV0aG9kQ29uZmlnKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBtZXRob2RDb25maWcubmFtZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzZWVuTmFtZSBvZiBzZWVuTWV0aG9kTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zZXJ2aWNlID09PSBzZWVuTmFtZS5zZXJ2aWNlICYmXG4gICAgICAgICAgICAgICAgICAgIG5hbWUubWV0aG9kID09PSBzZWVuTmFtZS5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNlcnZpY2UgY29uZmlnOiBkdXBsaWNhdGUgbmFtZSAke25hbWUuc2VydmljZX0vJHtuYW1lLm1ldGhvZH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWVuTWV0aG9kTmFtZXMucHVzaChuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVDYW5hcnlDb25maWcob2JqKSB7XG4gICAgaWYgKCEoJ3NlcnZpY2VDb25maWcnIGluIG9iaikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogbWlzc2luZyBzZXJ2aWNlIGNvbmZpZycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHNlcnZpY2VDb25maWc6IHZhbGlkYXRlU2VydmljZUNvbmZpZyhvYmouc2VydmljZUNvbmZpZyksXG4gICAgfTtcbiAgICBpZiAoJ2NsaWVudExhbmd1YWdlJyBpbiBvYmopIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLmNsaWVudExhbmd1YWdlKSkge1xuICAgICAgICAgICAgcmVzdWx0LmNsaWVudExhbmd1YWdlID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxhbmcgb2Ygb2JqLmNsaWVudExhbmd1YWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY2xpZW50TGFuZ3VhZ2UucHVzaChsYW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBjaG9pY2U6IGludmFsaWQgY2xpZW50TGFuZ3VhZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiBpbnZhbGlkIGNsaWVudExhbmd1YWdlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdjbGllbnRIb3N0bmFtZScgaW4gb2JqKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iai5jbGllbnRIb3N0bmFtZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jbGllbnRIb3N0bmFtZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsYW5nIG9mIG9iai5jbGllbnRIb3N0bmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGFuZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNsaWVudEhvc3RuYW1lLnB1c2gobGFuZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiBpbnZhbGlkIGNsaWVudEhvc3RuYW1lJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBjbGllbnRIb3N0bmFtZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgncGVyY2VudGFnZScgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLnBlcmNlbnRhZ2UgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAwIDw9IG9iai5wZXJjZW50YWdlICYmXG4gICAgICAgICAgICBvYmoucGVyY2VudGFnZSA8PSAxMDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wZXJjZW50YWdlID0gb2JqLnBlcmNlbnRhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiBpbnZhbGlkIHBlcmNlbnRhZ2UnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB0aGF0IG5vIHVuZXhwZWN0ZWQgZmllbGRzIGFyZSBwcmVzZW50XG4gICAgY29uc3QgYWxsb3dlZEZpZWxkcyA9IFtcbiAgICAgICAgJ2NsaWVudExhbmd1YWdlJyxcbiAgICAgICAgJ3BlcmNlbnRhZ2UnLFxuICAgICAgICAnY2xpZW50SG9zdG5hbWUnLFxuICAgICAgICAnc2VydmljZUNvbmZpZycsXG4gICAgXTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIGluIG9iaikge1xuICAgICAgICBpZiAoIWFsbG93ZWRGaWVsZHMuaW5jbHVkZXMoZmllbGQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiB1bmV4cGVjdGVkIGZpZWxkICR7ZmllbGR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQW5kU2VsZWN0Q2FuYXJ5Q29uZmlnKG9iaiwgcGVyY2VudGFnZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBsaXN0Jyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY29uZmlnIG9mIG9iaikge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRDb25maWcgPSB2YWxpZGF0ZUNhbmFyeUNvbmZpZyhjb25maWcpO1xuICAgICAgICAvKiBGb3IgZWFjaCBmaWVsZCwgd2UgY2hlY2sgaWYgaXQgaXMgcHJlc2VudCwgdGhlbiBvbmx5IGRpc2NhcmQgdGhlXG4gICAgICAgICAqIGNvbmZpZyBpZiB0aGUgZmllbGQgdmFsdWUgZG9lcyBub3QgbWF0Y2ggdGhlIGN1cnJlbnQgY2xpZW50ICovXG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdGVkQ29uZmlnLnBlcmNlbnRhZ2UgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICBwZXJjZW50YWdlID4gdmFsaWRhdGVkQ29uZmlnLnBlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbGlkYXRlZENvbmZpZy5jbGllbnRIb3N0bmFtZSkpIHtcbiAgICAgICAgICAgIGxldCBob3N0bmFtZU1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaG9zdG5hbWUgb2YgdmFsaWRhdGVkQ29uZmlnLmNsaWVudEhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhvc3RuYW1lID09PSBvcy5ob3N0bmFtZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RuYW1lTWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFob3N0bmFtZU1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWxpZGF0ZWRDb25maWcuY2xpZW50TGFuZ3VhZ2UpKSB7XG4gICAgICAgICAgICBsZXQgbGFuZ3VhZ2VNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxhbmd1YWdlIG9mIHZhbGlkYXRlZENvbmZpZy5jbGllbnRMYW5ndWFnZSkge1xuICAgICAgICAgICAgICAgIGlmIChsYW5ndWFnZSA9PT0gQ0xJRU5UX0xBTkdVQUdFX1NUUklORykge1xuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZU1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbGFuZ3VhZ2VNYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZENvbmZpZy5zZXJ2aWNlQ29uZmlnO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1hdGNoaW5nIHNlcnZpY2UgY29uZmlnIGZvdW5kJyk7XG59XG4vKipcbiAqIEZpbmQgdGhlIFwiZ3JwY19jb25maWdcIiByZWNvcmQgYW1vbmcgdGhlIFRYVCByZWNvcmRzLCBwYXJzZSBpdHMgdmFsdWUgYXMgSlNPTiwgdmFsaWRhdGUgaXRzIGNvbnRlbnRzLFxuICogYW5kIHNlbGVjdCBhIHNlcnZpY2UgY29uZmlnIHdpdGggc2VsZWN0aW9uIGZpZWxkcyB0aGF0IGFsbCBtYXRjaCB0aGlzIGNsaWVudC4gTW9zdCBvZiB0aGVzZSBzdGVwc1xuICogY2FuIGZhaWwgd2l0aCBhbiBlcnJvcjsgdGhlIGNhbGxlciBtdXN0IGhhbmRsZSBhbnkgZXJyb3JzIHRocm93biB0aGlzIHdheS5cbiAqIEBwYXJhbSB0eHRSZWNvcmQgVGhlIFRYVCByZWNvcmQgYXJyYXkgdGhhdCBpcyBvdXRwdXQgZnJvbSBhIHN1Y2Nlc3NmdWwgY2FsbCB0byBkbnMucmVzb2x2ZVR4dFxuICogQHBhcmFtIHBlcmNlbnRhZ2UgQSBudW1iZXIgY2hvc2VuIGZyb20gdGhlIHJhbmdlIFswLCAxMDApIHRoYXQgaXMgdXNlZCB0byBzZWxlY3Qgd2hpY2ggY29uZmlnIHRvIHVzZVxuICogQHJldHVybiBUaGUgc2VydmljZSBjb25maWd1cmF0aW9uIHRvIHVzZSwgZ2l2ZW4gdGhlIHBlcmNlbnRhZ2UgdmFsdWUsIG9yIG51bGwgaWYgdGhlIHNlcnZpY2UgY29uZmlnXG4gKiAgICAgZGF0YSBoYXMgYSB2YWxpZCBmb3JtYXQgYnV0IG5vbmUgb2YgdGhlIG9wdGlvbnMgbWF0Y2ggdGhlIGN1cnJlbnQgY2xpZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZyh0eHRSZWNvcmQsIHBlcmNlbnRhZ2UpIHtcbiAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiB0eHRSZWNvcmQpIHtcbiAgICAgICAgaWYgKHJlY29yZC5sZW5ndGggPiAwICYmIHJlY29yZFswXS5zdGFydHNXaXRoKCdncnBjX2NvbmZpZz0nKSkge1xuICAgICAgICAgICAgLyogVHJlYXQgdGhlIGxpc3Qgb2Ygc3RyaW5ncyBpbiB0aGlzIHJlY29yZCBhcyBhIHNpbmdsZSBzdHJpbmcgYW5kIHJlbW92ZVxuICAgICAgICAgICAgICogXCJncnBjX2NvbmZpZz1cIiBmcm9tIHRoZSBiZWdpbm5pbmcuIFRoZSByZXN0IHNob3VsZCBiZSBhIEpTT04gc3RyaW5nICovXG4gICAgICAgICAgICBjb25zdCByZWNvcmRTdHJpbmcgPSByZWNvcmQuam9pbignJykuc3Vic3RyaW5nKCdncnBjX2NvbmZpZz0nLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCByZWNvcmRKc29uID0gSlNPTi5wYXJzZShyZWNvcmRTdHJpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlQW5kU2VsZWN0Q2FuYXJ5Q29uZmlnKHJlY29yZEpzb24sIHBlcmNlbnRhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmljZS1jb25maWcuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidmFsaWRhdGVSZXRyeVRocm90dGxpbmciLCJ2YWxpZGF0ZVNlcnZpY2VDb25maWciLCJleHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZyIsIm9zIiwicmVxdWlyZSIsImNvbnN0YW50c18xIiwiRFVSQVRJT05fUkVHRVgiLCJDTElFTlRfTEFOR1VBR0VfU1RSSU5HIiwidmFsaWRhdGVOYW1lIiwib2JqIiwic2VydmljZSIsIkVycm9yIiwibWV0aG9kIiwidW5kZWZpbmVkIiwidmFsaWRhdGVSZXRyeVBvbGljeSIsIk51bWJlciIsImlzSW50ZWdlciIsIm1heEF0dGVtcHRzIiwiaW5pdGlhbEJhY2tvZmYiLCJ0ZXN0IiwibWF4QmFja29mZiIsImJhY2tvZmZNdWx0aXBsaWVyIiwiQXJyYXkiLCJpc0FycmF5IiwicmV0cnlhYmxlU3RhdHVzQ29kZXMiLCJsZW5ndGgiLCJ2YWx1ZXMiLCJTdGF0dXMiLCJpbmNsdWRlcyIsInRvVXBwZXJDYXNlIiwidmFsaWRhdGVIZWRnaW5nUG9saWN5IiwiaGVkZ2luZ0RlbGF5Iiwibm9uRmF0YWxTdGF0dXNDb2RlcyIsInJlc3VsdCIsInZhbGlkYXRlTWV0aG9kQ29uZmlnIiwiX2EiLCJuYW1lIiwicHVzaCIsIndhaXRGb3JSZWFkeSIsInRpbWVvdXQiLCJzZWNvbmRzIiwibmFub3MiLCJ0aW1lb3V0UGFydHMiLCJzdWJzdHJpbmciLCJzcGxpdCIsIm1heFJlcXVlc3RCeXRlcyIsIm1heFJlc3BvbnNlQnl0ZXMiLCJyZXRyeVBvbGljeSIsImhlZGdpbmdQb2xpY3kiLCJtYXhUb2tlbnMiLCJ0b2tlblJhdGlvIiwidG9GaXhlZCIsInZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZyIsImtleXMiLCJsb2FkQmFsYW5jaW5nQ29uZmlnIiwibWV0aG9kQ29uZmlnIiwibG9hZEJhbGFuY2luZ1BvbGljeSIsImNvbmZpZyIsInJldHJ5VGhyb3R0bGluZyIsInNlZW5NZXRob2ROYW1lcyIsInNlZW5OYW1lIiwidmFsaWRhdGVDYW5hcnlDb25maWciLCJzZXJ2aWNlQ29uZmlnIiwiY2xpZW50TGFuZ3VhZ2UiLCJsYW5nIiwiY2xpZW50SG9zdG5hbWUiLCJwZXJjZW50YWdlIiwiYWxsb3dlZEZpZWxkcyIsImZpZWxkIiwidmFsaWRhdGVBbmRTZWxlY3RDYW5hcnlDb25maWciLCJ2YWxpZGF0ZWRDb25maWciLCJob3N0bmFtZU1hdGNoZWQiLCJob3N0bmFtZSIsImxhbmd1YWdlTWF0Y2hlZCIsImxhbmd1YWdlIiwidHh0UmVjb3JkIiwicmVjb3JkIiwic3RhcnRzV2l0aCIsInJlY29yZFN0cmluZyIsImpvaW4iLCJyZWNvcmRKc29uIiwiSlNPTiIsInBhcnNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/service-config.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/status-builder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/status-builder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.StatusBuilder = void 0;\n/**\n * A builder for gRPC status objects.\n */ class StatusBuilder {\n    constructor(){\n        this.code = null;\n        this.details = null;\n        this.metadata = null;\n    }\n    /**\n     * Adds a status code to the builder.\n     */ withCode(code) {\n        this.code = code;\n        return this;\n    }\n    /**\n     * Adds details to the builder.\n     */ withDetails(details) {\n        this.details = details;\n        return this;\n    }\n    /**\n     * Adds metadata to the builder.\n     */ withMetadata(metadata) {\n        this.metadata = metadata;\n        return this;\n    }\n    /**\n     * Builds the status object.\n     */ build() {\n        const status = {};\n        if (this.code !== null) {\n            status.code = this.code;\n        }\n        if (this.details !== null) {\n            status.details = this.details;\n        }\n        if (this.metadata !== null) {\n            status.metadata = this.metadata;\n        }\n        return status;\n    }\n}\nexports.StatusBuilder = StatusBuilder; //# sourceMappingURL=status-builder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RhdHVzLWJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHLEtBQUs7QUFDN0I7O0NBRUMsR0FDRCxNQUFNRTtJQUNGQyxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ3BCO0lBQ0E7O0tBRUMsR0FDREMsU0FBU0gsSUFBSSxFQUFFO1FBQ1gsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1osT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7S0FFQyxHQUNESSxZQUFZSCxPQUFPLEVBQUU7UUFDakIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO1FBQ2YsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7S0FFQyxHQUNESSxhQUFhSCxRQUFRLEVBQUU7UUFDbkIsSUFBSSxDQUFDQSxRQUFRLEdBQUdBO1FBQ2hCLE9BQU8sSUFBSTtJQUNmO0lBQ0E7O0tBRUMsR0FDREksUUFBUTtRQUNKLE1BQU1DLFNBQVMsQ0FBQztRQUNoQixJQUFJLElBQUksQ0FBQ1AsSUFBSSxLQUFLLE1BQU07WUFDcEJPLE9BQU9QLElBQUksR0FBRyxJQUFJLENBQUNBLElBQUk7UUFDM0I7UUFDQSxJQUFJLElBQUksQ0FBQ0MsT0FBTyxLQUFLLE1BQU07WUFDdkJNLE9BQU9OLE9BQU8sR0FBRyxJQUFJLENBQUNBLE9BQU87UUFDakM7UUFDQSxJQUFJLElBQUksQ0FBQ0MsUUFBUSxLQUFLLE1BQU07WUFDeEJLLE9BQU9MLFFBQVEsR0FBRyxJQUFJLENBQUNBLFFBQVE7UUFDbkM7UUFDQSxPQUFPSztJQUNYO0FBQ0o7QUFDQVgscUJBQXFCLEdBQUdFLGVBQ3hCLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1ob3VzaW5nLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdGF0dXMtYnVpbGRlci5qcz9kMjkyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0YXR1c0J1aWxkZXIgPSB2b2lkIDA7XG4vKipcbiAqIEEgYnVpbGRlciBmb3IgZ1JQQyBzdGF0dXMgb2JqZWN0cy5cbiAqL1xuY2xhc3MgU3RhdHVzQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IG51bGw7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc3RhdHVzIGNvZGUgdG8gdGhlIGJ1aWxkZXIuXG4gICAgICovXG4gICAgd2l0aENvZGUoY29kZSkge1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBkZXRhaWxzIHRvIHRoZSBidWlsZGVyLlxuICAgICAqL1xuICAgIHdpdGhEZXRhaWxzKGRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgbWV0YWRhdGEgdG8gdGhlIGJ1aWxkZXIuXG4gICAgICovXG4gICAgd2l0aE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyB0aGUgc3RhdHVzIG9iamVjdC5cbiAgICAgKi9cbiAgICBidWlsZCgpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0ge307XG4gICAgICAgIGlmICh0aGlzLmNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXR1cy5jb2RlID0gdGhpcy5jb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRldGFpbHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXR1cy5kZXRhaWxzID0gdGhpcy5kZXRhaWxzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1ldGFkYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0dXMubWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxufVxuZXhwb3J0cy5TdGF0dXNCdWlsZGVyID0gU3RhdHVzQnVpbGRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXR1cy1idWlsZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlN0YXR1c0J1aWxkZXIiLCJjb25zdHJ1Y3RvciIsImNvZGUiLCJkZXRhaWxzIiwibWV0YWRhdGEiLCJ3aXRoQ29kZSIsIndpdGhEZXRhaWxzIiwid2l0aE1ldGFkYXRhIiwiYnVpbGQiLCJzdGF0dXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/stream-decoder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.StreamDecoder = void 0;\nvar ReadState;\n(function(ReadState) {\n    ReadState[ReadState[\"NO_DATA\"] = 0] = \"NO_DATA\";\n    ReadState[ReadState[\"READING_SIZE\"] = 1] = \"READING_SIZE\";\n    ReadState[ReadState[\"READING_MESSAGE\"] = 2] = \"READING_MESSAGE\";\n})(ReadState || (ReadState = {}));\nclass StreamDecoder {\n    constructor(maxReadMessageLength){\n        this.maxReadMessageLength = maxReadMessageLength;\n        this.readState = ReadState.NO_DATA;\n        this.readCompressFlag = Buffer.alloc(1);\n        this.readPartialSize = Buffer.alloc(4);\n        this.readSizeRemaining = 4;\n        this.readMessageSize = 0;\n        this.readPartialMessage = [];\n        this.readMessageRemaining = 0;\n    }\n    write(data) {\n        let readHead = 0;\n        let toRead;\n        const result = [];\n        while(readHead < data.length){\n            switch(this.readState){\n                case ReadState.NO_DATA:\n                    this.readCompressFlag = data.slice(readHead, readHead + 1);\n                    readHead += 1;\n                    this.readState = ReadState.READING_SIZE;\n                    this.readPartialSize.fill(0);\n                    this.readSizeRemaining = 4;\n                    this.readMessageSize = 0;\n                    this.readMessageRemaining = 0;\n                    this.readPartialMessage = [];\n                    break;\n                case ReadState.READING_SIZE:\n                    toRead = Math.min(data.length - readHead, this.readSizeRemaining);\n                    data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);\n                    this.readSizeRemaining -= toRead;\n                    readHead += toRead;\n                    // readSizeRemaining >=0 here\n                    if (this.readSizeRemaining === 0) {\n                        this.readMessageSize = this.readPartialSize.readUInt32BE(0);\n                        if (this.maxReadMessageLength !== -1 && this.readMessageSize > this.maxReadMessageLength) {\n                            throw new Error(`Received message larger than max (${this.readMessageSize} vs ${this.maxReadMessageLength})`);\n                        }\n                        this.readMessageRemaining = this.readMessageSize;\n                        if (this.readMessageRemaining > 0) {\n                            this.readState = ReadState.READING_MESSAGE;\n                        } else {\n                            const message = Buffer.concat([\n                                this.readCompressFlag,\n                                this.readPartialSize\n                            ], 5);\n                            this.readState = ReadState.NO_DATA;\n                            result.push(message);\n                        }\n                    }\n                    break;\n                case ReadState.READING_MESSAGE:\n                    toRead = Math.min(data.length - readHead, this.readMessageRemaining);\n                    this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\n                    this.readMessageRemaining -= toRead;\n                    readHead += toRead;\n                    // readMessageRemaining >=0 here\n                    if (this.readMessageRemaining === 0) {\n                        // At this point, we have read a full message\n                        const framedMessageBuffers = [\n                            this.readCompressFlag,\n                            this.readPartialSize\n                        ].concat(this.readPartialMessage);\n                        const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);\n                        this.readState = ReadState.NO_DATA;\n                        result.push(framedMessage);\n                    }\n                    break;\n                default:\n                    throw new Error(\"Unexpected read state\");\n            }\n        }\n        return result;\n    }\n}\nexports.StreamDecoder = StreamDecoder; //# sourceMappingURL=stream-decoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RyZWFtLWRlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHLEtBQUs7QUFDN0IsSUFBSUc7QUFDSCxVQUFVQSxTQUFTO0lBQ2hCQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQ3RDQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxlQUFlLEdBQUcsRUFBRSxHQUFHO0lBQzNDQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxrQkFBa0IsR0FBRyxFQUFFLEdBQUc7QUFDbEQsR0FBR0EsYUFBY0EsQ0FBQUEsWUFBWSxDQUFDO0FBQzlCLE1BQU1EO0lBQ0ZFLFlBQVlDLG9CQUFvQixDQUFFO1FBQzlCLElBQUksQ0FBQ0Esb0JBQW9CLEdBQUdBO1FBQzVCLElBQUksQ0FBQ0MsU0FBUyxHQUFHSCxVQUFVSSxPQUFPO1FBQ2xDLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUdDLE9BQU9DLEtBQUssQ0FBQztRQUNyQyxJQUFJLENBQUNDLGVBQWUsR0FBR0YsT0FBT0MsS0FBSyxDQUFDO1FBQ3BDLElBQUksQ0FBQ0UsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDQyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRyxFQUFFO1FBQzVCLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUc7SUFDaEM7SUFDQUMsTUFBTUMsSUFBSSxFQUFFO1FBQ1IsSUFBSUMsV0FBVztRQUNmLElBQUlDO1FBQ0osTUFBTUMsU0FBUyxFQUFFO1FBQ2pCLE1BQU9GLFdBQVdELEtBQUtJLE1BQU0sQ0FBRTtZQUMzQixPQUFRLElBQUksQ0FBQ2YsU0FBUztnQkFDbEIsS0FBS0gsVUFBVUksT0FBTztvQkFDbEIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FB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cy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdHJlYW0tZGVjb2Rlci5qcz82Y2I2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0cmVhbURlY29kZXIgPSB2b2lkIDA7XG52YXIgUmVhZFN0YXRlO1xuKGZ1bmN0aW9uIChSZWFkU3RhdGUpIHtcbiAgICBSZWFkU3RhdGVbUmVhZFN0YXRlW1wiTk9fREFUQVwiXSA9IDBdID0gXCJOT19EQVRBXCI7XG4gICAgUmVhZFN0YXRlW1JlYWRTdGF0ZVtcIlJFQURJTkdfU0laRVwiXSA9IDFdID0gXCJSRUFESU5HX1NJWkVcIjtcbiAgICBSZWFkU3RhdGVbUmVhZFN0YXRlW1wiUkVBRElOR19NRVNTQUdFXCJdID0gMl0gPSBcIlJFQURJTkdfTUVTU0FHRVwiO1xufSkoUmVhZFN0YXRlIHx8IChSZWFkU3RhdGUgPSB7fSkpO1xuY2xhc3MgU3RyZWFtRGVjb2RlciB7XG4gICAgY29uc3RydWN0b3IobWF4UmVhZE1lc3NhZ2VMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5tYXhSZWFkTWVzc2FnZUxlbmd0aCA9IG1heFJlYWRNZXNzYWdlTGVuZ3RoO1xuICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5OT19EQVRBO1xuICAgICAgICB0aGlzLnJlYWRDb21wcmVzc0ZsYWcgPSBCdWZmZXIuYWxsb2MoMSk7XG4gICAgICAgIHRoaXMucmVhZFBhcnRpYWxTaXplID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgICAgICB0aGlzLnJlYWRTaXplUmVtYWluaW5nID0gNDtcbiAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVNpemUgPSAwO1xuICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsTWVzc2FnZSA9IFtdO1xuICAgICAgICB0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nID0gMDtcbiAgICB9XG4gICAgd3JpdGUoZGF0YSkge1xuICAgICAgICBsZXQgcmVhZEhlYWQgPSAwO1xuICAgICAgICBsZXQgdG9SZWFkO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKHJlYWRIZWFkIDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5yZWFkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFJlYWRTdGF0ZS5OT19EQVRBOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRDb21wcmVzc0ZsYWcgPSBkYXRhLnNsaWNlKHJlYWRIZWFkLCByZWFkSGVhZCArIDEpO1xuICAgICAgICAgICAgICAgICAgICByZWFkSGVhZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5SRUFESU5HX1NJWkU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFBhcnRpYWxTaXplLmZpbGwoMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFNpemVSZW1haW5pbmcgPSA0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRNZXNzYWdlU2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsTWVzc2FnZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFJlYWRTdGF0ZS5SRUFESU5HX1NJWkU6XG4gICAgICAgICAgICAgICAgICAgIHRvUmVhZCA9IE1hdGgubWluKGRhdGEubGVuZ3RoIC0gcmVhZEhlYWQsIHRoaXMucmVhZFNpemVSZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmNvcHkodGhpcy5yZWFkUGFydGlhbFNpemUsIDQgLSB0aGlzLnJlYWRTaXplUmVtYWluaW5nLCByZWFkSGVhZCwgcmVhZEhlYWQgKyB0b1JlYWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTaXplUmVtYWluaW5nIC09IHRvUmVhZDtcbiAgICAgICAgICAgICAgICAgICAgcmVhZEhlYWQgKz0gdG9SZWFkO1xuICAgICAgICAgICAgICAgICAgICAvLyByZWFkU2l6ZVJlbWFpbmluZyA+PTAgaGVyZVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkU2l6ZVJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVNpemUgPSB0aGlzLnJlYWRQYXJ0aWFsU2l6ZS5yZWFkVUludDMyQkUoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhSZWFkTWVzc2FnZUxlbmd0aCAhPT0gLTEgJiYgdGhpcy5yZWFkTWVzc2FnZVNpemUgPiB0aGlzLm1heFJlYWRNZXNzYWdlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCBtZXNzYWdlIGxhcmdlciB0aGFuIG1heCAoJHt0aGlzLnJlYWRNZXNzYWdlU2l6ZX0gdnMgJHt0aGlzLm1heFJlYWRNZXNzYWdlTGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgPSB0aGlzLnJlYWRNZXNzYWdlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLlJFQURJTkdfTUVTU0FHRTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBCdWZmZXIuY29uY2F0KFt0aGlzLnJlYWRDb21wcmVzc0ZsYWcsIHRoaXMucmVhZFBhcnRpYWxTaXplXSwgNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuTk9fREFUQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFJlYWRTdGF0ZS5SRUFESU5HX01FU1NBR0U6XG4gICAgICAgICAgICAgICAgICAgIHRvUmVhZCA9IE1hdGgubWluKGRhdGEubGVuZ3RoIC0gcmVhZEhlYWQsIHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsTWVzc2FnZS5wdXNoKGRhdGEuc2xpY2UocmVhZEhlYWQsIHJlYWRIZWFkICsgdG9SZWFkKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgLT0gdG9SZWFkO1xuICAgICAgICAgICAgICAgICAgICByZWFkSGVhZCArPSB0b1JlYWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWRNZXNzYWdlUmVtYWluaW5nID49MCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIHJlYWQgYSBmdWxsIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lZE1lc3NhZ2VCdWZmZXJzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZENvbXByZXNzRmxhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0uY29uY2F0KHRoaXMucmVhZFBhcnRpYWxNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lZE1lc3NhZ2UgPSBCdWZmZXIuY29uY2F0KGZyYW1lZE1lc3NhZ2VCdWZmZXJzLCB0aGlzLnJlYWRNZXNzYWdlU2l6ZSArIDUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuTk9fREFUQTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYW1lZE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCByZWFkIHN0YXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLlN0cmVhbURlY29kZXIgPSBTdHJlYW1EZWNvZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyZWFtLWRlY29kZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU3RyZWFtRGVjb2RlciIsIlJlYWRTdGF0ZSIsImNvbnN0cnVjdG9yIiwibWF4UmVhZE1lc3NhZ2VMZW5ndGgiLCJyZWFkU3RhdGUiLCJOT19EQVRBIiwicmVhZENvbXByZXNzRmxhZyIsIkJ1ZmZlciIsImFsbG9jIiwicmVhZFBhcnRpYWxTaXplIiwicmVhZFNpemVSZW1haW5pbmciLCJyZWFkTWVzc2FnZVNpemUiLCJyZWFkUGFydGlhbE1lc3NhZ2UiLCJyZWFkTWVzc2FnZVJlbWFpbmluZyIsIndyaXRlIiwiZGF0YSIsInJlYWRIZWFkIiwidG9SZWFkIiwicmVzdWx0IiwibGVuZ3RoIiwic2xpY2UiLCJSRUFESU5HX1NJWkUiLCJmaWxsIiwiTWF0aCIsIm1pbiIsImNvcHkiLCJyZWFkVUludDMyQkUiLCJFcnJvciIsIlJFQURJTkdfTUVTU0FHRSIsIm1lc3NhZ2UiLCJjb25jYXQiLCJwdXNoIiwiZnJhbWVkTWVzc2FnZUJ1ZmZlcnMiLCJmcmFtZWRNZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-address.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.EndpointMap = void 0;\nexports.isTcpSubchannelAddress = isTcpSubchannelAddress;\nexports.subchannelAddressEqual = subchannelAddressEqual;\nexports.subchannelAddressToString = subchannelAddressToString;\nexports.stringToSubchannelAddress = stringToSubchannelAddress;\nexports.endpointEqual = endpointEqual;\nexports.endpointToString = endpointToString;\nexports.endpointHasAddress = endpointHasAddress;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nfunction isTcpSubchannelAddress(address) {\n    return \"port\" in address;\n}\nfunction subchannelAddressEqual(address1, address2) {\n    if (!address1 && !address2) {\n        return true;\n    }\n    if (!address1 || !address2) {\n        return false;\n    }\n    if (isTcpSubchannelAddress(address1)) {\n        return isTcpSubchannelAddress(address2) && address1.host === address2.host && address1.port === address2.port;\n    } else {\n        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;\n    }\n}\nfunction subchannelAddressToString(address) {\n    if (isTcpSubchannelAddress(address)) {\n        if ((0, net_1.isIPv6)(address.host)) {\n            return \"[\" + address.host + \"]:\" + address.port;\n        } else {\n            return address.host + \":\" + address.port;\n        }\n    } else {\n        return address.path;\n    }\n}\nconst DEFAULT_PORT = 443;\nfunction stringToSubchannelAddress(addressString, port) {\n    if ((0, net_1.isIP)(addressString)) {\n        return {\n            host: addressString,\n            port: port !== null && port !== void 0 ? port : DEFAULT_PORT\n        };\n    } else {\n        return {\n            path: addressString\n        };\n    }\n}\nfunction endpointEqual(endpoint1, endpoint2) {\n    if (endpoint1.addresses.length !== endpoint2.addresses.length) {\n        return false;\n    }\n    for(let i = 0; i < endpoint1.addresses.length; i++){\n        if (!subchannelAddressEqual(endpoint1.addresses[i], endpoint2.addresses[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction endpointToString(endpoint) {\n    return \"[\" + endpoint.addresses.map(subchannelAddressToString).join(\", \") + \"]\";\n}\nfunction endpointHasAddress(endpoint, expectedAddress) {\n    for (const address of endpoint.addresses){\n        if (subchannelAddressEqual(address, expectedAddress)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction endpointEqualUnordered(endpoint1, endpoint2) {\n    if (endpoint1.addresses.length !== endpoint2.addresses.length) {\n        return false;\n    }\n    for (const address1 of endpoint1.addresses){\n        let matchFound = false;\n        for (const address2 of endpoint2.addresses){\n            if (subchannelAddressEqual(address1, address2)) {\n                matchFound = true;\n                break;\n            }\n        }\n        if (!matchFound) {\n            return false;\n        }\n    }\n    return true;\n}\nclass EndpointMap {\n    constructor(){\n        this.map = new Set();\n    }\n    get size() {\n        return this.map.size;\n    }\n    getForSubchannelAddress(address) {\n        for (const entry of this.map){\n            if (endpointHasAddress(entry.key, address)) {\n                return entry.value;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Delete any entries in this map with keys that are not in endpoints\n     * @param endpoints\n     */ deleteMissing(endpoints) {\n        const removedValues = [];\n        for (const entry of this.map){\n            let foundEntry = false;\n            for (const endpoint of endpoints){\n                if (endpointEqualUnordered(endpoint, entry.key)) {\n                    foundEntry = true;\n                }\n            }\n            if (!foundEntry) {\n                removedValues.push(entry.value);\n                this.map.delete(entry);\n            }\n        }\n        return removedValues;\n    }\n    get(endpoint) {\n        for (const entry of this.map){\n            if (endpointEqualUnordered(endpoint, entry.key)) {\n                return entry.value;\n            }\n        }\n        return undefined;\n    }\n    set(endpoint, mapEntry) {\n        for (const entry of this.map){\n            if (endpointEqualUnordered(endpoint, entry.key)) {\n                entry.value = mapEntry;\n                return;\n            }\n        }\n        this.map.add({\n            key: endpoint,\n            value: mapEntry\n        });\n    }\n    delete(endpoint) {\n        for (const entry of this.map){\n            if (endpointEqualUnordered(endpoint, entry.key)) {\n                this.map.delete(entry);\n                return;\n            }\n        }\n    }\n    has(endpoint) {\n        for (const entry of this.map){\n            if (endpointEqualUnordered(endpoint, entry.key)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    clear() {\n        this.map.clear();\n    }\n    *keys() {\n        for (const entry of this.map){\n            yield entry.key;\n        }\n    }\n    *values() {\n        for (const entry of this.map){\n            yield entry.value;\n        }\n    }\n    *entries() {\n        for (const entry of this.map){\n            yield [\n                entry.key,\n                entry.value\n            ];\n        }\n    }\n}\nexports.EndpointMap = EndpointMap; //# sourceMappingURL=subchannel-address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQkFBbUIsR0FBRyxLQUFLO0FBQzNCQSw4QkFBOEIsR0FBR0c7QUFDakNILDhCQUE4QixHQUFHSTtBQUNqQ0osaUNBQWlDLEdBQUdLO0FBQ3BDTCxpQ0FBaUMsR0FBR007QUFDcENOLHFCQUFxQixHQUFHTztBQUN4QlAsd0JBQXdCLEdBQUdRO0FBQzNCUiwwQkFBMEIsR0FBR1M7QUFDN0IsTUFBTUMsUUFBUUMsbUJBQU9BLENBQUMsZ0JBQUs7QUFDM0IsU0FBU1IsdUJBQXVCUyxPQUFPO0lBQ25DLE9BQU8sVUFBVUE7QUFDckI7QUFDQSxTQUFTUix1QkFBdUJTLFFBQVEsRUFBRUMsUUFBUTtJQUM5QyxJQUFJLENBQUNELFlBQVksQ0FBQ0MsVUFBVTtRQUN4QixPQUFPO0lBQ1g7SUFDQSxJQUFJLENBQUNELFlBQVksQ0FBQ0MsVUFBVTtRQUN4QixPQUFPO0lBQ1g7SUFDQSxJQUFJWCx1QkFBdUJVLFdBQVc7UUFDbEMsT0FBUVYsdUJBQXVCVyxhQUMzQkQsU0FBU0UsSUFBSSxLQUFLRCxTQUFTQyxJQUFJLElBQy9CRixTQUFTRyxJQUFJLEtBQUtGLFNBQVNFLElBQUk7SUFDdkMsT0FDSztRQUNELE9BQU8sQ0FBQ2IsdUJBQXVCVyxhQUFhRCxTQUFTSSxJQUFJLEtBQUtILFNBQVNHLElBQUk7SUFDL0U7QUFDSjtBQUNBLFNBQVNaLDBCQUEwQk8sT0FBTztJQUN0QyxJQUFJVCx1QkFBdUJTLFVBQVU7UUFDakMsSUFBSSxDQUFDLEdBQUdGLE1BQU1RLE1BQU0sRUFBRU4sUUFBUUcsSUFBSSxHQUFHO1lBQ2pDLE9BQU8sTUFBTUgsUUFBUUcsSUFBSSxHQUFHLE9BQU9ILFFBQVFJLElBQUk7UUFD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QVM7UUFDTixLQUFLLE1BQU1oQixTQUFTLElBQUksQ0FBQ1QsR0FBRyxDQUFFO1lBQzFCLE1BQU1TLE1BQU1wQyxLQUFLO1FBQ3JCO0lBQ0o7SUFDQSxDQUFDcUQsVUFBVTtRQUNQLEtBQUssTUFBTWpCLFNBQVMsSUFBSSxDQUFDVCxHQUFHLENBQUU7WUFDMUIsTUFBTTtnQkFBQ1MsTUFBTUMsR0FBRztnQkFBRUQsTUFBTXBDLEtBQUs7YUFBQztRQUNsQztJQUNKO0FBQ0o7QUFDQUQsbUJBQW1CLEdBQUdFLGFBQ3RCLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1ob3VzaW5nLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLWFkZHJlc3MuanM/YmEzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FbmRwb2ludE1hcCA9IHZvaWQgMDtcbmV4cG9ydHMuaXNUY3BTdWJjaGFubmVsQWRkcmVzcyA9IGlzVGNwU3ViY2hhbm5lbEFkZHJlc3M7XG5leHBvcnRzLnN1YmNoYW5uZWxBZGRyZXNzRXF1YWwgPSBzdWJjaGFubmVsQWRkcmVzc0VxdWFsO1xuZXhwb3J0cy5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nID0gc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZztcbmV4cG9ydHMuc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyA9IHN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3M7XG5leHBvcnRzLmVuZHBvaW50RXF1YWwgPSBlbmRwb2ludEVxdWFsO1xuZXhwb3J0cy5lbmRwb2ludFRvU3RyaW5nID0gZW5kcG9pbnRUb1N0cmluZztcbmV4cG9ydHMuZW5kcG9pbnRIYXNBZGRyZXNzID0gZW5kcG9pbnRIYXNBZGRyZXNzO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuZnVuY3Rpb24gaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgcmV0dXJuICdwb3J0JyBpbiBhZGRyZXNzO1xufVxuZnVuY3Rpb24gc3ViY2hhbm5lbEFkZHJlc3NFcXVhbChhZGRyZXNzMSwgYWRkcmVzczIpIHtcbiAgICBpZiAoIWFkZHJlc3MxICYmICFhZGRyZXNzMikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFhZGRyZXNzMSB8fCAhYWRkcmVzczIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzMSkpIHtcbiAgICAgICAgcmV0dXJuIChpc1RjcFN1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3MyKSAmJlxuICAgICAgICAgICAgYWRkcmVzczEuaG9zdCA9PT0gYWRkcmVzczIuaG9zdCAmJlxuICAgICAgICAgICAgYWRkcmVzczEucG9ydCA9PT0gYWRkcmVzczIucG9ydCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gIWlzVGNwU3ViY2hhbm5lbEFkZHJlc3MoYWRkcmVzczIpICYmIGFkZHJlc3MxLnBhdGggPT09IGFkZHJlc3MyLnBhdGg7XG4gICAgfVxufVxuZnVuY3Rpb24gc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyhhZGRyZXNzKSB7XG4gICAgaWYgKGlzVGNwU3ViY2hhbm5lbEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgICAgaWYgKCgwLCBuZXRfMS5pc0lQdjYpKGFkZHJlc3MuaG9zdCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnWycgKyBhZGRyZXNzLmhvc3QgKyAnXTonICsgYWRkcmVzcy5wb3J0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3MuaG9zdCArICc6JyArIGFkZHJlc3MucG9ydDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFkZHJlc3MucGF0aDtcbiAgICB9XG59XG5jb25zdCBERUZBVUxUX1BPUlQgPSA0NDM7XG5mdW5jdGlvbiBzdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3NTdHJpbmcsIHBvcnQpIHtcbiAgICBpZiAoKDAsIG5ldF8xLmlzSVApKGFkZHJlc3NTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBob3N0OiBhZGRyZXNzU3RyaW5nLFxuICAgICAgICAgICAgcG9ydDogcG9ydCAhPT0gbnVsbCAmJiBwb3J0ICE9PSB2b2lkIDAgPyBwb3J0IDogREVGQVVMVF9QT1JULFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdGg6IGFkZHJlc3NTdHJpbmcsXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZW5kcG9pbnRFcXVhbChlbmRwb2ludDEsIGVuZHBvaW50Mikge1xuICAgIGlmIChlbmRwb2ludDEuYWRkcmVzc2VzLmxlbmd0aCAhPT0gZW5kcG9pbnQyLmFkZHJlc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuZHBvaW50MS5hZGRyZXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFzdWJjaGFubmVsQWRkcmVzc0VxdWFsKGVuZHBvaW50MS5hZGRyZXNzZXNbaV0sIGVuZHBvaW50Mi5hZGRyZXNzZXNbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBlbmRwb2ludFRvU3RyaW5nKGVuZHBvaW50KSB7XG4gICAgcmV0dXJuICgnWycgKyBlbmRwb2ludC5hZGRyZXNzZXMubWFwKHN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpLmpvaW4oJywgJykgKyAnXScpO1xufVxuZnVuY3Rpb24gZW5kcG9pbnRIYXNBZGRyZXNzKGVuZHBvaW50LCBleHBlY3RlZEFkZHJlc3MpIHtcbiAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgZW5kcG9pbnQuYWRkcmVzc2VzKSB7XG4gICAgICAgIGlmIChzdWJjaGFubmVsQWRkcmVzc0VxdWFsKGFkZHJlc3MsIGV4cGVjdGVkQWRkcmVzcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGVuZHBvaW50RXF1YWxVbm9yZGVyZWQoZW5kcG9pbnQxLCBlbmRwb2ludDIpIHtcbiAgICBpZiAoZW5kcG9pbnQxLmFkZHJlc3Nlcy5sZW5ndGggIT09IGVuZHBvaW50Mi5hZGRyZXNzZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBhZGRyZXNzMSBvZiBlbmRwb2ludDEuYWRkcmVzc2VzKSB7XG4gICAgICAgIGxldCBtYXRjaEZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgYWRkcmVzczIgb2YgZW5kcG9pbnQyLmFkZHJlc3Nlcykge1xuICAgICAgICAgICAgaWYgKHN1YmNoYW5uZWxBZGRyZXNzRXF1YWwoYWRkcmVzczEsIGFkZHJlc3MyKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbWF0Y2hGb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuY2xhc3MgRW5kcG9pbnRNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5zaXplO1xuICAgIH1cbiAgICBnZXRGb3JTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5tYXApIHtcbiAgICAgICAgICAgIGlmIChlbmRwb2ludEhhc0FkZHJlc3MoZW50cnkua2V5LCBhZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYW55IGVudHJpZXMgaW4gdGhpcyBtYXAgd2l0aCBrZXlzIHRoYXQgYXJlIG5vdCBpbiBlbmRwb2ludHNcbiAgICAgKiBAcGFyYW0gZW5kcG9pbnRzXG4gICAgICovXG4gICAgZGVsZXRlTWlzc2luZyhlbmRwb2ludHMpIHtcbiAgICAgICAgY29uc3QgcmVtb3ZlZFZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMubWFwKSB7XG4gICAgICAgICAgICBsZXQgZm91bmRFbnRyeSA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmRwb2ludCBvZiBlbmRwb2ludHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5kcG9pbnRFcXVhbFVub3JkZXJlZChlbmRwb2ludCwgZW50cnkua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZEVudHJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZvdW5kRW50cnkpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkVmFsdWVzLnB1c2goZW50cnkudmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMubWFwLmRlbGV0ZShlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbW92ZWRWYWx1ZXM7XG4gICAgfVxuICAgIGdldChlbmRwb2ludCkge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMubWFwKSB7XG4gICAgICAgICAgICBpZiAoZW5kcG9pbnRFcXVhbFVub3JkZXJlZChlbmRwb2ludCwgZW50cnkua2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzZXQoZW5kcG9pbnQsIG1hcEVudHJ5KSB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5tYXApIHtcbiAgICAgICAgICAgIGlmIChlbmRwb2ludEVxdWFsVW5vcmRlcmVkKGVuZHBvaW50LCBlbnRyeS5rZXkpKSB7XG4gICAgICAgICAgICAgICAgZW50cnkudmFsdWUgPSBtYXBFbnRyeTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXAuYWRkKHsga2V5OiBlbmRwb2ludCwgdmFsdWU6IG1hcEVudHJ5IH0pO1xuICAgIH1cbiAgICBkZWxldGUoZW5kcG9pbnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLm1hcCkge1xuICAgICAgICAgICAgaWYgKGVuZHBvaW50RXF1YWxVbm9yZGVyZWQoZW5kcG9pbnQsIGVudHJ5LmtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5kZWxldGUoZW50cnkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXMoZW5kcG9pbnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLm1hcCkge1xuICAgICAgICAgICAgaWYgKGVuZHBvaW50RXF1YWxVbm9yZGVyZWQoZW5kcG9pbnQsIGVudHJ5LmtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLm1hcC5jbGVhcigpO1xuICAgIH1cbiAgICAqa2V5cygpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLm1hcCkge1xuICAgICAgICAgICAgeWllbGQgZW50cnkua2V5O1xuICAgICAgICB9XG4gICAgfVxuICAgICp2YWx1ZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5tYXApIHtcbiAgICAgICAgICAgIHlpZWxkIGVudHJ5LnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgICplbnRyaWVzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMubWFwKSB7XG4gICAgICAgICAgICB5aWVsZCBbZW50cnkua2V5LCBlbnRyeS52YWx1ZV07XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkVuZHBvaW50TWFwID0gRW5kcG9pbnRNYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJjaGFubmVsLWFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRW5kcG9pbnRNYXAiLCJpc1RjcFN1YmNoYW5uZWxBZGRyZXNzIiwic3ViY2hhbm5lbEFkZHJlc3NFcXVhbCIsInN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmciLCJzdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzIiwiZW5kcG9pbnRFcXVhbCIsImVuZHBvaW50VG9TdHJpbmciLCJlbmRwb2ludEhhc0FkZHJlc3MiLCJuZXRfMSIsInJlcXVpcmUiLCJhZGRyZXNzIiwiYWRkcmVzczEiLCJhZGRyZXNzMiIsImhvc3QiLCJwb3J0IiwicGF0aCIsImlzSVB2NiIsIkRFRkFVTFRfUE9SVCIsImFkZHJlc3NTdHJpbmciLCJpc0lQIiwiZW5kcG9pbnQxIiwiZW5kcG9pbnQyIiwiYWRkcmVzc2VzIiwibGVuZ3RoIiwiaSIsImVuZHBvaW50IiwibWFwIiwiam9pbiIsImV4cGVjdGVkQWRkcmVzcyIsImVuZHBvaW50RXF1YWxVbm9yZGVyZWQiLCJtYXRjaEZvdW5kIiwiY29uc3RydWN0b3IiLCJTZXQiLCJzaXplIiwiZ2V0Rm9yU3ViY2hhbm5lbEFkZHJlc3MiLCJlbnRyeSIsImtleSIsInVuZGVmaW5lZCIsImRlbGV0ZU1pc3NpbmciLCJlbmRwb2ludHMiLCJyZW1vdmVkVmFsdWVzIiwiZm91bmRFbnRyeSIsInB1c2giLCJkZWxldGUiLCJnZXQiLCJzZXQiLCJtYXBFbnRyeSIsImFkZCIsImhhcyIsImNsZWFyIiwia2V5cyIsInZhbHVlcyIsImVudHJpZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-call.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Http2SubchannelCall = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = \"subchannel_call\";\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */ function getSystemErrorName(errno) {\n    for (const [name, num] of Object.entries(os.constants.errno)){\n        if (num === errno) {\n            return name;\n        }\n    }\n    return \"Unknown system error \" + errno;\n}\nfunction mapHttpStatusCode(code) {\n    const details = `Received HTTP status code ${code}`;\n    let mappedStatusCode;\n    switch(code){\n        // TODO(murgatroid99): handle 100 and 101\n        case 400:\n            mappedStatusCode = constants_1.Status.INTERNAL;\n            break;\n        case 401:\n            mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n            break;\n        case 403:\n            mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n            break;\n        case 404:\n            mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n            break;\n        case 429:\n        case 502:\n        case 503:\n        case 504:\n            mappedStatusCode = constants_1.Status.UNAVAILABLE;\n            break;\n        default:\n            mappedStatusCode = constants_1.Status.UNKNOWN;\n    }\n    return {\n        code: mappedStatusCode,\n        details: details,\n        metadata: new metadata_1.Metadata()\n    };\n}\nclass Http2SubchannelCall {\n    constructor(http2Stream, callEventTracker, listener, transport, callId){\n        var _a;\n        this.http2Stream = http2Stream;\n        this.callEventTracker = callEventTracker;\n        this.listener = listener;\n        this.transport = transport;\n        this.callId = callId;\n        this.isReadFilterPending = false;\n        this.isPushPending = false;\n        this.canPush = false;\n        /**\n         * Indicates that an 'end' event has come from the http2 stream, so there\n         * will be no more data events.\n         */ this.readsClosed = false;\n        this.statusOutput = false;\n        this.unpushedReadMessages = [];\n        // This is populated (non-null) if and only if the call has ended\n        this.finalStatus = null;\n        this.internalError = null;\n        this.serverEndedCall = false;\n        this.connectionDropped = false;\n        const maxReceiveMessageLength = (_a = transport.getOptions()[\"grpc.max_receive_message_length\"]) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        this.decoder = new stream_decoder_1.StreamDecoder(maxReceiveMessageLength);\n        http2Stream.on(\"response\", (headers, flags)=>{\n            let headersString = \"\";\n            for (const header of Object.keys(headers)){\n                headersString += \"\t\t\" + header + \": \" + headers[header] + \"\\n\";\n            }\n            this.trace(\"Received server headers:\\n\" + headersString);\n            this.httpStatusCode = headers[\":status\"];\n            if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n                this.handleTrailers(headers);\n            } else {\n                let metadata;\n                try {\n                    metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n                } catch (error) {\n                    this.endCall({\n                        code: constants_1.Status.UNKNOWN,\n                        details: error.message,\n                        metadata: new metadata_1.Metadata()\n                    });\n                    return;\n                }\n                this.listener.onReceiveMetadata(metadata);\n            }\n        });\n        http2Stream.on(\"trailers\", (headers)=>{\n            this.handleTrailers(headers);\n        });\n        http2Stream.on(\"data\", (data)=>{\n            /* If the status has already been output, allow the http2 stream to\n             * drain without processing the data. */ if (this.statusOutput) {\n                return;\n            }\n            this.trace(\"receive HTTP/2 data frame of length \" + data.length);\n            let messages;\n            try {\n                messages = this.decoder.write(data);\n            } catch (e) {\n                /* Some servers send HTML error pages along with HTTP status codes.\n                 * When the client attempts to parse this as a length-delimited\n                 * message, the parsed message size is greater than the default limit,\n                 * resulting in a message decoding error. In that situation, the HTTP\n                 * error code information is more useful to the user than the\n                 * RESOURCE_EXHAUSTED error is, so we report that instead. Normally,\n                 * we delay processing the HTTP status until after the stream ends, to\n                 * prioritize reporting the gRPC status from trailers if it is present,\n                 * but when there is a message parsing error we end the stream early\n                 * before processing trailers. */ if (this.httpStatusCode !== undefined && this.httpStatusCode !== 200) {\n                    const mappedStatus = mapHttpStatusCode(this.httpStatusCode);\n                    this.cancelWithStatus(mappedStatus.code, mappedStatus.details);\n                } else {\n                    this.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, e.message);\n                }\n                return;\n            }\n            for (const message of messages){\n                this.trace(\"parsed message of length \" + message.length);\n                this.callEventTracker.addMessageReceived();\n                this.tryPush(message);\n            }\n        });\n        http2Stream.on(\"end\", ()=>{\n            this.readsClosed = true;\n            this.maybeOutputStatus();\n        });\n        http2Stream.on(\"close\", ()=>{\n            this.serverEndedCall = true;\n            /* Use process.next tick to ensure that this code happens after any\n             * \"error\" event that may be emitted at about the same time, so that\n             * we can bubble up the error message from that event. */ process.nextTick(()=>{\n                var _a;\n                this.trace(\"HTTP/2 stream closed with code \" + http2Stream.rstCode);\n                /* If we have a final status with an OK status code, that means that\n                 * we have received all of the messages and we have processed the\n                 * trailers and the call completed successfully, so it doesn't matter\n                 * how the stream ends after that */ if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                    return;\n                }\n                let code;\n                let details = \"\";\n                switch(http2Stream.rstCode){\n                    case http2.constants.NGHTTP2_NO_ERROR:\n                        /* If we get a NO_ERROR code and we already have a status, the\n                         * stream completed properly and we just haven't fully processed\n                         * it yet */ if (this.finalStatus !== null) {\n                            return;\n                        }\n                        if (this.httpStatusCode && this.httpStatusCode !== 200) {\n                            const mappedStatus = mapHttpStatusCode(this.httpStatusCode);\n                            code = mappedStatus.code;\n                            details = mappedStatus.details;\n                        } else {\n                            code = constants_1.Status.INTERNAL;\n                            details = `Received RST_STREAM with code ${http2Stream.rstCode} (Call ended without gRPC status)`;\n                        }\n                        break;\n                    case http2.constants.NGHTTP2_REFUSED_STREAM:\n                        code = constants_1.Status.UNAVAILABLE;\n                        details = \"Stream refused by server\";\n                        break;\n                    case http2.constants.NGHTTP2_CANCEL:\n                        /* Bug reports indicate that Node synthesizes a NGHTTP2_CANCEL\n                         * code from connection drops. We want to prioritize reporting\n                         * an unavailable status when that happens. */ if (this.connectionDropped) {\n                            code = constants_1.Status.UNAVAILABLE;\n                            details = \"Connection dropped\";\n                        } else {\n                            code = constants_1.Status.CANCELLED;\n                            details = \"Call cancelled\";\n                        }\n                        break;\n                    case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n                        code = constants_1.Status.RESOURCE_EXHAUSTED;\n                        details = \"Bandwidth exhausted or memory limit exceeded\";\n                        break;\n                    case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n                        code = constants_1.Status.PERMISSION_DENIED;\n                        details = \"Protocol not secure enough\";\n                        break;\n                    case http2.constants.NGHTTP2_INTERNAL_ERROR:\n                        code = constants_1.Status.INTERNAL;\n                        if (this.internalError === null) {\n                            /* This error code was previously handled in the default case, and\n                             * there are several instances of it online, so I wanted to\n                             * preserve the original error message so that people find existing\n                             * information in searches, but also include the more recognizable\n                             * \"Internal server error\" message. */ details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;\n                        } else {\n                            if (this.internalError.code === \"ECONNRESET\" || this.internalError.code === \"ETIMEDOUT\") {\n                                code = constants_1.Status.UNAVAILABLE;\n                                details = this.internalError.message;\n                            } else {\n                                /* The \"Received RST_STREAM with code ...\" error is preserved\n                                 * here for continuity with errors reported online, but the\n                                 * error message at the end will probably be more relevant in\n                                 * most cases. */ details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n                            }\n                        }\n                        break;\n                    default:\n                        code = constants_1.Status.INTERNAL;\n                        details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n                }\n                // This is a no-op if trailers were received at all.\n                // This is OK, because status codes emitted here correspond to more\n                // catastrophic issues that prevent us from receiving trailers in the\n                // first place.\n                this.endCall({\n                    code,\n                    details,\n                    metadata: new metadata_1.Metadata(),\n                    rstCode: http2Stream.rstCode\n                });\n            });\n        });\n        http2Stream.on(\"error\", (err)=>{\n            /* We need an error handler here to stop \"Uncaught Error\" exceptions\n             * from bubbling up. However, errors here should all correspond to\n             * \"close\" events, where we will handle the error more granularly */ /* Specifically looking for stream errors that were *not* constructed\n             * from a RST_STREAM response here:\n             * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n             */ if (err.code !== \"ERR_HTTP2_STREAM_ERROR\") {\n                this.trace(\"Node error event: message=\" + err.message + \" code=\" + err.code + \" errno=\" + getSystemErrorName(err.errno) + \" syscall=\" + err.syscall);\n                this.internalError = err;\n            }\n            this.callEventTracker.onStreamEnd(false);\n        });\n    }\n    getDeadlineInfo() {\n        return [\n            `remote_addr=${this.getPeer()}`\n        ];\n    }\n    onDisconnect() {\n        this.connectionDropped = true;\n        /* Give the call an event loop cycle to finish naturally before reporting\n         * the disconnection as an error. */ setImmediate(()=>{\n            this.endCall({\n                code: constants_1.Status.UNAVAILABLE,\n                details: \"Connection dropped\",\n                metadata: new metadata_1.Metadata()\n            });\n        });\n    }\n    outputStatus() {\n        /* Precondition: this.finalStatus !== null */ if (!this.statusOutput) {\n            this.statusOutput = true;\n            this.trace(\"ended with status: code=\" + this.finalStatus.code + ' details=\"' + this.finalStatus.details + '\"');\n            this.callEventTracker.onCallEnd(this.finalStatus);\n            /* We delay the actual action of bubbling up the status to insulate the\n             * cleanup code in this class from any errors that may be thrown in the\n             * upper layers as a result of bubbling up the status. In particular,\n             * if the status is not OK, the \"error\" event may be emitted\n             * synchronously at the top level, which will result in a thrown error if\n             * the user does not handle that event. */ process.nextTick(()=>{\n                this.listener.onReceiveStatus(this.finalStatus);\n            });\n            /* Leave the http2 stream in flowing state to drain incoming messages, to\n             * ensure that the stream closure completes. The call stream already does\n             * not push more messages after the status is output, so the messages go\n             * nowhere either way. */ this.http2Stream.resume();\n        }\n    }\n    trace(text) {\n        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, \"[\" + this.callId + \"] \" + text);\n    }\n    /**\n     * On first call, emits a 'status' event with the given StatusObject.\n     * Subsequent calls are no-ops.\n     * @param status The status of the call.\n     */ endCall(status) {\n        /* If the status is OK and a new status comes in (e.g. from a\n         * deserialization failure), that new status takes priority */ if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\n            this.finalStatus = status;\n            this.maybeOutputStatus();\n        }\n        this.destroyHttp2Stream();\n    }\n    maybeOutputStatus() {\n        if (this.finalStatus !== null) {\n            /* The combination check of readsClosed and that the two message buffer\n             * arrays are empty checks that there all incoming data has been fully\n             * processed */ if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && !this.isReadFilterPending && !this.isPushPending) {\n                this.outputStatus();\n            }\n        }\n    }\n    push(message) {\n        this.trace(\"pushing to reader message of length \" + (message instanceof Buffer ? message.length : null));\n        this.canPush = false;\n        this.isPushPending = true;\n        process.nextTick(()=>{\n            this.isPushPending = false;\n            /* If we have already output the status any later messages should be\n             * ignored, and can cause out-of-order operation errors higher up in the\n             * stack. Checking as late as possible here to avoid any race conditions.\n             */ if (this.statusOutput) {\n                return;\n            }\n            this.listener.onReceiveMessage(message);\n            this.maybeOutputStatus();\n        });\n    }\n    tryPush(messageBytes) {\n        if (this.canPush) {\n            this.http2Stream.pause();\n            this.push(messageBytes);\n        } else {\n            this.trace(\"unpushedReadMessages.push message of length \" + messageBytes.length);\n            this.unpushedReadMessages.push(messageBytes);\n        }\n    }\n    handleTrailers(headers) {\n        this.serverEndedCall = true;\n        this.callEventTracker.onStreamEnd(true);\n        let headersString = \"\";\n        for (const header of Object.keys(headers)){\n            headersString += \"\t\t\" + header + \": \" + headers[header] + \"\\n\";\n        }\n        this.trace(\"Received server trailers:\\n\" + headersString);\n        let metadata;\n        try {\n            metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        } catch (e) {\n            metadata = new metadata_1.Metadata();\n        }\n        const metadataMap = metadata.getMap();\n        let status;\n        if (typeof metadataMap[\"grpc-status\"] === \"string\") {\n            const receivedStatus = Number(metadataMap[\"grpc-status\"]);\n            this.trace(\"received status code \" + receivedStatus + \" from server\");\n            metadata.remove(\"grpc-status\");\n            let details = \"\";\n            if (typeof metadataMap[\"grpc-message\"] === \"string\") {\n                try {\n                    details = decodeURI(metadataMap[\"grpc-message\"]);\n                } catch (e) {\n                    details = metadataMap[\"grpc-message\"];\n                }\n                metadata.remove(\"grpc-message\");\n                this.trace('received status details string \"' + details + '\" from server');\n            }\n            status = {\n                code: receivedStatus,\n                details: details,\n                metadata: metadata\n            };\n        } else if (this.httpStatusCode) {\n            status = mapHttpStatusCode(this.httpStatusCode);\n            status.metadata = metadata;\n        } else {\n            status = {\n                code: constants_1.Status.UNKNOWN,\n                details: \"No status information received\",\n                metadata: metadata\n            };\n        }\n        // This is a no-op if the call was already ended when handling headers.\n        this.endCall(status);\n    }\n    destroyHttp2Stream() {\n        var _a;\n        // The http2 stream could already have been destroyed if cancelWithStatus\n        // is called in response to an internal http2 error.\n        if (this.http2Stream.destroyed) {\n            return;\n        }\n        /* If the server ended the call, sending an RST_STREAM is redundant, so we\n         * just half close on the client side instead to finish closing the stream.\n         */ if (this.serverEndedCall) {\n            this.http2Stream.end();\n        } else {\n            /* If the call has ended with an OK status, communicate that when closing\n             * the stream, partly to avoid a situation in which we detect an error\n             * RST_STREAM as a result after we have the status */ let code;\n            if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                code = http2.constants.NGHTTP2_NO_ERROR;\n            } else {\n                code = http2.constants.NGHTTP2_CANCEL;\n            }\n            this.trace(\"close http2 stream with code \" + code);\n            this.http2Stream.close(code);\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.trace(\"cancelWithStatus code: \" + status + ' details: \"' + details + '\"');\n        this.endCall({\n            code: status,\n            details,\n            metadata: new metadata_1.Metadata()\n        });\n    }\n    getStatus() {\n        return this.finalStatus;\n    }\n    getPeer() {\n        return this.transport.getPeerName();\n    }\n    getCallNumber() {\n        return this.callId;\n    }\n    startRead() {\n        /* If the stream has ended with an error, we should not emit any more\n         * messages and we should communicate that the stream has ended */ if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n            this.readsClosed = true;\n            this.maybeOutputStatus();\n            return;\n        }\n        this.canPush = true;\n        if (this.unpushedReadMessages.length > 0) {\n            const nextMessage = this.unpushedReadMessages.shift();\n            this.push(nextMessage);\n            return;\n        }\n        /* Only resume reading from the http2Stream if we don't have any pending\n         * messages to emit */ this.http2Stream.resume();\n    }\n    sendMessageWithContext(context, message) {\n        this.trace(\"write() called with message of length \" + message.length);\n        const cb = (error)=>{\n            /* nextTick here ensures that no stream action can be taken in the call\n             * stack of the write callback, in order to hopefully work around\n             * https://github.com/nodejs/node/issues/49147 */ process.nextTick(()=>{\n                var _a;\n                let code = constants_1.Status.UNAVAILABLE;\n                if ((error === null || error === void 0 ? void 0 : error.code) === \"ERR_STREAM_WRITE_AFTER_END\") {\n                    code = constants_1.Status.INTERNAL;\n                }\n                if (error) {\n                    this.cancelWithStatus(code, `Write error: ${error.message}`);\n                }\n                (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\n            });\n        };\n        this.trace(\"sending data chunk of length \" + message.length);\n        this.callEventTracker.addMessageSent();\n        try {\n            this.http2Stream.write(message, cb);\n        } catch (error) {\n            this.endCall({\n                code: constants_1.Status.UNAVAILABLE,\n                details: `Write failed with error ${error.message}`,\n                metadata: new metadata_1.Metadata()\n            });\n        }\n    }\n    halfClose() {\n        this.trace(\"end() called\");\n        this.trace(\"calling end() on HTTP/2 stream\");\n        this.http2Stream.end();\n    }\n}\nexports.Http2SubchannelCall = Http2SubchannelCall; //# sourceMappingURL=subchannel-call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1jYWxsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQkFBMkIsR0FBRyxLQUFLO0FBQ25DLE1BQU1HLFFBQVFDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQzdCLE1BQU1DLEtBQUtELG1CQUFPQSxDQUFDLGNBQUk7QUFDdkIsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUcsYUFBYUgsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUksbUJBQW1CSixtQkFBT0EsQ0FBQyx3RkFBa0I7QUFDbkQsTUFBTUssVUFBVUwsbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTU0sY0FBY04sbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTU8sY0FBYztBQUNwQjs7Ozs7Q0FLQyxHQUNELFNBQVNDLG1CQUFtQkMsS0FBSztJQUM3QixLQUFLLE1BQU0sQ0FBQ0MsTUFBTUMsSUFBSSxJQUFJakIsT0FBT2tCLE9BQU8sQ0FBQ1gsR0FBR1ksU0FBUyxDQUFDSixLQUFLLEVBQUc7UUFDMUQsSUFBSUUsUUFBUUYsT0FBTztZQUNmLE9BQU9DO1FBQ1g7SUFDSjtJQUNBLE9BQU8sMEJBQTBCRDtBQUNyQztBQUNBLFNBQVNLLGtCQUFrQkMsSUFBSTtJQUMzQixNQUFNQyxVQUFVLENBQUMsMEJBQTBCLEVBQUVELEtBQUssQ0FBQztJQUNuRCxJQUFJRTtJQUNKLE9BQVFGO1FBQ0oseUNBQXlDO1FBQ3pDLEtBQUs7WUFDREUsbUJBQW1CZixZQUFZZ0IsTUFBTSxDQUFDQyxRQUFRO1lBQzlDO1FBQ0osS0FBSztZQUNERixtQkFBbUJmLFlBQVlnQixNQUFNLENBQUNFLGVBQWU7WUFDckQ7UUFDSixLQUFLO1lBQ0RILG1CQUFtQmYsWUFBWWdCLE1BQU0s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QUM7Z0JBQ25EckMsVUFBVSxJQUFJdEIsV0FBV3VCLFFBQVE7WUFDckM7UUFDSjtJQUNKO0lBQ0F1RyxZQUFZO1FBQ1IsSUFBSSxDQUFDMUUsS0FBSyxDQUFDO1FBQ1gsSUFBSSxDQUFDQSxLQUFLLENBQUM7UUFDWCxJQUFJLENBQUMzQixXQUFXLENBQUN1RixHQUFHO0lBQ3hCO0FBQ0o7QUFDQXZILDJCQUEyQixHQUFHRSxxQkFDOUIsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnljLWhvdXNpbmctYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N1YmNoYW5uZWwtY2FsbC5qcz8wMDUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkh0dHAyU3ViY2hhbm5lbENhbGwgPSB2b2lkIDA7XG5jb25zdCBodHRwMiA9IHJlcXVpcmUoXCJodHRwMlwiKTtcbmNvbnN0IG9zID0gcmVxdWlyZShcIm9zXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBzdHJlYW1fZGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vc3RyZWFtLWRlY29kZXJcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18yID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnc3ViY2hhbm5lbF9jYWxsJztcbi8qKlxuICogU2hvdWxkIGRvIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgdGhpbmcgYXMgdXRpbC5nZXRTeXN0ZW1FcnJvck5hbWUgYnV0IHRoZVxuICogVHlwZVNjcmlwdCB0eXBlcyBkb24ndCBoYXZlIHRoYXQgZnVuY3Rpb24gZm9yIHNvbWUgcmVhc29uIHNvIEkganVzdCBtYWRlIG15XG4gKiBvd24uXG4gKiBAcGFyYW0gZXJybm9cbiAqL1xuZnVuY3Rpb24gZ2V0U3lzdGVtRXJyb3JOYW1lKGVycm5vKSB7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgbnVtXSBvZiBPYmplY3QuZW50cmllcyhvcy5jb25zdGFudHMuZXJybm8pKSB7XG4gICAgICAgIGlmIChudW0gPT09IGVycm5vKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ1Vua25vd24gc3lzdGVtIGVycm9yICcgKyBlcnJubztcbn1cbmZ1bmN0aW9uIG1hcEh0dHBTdGF0dXNDb2RlKGNvZGUpIHtcbiAgICBjb25zdCBkZXRhaWxzID0gYFJlY2VpdmVkIEhUVFAgc3RhdHVzIGNvZGUgJHtjb2RlfWA7XG4gICAgbGV0IG1hcHBlZFN0YXR1c0NvZGU7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIC8vIFRPRE8obXVyZ2F0cm9pZDk5KTogaGFuZGxlIDEwMCBhbmQgMTAxXG4gICAgICAgIGNhc2UgNDAwOlxuICAgICAgICAgICAgbWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQwMTpcbiAgICAgICAgICAgIG1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVVRIRU5USUNBVEVEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDAzOlxuICAgICAgICAgICAgbWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5QRVJNSVNTSU9OX0RFTklFRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQwNDpcbiAgICAgICAgICAgIG1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQyOTpcbiAgICAgICAgY2FzZSA1MDI6XG4gICAgICAgIGNhc2UgNTAzOlxuICAgICAgICBjYXNlIDUwNDpcbiAgICAgICAgICAgIG1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIG1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogbWFwcGVkU3RhdHVzQ29kZSxcbiAgICAgICAgZGV0YWlsczogZGV0YWlscyxcbiAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKClcbiAgICB9O1xufVxuY2xhc3MgSHR0cDJTdWJjaGFubmVsQ2FsbCB7XG4gICAgY29uc3RydWN0b3IoaHR0cDJTdHJlYW0sIGNhbGxFdmVudFRyYWNrZXIsIGxpc3RlbmVyLCB0cmFuc3BvcnQsIGNhbGxJZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuaHR0cDJTdHJlYW0gPSBodHRwMlN0cmVhbTtcbiAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyID0gY2FsbEV2ZW50VHJhY2tlcjtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgdGhpcy5jYWxsSWQgPSBjYWxsSWQ7XG4gICAgICAgIHRoaXMuaXNSZWFkRmlsdGVyUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUHVzaFBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5QdXNoID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhbiAnZW5kJyBldmVudCBoYXMgY29tZSBmcm9tIHRoZSBodHRwMiBzdHJlYW0sIHNvIHRoZXJlXG4gICAgICAgICAqIHdpbGwgYmUgbm8gbW9yZSBkYXRhIGV2ZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZHNDbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGF0dXNPdXRwdXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51bnB1c2hlZFJlYWRNZXNzYWdlcyA9IFtdO1xuICAgICAgICAvLyBUaGlzIGlzIHBvcHVsYXRlZCAobm9uLW51bGwpIGlmIGFuZCBvbmx5IGlmIHRoZSBjYWxsIGhhcyBlbmRlZFxuICAgICAgICB0aGlzLmZpbmFsU3RhdHVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnRlcm5hbEVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXJ2ZXJFbmRlZENhbGwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uRHJvcHBlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBtYXhSZWNlaXZlTWVzc2FnZUxlbmd0aCA9IChfYSA9IHRyYW5zcG9ydC5nZXRPcHRpb25zKClbJ2dycGMubWF4X3JlY2VpdmVfbWVzc2FnZV9sZW5ndGgnXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29uc3RhbnRzXzEuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSDtcbiAgICAgICAgdGhpcy5kZWNvZGVyID0gbmV3IHN0cmVhbV9kZWNvZGVyXzEuU3RyZWFtRGVjb2RlcihtYXhSZWNlaXZlTWVzc2FnZUxlbmd0aCk7XG4gICAgICAgIGh0dHAyU3RyZWFtLm9uKCdyZXNwb25zZScsIChoZWFkZXJzLCBmbGFncykgPT4ge1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNTdHJpbmcgPSAnJztcbiAgICAgICAgICAgIGZvciAoY29uc3QgaGVhZGVyIG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1N0cmluZyArPSAnXFx0XFx0JyArIGhlYWRlciArICc6ICcgKyBoZWFkZXJzW2hlYWRlcl0gKyAnXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIHNlcnZlciBoZWFkZXJzOlxcbicgKyBoZWFkZXJzU3RyaW5nKTtcbiAgICAgICAgICAgIHRoaXMuaHR0cFN0YXR1c0NvZGUgPSBoZWFkZXJzWyc6c3RhdHVzJ107XG4gICAgICAgICAgICBpZiAoZmxhZ3MgJiBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9GTEFHX0VORF9TVFJFQU0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVRyYWlsZXJzKGhlYWRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gbWV0YWRhdGFfMS5NZXRhZGF0YS5mcm9tSHR0cDJIZWFkZXJzKGhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRDYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGh0dHAyU3RyZWFtLm9uKCd0cmFpbGVycycsIChoZWFkZXJzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVRyYWlsZXJzKGhlYWRlcnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgaHR0cDJTdHJlYW0ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgLyogSWYgdGhlIHN0YXR1cyBoYXMgYWxyZWFkeSBiZWVuIG91dHB1dCwgYWxsb3cgdGhlIGh0dHAyIHN0cmVhbSB0b1xuICAgICAgICAgICAgICogZHJhaW4gd2l0aG91dCBwcm9jZXNzaW5nIHRoZSBkYXRhLiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFjZSgncmVjZWl2ZSBIVFRQLzIgZGF0YSBmcmFtZSBvZiBsZW5ndGggJyArIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlcztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZXMgPSB0aGlzLmRlY29kZXIud3JpdGUoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8qIFNvbWUgc2VydmVycyBzZW5kIEhUTUwgZXJyb3IgcGFnZXMgYWxvbmcgd2l0aCBIVFRQIHN0YXR1cyBjb2Rlcy5cbiAgICAgICAgICAgICAgICAgKiBXaGVuIHRoZSBjbGllbnQgYXR0ZW1wdHMgdG8gcGFyc2UgdGhpcyBhcyBhIGxlbmd0aC1kZWxpbWl0ZWRcbiAgICAgICAgICAgICAgICAgKiBtZXNzYWdlLCB0aGUgcGFyc2VkIG1lc3NhZ2Ugc2l6ZSBpcyBncmVhdGVyIHRoYW4gdGhlIGRlZmF1bHQgbGltaXQsXG4gICAgICAgICAgICAgICAgICogcmVzdWx0aW5nIGluIGEgbWVzc2FnZSBkZWNvZGluZyBlcnJvci4gSW4gdGhhdCBzaXR1YXRpb24sIHRoZSBIVFRQXG4gICAgICAgICAgICAgICAgICogZXJyb3IgY29kZSBpbmZvcm1hdGlvbiBpcyBtb3JlIHVzZWZ1bCB0byB0aGUgdXNlciB0aGFuIHRoZVxuICAgICAgICAgICAgICAgICAqIFJFU09VUkNFX0VYSEFVU1RFRCBlcnJvciBpcywgc28gd2UgcmVwb3J0IHRoYXQgaW5zdGVhZC4gTm9ybWFsbHksXG4gICAgICAgICAgICAgICAgICogd2UgZGVsYXkgcHJvY2Vzc2luZyB0aGUgSFRUUCBzdGF0dXMgdW50aWwgYWZ0ZXIgdGhlIHN0cmVhbSBlbmRzLCB0b1xuICAgICAgICAgICAgICAgICAqIHByaW9yaXRpemUgcmVwb3J0aW5nIHRoZSBnUlBDIHN0YXR1cyBmcm9tIHRyYWlsZXJzIGlmIGl0IGlzIHByZXNlbnQsXG4gICAgICAgICAgICAgICAgICogYnV0IHdoZW4gdGhlcmUgaXMgYSBtZXNzYWdlIHBhcnNpbmcgZXJyb3Igd2UgZW5kIHRoZSBzdHJlYW0gZWFybHlcbiAgICAgICAgICAgICAgICAgKiBiZWZvcmUgcHJvY2Vzc2luZyB0cmFpbGVycy4gKi9cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5odHRwU3RhdHVzQ29kZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuaHR0cFN0YXR1c0NvZGUgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXBwZWRTdGF0dXMgPSBtYXBIdHRwU3RhdHVzQ29kZSh0aGlzLmh0dHBTdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxXaXRoU3RhdHVzKG1hcHBlZFN0YXR1cy5jb2RlLCBtYXBwZWRTdGF0dXMuZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgncGFyc2VkIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgKyBtZXNzYWdlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyLmFkZE1lc3NhZ2VSZWNlaXZlZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJ5UHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGh0dHAyU3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlYWRzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubWF5YmVPdXRwdXRTdGF0dXMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGh0dHAyU3RyZWFtLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyRW5kZWRDYWxsID0gdHJ1ZTtcbiAgICAgICAgICAgIC8qIFVzZSBwcm9jZXNzLm5leHQgdGljayB0byBlbnN1cmUgdGhhdCB0aGlzIGNvZGUgaGFwcGVucyBhZnRlciBhbnlcbiAgICAgICAgICAgICAqIFwiZXJyb3JcIiBldmVudCB0aGF0IG1heSBiZSBlbWl0dGVkIGF0IGFib3V0IHRoZSBzYW1lIHRpbWUsIHNvIHRoYXRcbiAgICAgICAgICAgICAqIHdlIGNhbiBidWJibGUgdXAgdGhlIGVycm9yIG1lc3NhZ2UgZnJvbSB0aGF0IGV2ZW50LiAqL1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0hUVFAvMiBzdHJlYW0gY2xvc2VkIHdpdGggY29kZSAnICsgaHR0cDJTdHJlYW0ucnN0Q29kZSk7XG4gICAgICAgICAgICAgICAgLyogSWYgd2UgaGF2ZSBhIGZpbmFsIHN0YXR1cyB3aXRoIGFuIE9LIHN0YXR1cyBjb2RlLCB0aGF0IG1lYW5zIHRoYXRcbiAgICAgICAgICAgICAgICAgKiB3ZSBoYXZlIHJlY2VpdmVkIGFsbCBvZiB0aGUgbWVzc2FnZXMgYW5kIHdlIGhhdmUgcHJvY2Vzc2VkIHRoZVxuICAgICAgICAgICAgICAgICAqIHRyYWlsZXJzIGFuZCB0aGUgY2FsbCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LCBzbyBpdCBkb2Vzbid0IG1hdHRlclxuICAgICAgICAgICAgICAgICAqIGhvdyB0aGUgc3RyZWFtIGVuZHMgYWZ0ZXIgdGhhdCAqL1xuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy5maW5hbFN0YXR1cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgY29kZTtcbiAgICAgICAgICAgICAgICBsZXQgZGV0YWlscyA9ICcnO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoaHR0cDJTdHJlYW0ucnN0Q29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX05PX0VSUk9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgLyogSWYgd2UgZ2V0IGEgTk9fRVJST1IgY29kZSBhbmQgd2UgYWxyZWFkeSBoYXZlIGEgc3RhdHVzLCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHN0cmVhbSBjb21wbGV0ZWQgcHJvcGVybHkgYW5kIHdlIGp1c3QgaGF2ZW4ndCBmdWxseSBwcm9jZXNzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGl0IHlldCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5odHRwU3RhdHVzQ29kZSAmJiB0aGlzLmh0dHBTdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXBwZWRTdGF0dXMgPSBtYXBIdHRwU3RhdHVzQ29kZSh0aGlzLmh0dHBTdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gbWFwcGVkU3RhdHVzLmNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9IG1hcHBlZFN0YXR1cy5kZXRhaWxzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gYFJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlICR7aHR0cDJTdHJlYW0ucnN0Q29kZX0gKENhbGwgZW5kZWQgd2l0aG91dCBnUlBDIHN0YXR1cylgO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfUkVGVVNFRF9TVFJFQU06XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9ICdTdHJlYW0gcmVmdXNlZCBieSBzZXJ2ZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfQ0FOQ0VMOlxuICAgICAgICAgICAgICAgICAgICAgICAgLyogQnVnIHJlcG9ydHMgaW5kaWNhdGUgdGhhdCBOb2RlIHN5bnRoZXNpemVzIGEgTkdIVFRQMl9DQU5DRUxcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGNvZGUgZnJvbSBjb25uZWN0aW9uIGRyb3BzLiBXZSB3YW50IHRvIHByaW9yaXRpemUgcmVwb3J0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBhbiB1bmF2YWlsYWJsZSBzdGF0dXMgd2hlbiB0aGF0IGhhcHBlbnMuICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uRHJvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9ICdDb25uZWN0aW9uIGRyb3BwZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9ICdDYWxsIGNhbmNlbGxlZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9FTkhBTkNFX1lPVVJfQ0FMTTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9ICdCYW5kd2lkdGggZXhoYXVzdGVkIG9yIG1lbW9yeSBsaW1pdCBleGNlZWRlZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9JTkFERVFVQVRFX1NFQ1VSSVRZOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5QRVJNSVNTSU9OX0RFTklFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSAnUHJvdG9jb2wgbm90IHNlY3VyZSBlbm91Z2gnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfSU5URVJOQUxfRVJST1I6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJuYWxFcnJvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRoaXMgZXJyb3IgY29kZSB3YXMgcHJldmlvdXNseSBoYW5kbGVkIGluIHRoZSBkZWZhdWx0IGNhc2UsIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoZXJlIGFyZSBzZXZlcmFsIGluc3RhbmNlcyBvZiBpdCBvbmxpbmUsIHNvIEkgd2FudGVkIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogcHJlc2VydmUgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2Ugc28gdGhhdCBwZW9wbGUgZmluZCBleGlzdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGluZm9ybWF0aW9uIGluIHNlYXJjaGVzLCBidXQgYWxzbyBpbmNsdWRlIHRoZSBtb3JlIHJlY29nbml6YWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFwiSW50ZXJuYWwgc2VydmVyIGVycm9yXCIgbWVzc2FnZS4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gYFJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlICR7aHR0cDJTdHJlYW0ucnN0Q29kZX0gKEludGVybmFsIHNlcnZlciBlcnJvcilgO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJuYWxFcnJvci5jb2RlID09PSAnRUNPTk5SRVNFVCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEVycm9yLmNvZGUgPT09ICdFVElNRURPVVQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSB0aGlzLmludGVybmFsRXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRoZSBcIlJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlIC4uLlwiIGVycm9yIGlzIHByZXNlcnZlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBoZXJlIGZvciBjb250aW51aXR5IHdpdGggZXJyb3JzIHJlcG9ydGVkIG9ubGluZSwgYnV0IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBlcnJvciBtZXNzYWdlIGF0IHRoZSBlbmQgd2lsbCBwcm9iYWJseSBiZSBtb3JlIHJlbGV2YW50IGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG1vc3QgY2FzZXMuICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSBgUmVjZWl2ZWQgUlNUX1NUUkVBTSB3aXRoIGNvZGUgJHtodHRwMlN0cmVhbS5yc3RDb2RlfSB0cmlnZ2VyZWQgYnkgaW50ZXJuYWwgY2xpZW50IGVycm9yOiAke3RoaXMuaW50ZXJuYWxFcnJvci5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9IGBSZWNlaXZlZCBSU1RfU1RSRUFNIHdpdGggY29kZSAke2h0dHAyU3RyZWFtLnJzdENvZGV9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG5vLW9wIGlmIHRyYWlsZXJzIHdlcmUgcmVjZWl2ZWQgYXQgYWxsLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgT0ssIGJlY2F1c2Ugc3RhdHVzIGNvZGVzIGVtaXR0ZWQgaGVyZSBjb3JyZXNwb25kIHRvIG1vcmVcbiAgICAgICAgICAgICAgICAvLyBjYXRhc3Ryb3BoaWMgaXNzdWVzIHRoYXQgcHJldmVudCB1cyBmcm9tIHJlY2VpdmluZyB0cmFpbGVycyBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBmaXJzdCBwbGFjZS5cbiAgICAgICAgICAgICAgICB0aGlzLmVuZENhbGwoe1xuICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgcnN0Q29kZTogaHR0cDJTdHJlYW0ucnN0Q29kZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaHR0cDJTdHJlYW0ub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICAgICAgLyogV2UgbmVlZCBhbiBlcnJvciBoYW5kbGVyIGhlcmUgdG8gc3RvcCBcIlVuY2F1Z2h0IEVycm9yXCIgZXhjZXB0aW9uc1xuICAgICAgICAgICAgICogZnJvbSBidWJibGluZyB1cC4gSG93ZXZlciwgZXJyb3JzIGhlcmUgc2hvdWxkIGFsbCBjb3JyZXNwb25kIHRvXG4gICAgICAgICAgICAgKiBcImNsb3NlXCIgZXZlbnRzLCB3aGVyZSB3ZSB3aWxsIGhhbmRsZSB0aGUgZXJyb3IgbW9yZSBncmFudWxhcmx5ICovXG4gICAgICAgICAgICAvKiBTcGVjaWZpY2FsbHkgbG9va2luZyBmb3Igc3RyZWFtIGVycm9ycyB0aGF0IHdlcmUgKm5vdCogY29uc3RydWN0ZWRcbiAgICAgICAgICAgICAqIGZyb20gYSBSU1RfU1RSRUFNIHJlc3BvbnNlIGhlcmU6XG4gICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi84Yjg2MjBkNTgwMzE0MDUwMTc1OTgzNDAyZGZkZGYyNjc0ZThlMjJhL2xpYi9pbnRlcm5hbC9odHRwMi9jb3JlLmpzI0wyMjY3XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChlcnIuY29kZSAhPT0gJ0VSUl9IVFRQMl9TVFJFQU1fRVJST1InKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnTm9kZSBlcnJvciBldmVudDogbWVzc2FnZT0nICtcbiAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgK1xuICAgICAgICAgICAgICAgICAgICAnIGNvZGU9JyArXG4gICAgICAgICAgICAgICAgICAgIGVyci5jb2RlICtcbiAgICAgICAgICAgICAgICAgICAgJyBlcnJubz0nICtcbiAgICAgICAgICAgICAgICAgICAgZ2V0U3lzdGVtRXJyb3JOYW1lKGVyci5lcnJubykgK1xuICAgICAgICAgICAgICAgICAgICAnIHN5c2NhbGw9JyArXG4gICAgICAgICAgICAgICAgICAgIGVyci5zeXNjYWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsRXJyb3IgPSBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhbGxFdmVudFRyYWNrZXIub25TdHJlYW1FbmQoZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RGVhZGxpbmVJbmZvKCkge1xuICAgICAgICByZXR1cm4gW2ByZW1vdGVfYWRkcj0ke3RoaXMuZ2V0UGVlcigpfWBdO1xuICAgIH1cbiAgICBvbkRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkRyb3BwZWQgPSB0cnVlO1xuICAgICAgICAvKiBHaXZlIHRoZSBjYWxsIGFuIGV2ZW50IGxvb3AgY3ljbGUgdG8gZmluaXNoIG5hdHVyYWxseSBiZWZvcmUgcmVwb3J0aW5nXG4gICAgICAgICAqIHRoZSBkaXNjb25uZWN0aW9uIGFzIGFuIGVycm9yLiAqL1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbmRDYWxsKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogJ0Nvbm5lY3Rpb24gZHJvcHBlZCcsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG91dHB1dFN0YXR1cygpIHtcbiAgICAgICAgLyogUHJlY29uZGl0aW9uOiB0aGlzLmZpbmFsU3RhdHVzICE9PSBudWxsICovXG4gICAgICAgIGlmICghdGhpcy5zdGF0dXNPdXRwdXQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzT3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2VuZGVkIHdpdGggc3RhdHVzOiBjb2RlPScgK1xuICAgICAgICAgICAgICAgIHRoaXMuZmluYWxTdGF0dXMuY29kZSArXG4gICAgICAgICAgICAgICAgJyBkZXRhaWxzPVwiJyArXG4gICAgICAgICAgICAgICAgdGhpcy5maW5hbFN0YXR1cy5kZXRhaWxzICtcbiAgICAgICAgICAgICAgICAnXCInKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlci5vbkNhbGxFbmQodGhpcy5maW5hbFN0YXR1cyk7XG4gICAgICAgICAgICAvKiBXZSBkZWxheSB0aGUgYWN0dWFsIGFjdGlvbiBvZiBidWJibGluZyB1cCB0aGUgc3RhdHVzIHRvIGluc3VsYXRlIHRoZVxuICAgICAgICAgICAgICogY2xlYW51cCBjb2RlIGluIHRoaXMgY2xhc3MgZnJvbSBhbnkgZXJyb3JzIHRoYXQgbWF5IGJlIHRocm93biBpbiB0aGVcbiAgICAgICAgICAgICAqIHVwcGVyIGxheWVycyBhcyBhIHJlc3VsdCBvZiBidWJibGluZyB1cCB0aGUgc3RhdHVzLiBJbiBwYXJ0aWN1bGFyLFxuICAgICAgICAgICAgICogaWYgdGhlIHN0YXR1cyBpcyBub3QgT0ssIHRoZSBcImVycm9yXCIgZXZlbnQgbWF5IGJlIGVtaXR0ZWRcbiAgICAgICAgICAgICAqIHN5bmNocm9ub3VzbHkgYXQgdGhlIHRvcCBsZXZlbCwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSB0aHJvd24gZXJyb3IgaWZcbiAgICAgICAgICAgICAqIHRoZSB1c2VyIGRvZXMgbm90IGhhbmRsZSB0aGF0IGV2ZW50LiAqL1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVTdGF0dXModGhpcy5maW5hbFN0YXR1cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qIExlYXZlIHRoZSBodHRwMiBzdHJlYW0gaW4gZmxvd2luZyBzdGF0ZSB0byBkcmFpbiBpbmNvbWluZyBtZXNzYWdlcywgdG9cbiAgICAgICAgICAgICAqIGVuc3VyZSB0aGF0IHRoZSBzdHJlYW0gY2xvc3VyZSBjb21wbGV0ZXMuIFRoZSBjYWxsIHN0cmVhbSBhbHJlYWR5IGRvZXNcbiAgICAgICAgICAgICAqIG5vdCBwdXNoIG1vcmUgbWVzc2FnZXMgYWZ0ZXIgdGhlIHN0YXR1cyBpcyBvdXRwdXQsIHNvIHRoZSBtZXNzYWdlcyBnb1xuICAgICAgICAgICAgICogbm93aGVyZSBlaXRoZXIgd2F5LiAqL1xuICAgICAgICAgICAgdGhpcy5odHRwMlN0cmVhbS5yZXN1bWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzIuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgJ1snICsgdGhpcy5jYWxsSWQgKyAnXSAnICsgdGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9uIGZpcnN0IGNhbGwsIGVtaXRzIGEgJ3N0YXR1cycgZXZlbnQgd2l0aCB0aGUgZ2l2ZW4gU3RhdHVzT2JqZWN0LlxuICAgICAqIFN1YnNlcXVlbnQgY2FsbHMgYXJlIG5vLW9wcy5cbiAgICAgKiBAcGFyYW0gc3RhdHVzIFRoZSBzdGF0dXMgb2YgdGhlIGNhbGwuXG4gICAgICovXG4gICAgZW5kQ2FsbChzdGF0dXMpIHtcbiAgICAgICAgLyogSWYgdGhlIHN0YXR1cyBpcyBPSyBhbmQgYSBuZXcgc3RhdHVzIGNvbWVzIGluIChlLmcuIGZyb20gYVxuICAgICAgICAgKiBkZXNlcmlhbGl6YXRpb24gZmFpbHVyZSksIHRoYXQgbmV3IHN0YXR1cyB0YWtlcyBwcmlvcml0eSAqL1xuICAgICAgICBpZiAodGhpcy5maW5hbFN0YXR1cyA9PT0gbnVsbCB8fCB0aGlzLmZpbmFsU3RhdHVzLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgdGhpcy5maW5hbFN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgIHRoaXMubWF5YmVPdXRwdXRTdGF0dXMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3Ryb3lIdHRwMlN0cmVhbSgpO1xuICAgIH1cbiAgICBtYXliZU91dHB1dFN0YXR1cygpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8qIFRoZSBjb21iaW5hdGlvbiBjaGVjayBvZiByZWFkc0Nsb3NlZCBhbmQgdGhhdCB0aGUgdHdvIG1lc3NhZ2UgYnVmZmVyXG4gICAgICAgICAgICAgKiBhcnJheXMgYXJlIGVtcHR5IGNoZWNrcyB0aGF0IHRoZXJlIGFsbCBpbmNvbWluZyBkYXRhIGhhcyBiZWVuIGZ1bGx5XG4gICAgICAgICAgICAgKiBwcm9jZXNzZWQgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmZpbmFsU3RhdHVzLmNvZGUgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSyB8fFxuICAgICAgICAgICAgICAgICh0aGlzLnJlYWRzQ2xvc2VkICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5wdXNoZWRSZWFkTWVzc2FnZXMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmlzUmVhZEZpbHRlclBlbmRpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuaXNQdXNoUGVuZGluZykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHB1c2gobWVzc2FnZSkge1xuICAgICAgICB0aGlzLnRyYWNlKCdwdXNoaW5nIHRvIHJlYWRlciBtZXNzYWdlIG9mIGxlbmd0aCAnICtcbiAgICAgICAgICAgIChtZXNzYWdlIGluc3RhbmNlb2YgQnVmZmVyID8gbWVzc2FnZS5sZW5ndGggOiBudWxsKSk7XG4gICAgICAgIHRoaXMuY2FuUHVzaCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUHVzaFBlbmRpbmcgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNQdXNoUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgLyogSWYgd2UgaGF2ZSBhbHJlYWR5IG91dHB1dCB0aGUgc3RhdHVzIGFueSBsYXRlciBtZXNzYWdlcyBzaG91bGQgYmVcbiAgICAgICAgICAgICAqIGlnbm9yZWQsIGFuZCBjYW4gY2F1c2Ugb3V0LW9mLW9yZGVyIG9wZXJhdGlvbiBlcnJvcnMgaGlnaGVyIHVwIGluIHRoZVxuICAgICAgICAgICAgICogc3RhY2suIENoZWNraW5nIGFzIGxhdGUgYXMgcG9zc2libGUgaGVyZSB0byBhdm9pZCBhbnkgcmFjZSBjb25kaXRpb25zLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0dXNPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLm1heWJlT3V0cHV0U3RhdHVzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0cnlQdXNoKG1lc3NhZ2VCeXRlcykge1xuICAgICAgICBpZiAodGhpcy5jYW5QdXNoKSB7XG4gICAgICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLnBhdXNlKCk7XG4gICAgICAgICAgICB0aGlzLnB1c2gobWVzc2FnZUJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ3VucHVzaGVkUmVhZE1lc3NhZ2VzLnB1c2ggbWVzc2FnZSBvZiBsZW5ndGggJyArIG1lc3NhZ2VCeXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy51bnB1c2hlZFJlYWRNZXNzYWdlcy5wdXNoKG1lc3NhZ2VCeXRlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlVHJhaWxlcnMoaGVhZGVycykge1xuICAgICAgICB0aGlzLnNlcnZlckVuZGVkQ2FsbCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlci5vblN0cmVhbUVuZCh0cnVlKTtcbiAgICAgICAgbGV0IGhlYWRlcnNTdHJpbmcgPSAnJztcbiAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgICAgICAgIGhlYWRlcnNTdHJpbmcgKz0gJ1xcdFxcdCcgKyBoZWFkZXIgKyAnOiAnICsgaGVhZGVyc1toZWFkZXJdICsgJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgc2VydmVyIHRyYWlsZXJzOlxcbicgKyBoZWFkZXJzU3RyaW5nKTtcbiAgICAgICAgbGV0IG1ldGFkYXRhO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWV0YWRhdGEgPSBtZXRhZGF0YV8xLk1ldGFkYXRhLmZyb21IdHRwMkhlYWRlcnMoaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhID0gbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhZGF0YU1hcCA9IG1ldGFkYXRhLmdldE1hcCgpO1xuICAgICAgICBsZXQgc3RhdHVzO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGFkYXRhTWFwWydncnBjLXN0YXR1cyddID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgcmVjZWl2ZWRTdGF0dXMgPSBOdW1iZXIobWV0YWRhdGFNYXBbJ2dycGMtc3RhdHVzJ10pO1xuICAgICAgICAgICAgdGhpcy50cmFjZSgncmVjZWl2ZWQgc3RhdHVzIGNvZGUgJyArIHJlY2VpdmVkU3RhdHVzICsgJyBmcm9tIHNlcnZlcicpO1xuICAgICAgICAgICAgbWV0YWRhdGEucmVtb3ZlKCdncnBjLXN0YXR1cycpO1xuICAgICAgICAgICAgbGV0IGRldGFpbHMgPSAnJztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0YWRhdGFNYXBbJ2dycGMtbWVzc2FnZSddID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSBkZWNvZGVVUkkobWV0YWRhdGFNYXBbJ2dycGMtbWVzc2FnZSddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9IG1ldGFkYXRhTWFwWydncnBjLW1lc3NhZ2UnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEucmVtb3ZlKCdncnBjLW1lc3NhZ2UnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdyZWNlaXZlZCBzdGF0dXMgZGV0YWlscyBzdHJpbmcgXCInICsgZGV0YWlscyArICdcIiBmcm9tIHNlcnZlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdHVzID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IHJlY2VpdmVkU3RhdHVzLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGRldGFpbHMsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaHR0cFN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9IG1hcEh0dHBTdGF0dXNDb2RlKHRoaXMuaHR0cFN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgc3RhdHVzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0dXMgPSB7XG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV04sXG4gICAgICAgICAgICAgICAgZGV0YWlsczogJ05vIHN0YXR1cyBpbmZvcm1hdGlvbiByZWNlaXZlZCcsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgaXMgYSBuby1vcCBpZiB0aGUgY2FsbCB3YXMgYWxyZWFkeSBlbmRlZCB3aGVuIGhhbmRsaW5nIGhlYWRlcnMuXG4gICAgICAgIHRoaXMuZW5kQ2FsbChzdGF0dXMpO1xuICAgIH1cbiAgICBkZXN0cm95SHR0cDJTdHJlYW0oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gVGhlIGh0dHAyIHN0cmVhbSBjb3VsZCBhbHJlYWR5IGhhdmUgYmVlbiBkZXN0cm95ZWQgaWYgY2FuY2VsV2l0aFN0YXR1c1xuICAgICAgICAvLyBpcyBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gYW4gaW50ZXJuYWwgaHR0cDIgZXJyb3IuXG4gICAgICAgIGlmICh0aGlzLmh0dHAyU3RyZWFtLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qIElmIHRoZSBzZXJ2ZXIgZW5kZWQgdGhlIGNhbGwsIHNlbmRpbmcgYW4gUlNUX1NUUkVBTSBpcyByZWR1bmRhbnQsIHNvIHdlXG4gICAgICAgICAqIGp1c3QgaGFsZiBjbG9zZSBvbiB0aGUgY2xpZW50IHNpZGUgaW5zdGVhZCB0byBmaW5pc2ggY2xvc2luZyB0aGUgc3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuc2VydmVyRW5kZWRDYWxsKSB7XG4gICAgICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLmVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogSWYgdGhlIGNhbGwgaGFzIGVuZGVkIHdpdGggYW4gT0sgc3RhdHVzLCBjb21tdW5pY2F0ZSB0aGF0IHdoZW4gY2xvc2luZ1xuICAgICAgICAgICAgICogdGhlIHN0cmVhbSwgcGFydGx5IHRvIGF2b2lkIGEgc2l0dWF0aW9uIGluIHdoaWNoIHdlIGRldGVjdCBhbiBlcnJvclxuICAgICAgICAgICAgICogUlNUX1NUUkVBTSBhcyBhIHJlc3VsdCBhZnRlciB3ZSBoYXZlIHRoZSBzdGF0dXMgKi9cbiAgICAgICAgICAgIGxldCBjb2RlO1xuICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLmZpbmFsU3RhdHVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9OT19FUlJPUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9DQU5DRUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdjbG9zZSBodHRwMiBzdHJlYW0gd2l0aCBjb2RlICcgKyBjb2RlKTtcbiAgICAgICAgICAgIHRoaXMuaHR0cDJTdHJlYW0uY2xvc2UoY29kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnY2FuY2VsV2l0aFN0YXR1cyBjb2RlOiAnICsgc3RhdHVzICsgJyBkZXRhaWxzOiBcIicgKyBkZXRhaWxzICsgJ1wiJyk7XG4gICAgICAgIHRoaXMuZW5kQ2FsbCh7IGNvZGU6IHN0YXR1cywgZGV0YWlscywgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCkgfSk7XG4gICAgfVxuICAgIGdldFN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxTdGF0dXM7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5nZXRQZWVyTmFtZSgpO1xuICAgIH1cbiAgICBnZXRDYWxsTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsSWQ7XG4gICAgfVxuICAgIHN0YXJ0UmVhZCgpIHtcbiAgICAgICAgLyogSWYgdGhlIHN0cmVhbSBoYXMgZW5kZWQgd2l0aCBhbiBlcnJvciwgd2Ugc2hvdWxkIG5vdCBlbWl0IGFueSBtb3JlXG4gICAgICAgICAqIG1lc3NhZ2VzIGFuZCB3ZSBzaG91bGQgY29tbXVuaWNhdGUgdGhhdCB0aGUgc3RyZWFtIGhhcyBlbmRlZCAqL1xuICAgICAgICBpZiAodGhpcy5maW5hbFN0YXR1cyAhPT0gbnVsbCAmJiB0aGlzLmZpbmFsU3RhdHVzLmNvZGUgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgdGhpcy5yZWFkc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1heWJlT3V0cHV0U3RhdHVzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5QdXNoID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMudW5wdXNoZWRSZWFkTWVzc2FnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dE1lc3NhZ2UgPSB0aGlzLnVucHVzaGVkUmVhZE1lc3NhZ2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICB0aGlzLnB1c2gobmV4dE1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qIE9ubHkgcmVzdW1lIHJlYWRpbmcgZnJvbSB0aGUgaHR0cDJTdHJlYW0gaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgcGVuZGluZ1xuICAgICAgICAgKiBtZXNzYWdlcyB0byBlbWl0ICovXG4gICAgICAgIHRoaXMuaHR0cDJTdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICAgIHNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLnRyYWNlKCd3cml0ZSgpIGNhbGxlZCB3aXRoIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgKyBtZXNzYWdlLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGNiID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvKiBuZXh0VGljayBoZXJlIGVuc3VyZXMgdGhhdCBubyBzdHJlYW0gYWN0aW9uIGNhbiBiZSB0YWtlbiBpbiB0aGUgY2FsbFxuICAgICAgICAgICAgICogc3RhY2sgb2YgdGhlIHdyaXRlIGNhbGxiYWNrLCBpbiBvcmRlciB0byBob3BlZnVsbHkgd29yayBhcm91bmRcbiAgICAgICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvNDkxNDcgKi9cbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBsZXQgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRTtcbiAgICAgICAgICAgICAgICBpZiAoKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5jb2RlKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgJ0VSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EJykge1xuICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxXaXRoU3RhdHVzKGNvZGUsIGBXcml0ZSBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoX2EgPSBjb250ZXh0LmNhbGxiYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChjb250ZXh0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyYWNlKCdzZW5kaW5nIGRhdGEgY2h1bmsgb2YgbGVuZ3RoICcgKyBtZXNzYWdlLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlci5hZGRNZXNzYWdlU2VudCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5odHRwMlN0cmVhbS53cml0ZShtZXNzYWdlLCBjYik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVuZENhbGwoe1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBgV3JpdGUgZmFpbGVkIHdpdGggZXJyb3IgJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYWxmQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ2VuZCgpIGNhbGxlZCcpO1xuICAgICAgICB0aGlzLnRyYWNlKCdjYWxsaW5nIGVuZCgpIG9uIEhUVFAvMiBzdHJlYW0nKTtcbiAgICAgICAgdGhpcy5odHRwMlN0cmVhbS5lbmQoKTtcbiAgICB9XG59XG5leHBvcnRzLkh0dHAyU3ViY2hhbm5lbENhbGwgPSBIdHRwMlN1YmNoYW5uZWxDYWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ViY2hhbm5lbC1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkh0dHAyU3ViY2hhbm5lbENhbGwiLCJodHRwMiIsInJlcXVpcmUiLCJvcyIsImNvbnN0YW50c18xIiwibWV0YWRhdGFfMSIsInN0cmVhbV9kZWNvZGVyXzEiLCJsb2dnaW5nIiwiY29uc3RhbnRzXzIiLCJUUkFDRVJfTkFNRSIsImdldFN5c3RlbUVycm9yTmFtZSIsImVycm5vIiwibmFtZSIsIm51bSIsImVudHJpZXMiLCJjb25zdGFudHMiLCJtYXBIdHRwU3RhdHVzQ29kZSIsImNvZGUiLCJkZXRhaWxzIiwibWFwcGVkU3RhdHVzQ29kZSIsIlN0YXR1cyIsIklOVEVSTkFMIiwiVU5BVVRIRU5USUNBVEVEIiwiUEVSTUlTU0lPTl9ERU5JRUQiLCJVTklNUExFTUVOVEVEIiwiVU5BVkFJTEFCTEUiLCJVTktOT1dOIiwibWV0YWRhdGEiLCJNZXRhZGF0YSIsImNvbnN0cnVjdG9yIiwiaHR0cDJTdHJlYW0iLCJjYWxsRXZlbnRUcmFja2VyIiwibGlzdGVuZXIiLCJ0cmFuc3BvcnQiLCJjYWxsSWQiLCJfYSIsImlzUmVhZEZpbHRlclBlbmRpbmciLCJpc1B1c2hQZW5kaW5nIiwiY2FuUHVzaCIsInJlYWRzQ2xvc2VkIiwic3RhdHVzT3V0cHV0IiwidW5wdXNoZWRSZWFkTWVzc2FnZXMiLCJmaW5hbFN0YXR1cyIsImludGVybmFsRXJyb3IiLCJzZXJ2ZXJFbmRlZENhbGwiLCJjb25uZWN0aW9uRHJvcHBlZCIsIm1heFJlY2VpdmVNZXNzYWdlTGVuZ3RoIiwiZ2V0T3B0aW9ucyIsIkRFRkFVTFRfTUFYX1JFQ0VJVkVfTUVTU0FHRV9MRU5HVEgiLCJkZWNvZGVyIiwiU3RyZWFtRGVjb2RlciIsIm9uIiwiaGVhZGVycyIsImZsYWdzIiwiaGVhZGVyc1N0cmluZyIsImhlYWRlciIsImtleXMiLCJ0cmFjZSIsImh0dHBTdGF0dXNDb2RlIiwiTkdIVFRQMl9GTEFHX0VORF9TVFJFQU0iLCJoYW5kbGVUcmFpbGVycyIsImZyb21IdHRwMkhlYWRlcnMiLCJlcnJvciIsImVuZENhbGwiLCJtZXNzYWdlIiwib25SZWNlaXZlTWV0YWRhdGEiLCJkYXRhIiwibGVuZ3RoIiwibWVzc2FnZXMiLCJ3cml0ZSIsImUiLCJ1bmRlZmluZWQiLCJtYXBwZWRTdGF0dXMiLCJjYW5jZWxXaXRoU3RhdHVzIiwiUkVTT1VSQ0VfRVhIQVVTVEVEIiwiYWRkTWVzc2FnZVJlY2VpdmVkIiwidHJ5UHVzaCIsIm1heWJlT3V0cHV0U3RhdHVzIiwicHJvY2VzcyIsIm5leHRUaWNrIiwicnN0Q29kZSIsIk9LIiwiTkdIVFRQMl9OT19FUlJPUiIsIk5HSFRUUDJfUkVGVVNFRF9TVFJFQU0iLCJOR0hUVFAyX0NBTkNFTCIsIkNBTkNFTExFRCIsIk5HSFRUUDJfRU5IQU5DRV9ZT1VSX0NBTE0iLCJOR0hUVFAyX0lOQURFUVVBVEVfU0VDVVJJVFkiLCJOR0hUVFAyX0lOVEVSTkFMX0VSUk9SIiwiZXJyIiwic3lzY2FsbCIsIm9uU3RyZWFtRW5kIiwiZ2V0RGVhZGxpbmVJbmZvIiwiZ2V0UGVlciIsIm9uRGlzY29ubmVjdCIsInNldEltbWVkaWF0ZSIsIm91dHB1dFN0YXR1cyIsIm9uQ2FsbEVuZCIsIm9uUmVjZWl2ZVN0YXR1cyIsInJlc3VtZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsInN0YXR1cyIsImRlc3Ryb3lIdHRwMlN0cmVhbSIsInB1c2giLCJCdWZmZXIiLCJvblJlY2VpdmVNZXNzYWdlIiwibWVzc2FnZUJ5dGVzIiwicGF1c2UiLCJtZXRhZGF0YU1hcCIsImdldE1hcCIsInJlY2VpdmVkU3RhdHVzIiwiTnVtYmVyIiwicmVtb3ZlIiwiZGVjb2RlVVJJIiwiZGVzdHJveWVkIiwiZW5kIiwiY2xvc2UiLCJnZXRTdGF0dXMiLCJnZXRQZWVyTmFtZSIsImdldENhbGxOdW1iZXIiLCJzdGFydFJlYWQiLCJuZXh0TWVzc2FnZSIsInNoaWZ0Iiwic2VuZE1lc3NhZ2VXaXRoQ29udGV4dCIsImNvbnRleHQiLCJjYiIsImNhbGxiYWNrIiwiY2FsbCIsImFkZE1lc3NhZ2VTZW50IiwiaGFsZkNsb3NlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BaseSubchannelWrapper = void 0;\nclass BaseSubchannelWrapper {\n    constructor(child){\n        this.child = child;\n        this.healthy = true;\n        this.healthListeners = new Set();\n        child.addHealthStateWatcher((childHealthy)=>{\n            /* A change to the child health state only affects this wrapper's overall\n             * health state if this wrapper is reporting healthy. */ if (this.healthy) {\n                this.updateHealthListeners();\n            }\n        });\n    }\n    updateHealthListeners() {\n        for (const listener of this.healthListeners){\n            listener(this.isHealthy());\n        }\n    }\n    getConnectivityState() {\n        return this.child.getConnectivityState();\n    }\n    addConnectivityStateListener(listener) {\n        this.child.addConnectivityStateListener(listener);\n    }\n    removeConnectivityStateListener(listener) {\n        this.child.removeConnectivityStateListener(listener);\n    }\n    startConnecting() {\n        this.child.startConnecting();\n    }\n    getAddress() {\n        return this.child.getAddress();\n    }\n    throttleKeepalive(newKeepaliveTime) {\n        this.child.throttleKeepalive(newKeepaliveTime);\n    }\n    ref() {\n        this.child.ref();\n    }\n    unref() {\n        this.child.unref();\n    }\n    getChannelzRef() {\n        return this.child.getChannelzRef();\n    }\n    isHealthy() {\n        return this.healthy && this.child.isHealthy();\n    }\n    addHealthStateWatcher(listener) {\n        this.healthListeners.add(listener);\n    }\n    removeHealthStateWatcher(listener) {\n        this.healthListeners.delete(listener);\n    }\n    setHealthy(healthy) {\n        if (healthy !== this.healthy) {\n            this.healthy = healthy;\n            /* A change to this wrapper's health state only affects the overall\n             * reported health state if the child is healthy. */ if (this.child.isHealthy()) {\n                this.updateHealthListeners();\n            }\n        }\n    }\n    getRealSubchannel() {\n        return this.child.getRealSubchannel();\n    }\n    realSubchannelEquals(other) {\n        return this.getRealSubchannel() === other.getRealSubchannel();\n    }\n    getCallCredentials() {\n        return this.child.getCallCredentials();\n    }\n}\nexports.BaseSubchannelWrapper = BaseSubchannelWrapper; //# sourceMappingURL=subchannel-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHLEtBQUs7QUFDckMsTUFBTUU7SUFDRkMsWUFBWUMsS0FBSyxDQUFFO1FBQ2YsSUFBSSxDQUFDQSxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLGVBQWUsR0FBRyxJQUFJQztRQUMzQkgsTUFBTUkscUJBQXFCLENBQUNDLENBQUFBO1lBQ3hCO2tFQUNzRCxHQUN0RCxJQUFJLElBQUksQ0FBQ0osT0FBTyxFQUFFO2dCQUNkLElBQUksQ0FBQ0sscUJBQXFCO1lBQzlCO1FBQ0o7SUFDSjtJQUNBQSx3QkFBd0I7UUFDcEIsS0FBSyxNQUFNQyxZQUFZLElBQUksQ0FBQ0wsZUFBZSxDQUFFO1lBQ3pDSyxTQUFTLElBQUksQ0FBQ0MsU0FBUztRQUMzQjtJQUNKO0lBQ0FDLHVCQUF1QjtRQUNuQixPQUFPLElBQUksQ0FBQ1QsS0FBSyxDQUFDUyxvQkFBb0I7SUFDMUM7SUFDQUMsNkJBQTZCSCxRQUFRLEVBQUU7UUFDbkMsSUFBSSxDQUFDUCxLQUFLLENBQUNVLDRCQUE0QixDQUFDSDtJQUM1QztJQUNBSSxnQ0FBZ0NKLFFBQVEsRUFBRTtRQUN0QyxJQUFJLENBQUNQLEtBQUssQ0FBQ1csK0JBQStCLENBQUNKO0lBQy9DO0lBQ0FLLGtCQUFrQjtRQUNkLElBQUksQ0FBQ1osS0FBSyxDQUFDWSxlQUFlO0lBQzlCO0lBQ0FDLGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQ2IsS0FBSyxDQUFDYSxVQUFVO0lBQ2hDO0lBQ0FDLGtCQUFrQkMsZ0JBQWdCLEVBQUU7UUFDaEMsSUFBSSxDQUFDZixLQUFLLENBQUNjLGlCQUFpQixDQUFDQztJQUNqQztJQUNBQyxNQUFNO1FBQ0YsSUFBSSxDQUFDaEIsS0FBSyxDQUFDZ0IsR0FBRztJQUNsQjtJQUNBQyxRQUFRO1FBQ0osSUFBSSxDQUFDakIsS0FBSyxDQUFDaUIsS0FBSztJQUNwQjtJQUNBQyxpQkFBaUI7UUFDYixPQUFPLElBQUksQ0FBQ2xCLEtBQUssQ0FBQ2tCLGNBQWM7SUFDcEM7SUFDQVYsWUFBWTtRQUNSLE9BQU8sSUFBSSxDQUFDUCxPQUFPLElBQUksSUFBSSxDQUFDRCxLQUFLLENBQUNRLFNBQVM7SUFDL0M7SUFDQUosc0JBQXNCRyxRQUFRLEVBQUU7UUFDNUIsSUFBSSxDQUFDTCxlQUFlLENBQUNpQixHQUFHLENBQUNaO0lBQzdCO0lBQ0FhLHlCQUF5QmIsUUFBUSxFQUFFO1FBQy9CLElBQUksQ0FBQ0wsZUFBZSxDQUFDbUIsTUFBTSxDQUFDZDtJQUNoQztJQUNBZSxXQUFXckIsT0FBTyxFQUFFO1FBQ2hCLElBQUlBLFlBQVksSUFBSSxDQUFDQSxPQUFPLEVBQUU7WUFDMUIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO1lBQ2Y7OERBQ2tELEdBQ2xELElBQUksSUFBSSxDQUFDRCxLQUFLLENBQUNRLFNBQVMsSUFBSTtnQkFDeEIsSUFBSSxDQUFDRixxQkFBcUI7WUFDOUI7UUFDSjtJQUNKO0lBQ0FpQixvQkFBb0I7UUFDaEIsT0FBTyxJQUFJLENBQUN2QixLQUFLLENBQUN1QixpQkFBaUI7SUFDdkM7SUFDQUMscUJBQXFCQyxLQUFLLEVBQUU7UUFDeEIsT0FBTyxJQUFJLENBQUNGLGlCQUFpQixPQUFPRSxNQUFNRixpQkFBaUI7SUFDL0Q7SUFDQUcscUJBQXFCO1FBQ2pCLE9BQU8sSUFBSSxDQUFDMUIsS0FBSyxDQUFDMEIsa0JBQWtCO0lBQ3hDO0FBQ0o7QUFDQTlCLDZCQUE2QixHQUFHRSx1QkFDaEMsZ0RBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnljLWhvdXNpbmctYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N1YmNoYW5uZWwtaW50ZXJmYWNlLmpzPzI4Y2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZVN1YmNoYW5uZWxXcmFwcGVyID0gdm9pZCAwO1xuY2xhc3MgQmFzZVN1YmNoYW5uZWxXcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZCkge1xuICAgICAgICB0aGlzLmNoaWxkID0gY2hpbGQ7XG4gICAgICAgIHRoaXMuaGVhbHRoeSA9IHRydWU7XG4gICAgICAgIHRoaXMuaGVhbHRoTGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgICAgICBjaGlsZC5hZGRIZWFsdGhTdGF0ZVdhdGNoZXIoY2hpbGRIZWFsdGh5ID0+IHtcbiAgICAgICAgICAgIC8qIEEgY2hhbmdlIHRvIHRoZSBjaGlsZCBoZWFsdGggc3RhdGUgb25seSBhZmZlY3RzIHRoaXMgd3JhcHBlcidzIG92ZXJhbGxcbiAgICAgICAgICAgICAqIGhlYWx0aCBzdGF0ZSBpZiB0aGlzIHdyYXBwZXIgaXMgcmVwb3J0aW5nIGhlYWx0aHkuICovXG4gICAgICAgICAgICBpZiAodGhpcy5oZWFsdGh5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVIZWFsdGhMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZUhlYWx0aExpc3RlbmVycygpIHtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmhlYWx0aExpc3RlbmVycykge1xuICAgICAgICAgICAgbGlzdGVuZXIodGhpcy5pc0hlYWx0aHkoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkLmdldENvbm5lY3Rpdml0eVN0YXRlKCk7XG4gICAgfVxuICAgIGFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5jaGlsZC5hZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmNoaWxkLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIH1cbiAgICBzdGFydENvbm5lY3RpbmcoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgfVxuICAgIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkLmdldEFkZHJlc3MoKTtcbiAgICB9XG4gICAgdGhyb3R0bGVLZWVwYWxpdmUobmV3S2VlcGFsaXZlVGltZSkge1xuICAgICAgICB0aGlzLmNoaWxkLnRocm90dGxlS2VlcGFsaXZlKG5ld0tlZXBhbGl2ZVRpbWUpO1xuICAgIH1cbiAgICByZWYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQucmVmKCk7XG4gICAgfVxuICAgIHVucmVmKCkge1xuICAgICAgICB0aGlzLmNoaWxkLnVucmVmKCk7XG4gICAgfVxuICAgIGdldENoYW5uZWx6UmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZC5nZXRDaGFubmVselJlZigpO1xuICAgIH1cbiAgICBpc0hlYWx0aHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWx0aHkgJiYgdGhpcy5jaGlsZC5pc0hlYWx0aHkoKTtcbiAgICB9XG4gICAgYWRkSGVhbHRoU3RhdGVXYXRjaGVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuaGVhbHRoTGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJlbW92ZUhlYWx0aFN0YXRlV2F0Y2hlcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmhlYWx0aExpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgIH1cbiAgICBzZXRIZWFsdGh5KGhlYWx0aHkpIHtcbiAgICAgICAgaWYgKGhlYWx0aHkgIT09IHRoaXMuaGVhbHRoeSkge1xuICAgICAgICAgICAgdGhpcy5oZWFsdGh5ID0gaGVhbHRoeTtcbiAgICAgICAgICAgIC8qIEEgY2hhbmdlIHRvIHRoaXMgd3JhcHBlcidzIGhlYWx0aCBzdGF0ZSBvbmx5IGFmZmVjdHMgdGhlIG92ZXJhbGxcbiAgICAgICAgICAgICAqIHJlcG9ydGVkIGhlYWx0aCBzdGF0ZSBpZiB0aGUgY2hpbGQgaXMgaGVhbHRoeS4gKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkLmlzSGVhbHRoeSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVIZWFsdGhMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSZWFsU3ViY2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQuZ2V0UmVhbFN1YmNoYW5uZWwoKTtcbiAgICB9XG4gICAgcmVhbFN1YmNoYW5uZWxFcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVhbFN1YmNoYW5uZWwoKSA9PT0gb3RoZXIuZ2V0UmVhbFN1YmNoYW5uZWwoKTtcbiAgICB9XG4gICAgZ2V0Q2FsbENyZWRlbnRpYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZC5nZXRDYWxsQ3JlZGVudGlhbHMoKTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VTdWJjaGFubmVsV3JhcHBlciA9IEJhc2VTdWJjaGFubmVsV3JhcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YmNoYW5uZWwtaW50ZXJmYWNlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkJhc2VTdWJjaGFubmVsV3JhcHBlciIsImNvbnN0cnVjdG9yIiwiY2hpbGQiLCJoZWFsdGh5IiwiaGVhbHRoTGlzdGVuZXJzIiwiU2V0IiwiYWRkSGVhbHRoU3RhdGVXYXRjaGVyIiwiY2hpbGRIZWFsdGh5IiwidXBkYXRlSGVhbHRoTGlzdGVuZXJzIiwibGlzdGVuZXIiLCJpc0hlYWx0aHkiLCJnZXRDb25uZWN0aXZpdHlTdGF0ZSIsImFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIiLCJyZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyIiwic3RhcnRDb25uZWN0aW5nIiwiZ2V0QWRkcmVzcyIsInRocm90dGxlS2VlcGFsaXZlIiwibmV3S2VlcGFsaXZlVGltZSIsInJlZiIsInVucmVmIiwiZ2V0Q2hhbm5lbHpSZWYiLCJhZGQiLCJyZW1vdmVIZWFsdGhTdGF0ZVdhdGNoZXIiLCJkZWxldGUiLCJzZXRIZWFsdGh5IiwiZ2V0UmVhbFN1YmNoYW5uZWwiLCJyZWFsU3ViY2hhbm5lbEVxdWFscyIsIm90aGVyIiwiZ2V0Q2FsbENyZWRlbnRpYWxzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SubchannelPool = void 0;\nexports.getSubchannelPool = getSubchannelPool;\nconst channel_options_1 = __webpack_require__(/*! ./channel-options */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\");\nconst subchannel_1 = __webpack_require__(/*! ./subchannel */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst transport_1 = __webpack_require__(/*! ./transport */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/transport.js\");\n// 10 seconds in milliseconds. This value is arbitrary.\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */ const REF_CHECK_INTERVAL = 10000;\nclass SubchannelPool {\n    /**\n     * A pool of subchannels use for making connections. Subchannels with the\n     * exact same parameters will be reused.\n     */ constructor(){\n        this.pool = Object.create(null);\n        /**\n         * A timer of a task performing a periodic subchannel cleanup.\n         */ this.cleanupTimer = null;\n    }\n    /**\n     * Unrefs all unused subchannels and cancels the cleanup task if all\n     * subchannels have been unrefed.\n     */ unrefUnusedSubchannels() {\n        let allSubchannelsUnrefed = true;\n        /* These objects are created with Object.create(null), so they do not\n         * have a prototype, which means that for (... in ...) loops over them\n         * do not need to be filtered */ // eslint-disable-disable-next-line:forin\n        for(const channelTarget in this.pool){\n            const subchannelObjArray = this.pool[channelTarget];\n            const refedSubchannels = subchannelObjArray.filter((value)=>!value.subchannel.unrefIfOneRef());\n            if (refedSubchannels.length > 0) {\n                allSubchannelsUnrefed = false;\n            }\n            /* For each subchannel in the pool, try to unref it if it has\n             * exactly one ref (which is the ref from the pool itself). If that\n             * does happen, remove the subchannel from the pool */ this.pool[channelTarget] = refedSubchannels;\n        }\n        /* Currently we do not delete keys with empty values. If that results\n         * in significant memory usage we should change it. */ // Cancel the cleanup task if all subchannels have been unrefed.\n        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n            clearInterval(this.cleanupTimer);\n            this.cleanupTimer = null;\n        }\n    }\n    /**\n     * Ensures that the cleanup task is spawned.\n     */ ensureCleanupTask() {\n        var _a, _b;\n        if (this.cleanupTimer === null) {\n            this.cleanupTimer = setInterval(()=>{\n                this.unrefUnusedSubchannels();\n            }, REF_CHECK_INTERVAL);\n            // Unref because this timer should not keep the event loop running.\n            // Call unref only if it exists to address electron/electron#21162\n            (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    /**\n     * Get a subchannel if one already exists with exactly matching parameters.\n     * Otherwise, create and save a subchannel with those parameters.\n     * @param channelTarget\n     * @param subchannelTarget\n     * @param channelArguments\n     * @param channelCredentials\n     */ getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {\n        this.ensureCleanupTask();\n        const channelTarget = (0, uri_parser_1.uriToString)(channelTargetUri);\n        if (channelTarget in this.pool) {\n            const subchannelObjArray = this.pool[channelTarget];\n            for (const subchannelObj of subchannelObjArray){\n                if ((0, subchannel_address_1.subchannelAddressEqual)(subchannelTarget, subchannelObj.subchannelAddress) && (0, channel_options_1.channelOptionsEqual)(channelArguments, subchannelObj.channelArguments) && channelCredentials._equals(subchannelObj.channelCredentials)) {\n                    return subchannelObj.subchannel;\n                }\n            }\n        }\n        // If we get here, no matching subchannel was found\n        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials, new transport_1.Http2SubchannelConnector(channelTargetUri));\n        if (!(channelTarget in this.pool)) {\n            this.pool[channelTarget] = [];\n        }\n        this.pool[channelTarget].push({\n            subchannelAddress: subchannelTarget,\n            channelArguments,\n            channelCredentials,\n            subchannel\n        });\n        subchannel.ref();\n        return subchannel;\n    }\n}\nexports.SubchannelPool = SubchannelPool;\nconst globalSubchannelPool = new SubchannelPool();\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */ function getSubchannelPool(global) {\n    if (global) {\n        return globalSubchannelPool;\n    } else {\n        return new SubchannelPool();\n    }\n} //# sourceMappingURL=subchannel-pool.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1wb29sLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBRyxLQUFLO0FBQzlCQSx5QkFBeUIsR0FBR0c7QUFDNUIsTUFBTUMsb0JBQW9CQyxtQkFBT0EsQ0FBQywwRkFBbUI7QUFDckQsTUFBTUMsZUFBZUQsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTUUsdUJBQXVCRixtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTUcsZUFBZUgsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTUksY0FBY0osbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsdURBQXVEO0FBQ3ZEOzs7Q0FHQyxHQUNELE1BQU1LLHFCQUFxQjtBQUMzQixNQUFNUjtJQUNGOzs7S0FHQyxHQUNEUyxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxJQUFJLEdBQUdkLE9BQU9lLE1BQU0sQ0FBQztRQUMxQjs7U0FFQyxHQUNELElBQUksQ0FBQ0MsWUFBWSxHQUFHO0lBQ3hCO0lBQ0E7OztLQUdDLEdBQ0RDLHlCQUF5QjtRQUNyQixJQUFJQyx3QkFBd0I7UUFDNUI7O3NDQUU4QixHQUM5Qix5Q0FBeUM7UUFDekMsSUFBSyxNQUFNQyxpQkFBaUIsSUFBSSxDQUFDTCxJQUFJLENBQUU7WUFDbkMsTUFBTU0scUJBQXFCLElBQUksQ0FBQ04sSUFBSSxDQUFDSyxjQUFjO1lBQ25ELE1BQU1FLG1CQUFtQkQsbUJBQW1CRSxNQUFNLENBQUNuQixDQUFBQSxRQUFTLENBQUNBLE1BQU1vQixVQUFVLENBQUNDLGFBQWE7WUFDM0YsSUFBSUgsaUJBQWlCSSxNQUFNLEdBQUcsR0FBRztnQkFDN0JQLHdCQUF3QjtZQUM1QjtZQUNBOztnRUFFb0QsR0FDcEQsSUFBSSxDQUFDSixJQUFJLENBQUNLLGNBQWMsR0FBR0U7UUFDL0I7UUFDQTs0REFDb0QsR0FDcEQsZ0VBQWdFO1FBQ2hFLElBQUlILHlCQUF5QixJQUFJLENBQUNGLFlBQVksS0FBSyxNQUFNO1lBQ3JEVSxjQUFjLElBQUksQ0FBQ1YsWUFBWTtZQUMvQixJQUFJLENBQUNBLFlBQVksR0FBRztRQUN4QjtJQUNKO0lBQ0E7O0tBRUMsR0FDRFcsb0JBQW9CO1FBQ2hCLElBQUlDLElBQUlDO1FBQ1IsSUFBSSxJQUFJLENBQUNiLFlBQVksS0FBSyxNQUFNO1lBQzVCLElBQUksQ0FBQ0EsWUFBWSxHQUFHYyxZQUFZO2dCQUM1QixJQUFJLENBQUNiLHNCQUFzQjtZQUMvQixHQUFHTDtZQUNILG1FQUFtRTtZQUNuRSxrRUFBa0U7WUFDakVpQixDQUFBQSxLQUFLLENBQUNELEtBQUssSUFBSSxDQUFDWixZQUFZLEVBQUVlLEtBQUssTUFBTSxRQUFRRixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdHLElBQUksQ0FBQ0o7UUFDdkY7SUFDSjtJQUNBOzs7Ozs7O0tBT0MsR0FDREssc0JBQXNCQyxnQkFBZ0IsRUFBRUMsZ0JBQWdCLEVBQUVDLGdCQUFnQixFQUFFQyxrQkFBa0IsRUFBRTtRQUM1RixJQUFJLENBQUNWLGlCQUFpQjtRQUN0QixNQUFNUixnQkFBZ0IsQ0FBQyxHQUFHVCxhQUFhNEIsV0FBVyxFQUFFSjtRQUNwRCxJQUFJZixpQkFBaUIsSUFBSSxDQUFDTCxJQUFJLEVBQUU7WUFDNUIsTUFBTU0scUJBQXFCLElBQUksQ0FBQ04sSUFBSSxDQUFDSyxjQUFjO1lBQ25ELEtBQUssTUFBTW9CLGlCQUFpQm5CLG1CQUFvQjtnQkFDNUMsSUFBSSxDQUFDLEdBQUdYLHFCQUFxQitCLHNCQUFzQixFQUFFTCxrQkFBa0JJLGNBQWNFLGlCQUFpQixLQUNsRyxDQUFDLEdBQUduQyxrQkFBa0JvQyxtQkFBbUIsRUFBRU4sa0JBQWtCRyxjQUFjSCxnQkFBZ0IsS0FDM0ZDLG1CQUFtQk0sT0FBTyxDQUFDSixjQUFjRixrQkFBa0IsR0FBRztvQkFDOUQsT0FBT0UsY0FBY2hCLFVBQVU7Z0JBQ25DO1lBQ0o7UUFDSjtRQUNBLG1EQUFtRDtRQUNuRCxNQUFNQSxhQUFhLElBQUlmLGFBQWFvQyxVQUFVLENBQUNWLGtCQUFrQkMsa0JBQWtCQyxrQkFBa0JDLG9CQUFvQixJQUFJMUIsWUFBWWtDLHdCQUF3QixDQUFDWDtRQUNsSyxJQUFJLENBQUVmLENBQUFBLGlCQUFpQixJQUFJLENBQUNMLElBQUksR0FBRztZQUMvQixJQUFJLENBQUNBLElBQUksQ0FBQ0ssY0FBYyxHQUFHLEVBQUU7UUFDakM7UUFDQSxJQUFJLENBQUNMLElBQUksQ0FBQ0ssY0FBYyxDQUFDMkIsSUFBSSxDQUFDO1lBQzFCTCxtQkFBbUJOO1lBQ25CQztZQUNBQztZQUNBZDtRQUNKO1FBQ0FBLFdBQVd3QixHQUFHO1FBQ2QsT0FBT3hCO0lBQ1g7QUFDSjtBQUNBckIsc0JBQXNCLEdBQUdFO0FBQ3pCLE1BQU00Qyx1QkFBdUIsSUFBSTVDO0FBQ2pDOzs7Q0FHQyxHQUNELFNBQVNDLGtCQUFrQjRDLE1BQU07SUFDN0IsSUFBSUEsUUFBUTtRQUNSLE9BQU9EO0lBQ1gsT0FDSztRQUNELE9BQU8sSUFBSTVDO0lBQ2Y7QUFDSixFQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1ob3VzaW5nLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLXBvb2wuanM/YzU2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdWJjaGFubmVsUG9vbCA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0U3ViY2hhbm5lbFBvb2wgPSBnZXRTdWJjaGFubmVsUG9vbDtcbmNvbnN0IGNoYW5uZWxfb3B0aW9uc18xID0gcmVxdWlyZShcIi4vY2hhbm5lbC1vcHRpb25zXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbFwiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IHRyYW5zcG9ydF8xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0XCIpO1xuLy8gMTAgc2Vjb25kcyBpbiBtaWxsaXNlY29uZHMuIFRoaXMgdmFsdWUgaXMgYXJiaXRyYXJ5LlxuLyoqXG4gKiBUaGUgYW1vdW50IG9mIHRpbWUgaW4gYmV0d2VlbiBjaGVja3MgZm9yIGRyb3BwaW5nIHN1YmNoYW5uZWxzIHRoYXQgaGF2ZSBub1xuICogb3RoZXIgcmVmZXJlbmNlc1xuICovXG5jb25zdCBSRUZfQ0hFQ0tfSU5URVJWQUwgPSAxMDAwMDtcbmNsYXNzIFN1YmNoYW5uZWxQb29sIHtcbiAgICAvKipcbiAgICAgKiBBIHBvb2wgb2Ygc3ViY2hhbm5lbHMgdXNlIGZvciBtYWtpbmcgY29ubmVjdGlvbnMuIFN1YmNoYW5uZWxzIHdpdGggdGhlXG4gICAgICogZXhhY3Qgc2FtZSBwYXJhbWV0ZXJzIHdpbGwgYmUgcmV1c2VkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnBvb2wgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSB0aW1lciBvZiBhIHRhc2sgcGVyZm9ybWluZyBhIHBlcmlvZGljIHN1YmNoYW5uZWwgY2xlYW51cC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5yZWZzIGFsbCB1bnVzZWQgc3ViY2hhbm5lbHMgYW5kIGNhbmNlbHMgdGhlIGNsZWFudXAgdGFzayBpZiBhbGxcbiAgICAgKiBzdWJjaGFubmVscyBoYXZlIGJlZW4gdW5yZWZlZC5cbiAgICAgKi9cbiAgICB1bnJlZlVudXNlZFN1YmNoYW5uZWxzKCkge1xuICAgICAgICBsZXQgYWxsU3ViY2hhbm5lbHNVbnJlZmVkID0gdHJ1ZTtcbiAgICAgICAgLyogVGhlc2Ugb2JqZWN0cyBhcmUgY3JlYXRlZCB3aXRoIE9iamVjdC5jcmVhdGUobnVsbCksIHNvIHRoZXkgZG8gbm90XG4gICAgICAgICAqIGhhdmUgYSBwcm90b3R5cGUsIHdoaWNoIG1lYW5zIHRoYXQgZm9yICguLi4gaW4gLi4uKSBsb29wcyBvdmVyIHRoZW1cbiAgICAgICAgICogZG8gbm90IG5lZWQgdG8gYmUgZmlsdGVyZWQgKi9cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtZGlzYWJsZS1uZXh0LWxpbmU6Zm9yaW5cbiAgICAgICAgZm9yIChjb25zdCBjaGFubmVsVGFyZ2V0IGluIHRoaXMucG9vbCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbE9iakFycmF5ID0gdGhpcy5wb29sW2NoYW5uZWxUYXJnZXRdO1xuICAgICAgICAgICAgY29uc3QgcmVmZWRTdWJjaGFubmVscyA9IHN1YmNoYW5uZWxPYmpBcnJheS5maWx0ZXIodmFsdWUgPT4gIXZhbHVlLnN1YmNoYW5uZWwudW5yZWZJZk9uZVJlZigpKTtcbiAgICAgICAgICAgIGlmIChyZWZlZFN1YmNoYW5uZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBhbGxTdWJjaGFubmVsc1VucmVmZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIEZvciBlYWNoIHN1YmNoYW5uZWwgaW4gdGhlIHBvb2wsIHRyeSB0byB1bnJlZiBpdCBpZiBpdCBoYXNcbiAgICAgICAgICAgICAqIGV4YWN0bHkgb25lIHJlZiAod2hpY2ggaXMgdGhlIHJlZiBmcm9tIHRoZSBwb29sIGl0c2VsZikuIElmIHRoYXRcbiAgICAgICAgICAgICAqIGRvZXMgaGFwcGVuLCByZW1vdmUgdGhlIHN1YmNoYW5uZWwgZnJvbSB0aGUgcG9vbCAqL1xuICAgICAgICAgICAgdGhpcy5wb29sW2NoYW5uZWxUYXJnZXRdID0gcmVmZWRTdWJjaGFubmVscztcbiAgICAgICAgfVxuICAgICAgICAvKiBDdXJyZW50bHkgd2UgZG8gbm90IGRlbGV0ZSBrZXlzIHdpdGggZW1wdHkgdmFsdWVzLiBJZiB0aGF0IHJlc3VsdHNcbiAgICAgICAgICogaW4gc2lnbmlmaWNhbnQgbWVtb3J5IHVzYWdlIHdlIHNob3VsZCBjaGFuZ2UgaXQuICovXG4gICAgICAgIC8vIENhbmNlbCB0aGUgY2xlYW51cCB0YXNrIGlmIGFsbCBzdWJjaGFubmVscyBoYXZlIGJlZW4gdW5yZWZlZC5cbiAgICAgICAgaWYgKGFsbFN1YmNoYW5uZWxzVW5yZWZlZCAmJiB0aGlzLmNsZWFudXBUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNsZWFudXBUaW1lcik7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXBUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlcyB0aGF0IHRoZSBjbGVhbnVwIHRhc2sgaXMgc3Bhd25lZC5cbiAgICAgKi9cbiAgICBlbnN1cmVDbGVhbnVwVGFzaygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuY2xlYW51cFRpbWVyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXBUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVucmVmVW51c2VkU3ViY2hhbm5lbHMoKTtcbiAgICAgICAgICAgIH0sIFJFRl9DSEVDS19JTlRFUlZBTCk7XG4gICAgICAgICAgICAvLyBVbnJlZiBiZWNhdXNlIHRoaXMgdGltZXIgc2hvdWxkIG5vdCBrZWVwIHRoZSBldmVudCBsb29wIHJ1bm5pbmcuXG4gICAgICAgICAgICAvLyBDYWxsIHVucmVmIG9ubHkgaWYgaXQgZXhpc3RzIHRvIGFkZHJlc3MgZWxlY3Ryb24vZWxlY3Ryb24jMjExNjJcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2xlYW51cFRpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHN1YmNoYW5uZWwgaWYgb25lIGFscmVhZHkgZXhpc3RzIHdpdGggZXhhY3RseSBtYXRjaGluZyBwYXJhbWV0ZXJzLlxuICAgICAqIE90aGVyd2lzZSwgY3JlYXRlIGFuZCBzYXZlIGEgc3ViY2hhbm5lbCB3aXRoIHRob3NlIHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIGNoYW5uZWxUYXJnZXRcbiAgICAgKiBAcGFyYW0gc3ViY2hhbm5lbFRhcmdldFxuICAgICAqIEBwYXJhbSBjaGFubmVsQXJndW1lbnRzXG4gICAgICogQHBhcmFtIGNoYW5uZWxDcmVkZW50aWFsc1xuICAgICAqL1xuICAgIGdldE9yQ3JlYXRlU3ViY2hhbm5lbChjaGFubmVsVGFyZ2V0VXJpLCBzdWJjaGFubmVsVGFyZ2V0LCBjaGFubmVsQXJndW1lbnRzLCBjaGFubmVsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVDbGVhbnVwVGFzaygpO1xuICAgICAgICBjb25zdCBjaGFubmVsVGFyZ2V0ID0gKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykoY2hhbm5lbFRhcmdldFVyaSk7XG4gICAgICAgIGlmIChjaGFubmVsVGFyZ2V0IGluIHRoaXMucG9vbCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbE9iakFycmF5ID0gdGhpcy5wb29sW2NoYW5uZWxUYXJnZXRdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzdWJjaGFubmVsT2JqIG9mIHN1YmNoYW5uZWxPYmpBcnJheSkge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NFcXVhbCkoc3ViY2hhbm5lbFRhcmdldCwgc3ViY2hhbm5lbE9iai5zdWJjaGFubmVsQWRkcmVzcykgJiZcbiAgICAgICAgICAgICAgICAgICAgKDAsIGNoYW5uZWxfb3B0aW9uc18xLmNoYW5uZWxPcHRpb25zRXF1YWwpKGNoYW5uZWxBcmd1bWVudHMsIHN1YmNoYW5uZWxPYmouY2hhbm5lbEFyZ3VtZW50cykgJiZcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENyZWRlbnRpYWxzLl9lcXVhbHMoc3ViY2hhbm5lbE9iai5jaGFubmVsQ3JlZGVudGlhbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJjaGFubmVsT2JqLnN1YmNoYW5uZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGdldCBoZXJlLCBubyBtYXRjaGluZyBzdWJjaGFubmVsIHdhcyBmb3VuZFxuICAgICAgICBjb25zdCBzdWJjaGFubmVsID0gbmV3IHN1YmNoYW5uZWxfMS5TdWJjaGFubmVsKGNoYW5uZWxUYXJnZXRVcmksIHN1YmNoYW5uZWxUYXJnZXQsIGNoYW5uZWxBcmd1bWVudHMsIGNoYW5uZWxDcmVkZW50aWFscywgbmV3IHRyYW5zcG9ydF8xLkh0dHAyU3ViY2hhbm5lbENvbm5lY3RvcihjaGFubmVsVGFyZ2V0VXJpKSk7XG4gICAgICAgIGlmICghKGNoYW5uZWxUYXJnZXQgaW4gdGhpcy5wb29sKSkge1xuICAgICAgICAgICAgdGhpcy5wb29sW2NoYW5uZWxUYXJnZXRdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb29sW2NoYW5uZWxUYXJnZXRdLnB1c2goe1xuICAgICAgICAgICAgc3ViY2hhbm5lbEFkZHJlc3M6IHN1YmNoYW5uZWxUYXJnZXQsXG4gICAgICAgICAgICBjaGFubmVsQXJndW1lbnRzLFxuICAgICAgICAgICAgY2hhbm5lbENyZWRlbnRpYWxzLFxuICAgICAgICAgICAgc3ViY2hhbm5lbCxcbiAgICAgICAgfSk7XG4gICAgICAgIHN1YmNoYW5uZWwucmVmKCk7XG4gICAgICAgIHJldHVybiBzdWJjaGFubmVsO1xuICAgIH1cbn1cbmV4cG9ydHMuU3ViY2hhbm5lbFBvb2wgPSBTdWJjaGFubmVsUG9vbDtcbmNvbnN0IGdsb2JhbFN1YmNoYW5uZWxQb29sID0gbmV3IFN1YmNoYW5uZWxQb29sKCk7XG4vKipcbiAqIEdldCBlaXRoZXIgdGhlIGdsb2JhbCBzdWJjaGFubmVsIHBvb2wsIG9yIGEgbmV3IHN1YmNoYW5uZWwgcG9vbC5cbiAqIEBwYXJhbSBnbG9iYWxcbiAqL1xuZnVuY3Rpb24gZ2V0U3ViY2hhbm5lbFBvb2woZ2xvYmFsKSB7XG4gICAgaWYgKGdsb2JhbCkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsU3ViY2hhbm5lbFBvb2w7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFN1YmNoYW5uZWxQb29sKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ViY2hhbm5lbC1wb29sLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlN1YmNoYW5uZWxQb29sIiwiZ2V0U3ViY2hhbm5lbFBvb2wiLCJjaGFubmVsX29wdGlvbnNfMSIsInJlcXVpcmUiLCJzdWJjaGFubmVsXzEiLCJzdWJjaGFubmVsX2FkZHJlc3NfMSIsInVyaV9wYXJzZXJfMSIsInRyYW5zcG9ydF8xIiwiUkVGX0NIRUNLX0lOVEVSVkFMIiwiY29uc3RydWN0b3IiLCJwb29sIiwiY3JlYXRlIiwiY2xlYW51cFRpbWVyIiwidW5yZWZVbnVzZWRTdWJjaGFubmVscyIsImFsbFN1YmNoYW5uZWxzVW5yZWZlZCIsImNoYW5uZWxUYXJnZXQiLCJzdWJjaGFubmVsT2JqQXJyYXkiLCJyZWZlZFN1YmNoYW5uZWxzIiwiZmlsdGVyIiwic3ViY2hhbm5lbCIsInVucmVmSWZPbmVSZWYiLCJsZW5ndGgiLCJjbGVhckludGVydmFsIiwiZW5zdXJlQ2xlYW51cFRhc2siLCJfYSIsIl9iIiwic2V0SW50ZXJ2YWwiLCJ1bnJlZiIsImNhbGwiLCJnZXRPckNyZWF0ZVN1YmNoYW5uZWwiLCJjaGFubmVsVGFyZ2V0VXJpIiwic3ViY2hhbm5lbFRhcmdldCIsImNoYW5uZWxBcmd1bWVudHMiLCJjaGFubmVsQ3JlZGVudGlhbHMiLCJ1cmlUb1N0cmluZyIsInN1YmNoYW5uZWxPYmoiLCJzdWJjaGFubmVsQWRkcmVzc0VxdWFsIiwic3ViY2hhbm5lbEFkZHJlc3MiLCJjaGFubmVsT3B0aW9uc0VxdWFsIiwiX2VxdWFscyIsIlN1YmNoYW5uZWwiLCJIdHRwMlN1YmNoYW5uZWxDb25uZWN0b3IiLCJwdXNoIiwicmVmIiwiZ2xvYmFsU3ViY2hhbm5lbFBvb2wiLCJnbG9iYWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Subchannel = void 0;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst TRACER_NAME = \"subchannel\";\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */ const KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nclass Subchannel {\n    /**\n     * A class representing a connection to a single backend.\n     * @param channelTarget The target string for the channel as a whole\n     * @param subchannelAddress The address for the backend that this subchannel\n     *     will connect to\n     * @param options The channel options, plus any specific subchannel options\n     *     for this subchannel\n     * @param credentials The channel credentials used to establish this\n     *     connection\n     */ constructor(channelTarget, subchannelAddress, options, credentials, connector){\n        var _a;\n        this.channelTarget = channelTarget;\n        this.subchannelAddress = subchannelAddress;\n        this.options = options;\n        this.connector = connector;\n        /**\n         * The subchannel's current connectivity state. Invariant: `session` === `null`\n         * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n         */ this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The underlying http2 session used to make requests.\n         */ this.transport = null;\n        /**\n         * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n         * CONNECTING instead of IDLE when the backoff timeout ends.\n         */ this.continueConnecting = false;\n        /**\n         * A list of listener functions that will be called whenever the connectivity\n         * state changes. Will be modified by `addConnectivityStateListener` and\n         * `removeConnectivityStateListener`\n         */ this.stateListeners = new Set();\n        /**\n         * Tracks channels and subchannel pools with references to this subchannel\n         */ this.refcount = 0;\n        // Channelz info\n        this.channelzEnabled = true;\n        const backoffOptions = {\n            initialDelay: options[\"grpc.initial_reconnect_backoff_ms\"],\n            maxDelay: options[\"grpc.max_reconnect_backoff_ms\"]\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(()=>{\n            this.handleBackoffTimer();\n        }, backoffOptions);\n        this.backoffTimeout.unref();\n        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n        this.keepaliveTime = (_a = options[\"grpc.keepalive_time_ms\"]) !== null && _a !== void 0 ? _a : -1;\n        if (options[\"grpc.enable_channelz\"] === 0) {\n            this.channelzEnabled = false;\n            this.channelzTrace = new channelz_1.ChannelzTraceStub();\n            this.callTracker = new channelz_1.ChannelzCallTrackerStub();\n            this.childrenTracker = new channelz_1.ChannelzChildrenTrackerStub();\n            this.streamTracker = new channelz_1.ChannelzCallTrackerStub();\n        } else {\n            this.channelzTrace = new channelz_1.ChannelzTrace();\n            this.callTracker = new channelz_1.ChannelzCallTracker();\n            this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n            this.streamTracker = new channelz_1.ChannelzCallTracker();\n        }\n        this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, ()=>this.getChannelzInfo(), this.channelzEnabled);\n        this.channelzTrace.addTrace(\"CT_INFO\", \"Subchannel created\");\n        this.trace(\"Subchannel constructed with options \" + JSON.stringify(options, undefined, 2));\n        this.secureConnector = credentials._createSecureConnector(channelTarget, options);\n    }\n    getChannelzInfo() {\n        return {\n            state: this.connectivityState,\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            children: this.childrenTracker.getChildLists(),\n            target: this.subchannelAddressString\n        };\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    refTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, \"subchannel_refcount\", \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    handleBackoffTimer() {\n        if (this.continueConnecting) {\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE\n            ], connectivity_state_1.ConnectivityState.CONNECTING);\n        } else {\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE\n            ], connectivity_state_1.ConnectivityState.IDLE);\n        }\n    }\n    /**\n     * Start a backoff timer with the current nextBackoff timeout\n     */ startBackoff() {\n        this.backoffTimeout.runOnce();\n    }\n    stopBackoff() {\n        this.backoffTimeout.stop();\n        this.backoffTimeout.reset();\n    }\n    startConnectingInternal() {\n        let options = this.options;\n        if (options[\"grpc.keepalive_time_ms\"]) {\n            const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);\n            options = Object.assign(Object.assign({}, options), {\n                \"grpc.keepalive_time_ms\": adjustedKeepaliveTime\n            });\n        }\n        this.connector.connect(this.subchannelAddress, this.secureConnector, options).then((transport)=>{\n            if (this.transitionToState([\n                connectivity_state_1.ConnectivityState.CONNECTING\n            ], connectivity_state_1.ConnectivityState.READY)) {\n                this.transport = transport;\n                if (this.channelzEnabled) {\n                    this.childrenTracker.refChild(transport.getChannelzRef());\n                }\n                transport.addDisconnectListener((tooManyPings)=>{\n                    this.transitionToState([\n                        connectivity_state_1.ConnectivityState.READY\n                    ], connectivity_state_1.ConnectivityState.IDLE);\n                    if (tooManyPings && this.keepaliveTime > 0) {\n                        this.keepaliveTime *= 2;\n                        logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTime} ms`);\n                    }\n                });\n            } else {\n                /* If we can't transition from CONNECTING to READY here, we will\n                 * not be using this transport, so release its resources. */ transport.shutdown();\n            }\n        }, (error)=>{\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.CONNECTING\n            ], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, `${error}`);\n        });\n    }\n    /**\n     * Initiate a state transition from any element of oldStates to the new\n     * state. If the current connectivityState is not in oldStates, do nothing.\n     * @param oldStates The set of states to transition from\n     * @param newState The state to transition to\n     * @returns True if the state changed, false otherwise\n     */ transitionToState(oldStates, newState, errorMessage) {\n        var _a, _b;\n        if (oldStates.indexOf(this.connectivityState) === -1) {\n            return false;\n        }\n        if (errorMessage) {\n            this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + \" -> \" + connectivity_state_1.ConnectivityState[newState] + ' with error \"' + errorMessage + '\"');\n        } else {\n            this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        }\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Connectivity state change to \" + connectivity_state_1.ConnectivityState[newState]);\n        }\n        const previousState = this.connectivityState;\n        this.connectivityState = newState;\n        switch(newState){\n            case connectivity_state_1.ConnectivityState.READY:\n                this.stopBackoff();\n                break;\n            case connectivity_state_1.ConnectivityState.CONNECTING:\n                this.startBackoff();\n                this.startConnectingInternal();\n                this.continueConnecting = false;\n                break;\n            case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n                if (this.channelzEnabled && this.transport) {\n                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n                }\n                (_a = this.transport) === null || _a === void 0 ? void 0 : _a.shutdown();\n                this.transport = null;\n                /* If the backoff timer has already ended by the time we get to the\n                 * TRANSIENT_FAILURE state, we want to immediately transition out of\n                 * TRANSIENT_FAILURE as though the backoff timer is ending right now */ if (!this.backoffTimeout.isRunning()) {\n                    process.nextTick(()=>{\n                        this.handleBackoffTimer();\n                    });\n                }\n                break;\n            case connectivity_state_1.ConnectivityState.IDLE:\n                if (this.channelzEnabled && this.transport) {\n                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n                }\n                (_b = this.transport) === null || _b === void 0 ? void 0 : _b.shutdown();\n                this.transport = null;\n                break;\n            default:\n                throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n        }\n        for (const listener of this.stateListeners){\n            listener(this, previousState, newState, this.keepaliveTime, errorMessage);\n        }\n        return true;\n    }\n    ref() {\n        this.refTrace(\"refcount \" + this.refcount + \" -> \" + (this.refcount + 1));\n        this.refcount += 1;\n    }\n    unref() {\n        this.refTrace(\"refcount \" + this.refcount + \" -> \" + (this.refcount - 1));\n        this.refcount -= 1;\n        if (this.refcount === 0) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Shutting down\");\n            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n            this.secureConnector.destroy();\n            process.nextTick(()=>{\n                this.transitionToState([\n                    connectivity_state_1.ConnectivityState.CONNECTING,\n                    connectivity_state_1.ConnectivityState.READY\n                ], connectivity_state_1.ConnectivityState.IDLE);\n            });\n        }\n    }\n    unrefIfOneRef() {\n        if (this.refcount === 1) {\n            this.unref();\n            return true;\n        }\n        return false;\n    }\n    createCall(metadata, host, method, listener) {\n        if (!this.transport) {\n            throw new Error(\"Cannot create call, subchannel not READY\");\n        }\n        let statsTracker;\n        if (this.channelzEnabled) {\n            this.callTracker.addCallStarted();\n            this.streamTracker.addCallStarted();\n            statsTracker = {\n                onCallEnd: (status)=>{\n                    if (status.code === constants_1.Status.OK) {\n                        this.callTracker.addCallSucceeded();\n                    } else {\n                        this.callTracker.addCallFailed();\n                    }\n                }\n            };\n        } else {\n            statsTracker = {};\n        }\n        return this.transport.createCall(metadata, host, method, listener, statsTracker);\n    }\n    /**\n     * If the subchannel is currently IDLE, start connecting and switch to the\n     * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n     * the next time it would transition to IDLE, start connecting again instead.\n     * Otherwise, do nothing.\n     */ startConnecting() {\n        process.nextTick(()=>{\n            /* First, try to transition from IDLE to connecting. If that doesn't happen\n             * because the state is not currently IDLE, check if it is\n             * TRANSIENT_FAILURE, and if so indicate that it should go back to\n             * connecting after the backoff timer ends. Otherwise do nothing */ if (!this.transitionToState([\n                connectivity_state_1.ConnectivityState.IDLE\n            ], connectivity_state_1.ConnectivityState.CONNECTING)) {\n                if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                    this.continueConnecting = true;\n                }\n            }\n        });\n    }\n    /**\n     * Get the subchannel's current connectivity state.\n     */ getConnectivityState() {\n        return this.connectivityState;\n    }\n    /**\n     * Add a listener function to be called whenever the subchannel's\n     * connectivity state changes.\n     * @param listener\n     */ addConnectivityStateListener(listener) {\n        this.stateListeners.add(listener);\n    }\n    /**\n     * Remove a listener previously added with `addConnectivityStateListener`\n     * @param listener A reference to a function previously passed to\n     *     `addConnectivityStateListener`\n     */ removeConnectivityStateListener(listener) {\n        this.stateListeners.delete(listener);\n    }\n    /**\n     * Reset the backoff timeout, and immediately start connecting if in backoff.\n     */ resetBackoff() {\n        process.nextTick(()=>{\n            this.backoffTimeout.reset();\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE\n            ], connectivity_state_1.ConnectivityState.CONNECTING);\n        });\n    }\n    getAddress() {\n        return this.subchannelAddressString;\n    }\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    isHealthy() {\n        return true;\n    }\n    addHealthStateWatcher(listener) {\n    // Do nothing with the listener\n    }\n    removeHealthStateWatcher(listener) {\n    // Do nothing with the listener\n    }\n    getRealSubchannel() {\n        return this;\n    }\n    realSubchannelEquals(other) {\n        return other.getRealSubchannel() === this;\n    }\n    throttleKeepalive(newKeepaliveTime) {\n        if (newKeepaliveTime > this.keepaliveTime) {\n            this.keepaliveTime = newKeepaliveTime;\n        }\n    }\n    getCallCredentials() {\n        return this.secureConnector.getCallCredentials();\n    }\n}\nexports.Subchannel = Subchannel; //# sourceMappingURL=subchannel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0JBQWtCLEdBQUcsS0FBSztBQUMxQixNQUFNRyx1QkFBdUJDLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNQyxvQkFBb0JELG1CQUFPQSxDQUFDLDBGQUFtQjtBQUNyRCxNQUFNRSxVQUFVRixtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNRyxjQUFjSCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNSSxlQUFlSixtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNSyx1QkFBdUJMLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNTSxhQUFhTixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNTyxjQUFjO0FBQ3BCOzttQkFFbUIsR0FDbkIsTUFBTUMsd0JBQXdCLENBQUUsTUFBSyxFQUFDO0FBQ3RDLE1BQU1WO0lBQ0Y7Ozs7Ozs7OztLQVNDLEdBQ0RXLFlBQVlDLGFBQWEsRUFBRUMsaUJBQWlCLEVBQUVDLE9BQU8sRUFBRUMsV0FBVyxFQUFFQyxTQUFTLENBQUU7UUFDM0UsSUFBSUM7UUFDSixJQUFJLENBQUNMLGFBQWEsR0FBR0E7UUFDckIsSUFBSSxDQUFDQyxpQkFBaUIsR0FBR0E7UUFDekIsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDRSxTQUFTLEdBQUdBO1FBQ2pCOzs7U0FHQyxHQUNELElBQUksQ0FBQ0UsaUJBQWlCLEdBQUdqQixxQkFBcUJrQixpQkFBaUIsQ0FBQ0MsSUFBSTtRQUNwRTs7U0FFQyxHQUNELElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCOzs7U0FHQyxHQUNELElBQUksQ0FBQ0Msa0JBQWtCLEdBQUc7UUFDMUI7Ozs7U0FJQyxHQUNELElBQUksQ0FBQ0MsY0FBYyxHQUFHLElBQUlDO1FBQzFCOztTQUVDLEdBQ0QsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsZ0JBQWdCO1FBQ2hCLElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3ZCLE1BQU1DLGlCQUFpQjtZQUNuQkMsY0FBY2QsT0FBTyxDQUFDLG9DQUFvQztZQUMxRGUsVUFBVWYsT0FBTyxDQUFDLGdDQUFnQztRQUN0RDtRQUNBLElBQUksQ0FBQ2dCLGNBQWMsR0FBRyxJQUFJM0Isa0JBQWtCNEIsY0FBYyxDQUFDO1lBQ3ZELElBQUksQ0FBQ0Msa0JBQWtCO1FBQzNCLEdBQUdMO1FBQ0gsSUFBSSxDQUFDRyxjQUFjLENBQUNHLEtBQUs7UUFDekIsSUFBSSxDQUFDQyx1QkFBdUIsR0FBRyxDQUFDLEdBQUczQixxQkFBcUI0Qix5QkFBeUIsRUFBRXRCO1FBQ25GLElBQUksQ0FBQ3VCLGFBQWEsR0FBRyxDQUFDbkIsS0FBS0gsT0FBTyxDQUFDLHlCQUF5QixNQUFNLFFBQVFHLE9BQU8sS0FBSyxJQUFJQSxLQUFLLENBQUM7UUFDaEcsSUFBSUgsT0FBTyxDQUFDLHVCQUF1QixLQUFLLEdBQUc7WUFDdkMsSUFBSSxDQUFDWSxlQUFlLEdBQUc7WUFDdkIsSUFBSSxDQUFDVyxhQUFhLEdBQUcsSUFBSTdCLFdBQVc4QixpQkFBaUI7WUFDckQsSUFBSSxDQUFDQyxXQUFXLEdBQUcsSUFBSS9CLFdBQVdnQyx1QkFBdUI7WUFDekQsSUFBSSxDQUFDQyxlQUFlLEdBQUcsSUFBSWpDLFdBQVdrQywyQkFBMkI7WUFDakUsSUFBSSxDQUFDQyxhQUFhLEdBQUcsSUFBSW5DLFdBQVdnQyx1QkFBdUI7UUFDL0QsT0FDSztZQUNELElBQUksQ0FBQ0gsYUFBYSxHQUFHLElBQUk3QixXQUFXb0MsYUFBYTtZQUNqRCxJQUFJLENBQUNMLFdBQVcsR0FBRyxJQUFJL0IsV0FBV3FDLG1CQUFtQjtZQUNyRCxJQUFJLENBQUNKLGVBQWUsR0FBRyxJQUFJakMsV0FBV3NDLHVCQUF1QjtZQUM3RCxJQUFJLENBQUNILGFBQWEsR0FBRyxJQUFJbkMsV0FBV3FDLG1CQUFtQjtRQUMzRDtRQUNBLElBQUksQ0FBQ0UsV0FBVyxHQUFHLENBQUMsR0FBR3ZDLFdBQVd3QywwQkFBMEIsRUFBRSxJQUFJLENBQUNkLHVCQUF1QixFQUFFLElBQU0sSUFBSSxDQUFDZSxlQUFlLElBQUksSUFBSSxDQUFDdkIsZUFBZTtRQUM5SSxJQUFJLENBQUNXLGFBQWEsQ0FBQ2EsUUFBUSxDQUFDLFdBQVc7UUFDdkMsSUFBSSxDQUFDQyxLQUFLLENBQUMseUNBQ1BDLEtBQUtDLFNBQVMsQ0FBQ3ZDLFNBQVN3QyxXQUFXO1FBQ3ZDLElBQUksQ0FBQ0MsZUFBZSxHQUFHeEMsWUFBWXlDLHNCQUFzQixDQUFDNUMsZUFBZUU7SUFDN0U7SUFDQW1DLGtCQUFrQjtRQUNkLE9BQU87WUFDSFEsT0FBTyxJQUFJLENBQUN2QyxpQkFBaUI7WUFDN0JpQyxPQUFPLElBQUksQ0FBQ2QsYUFBYTtZQUN6QkUsYUFBYSxJQUFJLENBQUNBLFdBQVc7WUFDN0JtQixVQUFVLElBQUksQ0FBQ2pCLGVBQWUsQ0FBQ2tCLGFBQWE7WUFDNUNDLFFBQVEsSUFBSSxDQUFDMUIsdUJBQXVCO1FBQ3hDO0lBQ0o7SUFDQWlCLE1BQU1VLElBQUksRUFBRTtRQUNSekQsUUFBUStDLEtBQUssQ0FBQzlDLFlBQVl5RCxZQUFZLENBQUNDLEtBQUssRUFBRXRELGFBQWEsTUFDdkQsSUFBSSxDQUFDc0MsV0FBVyxDQUFDaUIsRUFBRSxHQUNuQixPQUNBLElBQUksQ0FBQzlCLHVCQUF1QixHQUM1QixNQUNBMkI7SUFDUjtJQUNBSSxTQUFTSixJQUFJLEVBQUU7UUFDWHpELFFBQVErQyxLQUFLLENBQUM5QyxZQUFZeUQsWUFBWSxDQUFDQyxLQUFLLEVBQUUsdUJBQXVCLE1BQ2pFLElBQUksQ0FBQ2hCLFdBQVcsQ0FBQ2lCLEVBQUUsR0FDbkIsT0FDQSxJQUFJLENBQUM5Qix1QkFBdUIsR0FDNUIsTUFDQTJCO0lBQ1I7SUFDQTdCLHFCQUFxQjtRQUNqQixJQUFJLElBQUksQ0FBQ1Ysa0JBQWtCLEVBQUU7WUFDekIsSUFBSSxDQUFDNEMsaUJBQWlCLENBQUM7Z0JBQUNqRSxxQkFBcUJrQixpQkFBaUIsQ0FBQ2dELGlCQUFpQjthQUFDLEVBQUVsRSxxQkFBcUJrQixpQkFBaUIsQ0FBQ2lELFVBQVU7UUFDeEksT0FDSztZQUNELElBQUksQ0FBQ0YsaUJBQWlCLENBQUM7Z0JBQUNqRSxxQkFBcUJrQixpQkFBaUIsQ0FBQ2dELGlCQUFpQjthQUFDLEVBQUVsRSxxQkFBcUJrQixpQkFBaUIsQ0FBQ0MsSUFBSTtRQUNsSTtJQUNKO0lBQ0E7O0tBRUMsR0FDRGlELGVBQWU7UUFDWCxJQUFJLENBQUN2QyxjQUFjLENBQUN3QyxPQUFPO0lBQy9CO0lBQ0FDLGNBQWM7UUFDVixJQUFJLENBQUN6QyxjQUFjLENBQUMwQyxJQUFJO1FBQ3hCLElBQUksQ0FBQzFDLGNBQWMsQ0FBQzJDLEtBQUs7SUFDN0I7SUFDQUMsMEJBQTBCO1FBQ3RCLElBQUk1RCxVQUFVLElBQUksQ0FBQ0EsT0FBTztRQUMxQixJQUFJQSxPQUFPLENBQUMseUJBQXlCLEVBQUU7WUFDbkMsTUFBTTZELHdCQUF3QkMsS0FBS0MsR0FBRyxDQUFDLElBQUksQ0FBQ3pDLGFBQWEsRUFBRTFCO1lBQzNESSxVQUFVbEIsT0FBT2tGLE1BQU0sQ0FBQ2xGLE9BQU9rRixNQUFNLENBQUMsQ0FBQyxHQUFHaEUsVUFBVTtnQkFBRSwwQkFBMEI2RDtZQUFzQjtRQUMxRztRQUNBLElBQUksQ0FBQzNELFNBQVMsQ0FDVCtELE9BQU8sQ0FBQyxJQUFJLENBQUNsRSxpQkFBaUIsRUFBRSxJQUFJLENBQUMwQyxlQUFlLEVBQUV6QyxTQUN0RGtFLElBQUksQ0FBQzNELENBQUFBO1lBQ04sSUFBSSxJQUFJLENBQUM2QyxpQkFBaUIsQ0FBQztnQkFBQ2pFLHFCQUFxQmtCLGlCQUFpQixDQUFDaUQsVUFBVTthQUFDLEVBQUVuRSxxQkFBcUJrQixpQkFBaUIsQ0FBQzhELEtBQUssR0FBRztnQkFDM0gsSUFBSSxDQUFDNUQsU0FBUyxHQUFHQTtnQkFDakIsSUFBSSxJQUFJLENBQUNLLGVBQWUsRUFBRTtvQkFDdEIsSUFBSSxDQUFDZSxlQUFlLENBQUN5QyxRQUFRLENBQUM3RCxVQUFVOEQsY0FBYztnQkFDMUQ7Z0JBQ0E5RCxVQUFVK0QscUJBQXFCLENBQUNDLENBQUFBO29CQUM1QixJQUFJLENBQUNuQixpQkFBaUIsQ0FBQzt3QkFBQ2pFLHFCQUFxQmtCLGlCQUFpQixDQUFDOEQsS0FBSztxQkFBQyxFQUFFaEYscUJBQXFCa0IsaUJBQWlCLENBQUNDLElBQUk7b0JBQ2xILElBQUlpRSxnQkFBZ0IsSUFBSSxDQUFDakQsYUFBYSxHQUFHLEdBQUc7d0JBQ3hDLElBQUksQ0FBQ0EsYUFBYSxJQUFJO3dCQUN0QmhDLFFBQVFrRixHQUFHLENBQUNqRixZQUFZeUQsWUFBWSxDQUFDeUIsS0FBSyxFQUFFLENBQUMsY0FBYyxFQUFFLENBQUMsR0FBR2pGLGFBQWFrRixXQUFXLEVBQUUsSUFBSSxDQUFDNUUsYUFBYSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUNzQix1QkFBdUIsQ0FBQyx5RUFBeUUsRUFBRSxJQUFJLENBQUNFLGFBQWEsQ0FBQyxHQUFHLENBQUM7b0JBQ3hQO2dCQUNKO1lBQ0osT0FDSztnQkFDRDswRUFDMEQsR0FDMURmLFVBQVVvRSxRQUFRO1lBQ3RCO1FBQ0osR0FBR0MsQ0FBQUE7WUFDQyxJQUFJLENBQUN4QixpQkFBaUIsQ0FBQztnQkFBQ2pFLHFCQUFxQmtCLGlCQUFpQixDQUFDaUQsVUFBVTthQUFDLEVBQUVuRSxxQkFBcUJrQixpQkFBaUIsQ0FBQ2dELGlCQUFpQixFQUFFLENBQUMsRUFBRXVCLE1BQU0sQ0FBQztRQUNwSjtJQUNKO0lBQ0E7Ozs7OztLQU1DLEdBQ0R4QixrQkFBa0J5QixTQUFTLEVBQUVDLFFBQVEsRUFBRUMsWUFBWSxFQUFFO1FBQ2pELElBQUk1RSxJQUFJNkU7UUFDUixJQUFJSCxVQUFVSSxPQUFPLENBQUMsSUFBSSxDQUFDN0UsaUJBQWlCLE1BQU0sQ0FBQyxHQUFHO1lBQ2xELE9BQU87UUFDWDtRQUNBLElBQUkyRSxjQUFjO1lBQ2QsSUFBSSxDQUFDMUMsS0FBSyxDQUFDbEQscUJBQXFCa0IsaUJBQWlCLENBQUMsSUFBSSxDQUFDRCxpQkFBaUIsQ0FBQyxHQUNyRSxTQUNBakIscUJBQXFCa0IsaUJBQWlCLENBQUN5RSxTQUFTLEdBQ2hELGtCQUFrQkMsZUFBZTtRQUN6QyxPQUNLO1lBQ0QsSUFBSSxDQUFDMUMsS0FBSyxDQUFDbEQscUJBQXFCa0IsaUJBQWlCLENBQUMsSUFBSSxDQUFDRCxpQkFBaUIsQ0FBQyxHQUNyRSxTQUNBakIscUJBQXFCa0IsaUJBQWlCLENBQUN5RSxTQUFTO1FBQ3hEO1FBQ0EsSUFBSSxJQUFJLENBQUNsRSxlQUFlLEVBQUU7WUFDdEIsSUFBSSxDQUFDVyxhQUFhLENBQUNhLFFBQVEsQ0FBQyxXQUFXLGtDQUFrQ2pELHFCQUFxQmtCLGlCQUFpQixDQUFDeUUsU0FBUztRQUM3SDtRQUNBLE1BQU1JLGdCQUFnQixJQUFJLENBQUM5RSxpQkFBaUI7UUFDNUMsSUFBSSxDQUFDQSxpQkFBaUIsR0FBRzBFO1FBQ3pCLE9BQVFBO1lBQ0osS0FBSzNGLHFCQUFxQmtCLGlCQUFpQixDQUFDOEQsS0FBSztnQkFDN0MsSUFBSSxDQUFDVixXQUFXO2dCQUNoQjtZQUNKLEtBQUt0RSxxQkFBcUJrQixpQkFBaUIsQ0FBQ2lELFVBQVU7Z0JBQ2xELElBQUksQ0FBQ0MsWUFBWTtnQkFDakIsSUFBSSxDQUFDSyx1QkFBdUI7Z0JBQzVCLElBQUksQ0FBQ3BELGtCQUFrQixHQUFHO2dCQUMxQjtZQUNKLEtBQUtyQixxQkFBcUJrQixpQkFBaUIsQ0FBQ2dELGlCQUFpQjtnQkFDekQsSUFBSSxJQUFJLENBQUN6QyxlQUFlLElBQUksSUFBSSxDQUFDTCxTQUFTLEVBQUU7b0JBQ3hDLElBQUksQ0FBQ29CLGVBQWUsQ0FBQ3dELFVBQVUsQ0FBQyxJQUFJLENBQUM1RSxTQUFTLENBQUM4RCxjQUFjO2dCQUNqRTtnQkFDQ2xFLENBQUFBLEtBQUssSUFBSSxDQUFDSSxTQUFTLE1BQU0sUUFBUUosT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHd0UsUUFBUTtnQkFDdEUsSUFBSSxDQUFDcEUsU0FBUyxHQUFHO2dCQUNqQjs7cUZBRXFFLEdBQ3JFLElBQUksQ0FBQyxJQUFJLENBQUNTLGNBQWMsQ0FBQ29FLFNBQVMsSUFBSTtvQkFDbENDLFFBQVFDLFFBQVEsQ0FBQzt3QkFDYixJQUFJLENBQUNwRSxrQkFBa0I7b0JBQzNCO2dCQUNKO2dCQUNBO1lBQ0osS0FBSy9CLHFCQUFxQmtCLGlCQUFpQixDQUFDQyxJQUFJO2dCQUM1QyxJQUFJLElBQUksQ0FBQ00sZUFBZSxJQUFJLElBQUksQ0FBQ0wsU0FBUyxFQUFFO29CQUN4QyxJQUFJLENBQUNvQixlQUFlLENBQUN3RCxVQUFVLENBQUMsSUFBSSxDQUFDNUUsU0FBUyxDQUFDOEQsY0FBYztnQkFDakU7Z0JBQ0NXLENBQUFBLEtBQUssSUFBSSxDQUFDekUsU0FBUyxNQUFNLFFBQVF5RSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdMLFFBQVE7Z0JBQ3RFLElBQUksQ0FBQ3BFLFNBQVMsR0FBRztnQkFDakI7WUFDSjtnQkFDSSxNQUFNLElBQUlnRixNQUFNLENBQUMseUNBQXlDLEVBQUVULFNBQVMsQ0FBQztRQUM5RTtRQUNBLEtBQUssTUFBTVUsWUFBWSxJQUFJLENBQUMvRSxjQUFjLENBQUU7WUFDeEMrRSxTQUFTLElBQUksRUFBRU4sZUFBZUosVUFBVSxJQUFJLENBQUN4RCxhQUFhLEVBQUV5RDtRQUNoRTtRQUNBLE9BQU87SUFDWDtJQUNBVSxNQUFNO1FBQ0YsSUFBSSxDQUFDdEMsUUFBUSxDQUFDLGNBQWMsSUFBSSxDQUFDeEMsUUFBUSxHQUFHLFNBQVUsS0FBSSxDQUFDQSxRQUFRLEdBQUc7UUFDdEUsSUFBSSxDQUFDQSxRQUFRLElBQUk7SUFDckI7SUFDQVEsUUFBUTtRQUNKLElBQUksQ0FBQ2dDLFFBQVEsQ0FBQyxjQUFjLElBQUksQ0FBQ3hDLFFBQVEsR0FBRyxTQUFVLEtBQUksQ0FBQ0EsUUFBUSxHQUFHO1FBQ3RFLElBQUksQ0FBQ0EsUUFBUSxJQUFJO1FBQ2pCLElBQUksSUFBSSxDQUFDQSxRQUFRLEtBQUssR0FBRztZQUNyQixJQUFJLENBQUNZLGFBQWEsQ0FBQ2EsUUFBUSxDQUFDLFdBQVc7WUFDdEMsSUFBRzFDLFdBQVdnRyxxQkFBcUIsRUFBRSxJQUFJLENBQUN6RCxXQUFXO1lBQ3RELElBQUksQ0FBQ1EsZUFBZSxDQUFDa0QsT0FBTztZQUM1Qk4sUUFBUUMsUUFBUSxDQUFDO2dCQUNiLElBQUksQ0FBQ2xDLGlCQUFpQixDQUFDO29CQUFDakUscUJBQXFCa0IsaUJBQWlCLENBQUNpRCxVQUFVO29CQUFFbkUscUJBQXFCa0IsaUJBQWlCLENBQUM4RCxLQUFLO2lCQUFDLEVBQUVoRixxQkFBcUJrQixpQkFBaUIsQ0FBQ0MsSUFBSTtZQUN6SztRQUNKO0lBQ0o7SUFDQXNGLGdCQUFnQjtRQUNaLElBQUksSUFBSSxDQUFDakYsUUFBUSxLQUFLLEdBQUc7WUFDckIsSUFBSSxDQUFDUSxLQUFLO1lBQ1YsT0FBTztRQUNYO1FBQ0EsT0FBTztJQUNYO0lBQ0EwRSxXQUFXQyxRQUFRLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFUixRQUFRLEVBQUU7UUFDekMsSUFBSSxDQUFDLElBQUksQ0FBQ2pGLFNBQVMsRUFBRTtZQUNqQixNQUFNLElBQUlnRixNQUFNO1FBQ3BCO1FBQ0EsSUFBSVU7UUFDSixJQUFJLElBQUksQ0FBQ3JGLGVBQWUsRUFBRTtZQUN0QixJQUFJLENBQUNhLFdBQVcsQ0FBQ3lFLGNBQWM7WUFDL0IsSUFBSSxDQUFDckUsYUFBYSxDQUFDcUUsY0FBYztZQUNqQ0QsZUFBZTtnQkFDWEUsV0FBV0MsQ0FBQUE7b0JBQ1AsSUFBSUEsT0FBT0MsSUFBSSxLQUFLOUcsWUFBWStHLE1BQU0sQ0FBQ0MsRUFBRSxFQUFFO3dCQUN2QyxJQUFJLENBQUM5RSxXQUFXLENBQUMrRSxnQkFBZ0I7b0JBQ3JDLE9BQ0s7d0JBQ0QsSUFBSSxDQUFDL0UsV0FBVyxDQUFDZ0YsYUFBYTtvQkFDbEM7Z0JBQ0o7WUFDSjtRQUNKLE9BQ0s7WUFDRFIsZUFBZSxDQUFDO1FBQ3BCO1FBQ0EsT0FBTyxJQUFJLENBQUMxRixTQUFTLENBQUNzRixVQUFVLENBQUNDLFVBQVVDLE1BQU1DLFFBQVFSLFVBQVVTO0lBQ3ZFO0lBQ0E7Ozs7O0tBS0MsR0FDRFMsa0JBQWtCO1FBQ2RyQixRQUFRQyxRQUFRLENBQUM7WUFDYjs7OzZFQUdpRSxHQUNqRSxJQUFJLENBQUMsSUFBSSxDQUFDbEMsaUJBQWlCLENBQUM7Z0JBQUNqRSxxQkFBcUJrQixpQkFBaUIsQ0FBQ0MsSUFBSTthQUFDLEVBQUVuQixxQkFBcUJrQixpQkFBaUIsQ0FBQ2lELFVBQVUsR0FBRztnQkFDM0gsSUFBSSxJQUFJLENBQUNsRCxpQkFBaUIsS0FBS2pCLHFCQUFxQmtCLGlCQUFpQixDQUFDZ0QsaUJBQWlCLEVBQUU7b0JBQ3JGLElBQUksQ0FBQzdDLGtCQUFrQixHQUFHO2dCQUM5QjtZQUNKO1FBQ0o7SUFDSjtJQUNBOztLQUVDLEdBQ0RtRyx1QkFBdUI7UUFDbkIsT0FBTyxJQUFJLENBQUN2RyxpQkFBaUI7SUFDakM7SUFDQTs7OztLQUlDLEdBQ0R3Ryw2QkFBNkJwQixRQUFRLEVBQUU7UUFDbkMsSUFBSSxDQUFDL0UsY0FBYyxDQUFDb0csR0FBRyxDQUFDckI7SUFDNUI7SUFDQTs7OztLQUlDLEdBQ0RzQixnQ0FBZ0N0QixRQUFRLEVBQUU7UUFDdEMsSUFBSSxDQUFDL0UsY0FBYyxDQUFDc0csTUFBTSxDQUFDdkI7SUFDL0I7SUFDQTs7S0FFQyxHQUNEd0IsZUFBZTtRQUNYM0IsUUFBUUMsUUFBUSxDQUFDO1lBQ2IsSUFBSSxDQUFDdEUsY0FBYyxDQUFDMkMsS0FBSztZQUN6QixJQUFJLENBQUNQLGlCQUFpQixDQUFDO2dCQUFDakUscUJBQXFCa0IsaUJBQWlCLENBQUNnRCxpQkFBaUI7YUFBQyxFQUFFbEUscUJBQXFCa0IsaUJBQWlCLENBQUNpRCxVQUFVO1FBQ3hJO0lBQ0o7SUFDQTJELGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQzdGLHVCQUF1QjtJQUN2QztJQUNBaUQsaUJBQWlCO1FBQ2IsT0FBTyxJQUFJLENBQUNwQyxXQUFXO0lBQzNCO0lBQ0FpRixZQUFZO1FBQ1IsT0FBTztJQUNYO0lBQ0FDLHNCQUFzQjNCLFFBQVEsRUFBRTtJQUM1QiwrQkFBK0I7SUFDbkM7SUFDQTRCLHlCQUF5QjVCLFFBQVEsRUFBRTtJQUMvQiwrQkFBK0I7SUFDbkM7SUFDQTZCLG9CQUFvQjtRQUNoQixPQUFPLElBQUk7SUFDZjtJQUNBQyxxQkFBcUJDLEtBQUssRUFBRTtRQUN4QixPQUFPQSxNQUFNRixpQkFBaUIsT0FBTyxJQUFJO0lBQzdDO0lBQ0FHLGtCQUFrQkMsZ0JBQWdCLEVBQUU7UUFDaEMsSUFBSUEsbUJBQW1CLElBQUksQ0FBQ25HLGFBQWEsRUFBRTtZQUN2QyxJQUFJLENBQUNBLGFBQWEsR0FBR21HO1FBQ3pCO0lBQ0o7SUFDQUMscUJBQXFCO1FBQ2pCLE9BQU8sSUFBSSxDQUFDakYsZUFBZSxDQUFDaUYsa0JBQWtCO0lBQ2xEO0FBQ0o7QUFDQTFJLGtCQUFrQixHQUFHRSxZQUNyQixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC5qcz84ODc2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN1YmNoYW5uZWwgPSB2b2lkIDA7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IGJhY2tvZmZfdGltZW91dF8xID0gcmVxdWlyZShcIi4vYmFja29mZi10aW1lb3V0XCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IGNoYW5uZWx6XzEgPSByZXF1aXJlKFwiLi9jaGFubmVselwiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3N1YmNoYW5uZWwnO1xuLyogc2V0SW50ZXJ2YWwgYW5kIHNldFRpbWVvdXQgb25seSBhY2NlcHQgc2lnbmVkIDMyIGJpdCBpbnRlZ2Vycy4gSlMgZG9lc24ndFxuICogaGF2ZSBhIGNvbnN0YW50IGZvciB0aGUgbWF4IHNpZ25lZCAzMiBiaXQgaW50ZWdlciwgc28gdGhpcyBpcyBhIHNpbXBsZSB3YXlcbiAqIHRvIGNhbGN1bGF0ZSBpdCAqL1xuY29uc3QgS0VFUEFMSVZFX01BWF9USU1FX01TID0gfigxIDw8IDMxKTtcbmNsYXNzIFN1YmNoYW5uZWwge1xuICAgIC8qKlxuICAgICAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgY29ubmVjdGlvbiB0byBhIHNpbmdsZSBiYWNrZW5kLlxuICAgICAqIEBwYXJhbSBjaGFubmVsVGFyZ2V0IFRoZSB0YXJnZXQgc3RyaW5nIGZvciB0aGUgY2hhbm5lbCBhcyBhIHdob2xlXG4gICAgICogQHBhcmFtIHN1YmNoYW5uZWxBZGRyZXNzIFRoZSBhZGRyZXNzIGZvciB0aGUgYmFja2VuZCB0aGF0IHRoaXMgc3ViY2hhbm5lbFxuICAgICAqICAgICB3aWxsIGNvbm5lY3QgdG9cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY2hhbm5lbCBvcHRpb25zLCBwbHVzIGFueSBzcGVjaWZpYyBzdWJjaGFubmVsIG9wdGlvbnNcbiAgICAgKiAgICAgZm9yIHRoaXMgc3ViY2hhbm5lbFxuICAgICAqIEBwYXJhbSBjcmVkZW50aWFscyBUaGUgY2hhbm5lbCBjcmVkZW50aWFscyB1c2VkIHRvIGVzdGFibGlzaCB0aGlzXG4gICAgICogICAgIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsVGFyZ2V0LCBzdWJjaGFubmVsQWRkcmVzcywgb3B0aW9ucywgY3JlZGVudGlhbHMsIGNvbm5lY3Rvcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuY2hhbm5lbFRhcmdldCA9IGNoYW5uZWxUYXJnZXQ7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3MgPSBzdWJjaGFubmVsQWRkcmVzcztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb25uZWN0b3IgPSBjb25uZWN0b3I7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3ViY2hhbm5lbCdzIGN1cnJlbnQgY29ubmVjdGl2aXR5IHN0YXRlLiBJbnZhcmlhbnQ6IGBzZXNzaW9uYCA9PT0gYG51bGxgXG4gICAgICAgICAqIGlmIGFuZCBvbmx5IGlmIGBjb25uZWN0aXZpdHlTdGF0ZWAgaXMgSURMRSBvciBUUkFOU0lFTlRfRkFJTFVSRS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVuZGVybHlpbmcgaHR0cDIgc2Vzc2lvbiB1c2VkIHRvIG1ha2UgcmVxdWVzdHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgc3ViY2hhbm5lbCBzaG91bGQgdHJhbnNpdGlvbiBmcm9tIFRSQU5TSUVOVF9GQUlMVVJFIHRvXG4gICAgICAgICAqIENPTk5FQ1RJTkcgaW5zdGVhZCBvZiBJRExFIHdoZW4gdGhlIGJhY2tvZmYgdGltZW91dCBlbmRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250aW51ZUNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgY29ubmVjdGl2aXR5XG4gICAgICAgICAqIHN0YXRlIGNoYW5nZXMuIFdpbGwgYmUgbW9kaWZpZWQgYnkgYGFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXJgIGFuZFxuICAgICAgICAgKiBgcmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFja3MgY2hhbm5lbHMgYW5kIHN1YmNoYW5uZWwgcG9vbHMgd2l0aCByZWZlcmVuY2VzIHRvIHRoaXMgc3ViY2hhbm5lbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWZjb3VudCA9IDA7XG4gICAgICAgIC8vIENoYW5uZWx6IGluZm9cbiAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBiYWNrb2ZmT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGluaXRpYWxEZWxheTogb3B0aW9uc1snZ3JwYy5pbml0aWFsX3JlY29ubmVjdF9iYWNrb2ZmX21zJ10sXG4gICAgICAgICAgICBtYXhEZWxheTogb3B0aW9uc1snZ3JwYy5tYXhfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dCA9IG5ldyBiYWNrb2ZmX3RpbWVvdXRfMS5CYWNrb2ZmVGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUJhY2tvZmZUaW1lcigpO1xuICAgICAgICB9LCBiYWNrb2ZmT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQudW5yZWYoKTtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyA9ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShzdWJjaGFubmVsQWRkcmVzcyk7XG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZSA9IChfYSA9IG9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogLTE7XG4gICAgICAgIGlmIChvcHRpb25zWydncnBjLmVuYWJsZV9jaGFubmVseiddID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpUcmFjZVN0dWIoKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyU3R1YigpO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNoaWxkcmVuVHJhY2tlclN0dWIoKTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXJTdHViKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVselRyYWNlKCk7XG4gICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlcigpO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNoaWxkcmVuVHJhY2tlcigpO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1UcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbm5lbHpSZWYgPSAoMCwgY2hhbm5lbHpfMS5yZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbCkodGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZywgKCkgPT4gdGhpcy5nZXRDaGFubmVsekluZm8oKSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnU3ViY2hhbm5lbCBjcmVhdGVkJyk7XG4gICAgICAgIHRoaXMudHJhY2UoJ1N1YmNoYW5uZWwgY29uc3RydWN0ZWQgd2l0aCBvcHRpb25zICcgK1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkob3B0aW9ucywgdW5kZWZpbmVkLCAyKSk7XG4gICAgICAgIHRoaXMuc2VjdXJlQ29ubmVjdG9yID0gY3JlZGVudGlhbHMuX2NyZWF0ZVNlY3VyZUNvbm5lY3RvcihjaGFubmVsVGFyZ2V0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbHpJbmZvKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdGU6IHRoaXMuY29ubmVjdGl2aXR5U3RhdGUsXG4gICAgICAgICAgICB0cmFjZTogdGhpcy5jaGFubmVselRyYWNlLFxuICAgICAgICAgICAgY2FsbFRyYWNrZXI6IHRoaXMuY2FsbFRyYWNrZXIsXG4gICAgICAgICAgICBjaGlsZHJlbjogdGhpcy5jaGlsZHJlblRyYWNrZXIuZ2V0Q2hpbGRMaXN0cygpLFxuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0cmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgJygnICtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xuICAgICAgICAgICAgJykgJyArXG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICB0ZXh0KTtcbiAgICB9XG4gICAgcmVmVHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ3N1YmNoYW5uZWxfcmVmY291bnQnLCAnKCcgK1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselJlZi5pZCArXG4gICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIHRleHQpO1xuICAgIH1cbiAgICBoYW5kbGVCYWNrb2ZmVGltZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRpbnVlQ29ubmVjdGluZykge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkVdLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgYSBiYWNrb2ZmIHRpbWVyIHdpdGggdGhlIGN1cnJlbnQgbmV4dEJhY2tvZmYgdGltZW91dFxuICAgICAqL1xuICAgIHN0YXJ0QmFja29mZigpIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5ydW5PbmNlKCk7XG4gICAgfVxuICAgIHN0b3BCYWNrb2ZmKCkge1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnN0b3AoKTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5yZXNldCgpO1xuICAgIH1cbiAgICBzdGFydENvbm5lY3RpbmdJbnRlcm5hbCgpIHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zWydncnBjLmtlZXBhbGl2ZV90aW1lX21zJ10pIHtcbiAgICAgICAgICAgIGNvbnN0IGFkanVzdGVkS2VlcGFsaXZlVGltZSA9IE1hdGgubWluKHRoaXMua2VlcGFsaXZlVGltZSwgS0VFUEFMSVZFX01BWF9USU1FX01TKTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7ICdncnBjLmtlZXBhbGl2ZV90aW1lX21zJzogYWRqdXN0ZWRLZWVwYWxpdmVUaW1lIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdG9yXG4gICAgICAgICAgICAuY29ubmVjdCh0aGlzLnN1YmNoYW5uZWxBZGRyZXNzLCB0aGlzLnNlY3VyZUNvbm5lY3Rvciwgb3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKHRyYW5zcG9ydCA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElOR10sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlci5yZWZDaGlsZCh0cmFuc3BvcnQuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5hZGREaXNjb25uZWN0TGlzdGVuZXIodG9vTWFueVBpbmdzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFldLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb01hbnlQaW5ncyAmJiB0aGlzLmtlZXBhbGl2ZVRpbWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWUgKj0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dpbmcubG9nKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgYENvbm5lY3Rpb24gdG8gJHsoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLmNoYW5uZWxUYXJnZXQpfSBhdCAke3RoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmd9IHJlamVjdGVkIGJ5IHNlcnZlciBiZWNhdXNlIG9mIGV4Y2VzcyBwaW5ncy4gSW5jcmVhc2luZyBwaW5nIGludGVydmFsIHRvICR7dGhpcy5rZWVwYWxpdmVUaW1lfSBtc2ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBJZiB3ZSBjYW4ndCB0cmFuc2l0aW9uIGZyb20gQ09OTkVDVElORyB0byBSRUFEWSBoZXJlLCB3ZSB3aWxsXG4gICAgICAgICAgICAgICAgICogbm90IGJlIHVzaW5nIHRoaXMgdHJhbnNwb3J0LCBzbyByZWxlYXNlIGl0cyByZXNvdXJjZXMuICovXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNodXRkb3duKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkddLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgYCR7ZXJyb3J9YCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZSBhIHN0YXRlIHRyYW5zaXRpb24gZnJvbSBhbnkgZWxlbWVudCBvZiBvbGRTdGF0ZXMgdG8gdGhlIG5ld1xuICAgICAqIHN0YXRlLiBJZiB0aGUgY3VycmVudCBjb25uZWN0aXZpdHlTdGF0ZSBpcyBub3QgaW4gb2xkU3RhdGVzLCBkbyBub3RoaW5nLlxuICAgICAqIEBwYXJhbSBvbGRTdGF0ZXMgVGhlIHNldCBvZiBzdGF0ZXMgdG8gdHJhbnNpdGlvbiBmcm9tXG4gICAgICogQHBhcmFtIG5ld1N0YXRlIFRoZSBzdGF0ZSB0byB0cmFuc2l0aW9uIHRvXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc3RhdGUgY2hhbmdlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgdHJhbnNpdGlvblRvU3RhdGUob2xkU3RhdGVzLCBuZXdTdGF0ZSwgZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChvbGRTdGF0ZXMuaW5kZXhPZih0aGlzLmNvbm5lY3Rpdml0eVN0YXRlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3RoaXMuY29ubmVjdGl2aXR5U3RhdGVdICtcbiAgICAgICAgICAgICAgICAnIC0+ICcgK1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSArXG4gICAgICAgICAgICAgICAgJyB3aXRoIGVycm9yIFwiJyArIGVycm9yTWVzc2FnZSArICdcIicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFjZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmNvbm5lY3Rpdml0eVN0YXRlXSArXG4gICAgICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0Nvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2UgdG8gJyArIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHRoaXMuY29ubmVjdGl2aXR5U3RhdGU7XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgc3dpdGNoIChuZXdTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWTpcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BCYWNrb2ZmKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkc6XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEJhY2tvZmYoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdGluZ0ludGVybmFsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZUNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkICYmIHRoaXMudHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyLnVucmVmQ2hpbGQodGhpcy50cmFuc3BvcnQuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMudHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2h1dGRvd24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgICAgICAgLyogSWYgdGhlIGJhY2tvZmYgdGltZXIgaGFzIGFscmVhZHkgZW5kZWQgYnkgdGhlIHRpbWUgd2UgZ2V0IHRvIHRoZVxuICAgICAgICAgICAgICAgICAqIFRSQU5TSUVOVF9GQUlMVVJFIHN0YXRlLCB3ZSB3YW50IHRvIGltbWVkaWF0ZWx5IHRyYW5zaXRpb24gb3V0IG9mXG4gICAgICAgICAgICAgICAgICogVFJBTlNJRU5UX0ZBSUxVUkUgYXMgdGhvdWdoIHRoZSBiYWNrb2ZmIHRpbWVyIGlzIGVuZGluZyByaWdodCBub3cgKi9cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYmFja29mZlRpbWVvdXQuaXNSdW5uaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUJhY2tvZmZUaW1lcigpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkICYmIHRoaXMudHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyLnVucmVmQ2hpbGQodGhpcy50cmFuc3BvcnQuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMudHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2h1dGRvd24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdGF0ZTogdW5rbm93biBDb25uZWN0aXZpdHlTdGF0ZSAke25ld1N0YXRlfWApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5zdGF0ZUxpc3RlbmVycykge1xuICAgICAgICAgICAgbGlzdGVuZXIodGhpcywgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUsIHRoaXMua2VlcGFsaXZlVGltZSwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmVmKCkge1xuICAgICAgICB0aGlzLnJlZlRyYWNlKCdyZWZjb3VudCAnICsgdGhpcy5yZWZjb3VudCArICcgLT4gJyArICh0aGlzLnJlZmNvdW50ICsgMSkpO1xuICAgICAgICB0aGlzLnJlZmNvdW50ICs9IDE7XG4gICAgfVxuICAgIHVucmVmKCkge1xuICAgICAgICB0aGlzLnJlZlRyYWNlKCdyZWZjb3VudCAnICsgdGhpcy5yZWZjb3VudCArICcgLT4gJyArICh0aGlzLnJlZmNvdW50IC0gMSkpO1xuICAgICAgICB0aGlzLnJlZmNvdW50IC09IDE7XG4gICAgICAgIGlmICh0aGlzLnJlZmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnU2h1dHRpbmcgZG93bicpO1xuICAgICAgICAgICAgKDAsIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKSh0aGlzLmNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgIHRoaXMuc2VjdXJlQ29ubmVjdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bnJlZklmT25lUmVmKCkge1xuICAgICAgICBpZiAodGhpcy5yZWZjb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy51bnJlZigpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjcmVhdGVDYWxsKG1ldGFkYXRhLCBob3N0LCBtZXRob2QsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy50cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSBjYWxsLCBzdWJjaGFubmVsIG5vdCBSRUFEWScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0c1RyYWNrZXI7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1UcmFja2VyLmFkZENhbGxTdGFydGVkKCk7XG4gICAgICAgICAgICBzdGF0c1RyYWNrZXIgPSB7XG4gICAgICAgICAgICAgICAgb25DYWxsRW5kOiBzdGF0dXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdHNUcmFja2VyID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LmNyZWF0ZUNhbGwobWV0YWRhdGEsIGhvc3QsIG1ldGhvZCwgbGlzdGVuZXIsIHN0YXRzVHJhY2tlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSBzdWJjaGFubmVsIGlzIGN1cnJlbnRseSBJRExFLCBzdGFydCBjb25uZWN0aW5nIGFuZCBzd2l0Y2ggdG8gdGhlXG4gICAgICogQ09OTkVDVElORyBzdGF0ZS4gSWYgdGhlIHN1YmNoYW5uZWwgaXMgY3VycmVudCBpbiBUUkFOU0lFTlRfRkFJTFVSRSxcbiAgICAgKiB0aGUgbmV4dCB0aW1lIGl0IHdvdWxkIHRyYW5zaXRpb24gdG8gSURMRSwgc3RhcnQgY29ubmVjdGluZyBhZ2FpbiBpbnN0ZWFkLlxuICAgICAqIE90aGVyd2lzZSwgZG8gbm90aGluZy5cbiAgICAgKi9cbiAgICBzdGFydENvbm5lY3RpbmcoKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgLyogRmlyc3QsIHRyeSB0byB0cmFuc2l0aW9uIGZyb20gSURMRSB0byBjb25uZWN0aW5nLiBJZiB0aGF0IGRvZXNuJ3QgaGFwcGVuXG4gICAgICAgICAgICAgKiBiZWNhdXNlIHRoZSBzdGF0ZSBpcyBub3QgY3VycmVudGx5IElETEUsIGNoZWNrIGlmIGl0IGlzXG4gICAgICAgICAgICAgKiBUUkFOU0lFTlRfRkFJTFVSRSwgYW5kIGlmIHNvIGluZGljYXRlIHRoYXQgaXQgc2hvdWxkIGdvIGJhY2sgdG9cbiAgICAgICAgICAgICAqIGNvbm5lY3RpbmcgYWZ0ZXIgdGhlIGJhY2tvZmYgdGltZXIgZW5kcy4gT3RoZXJ3aXNlIGRvIG5vdGhpbmcgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVDb25uZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN1YmNoYW5uZWwncyBjdXJyZW50IGNvbm5lY3Rpdml0eSBzdGF0ZS5cbiAgICAgKi9cbiAgICBnZXRDb25uZWN0aXZpdHlTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGl2aXR5U3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgc3ViY2hhbm5lbCdzXG4gICAgICogY29ubmVjdGl2aXR5IHN0YXRlIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnN0YXRlTGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGxpc3RlbmVyIHByZXZpb3VzbHkgYWRkZWQgd2l0aCBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgQSByZWZlcmVuY2UgdG8gYSBmdW5jdGlvbiBwcmV2aW91c2x5IHBhc3NlZCB0b1xuICAgICAqICAgICBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcbiAgICAgKi9cbiAgICByZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGJhY2tvZmYgdGltZW91dCwgYW5kIGltbWVkaWF0ZWx5IHN0YXJ0IGNvbm5lY3RpbmcgaWYgaW4gYmFja29mZi5cbiAgICAgKi9cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkVdLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nO1xuICAgIH1cbiAgICBnZXRDaGFubmVselJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHpSZWY7XG4gICAgfVxuICAgIGlzSGVhbHRoeSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFkZEhlYWx0aFN0YXRlV2F0Y2hlcihsaXN0ZW5lcikge1xuICAgICAgICAvLyBEbyBub3RoaW5nIHdpdGggdGhlIGxpc3RlbmVyXG4gICAgfVxuICAgIHJlbW92ZUhlYWx0aFN0YXRlV2F0Y2hlcihsaXN0ZW5lcikge1xuICAgICAgICAvLyBEbyBub3RoaW5nIHdpdGggdGhlIGxpc3RlbmVyXG4gICAgfVxuICAgIGdldFJlYWxTdWJjaGFubmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVhbFN1YmNoYW5uZWxFcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyLmdldFJlYWxTdWJjaGFubmVsKCkgPT09IHRoaXM7XG4gICAgfVxuICAgIHRocm90dGxlS2VlcGFsaXZlKG5ld0tlZXBhbGl2ZVRpbWUpIHtcbiAgICAgICAgaWYgKG5ld0tlZXBhbGl2ZVRpbWUgPiB0aGlzLmtlZXBhbGl2ZVRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZSA9IG5ld0tlZXBhbGl2ZVRpbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2FsbENyZWRlbnRpYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWN1cmVDb25uZWN0b3IuZ2V0Q2FsbENyZWRlbnRpYWxzKCk7XG4gICAgfVxufVxuZXhwb3J0cy5TdWJjaGFubmVsID0gU3ViY2hhbm5lbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YmNoYW5uZWwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU3ViY2hhbm5lbCIsImNvbm5lY3Rpdml0eV9zdGF0ZV8xIiwicmVxdWlyZSIsImJhY2tvZmZfdGltZW91dF8xIiwibG9nZ2luZyIsImNvbnN0YW50c18xIiwidXJpX3BhcnNlcl8xIiwic3ViY2hhbm5lbF9hZGRyZXNzXzEiLCJjaGFubmVsel8xIiwiVFJBQ0VSX05BTUUiLCJLRUVQQUxJVkVfTUFYX1RJTUVfTVMiLCJjb25zdHJ1Y3RvciIsImNoYW5uZWxUYXJnZXQiLCJzdWJjaGFubmVsQWRkcmVzcyIsIm9wdGlvbnMiLCJjcmVkZW50aWFscyIsImNvbm5lY3RvciIsIl9hIiwiY29ubmVjdGl2aXR5U3RhdGUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIklETEUiLCJ0cmFuc3BvcnQiLCJjb250aW51ZUNvbm5lY3RpbmciLCJzdGF0ZUxpc3RlbmVycyIsIlNldCIsInJlZmNvdW50IiwiY2hhbm5lbHpFbmFibGVkIiwiYmFja29mZk9wdGlvbnMiLCJpbml0aWFsRGVsYXkiLCJtYXhEZWxheSIsImJhY2tvZmZUaW1lb3V0IiwiQmFja29mZlRpbWVvdXQiLCJoYW5kbGVCYWNrb2ZmVGltZXIiLCJ1bnJlZiIsInN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nIiwic3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyIsImtlZXBhbGl2ZVRpbWUiLCJjaGFubmVselRyYWNlIiwiQ2hhbm5lbHpUcmFjZVN0dWIiLCJjYWxsVHJhY2tlciIsIkNoYW5uZWx6Q2FsbFRyYWNrZXJTdHViIiwiY2hpbGRyZW5UcmFja2VyIiwiQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXJTdHViIiwic3RyZWFtVHJhY2tlciIsIkNoYW5uZWx6VHJhY2UiLCJDaGFubmVsekNhbGxUcmFja2VyIiwiQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXIiLCJjaGFubmVselJlZiIsInJlZ2lzdGVyQ2hhbm5lbHpTdWJjaGFubmVsIiwiZ2V0Q2hhbm5lbHpJbmZvIiwiYWRkVHJhY2UiLCJ0cmFjZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1bmRlZmluZWQiLCJzZWN1cmVDb25uZWN0b3IiLCJfY3JlYXRlU2VjdXJlQ29ubmVjdG9yIiwic3RhdGUiLCJjaGlsZHJlbiIsImdldENoaWxkTGlzdHMiLCJ0YXJnZXQiLCJ0ZXh0IiwiTG9nVmVyYm9zaXR5IiwiREVCVUciLCJpZCIsInJlZlRyYWNlIiwidHJhbnNpdGlvblRvU3RhdGUiLCJUUkFOU0lFTlRfRkFJTFVSRSIsIkNPTk5FQ1RJTkciLCJzdGFydEJhY2tvZmYiLCJydW5PbmNlIiwic3RvcEJhY2tvZmYiLCJzdG9wIiwicmVzZXQiLCJzdGFydENvbm5lY3RpbmdJbnRlcm5hbCIsImFkanVzdGVkS2VlcGFsaXZlVGltZSIsIk1hdGgiLCJtaW4iLCJhc3NpZ24iLCJjb25uZWN0IiwidGhlbiIsIlJFQURZIiwicmVmQ2hpbGQiLCJnZXRDaGFubmVselJlZiIsImFkZERpc2Nvbm5lY3RMaXN0ZW5lciIsInRvb01hbnlQaW5ncyIsImxvZyIsIkVSUk9SIiwidXJpVG9TdHJpbmciLCJzaHV0ZG93biIsImVycm9yIiwib2xkU3RhdGVzIiwibmV3U3RhdGUiLCJlcnJvck1lc3NhZ2UiLCJfYiIsImluZGV4T2YiLCJwcmV2aW91c1N0YXRlIiwidW5yZWZDaGlsZCIsImlzUnVubmluZyIsInByb2Nlc3MiLCJuZXh0VGljayIsIkVycm9yIiwibGlzdGVuZXIiLCJyZWYiLCJ1bnJlZ2lzdGVyQ2hhbm5lbHpSZWYiLCJkZXN0cm95IiwidW5yZWZJZk9uZVJlZiIsImNyZWF0ZUNhbGwiLCJtZXRhZGF0YSIsImhvc3QiLCJtZXRob2QiLCJzdGF0c1RyYWNrZXIiLCJhZGRDYWxsU3RhcnRlZCIsIm9uQ2FsbEVuZCIsInN0YXR1cyIsImNvZGUiLCJTdGF0dXMiLCJPSyIsImFkZENhbGxTdWNjZWVkZWQiLCJhZGRDYWxsRmFpbGVkIiwic3RhcnRDb25uZWN0aW5nIiwiZ2V0Q29ubmVjdGl2aXR5U3RhdGUiLCJhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyIiwiYWRkIiwicmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lciIsImRlbGV0ZSIsInJlc2V0QmFja29mZiIsImdldEFkZHJlc3MiLCJpc0hlYWx0aHkiLCJhZGRIZWFsdGhTdGF0ZVdhdGNoZXIiLCJyZW1vdmVIZWFsdGhTdGF0ZVdhdGNoZXIiLCJnZXRSZWFsU3ViY2hhbm5lbCIsInJlYWxTdWJjaGFubmVsRXF1YWxzIiwib3RoZXIiLCJ0aHJvdHRsZUtlZXBhbGl2ZSIsIm5ld0tlZXBhbGl2ZVRpbWUiLCJnZXRDYWxsQ3JlZGVudGlhbHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/tls-helpers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CIPHER_SUITES = void 0;\nexports.getDefaultRootsData = getDefaultRootsData;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nexports.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;\nconst DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;\nlet defaultRootsData = null;\nfunction getDefaultRootsData() {\n    if (DEFAULT_ROOTS_FILE_PATH) {\n        if (defaultRootsData === null) {\n            defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);\n        }\n        return defaultRootsData;\n    }\n    return null;\n} //# sourceMappingURL=tls-helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdGxzLWhlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHLEtBQUs7QUFDN0JBLDJCQUEyQixHQUFHRztBQUM5QixNQUFNQyxLQUFLQyxtQkFBT0EsQ0FBQyxjQUFJO0FBQ3ZCTCxxQkFBcUIsR0FBR00sUUFBUUMsR0FBRyxDQUFDQyxzQkFBc0I7QUFDMUQsTUFBTUMsMEJBQTBCSCxRQUFRQyxHQUFHLENBQUNHLGdDQUFnQztBQUM1RSxJQUFJQyxtQkFBbUI7QUFDdkIsU0FBU1I7SUFDTCxJQUFJTSx5QkFBeUI7UUFDekIsSUFBSUUscUJBQXFCLE1BQU07WUFDM0JBLG1CQUFtQlAsR0FBR1EsWUFBWSxDQUFDSDtRQUN2QztRQUNBLE9BQU9FO0lBQ1g7SUFDQSxPQUFPO0FBQ1gsRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdGxzLWhlbHBlcnMuanM/MGVkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DSVBIRVJfU1VJVEVTID0gdm9pZCAwO1xuZXhwb3J0cy5nZXREZWZhdWx0Um9vdHNEYXRhID0gZ2V0RGVmYXVsdFJvb3RzRGF0YTtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuZXhwb3J0cy5DSVBIRVJfU1VJVEVTID0gcHJvY2Vzcy5lbnYuR1JQQ19TU0xfQ0lQSEVSX1NVSVRFUztcbmNvbnN0IERFRkFVTFRfUk9PVFNfRklMRV9QQVRIID0gcHJvY2Vzcy5lbnYuR1JQQ19ERUZBVUxUX1NTTF9ST09UU19GSUxFX1BBVEg7XG5sZXQgZGVmYXVsdFJvb3RzRGF0YSA9IG51bGw7XG5mdW5jdGlvbiBnZXREZWZhdWx0Um9vdHNEYXRhKCkge1xuICAgIGlmIChERUZBVUxUX1JPT1RTX0ZJTEVfUEFUSCkge1xuICAgICAgICBpZiAoZGVmYXVsdFJvb3RzRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZGVmYXVsdFJvb3RzRGF0YSA9IGZzLnJlYWRGaWxlU3luYyhERUZBVUxUX1JPT1RTX0ZJTEVfUEFUSCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRSb290c0RhdGE7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGxzLWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ0lQSEVSX1NVSVRFUyIsImdldERlZmF1bHRSb290c0RhdGEiLCJmcyIsInJlcXVpcmUiLCJwcm9jZXNzIiwiZW52IiwiR1JQQ19TU0xfQ0lQSEVSX1NVSVRFUyIsIkRFRkFVTFRfUk9PVFNfRklMRV9QQVRIIiwiR1JQQ19ERUZBVUxUX1NTTF9ST09UU19GSUxFX1BBVEgiLCJkZWZhdWx0Um9vdHNEYXRhIiwicmVhZEZpbGVTeW5jIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/transport.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/transport.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2023 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Http2SubchannelConnector = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst subchannel_call_1 = __webpack_require__(/*! ./subchannel-call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js\");\nconst call_number_1 = __webpack_require__(/*! ./call-number */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-number.js\");\nconst TRACER_NAME = \"transport\";\nconst FLOW_CONTROL_TRACER_NAME = \"transport_flowctrl\";\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/@grpc/grpc-js/package.json\").version);\nconst { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT } = http2.constants;\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst tooManyPingsData = Buffer.from(\"too_many_pings\", \"ascii\");\nclass Http2Transport {\n    constructor(session, subchannelAddress, options, /**\n     * Name of the remote server, if it is not the same as the subchannel\n     * address, i.e. if connecting through an HTTP CONNECT proxy.\n     */ remoteName){\n        this.session = session;\n        this.options = options;\n        this.remoteName = remoteName;\n        /**\n         * Timer reference indicating when to send the next ping or when the most recent ping will be considered lost.\n         */ this.keepaliveTimer = null;\n        /**\n         * Indicates that the keepalive timer ran out while there were no active\n         * calls, and a ping should be sent the next time a call starts.\n         */ this.pendingSendKeepalivePing = false;\n        this.activeCalls = new Set();\n        this.disconnectListeners = [];\n        this.disconnectHandled = false;\n        this.channelzEnabled = true;\n        this.keepalivesSent = 0;\n        this.messagesSent = 0;\n        this.messagesReceived = 0;\n        this.lastMessageSentTimestamp = null;\n        this.lastMessageReceivedTimestamp = null;\n        /* Populate subchannelAddressString and channelzRef before doing anything\n         * else, because they are used in the trace methods. */ this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n        if (options[\"grpc.enable_channelz\"] === 0) {\n            this.channelzEnabled = false;\n            this.streamTracker = new channelz_1.ChannelzCallTrackerStub();\n        } else {\n            this.streamTracker = new channelz_1.ChannelzCallTracker();\n        }\n        this.channelzRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, ()=>this.getChannelzInfo(), this.channelzEnabled);\n        // Build user-agent string.\n        this.userAgent = [\n            options[\"grpc.primary_user_agent\"],\n            `grpc-node-js/${clientVersion}`,\n            options[\"grpc.secondary_user_agent\"]\n        ].filter((e)=>e).join(\" \"); // remove falsey values first\n        if (\"grpc.keepalive_time_ms\" in options) {\n            this.keepaliveTimeMs = options[\"grpc.keepalive_time_ms\"];\n        } else {\n            this.keepaliveTimeMs = -1;\n        }\n        if (\"grpc.keepalive_timeout_ms\" in options) {\n            this.keepaliveTimeoutMs = options[\"grpc.keepalive_timeout_ms\"];\n        } else {\n            this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n        }\n        if (\"grpc.keepalive_permit_without_calls\" in options) {\n            this.keepaliveWithoutCalls = options[\"grpc.keepalive_permit_without_calls\"] === 1;\n        } else {\n            this.keepaliveWithoutCalls = false;\n        }\n        session.once(\"close\", ()=>{\n            this.trace(\"session closed\");\n            this.handleDisconnect();\n        });\n        session.once(\"goaway\", (errorCode, lastStreamID, opaqueData)=>{\n            let tooManyPings = false;\n            /* See the last paragraph of\n             * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */ if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData && opaqueData.equals(tooManyPingsData)) {\n                tooManyPings = true;\n            }\n            this.trace(\"connection closed by GOAWAY with code \" + errorCode + \" and data \" + (opaqueData === null || opaqueData === void 0 ? void 0 : opaqueData.toString()));\n            this.reportDisconnectToOwner(tooManyPings);\n        });\n        session.once(\"error\", (error)=>{\n            this.trace(\"connection closed with error \" + error.message);\n            this.handleDisconnect();\n        });\n        session.socket.once(\"close\", (hadError)=>{\n            this.trace(\"connection closed. hadError=\" + hadError);\n            this.handleDisconnect();\n        });\n        if (logging.isTracerEnabled(TRACER_NAME)) {\n            session.on(\"remoteSettings\", (settings)=>{\n                this.trace(\"new settings received\" + (this.session !== session ? \" on the old connection\" : \"\") + \": \" + JSON.stringify(settings));\n            });\n            session.on(\"localSettings\", (settings)=>{\n                this.trace(\"local settings acknowledged by remote\" + (this.session !== session ? \" on the old connection\" : \"\") + \": \" + JSON.stringify(settings));\n            });\n        }\n        /* Start the keepalive timer last, because this can trigger trace logs,\n         * which should only happen after everything else is set up. */ if (this.keepaliveWithoutCalls) {\n            this.maybeStartKeepalivePingTimer();\n        }\n    }\n    getChannelzInfo() {\n        var _a, _b, _c;\n        const sessionSocket = this.session.socket;\n        const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n        const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;\n        let tlsInfo;\n        if (this.session.encrypted) {\n            const tlsSocket = sessionSocket;\n            const cipherInfo = tlsSocket.getCipher();\n            const certificate = tlsSocket.getCertificate();\n            const peerCertificate = tlsSocket.getPeerCertificate();\n            tlsInfo = {\n                cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n                cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n                localCertificate: certificate && \"raw\" in certificate ? certificate.raw : null,\n                remoteCertificate: peerCertificate && \"raw\" in peerCertificate ? peerCertificate.raw : null\n            };\n        } else {\n            tlsInfo = null;\n        }\n        const socketInfo = {\n            remoteAddress: remoteAddress,\n            localAddress: localAddress,\n            security: tlsInfo,\n            remoteName: this.remoteName,\n            streamsStarted: this.streamTracker.callsStarted,\n            streamsSucceeded: this.streamTracker.callsSucceeded,\n            streamsFailed: this.streamTracker.callsFailed,\n            messagesSent: this.messagesSent,\n            messagesReceived: this.messagesReceived,\n            keepAlivesSent: this.keepalivesSent,\n            lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n            lastRemoteStreamCreatedTimestamp: null,\n            lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n            lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n            localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n            remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n        };\n        return socketInfo;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    keepaliveTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, \"keepalive\", \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    flowControlTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    internalsTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, \"transport_internals\", \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    /**\n     * Indicate to the owner of this object that this transport should no longer\n     * be used. That happens if the connection drops, or if the server sends a\n     * GOAWAY.\n     * @param tooManyPings If true, this was triggered by a GOAWAY with data\n     * indicating that the session was closed becaues the client sent too many\n     * pings.\n     * @returns\n     */ reportDisconnectToOwner(tooManyPings) {\n        if (this.disconnectHandled) {\n            return;\n        }\n        this.disconnectHandled = true;\n        this.disconnectListeners.forEach((listener)=>listener(tooManyPings));\n    }\n    /**\n     * Handle connection drops, but not GOAWAYs.\n     */ handleDisconnect() {\n        this.clearKeepaliveTimeout();\n        this.reportDisconnectToOwner(false);\n        for (const call of this.activeCalls){\n            call.onDisconnect();\n        }\n        // Wait an event loop cycle before destroying the connection\n        setImmediate(()=>{\n            this.session.destroy();\n        });\n    }\n    addDisconnectListener(listener) {\n        this.disconnectListeners.push(listener);\n    }\n    canSendPing() {\n        return !this.session.destroyed && this.keepaliveTimeMs > 0 && (this.keepaliveWithoutCalls || this.activeCalls.size > 0);\n    }\n    maybeSendPing() {\n        var _a, _b;\n        if (!this.canSendPing()) {\n            this.pendingSendKeepalivePing = true;\n            return;\n        }\n        if (this.keepaliveTimer) {\n            console.error(\"keepaliveTimeout is not null\");\n            return;\n        }\n        if (this.channelzEnabled) {\n            this.keepalivesSent += 1;\n        }\n        this.keepaliveTrace(\"Sending ping with timeout \" + this.keepaliveTimeoutMs + \"ms\");\n        this.keepaliveTimer = setTimeout(()=>{\n            this.keepaliveTimer = null;\n            this.keepaliveTrace(\"Ping timeout passed without response\");\n            this.handleDisconnect();\n        }, this.keepaliveTimeoutMs);\n        (_b = (_a = this.keepaliveTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        let pingSendError = \"\";\n        try {\n            const pingSentSuccessfully = this.session.ping((err, duration, payload)=>{\n                this.clearKeepaliveTimeout();\n                if (err) {\n                    this.keepaliveTrace(\"Ping failed with error \" + err.message);\n                    this.handleDisconnect();\n                } else {\n                    this.keepaliveTrace(\"Received ping response\");\n                    this.maybeStartKeepalivePingTimer();\n                }\n            });\n            if (!pingSentSuccessfully) {\n                pingSendError = \"Ping returned false\";\n            }\n        } catch (e) {\n            // grpc/grpc-node#2139\n            pingSendError = (e instanceof Error ? e.message : \"\") || \"Unknown error\";\n        }\n        if (pingSendError) {\n            this.keepaliveTrace(\"Ping send failed: \" + pingSendError);\n            this.handleDisconnect();\n        }\n    }\n    /**\n     * Starts the keepalive ping timer if appropriate. If the timer already ran\n     * out while there were no active requests, instead send a ping immediately.\n     * If the ping timer is already running or a ping is currently in flight,\n     * instead do nothing and wait for them to resolve.\n     */ maybeStartKeepalivePingTimer() {\n        var _a, _b;\n        if (!this.canSendPing()) {\n            return;\n        }\n        if (this.pendingSendKeepalivePing) {\n            this.pendingSendKeepalivePing = false;\n            this.maybeSendPing();\n        } else if (!this.keepaliveTimer) {\n            this.keepaliveTrace(\"Starting keepalive timer for \" + this.keepaliveTimeMs + \"ms\");\n            this.keepaliveTimer = setTimeout(()=>{\n                this.keepaliveTimer = null;\n                this.maybeSendPing();\n            }, this.keepaliveTimeMs);\n            (_b = (_a = this.keepaliveTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    /* Otherwise, there is already either a keepalive timer or a ping pending,\n         * wait for those to resolve. */ }\n    /**\n     * Clears whichever keepalive timeout is currently active, if any.\n     */ clearKeepaliveTimeout() {\n        if (this.keepaliveTimer) {\n            clearTimeout(this.keepaliveTimer);\n            this.keepaliveTimer = null;\n        }\n    }\n    removeActiveCall(call) {\n        this.activeCalls.delete(call);\n        if (this.activeCalls.size === 0) {\n            this.session.unref();\n        }\n    }\n    addActiveCall(call) {\n        this.activeCalls.add(call);\n        if (this.activeCalls.size === 1) {\n            this.session.ref();\n            if (!this.keepaliveWithoutCalls) {\n                this.maybeStartKeepalivePingTimer();\n            }\n        }\n    }\n    createCall(metadata, host, method, listener, subchannelCallStatsTracker) {\n        const headers = metadata.toHttp2Headers();\n        headers[HTTP2_HEADER_AUTHORITY] = host;\n        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n        headers[HTTP2_HEADER_CONTENT_TYPE] = \"application/grpc\";\n        headers[HTTP2_HEADER_METHOD] = \"POST\";\n        headers[HTTP2_HEADER_PATH] = method;\n        headers[HTTP2_HEADER_TE] = \"trailers\";\n        let http2Stream;\n        /* In theory, if an error is thrown by session.request because session has\n         * become unusable (e.g. because it has received a goaway), this subchannel\n         * should soon see the corresponding close or goaway event anyway and leave\n         * READY. But we have seen reports that this does not happen\n         * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n         * so for defense in depth, we just discard the session when we see an\n         * error here.\n         */ try {\n            http2Stream = this.session.request(headers);\n        } catch (e) {\n            this.handleDisconnect();\n            throw e;\n        }\n        this.flowControlTrace(\"local window size: \" + this.session.state.localWindowSize + \" remote window size: \" + this.session.state.remoteWindowSize);\n        this.internalsTrace(\"session.closed=\" + this.session.closed + \" session.destroyed=\" + this.session.destroyed + \" session.socket.destroyed=\" + this.session.socket.destroyed);\n        let eventTracker;\n        // eslint-disable-next-line prefer-const\n        let call;\n        if (this.channelzEnabled) {\n            this.streamTracker.addCallStarted();\n            eventTracker = {\n                addMessageSent: ()=>{\n                    var _a;\n                    this.messagesSent += 1;\n                    this.lastMessageSentTimestamp = new Date();\n                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                addMessageReceived: ()=>{\n                    var _a;\n                    this.messagesReceived += 1;\n                    this.lastMessageReceivedTimestamp = new Date();\n                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                onCallEnd: (status)=>{\n                    var _a;\n                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n                    this.removeActiveCall(call);\n                },\n                onStreamEnd: (success)=>{\n                    var _a;\n                    if (success) {\n                        this.streamTracker.addCallSucceeded();\n                    } else {\n                        this.streamTracker.addCallFailed();\n                    }\n                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n                }\n            };\n        } else {\n            eventTracker = {\n                addMessageSent: ()=>{\n                    var _a;\n                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                addMessageReceived: ()=>{\n                    var _a;\n                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                onCallEnd: (status)=>{\n                    var _a;\n                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n                    this.removeActiveCall(call);\n                },\n                onStreamEnd: (success)=>{\n                    var _a;\n                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n                }\n            };\n        }\n        call = new subchannel_call_1.Http2SubchannelCall(http2Stream, eventTracker, listener, this, (0, call_number_1.getNextCallNumber)());\n        this.addActiveCall(call);\n        return call;\n    }\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    getPeerName() {\n        return this.subchannelAddressString;\n    }\n    getOptions() {\n        return this.options;\n    }\n    shutdown() {\n        this.session.close();\n        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n    }\n}\nclass Http2SubchannelConnector {\n    constructor(channelTarget){\n        this.channelTarget = channelTarget;\n        this.session = null;\n        this.isShutdown = false;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, (0, uri_parser_1.uriToString)(this.channelTarget) + \" \" + text);\n    }\n    createSession(secureConnectResult, address, options) {\n        if (this.isShutdown) {\n            return Promise.reject();\n        }\n        if (secureConnectResult.socket.closed) {\n            return Promise.reject(\"Connection closed before starting HTTP/2 handshake\");\n        }\n        return new Promise((resolve, reject)=>{\n            var _a;\n            let remoteName = null;\n            let realTarget = this.channelTarget;\n            if (\"grpc.http_connect_target\" in options) {\n                const parsedTarget = (0, uri_parser_1.parseUri)(options[\"grpc.http_connect_target\"]);\n                if (parsedTarget) {\n                    realTarget = parsedTarget;\n                    remoteName = (0, uri_parser_1.uriToString)(parsedTarget);\n                }\n            }\n            const scheme = secureConnectResult.secure ? \"https\" : \"http\";\n            const targetPath = (0, resolver_1.getDefaultAuthority)(realTarget);\n            const closeHandler = ()=>{\n                var _a;\n                (_a = this.session) === null || _a === void 0 ? void 0 : _a.destroy();\n                this.session = null;\n                // Leave time for error event to happen before rejecting\n                setImmediate(()=>{\n                    if (!reportedError) {\n                        reportedError = true;\n                        reject(`${errorMessage.trim()} (${new Date().toISOString()})`);\n                    }\n                });\n            };\n            const errorHandler = (error)=>{\n                var _a;\n                (_a = this.session) === null || _a === void 0 ? void 0 : _a.destroy();\n                errorMessage = error.message;\n                this.trace(\"connection failed with error \" + errorMessage);\n                if (!reportedError) {\n                    reportedError = true;\n                    reject(`${errorMessage} (${new Date().toISOString()})`);\n                }\n            };\n            const session = http2.connect(`${scheme}://${targetPath}`, {\n                createConnection: (authority, option)=>{\n                    return secureConnectResult.socket;\n                },\n                settings: {\n                    initialWindowSize: (_a = options[\"grpc-node.flow_control_window\"]) !== null && _a !== void 0 ? _a : http2.getDefaultSettings().initialWindowSize\n                }\n            });\n            this.session = session;\n            let errorMessage = \"Failed to connect\";\n            let reportedError = false;\n            session.unref();\n            session.once(\"remoteSettings\", ()=>{\n                session.removeAllListeners();\n                secureConnectResult.socket.removeListener(\"close\", closeHandler);\n                secureConnectResult.socket.removeListener(\"error\", errorHandler);\n                resolve(new Http2Transport(session, address, options, remoteName));\n                this.session = null;\n            });\n            session.once(\"close\", closeHandler);\n            session.once(\"error\", errorHandler);\n            secureConnectResult.socket.once(\"close\", closeHandler);\n            secureConnectResult.socket.once(\"error\", errorHandler);\n        });\n    }\n    tcpConnect(address, options) {\n        return (0, http_proxy_1.getProxiedConnection)(address, options).then((proxiedSocket)=>{\n            if (proxiedSocket) {\n                return proxiedSocket;\n            } else {\n                return new Promise((resolve, reject)=>{\n                    const closeCallback = ()=>{\n                        reject(new Error(\"Socket closed\"));\n                    };\n                    const errorCallback = (error)=>{\n                        reject(error);\n                    };\n                    const socket = net.connect(address, ()=>{\n                        socket.removeListener(\"close\", closeCallback);\n                        socket.removeListener(\"error\", errorCallback);\n                        resolve(socket);\n                    });\n                    socket.once(\"close\", closeCallback);\n                    socket.once(\"error\", errorCallback);\n                });\n            }\n        });\n    }\n    async connect(address, secureConnector, options) {\n        if (this.isShutdown) {\n            return Promise.reject();\n        }\n        let tcpConnection = null;\n        let secureConnectResult = null;\n        const addressString = (0, subchannel_address_1.subchannelAddressToString)(address);\n        try {\n            this.trace(addressString + \" Waiting for secureConnector to be ready\");\n            await secureConnector.waitForReady();\n            this.trace(addressString + \" secureConnector is ready\");\n            tcpConnection = await this.tcpConnect(address, options);\n            this.trace(addressString + \" Established TCP connection\");\n            secureConnectResult = await secureConnector.connect(tcpConnection);\n            this.trace(addressString + \" Established secure connection\");\n            return this.createSession(secureConnectResult, address, options);\n        } catch (e) {\n            tcpConnection === null || tcpConnection === void 0 ? void 0 : tcpConnection.destroy();\n            secureConnectResult === null || secureConnectResult === void 0 ? void 0 : secureConnectResult.socket.destroy();\n            throw e;\n        }\n    }\n    shutdown() {\n        var _a;\n        this.isShutdown = true;\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.close();\n        this.session = null;\n    }\n}\nexports.Http2SubchannelConnector = Http2SubchannelConnector; //# sourceMappingURL=transport.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdHJhbnNwb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQ0FBZ0MsR0FBRyxLQUFLO0FBQ3hDLE1BQU1HLFFBQVFDLG1CQUFPQSxDQUFDLG9CQUFPO0FBQzdCLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1HLGVBQWVILG1CQUFPQSxDQUFDLGdGQUFjO0FBQzNDLE1BQU1JLFVBQVVKLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1LLGFBQWFMLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1NLHVCQUF1Qk4sbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1PLGVBQWVQLG1CQUFPQSxDQUFDLGdGQUFjO0FBQzNDLE1BQU1RLE1BQU1SLG1CQUFPQSxDQUFDLGdCQUFLO0FBQ3pCLE1BQU1TLG9CQUFvQlQsbUJBQU9BLENBQUMsMEZBQW1CO0FBQ3JELE1BQU1VLGdCQUFnQlYsbUJBQU9BLENBQUMsa0ZBQWU7QUFDN0MsTUFBTVcsY0FBYztBQUNwQixNQUFNQywyQkFBMkI7QUFDakMsTUFBTUMsZ0JBQWdCYiwwR0FBcUM7QUFDM0QsTUFBTSxFQUFFZSxzQkFBc0IsRUFBRUMseUJBQXlCLEVBQUVDLG1CQUFtQixFQUFFQyxpQkFBaUIsRUFBRUMsZUFBZSxFQUFFQyx1QkFBdUIsRUFBRyxHQUFHckIsTUFBTXNCLFNBQVM7QUFDaEssTUFBTUMsdUJBQXVCO0FBQzdCLE1BQU1DLG1CQUFtQkMsT0FBT0MsSUFBSSxDQUFDLGtCQUFrQjtBQUN2RCxNQUFNQztJQUNGQyxZQUFZQyxPQUFPLEVBQUVDLGlCQUFpQixFQUFFQyxPQUFPLEVBQy9DOzs7S0FHQyxHQUNEQyxVQUFV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IjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdHJhbnNwb3J0LmpzPzZiMDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjMgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSHR0cDJTdWJjaGFubmVsQ29ubmVjdG9yID0gdm9pZCAwO1xuY29uc3QgaHR0cDIgPSByZXF1aXJlKFwiaHR0cDJcIik7XG5jb25zdCBjaGFubmVsel8xID0gcmVxdWlyZShcIi4vY2hhbm5lbHpcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGh0dHBfcHJveHlfMSA9IHJlcXVpcmUoXCIuL2h0dHBfcHJveHlcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IG5ldCA9IHJlcXVpcmUoXCJuZXRcIik7XG5jb25zdCBzdWJjaGFubmVsX2NhbGxfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtY2FsbFwiKTtcbmNvbnN0IGNhbGxfbnVtYmVyXzEgPSByZXF1aXJlKFwiLi9jYWxsLW51bWJlclwiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3RyYW5zcG9ydCc7XG5jb25zdCBGTE9XX0NPTlRST0xfVFJBQ0VSX05BTUUgPSAndHJhbnNwb3J0X2Zsb3djdHJsJztcbmNvbnN0IGNsaWVudFZlcnNpb24gPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuY29uc3QgeyBIVFRQMl9IRUFERVJfQVVUSE9SSVRZLCBIVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFLCBIVFRQMl9IRUFERVJfTUVUSE9ELCBIVFRQMl9IRUFERVJfUEFUSCwgSFRUUDJfSEVBREVSX1RFLCBIVFRQMl9IRUFERVJfVVNFUl9BR0VOVCwgfSA9IGh0dHAyLmNvbnN0YW50cztcbmNvbnN0IEtFRVBBTElWRV9USU1FT1VUX01TID0gMjAwMDA7XG5jb25zdCB0b29NYW55UGluZ3NEYXRhID0gQnVmZmVyLmZyb20oJ3Rvb19tYW55X3BpbmdzJywgJ2FzY2lpJyk7XG5jbGFzcyBIdHRwMlRyYW5zcG9ydCB7XG4gICAgY29uc3RydWN0b3Ioc2Vzc2lvbiwgc3ViY2hhbm5lbEFkZHJlc3MsIG9wdGlvbnMsIFxuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhlIHJlbW90ZSBzZXJ2ZXIsIGlmIGl0IGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgc3ViY2hhbm5lbFxuICAgICAqIGFkZHJlc3MsIGkuZS4gaWYgY29ubmVjdGluZyB0aHJvdWdoIGFuIEhUVFAgQ09OTkVDVCBwcm94eS5cbiAgICAgKi9cbiAgICByZW1vdGVOYW1lKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMucmVtb3RlTmFtZSA9IHJlbW90ZU5hbWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaW1lciByZWZlcmVuY2UgaW5kaWNhdGluZyB3aGVuIHRvIHNlbmQgdGhlIG5leHQgcGluZyBvciB3aGVuIHRoZSBtb3N0IHJlY2VudCBwaW5nIHdpbGwgYmUgY29uc2lkZXJlZCBsb3N0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUga2VlcGFsaXZlIHRpbWVyIHJhbiBvdXQgd2hpbGUgdGhlcmUgd2VyZSBubyBhY3RpdmVcbiAgICAgICAgICogY2FsbHMsIGFuZCBhIHBpbmcgc2hvdWxkIGJlIHNlbnQgdGhlIG5leHQgdGltZSBhIGNhbGwgc3RhcnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nU2VuZEtlZXBhbGl2ZVBpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hY3RpdmVDYWxscyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0TGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdEhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZXNTZW50ID0gMDtcbiAgICAgICAgdGhpcy5tZXNzYWdlc1NlbnQgPSAwO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzUmVjZWl2ZWQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgIC8qIFBvcHVsYXRlIHN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nIGFuZCBjaGFubmVselJlZiBiZWZvcmUgZG9pbmcgYW55dGhpbmdcbiAgICAgICAgICogZWxzZSwgYmVjYXVzZSB0aGV5IGFyZSB1c2VkIGluIHRoZSB0cmFjZSBtZXRob2RzLiAqL1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nID0gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKHN1YmNoYW5uZWxBZGRyZXNzKTtcbiAgICAgICAgaWYgKG9wdGlvbnNbJ2dycGMuZW5hYmxlX2NoYW5uZWx6J10gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyU3R1YigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1UcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbm5lbHpSZWYgPSAoMCwgY2hhbm5lbHpfMS5yZWdpc3RlckNoYW5uZWx6U29ja2V0KSh0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nLCAoKSA9PiB0aGlzLmdldENoYW5uZWx6SW5mbygpLCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XG4gICAgICAgIC8vIEJ1aWxkIHVzZXItYWdlbnQgc3RyaW5nLlxuICAgICAgICB0aGlzLnVzZXJBZ2VudCA9IFtcbiAgICAgICAgICAgIG9wdGlvbnNbJ2dycGMucHJpbWFyeV91c2VyX2FnZW50J10sXG4gICAgICAgICAgICBgZ3JwYy1ub2RlLWpzLyR7Y2xpZW50VmVyc2lvbn1gLFxuICAgICAgICAgICAgb3B0aW9uc1snZ3JwYy5zZWNvbmRhcnlfdXNlcl9hZ2VudCddLFxuICAgICAgICBdXG4gICAgICAgICAgICAuZmlsdGVyKGUgPT4gZSlcbiAgICAgICAgICAgIC5qb2luKCcgJyk7IC8vIHJlbW92ZSBmYWxzZXkgdmFsdWVzIGZpcnN0XG4gICAgICAgIGlmICgnZ3JwYy5rZWVwYWxpdmVfdGltZV9tcycgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lTXMgPSBvcHRpb25zWydncnBjLmtlZXBhbGl2ZV90aW1lX21zJ107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVNcyA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZ3JwYy5rZWVwYWxpdmVfdGltZW91dF9tcycgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lb3V0TXMgPSBvcHRpb25zWydncnBjLmtlZXBhbGl2ZV90aW1lb3V0X21zJ107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyA9IEtFRVBBTElWRV9USU1FT1VUX01TO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZ3JwYy5rZWVwYWxpdmVfcGVybWl0X3dpdGhvdXRfY2FsbHMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlV2l0aG91dENhbGxzID1cbiAgICAgICAgICAgICAgICBvcHRpb25zWydncnBjLmtlZXBhbGl2ZV9wZXJtaXRfd2l0aG91dF9jYWxscyddID09PSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzZXNzaW9uLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnc2Vzc2lvbiBjbG9zZWQnKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2Vzc2lvbi5vbmNlKCdnb2F3YXknLCAoZXJyb3JDb2RlLCBsYXN0U3RyZWFtSUQsIG9wYXF1ZURhdGEpID0+IHtcbiAgICAgICAgICAgIGxldCB0b29NYW55UGluZ3MgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qIFNlZSB0aGUgbGFzdCBwYXJhZ3JhcGggb2ZcbiAgICAgICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL3Byb3Bvc2FsL2Jsb2IvbWFzdGVyL0E4LWNsaWVudC1zaWRlLWtlZXBhbGl2ZS5tZCNiYXNpYy1rZWVwYWxpdmUgKi9cbiAgICAgICAgICAgIGlmIChlcnJvckNvZGUgPT09IGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0VOSEFOQ0VfWU9VUl9DQUxNICYmXG4gICAgICAgICAgICAgICAgb3BhcXVlRGF0YSAmJlxuICAgICAgICAgICAgICAgIG9wYXF1ZURhdGEuZXF1YWxzKHRvb01hbnlQaW5nc0RhdGEpKSB7XG4gICAgICAgICAgICAgICAgdG9vTWFueVBpbmdzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2Nvbm5lY3Rpb24gY2xvc2VkIGJ5IEdPQVdBWSB3aXRoIGNvZGUgJyArXG4gICAgICAgICAgICAgICAgZXJyb3JDb2RlICtcbiAgICAgICAgICAgICAgICAnIGFuZCBkYXRhICcgK1xuICAgICAgICAgICAgICAgIChvcGFxdWVEYXRhID09PSBudWxsIHx8IG9wYXF1ZURhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wYXF1ZURhdGEudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgdGhpcy5yZXBvcnREaXNjb25uZWN0VG9Pd25lcih0b29NYW55UGluZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2Vzc2lvbi5vbmNlKCdlcnJvcicsIGVycm9yID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2Nvbm5lY3Rpb24gY2xvc2VkIHdpdGggZXJyb3IgJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXNzaW9uLnNvY2tldC5vbmNlKCdjbG9zZScsIChoYWRFcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnY29ubmVjdGlvbiBjbG9zZWQuIGhhZEVycm9yPScgKyBoYWRFcnJvcik7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsb2dnaW5nLmlzVHJhY2VyRW5hYmxlZChUUkFDRVJfTkFNRSkpIHtcbiAgICAgICAgICAgIHNlc3Npb24ub24oJ3JlbW90ZVNldHRpbmdzJywgKHNldHRpbmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnbmV3IHNldHRpbmdzIHJlY2VpdmVkJyArXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnNlc3Npb24gIT09IHNlc3Npb24gPyAnIG9uIHRoZSBvbGQgY29ubmVjdGlvbicgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAnOiAnICtcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2Vzc2lvbi5vbignbG9jYWxTZXR0aW5ncycsIChzZXR0aW5ncykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ2xvY2FsIHNldHRpbmdzIGFja25vd2xlZGdlZCBieSByZW1vdGUnICtcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc2Vzc2lvbiAhPT0gc2Vzc2lvbiA/ICcgb24gdGhlIG9sZCBjb25uZWN0aW9uJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICc6ICcgK1xuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShzZXR0aW5ncykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogU3RhcnQgdGhlIGtlZXBhbGl2ZSB0aW1lciBsYXN0LCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXIgdHJhY2UgbG9ncyxcbiAgICAgICAgICogd2hpY2ggc2hvdWxkIG9ubHkgaGFwcGVuIGFmdGVyIGV2ZXJ5dGhpbmcgZWxzZSBpcyBzZXQgdXAuICovXG4gICAgICAgIGlmICh0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscykge1xuICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0S2VlcGFsaXZlUGluZ1RpbWVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2hhbm5lbHpJbmZvKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3Qgc2Vzc2lvblNvY2tldCA9IHRoaXMuc2Vzc2lvbi5zb2NrZXQ7XG4gICAgICAgIGNvbnN0IHJlbW90ZUFkZHJlc3MgPSBzZXNzaW9uU29ja2V0LnJlbW90ZUFkZHJlc3NcbiAgICAgICAgICAgID8gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3MpKHNlc3Npb25Tb2NrZXQucmVtb3RlQWRkcmVzcywgc2Vzc2lvblNvY2tldC5yZW1vdGVQb3J0KVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjb25zdCBsb2NhbEFkZHJlc3MgPSBzZXNzaW9uU29ja2V0LmxvY2FsQWRkcmVzc1xuICAgICAgICAgICAgPyAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcykoc2Vzc2lvblNvY2tldC5sb2NhbEFkZHJlc3MsIHNlc3Npb25Tb2NrZXQubG9jYWxQb3J0KVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBsZXQgdGxzSW5mbztcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi5lbmNyeXB0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRsc1NvY2tldCA9IHNlc3Npb25Tb2NrZXQ7XG4gICAgICAgICAgICBjb25zdCBjaXBoZXJJbmZvID0gdGxzU29ja2V0LmdldENpcGhlcigpO1xuICAgICAgICAgICAgY29uc3QgY2VydGlmaWNhdGUgPSB0bHNTb2NrZXQuZ2V0Q2VydGlmaWNhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHBlZXJDZXJ0aWZpY2F0ZSA9IHRsc1NvY2tldC5nZXRQZWVyQ2VydGlmaWNhdGUoKTtcbiAgICAgICAgICAgIHRsc0luZm8gPSB7XG4gICAgICAgICAgICAgICAgY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWU6IChfYSA9IGNpcGhlckluZm8uc3RhbmRhcmROYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLFxuICAgICAgICAgICAgICAgIGNpcGhlclN1aXRlT3RoZXJOYW1lOiBjaXBoZXJJbmZvLnN0YW5kYXJkTmFtZSA/IG51bGwgOiBjaXBoZXJJbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgbG9jYWxDZXJ0aWZpY2F0ZTogY2VydGlmaWNhdGUgJiYgJ3JhdycgaW4gY2VydGlmaWNhdGUgPyBjZXJ0aWZpY2F0ZS5yYXcgOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlbW90ZUNlcnRpZmljYXRlOiBwZWVyQ2VydGlmaWNhdGUgJiYgJ3JhdycgaW4gcGVlckNlcnRpZmljYXRlXG4gICAgICAgICAgICAgICAgICAgID8gcGVlckNlcnRpZmljYXRlLnJhd1xuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGxzSW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc29ja2V0SW5mbyA9IHtcbiAgICAgICAgICAgIHJlbW90ZUFkZHJlc3M6IHJlbW90ZUFkZHJlc3MsXG4gICAgICAgICAgICBsb2NhbEFkZHJlc3M6IGxvY2FsQWRkcmVzcyxcbiAgICAgICAgICAgIHNlY3VyaXR5OiB0bHNJbmZvLFxuICAgICAgICAgICAgcmVtb3RlTmFtZTogdGhpcy5yZW1vdGVOYW1lLFxuICAgICAgICAgICAgc3RyZWFtc1N0YXJ0ZWQ6IHRoaXMuc3RyZWFtVHJhY2tlci5jYWxsc1N0YXJ0ZWQsXG4gICAgICAgICAgICBzdHJlYW1zU3VjY2VlZGVkOiB0aGlzLnN0cmVhbVRyYWNrZXIuY2FsbHNTdWNjZWVkZWQsXG4gICAgICAgICAgICBzdHJlYW1zRmFpbGVkOiB0aGlzLnN0cmVhbVRyYWNrZXIuY2FsbHNGYWlsZWQsXG4gICAgICAgICAgICBtZXNzYWdlc1NlbnQ6IHRoaXMubWVzc2FnZXNTZW50LFxuICAgICAgICAgICAgbWVzc2FnZXNSZWNlaXZlZDogdGhpcy5tZXNzYWdlc1JlY2VpdmVkLFxuICAgICAgICAgICAga2VlcEFsaXZlc1NlbnQ6IHRoaXMua2VlcGFsaXZlc1NlbnQsXG4gICAgICAgICAgICBsYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiB0aGlzLnN0cmVhbVRyYWNrZXIubGFzdENhbGxTdGFydGVkVGltZXN0YW1wLFxuICAgICAgICAgICAgbGFzdFJlbW90ZVN0cmVhbUNyZWF0ZWRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICBsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXA6IHRoaXMubGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wLFxuICAgICAgICAgICAgbGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcDogdGhpcy5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wLFxuICAgICAgICAgICAgbG9jYWxGbG93Q29udHJvbFdpbmRvdzogKF9iID0gdGhpcy5zZXNzaW9uLnN0YXRlLmxvY2FsV2luZG93U2l6ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbCxcbiAgICAgICAgICAgIHJlbW90ZUZsb3dDb250cm9sV2luZG93OiAoX2MgPSB0aGlzLnNlc3Npb24uc3RhdGUucmVtb3RlV2luZG93U2l6ZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNvY2tldEluZm87XG4gICAgfVxuICAgIHRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnKCcgK1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselJlZi5pZCArXG4gICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIHRleHQpO1xuICAgIH1cbiAgICBrZWVwYWxpdmVUcmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAna2VlcGFsaXZlJywgJygnICtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xuICAgICAgICAgICAgJykgJyArXG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICB0ZXh0KTtcbiAgICB9XG4gICAgZmxvd0NvbnRyb2xUcmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBGTE9XX0NPTlRST0xfVFJBQ0VSX05BTUUsICcoJyArXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmLmlkICtcbiAgICAgICAgICAgICcpICcgK1xuICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgdGV4dCk7XG4gICAgfVxuICAgIGludGVybmFsc1RyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICd0cmFuc3BvcnRfaW50ZXJuYWxzJywgJygnICtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xuICAgICAgICAgICAgJykgJyArXG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICB0ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGUgdG8gdGhlIG93bmVyIG9mIHRoaXMgb2JqZWN0IHRoYXQgdGhpcyB0cmFuc3BvcnQgc2hvdWxkIG5vIGxvbmdlclxuICAgICAqIGJlIHVzZWQuIFRoYXQgaGFwcGVucyBpZiB0aGUgY29ubmVjdGlvbiBkcm9wcywgb3IgaWYgdGhlIHNlcnZlciBzZW5kcyBhXG4gICAgICogR09BV0FZLlxuICAgICAqIEBwYXJhbSB0b29NYW55UGluZ3MgSWYgdHJ1ZSwgdGhpcyB3YXMgdHJpZ2dlcmVkIGJ5IGEgR09BV0FZIHdpdGggZGF0YVxuICAgICAqIGluZGljYXRpbmcgdGhhdCB0aGUgc2Vzc2lvbiB3YXMgY2xvc2VkIGJlY2F1ZXMgdGhlIGNsaWVudCBzZW50IHRvbyBtYW55XG4gICAgICogcGluZ3MuXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICByZXBvcnREaXNjb25uZWN0VG9Pd25lcih0b29NYW55UGluZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzY29ubmVjdEhhbmRsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RIYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0TGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIodG9vTWFueVBpbmdzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBjb25uZWN0aW9uIGRyb3BzLCBidXQgbm90IEdPQVdBWXMuXG4gICAgICovXG4gICAgaGFuZGxlRGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5jbGVhcktlZXBhbGl2ZVRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5yZXBvcnREaXNjb25uZWN0VG9Pd25lcihmYWxzZSk7XG4gICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiB0aGlzLmFjdGl2ZUNhbGxzKSB7XG4gICAgICAgICAgICBjYWxsLm9uRGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdhaXQgYW4gZXZlbnQgbG9vcCBjeWNsZSBiZWZvcmUgZGVzdHJveWluZyB0aGUgY29ubmVjdGlvblxuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZERpc2Nvbm5lY3RMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICAgIGNhblNlbmRQaW5nKCkge1xuICAgICAgICByZXR1cm4gKCF0aGlzLnNlc3Npb24uZGVzdHJveWVkICYmXG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVNcyA+IDAgJiZcbiAgICAgICAgICAgICh0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscyB8fCB0aGlzLmFjdGl2ZUNhbGxzLnNpemUgPiAwKSk7XG4gICAgfVxuICAgIG1heWJlU2VuZFBpbmcoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5jYW5TZW5kUGluZygpKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdTZW5kS2VlcGFsaXZlUGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMua2VlcGFsaXZlVGltZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2tlZXBhbGl2ZVRpbWVvdXQgaXMgbm90IG51bGwnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlc1NlbnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdTZW5kaW5nIHBpbmcgd2l0aCB0aW1lb3V0ICcgKyB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyArICdtcycpO1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1BpbmcgdGltZW91dCBwYXNzZWQgd2l0aG91dCByZXNwb25zZScpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgIH0sIHRoaXMua2VlcGFsaXZlVGltZW91dE1zKTtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5rZWVwYWxpdmVUaW1lcikudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgbGV0IHBpbmdTZW5kRXJyb3IgPSAnJztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBpbmdTZW50U3VjY2Vzc2Z1bGx5ID0gdGhpcy5zZXNzaW9uLnBpbmcoKGVyciwgZHVyYXRpb24sIHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyS2VlcGFsaXZlVGltZW91dCgpO1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnUGluZyBmYWlsZWQgd2l0aCBlcnJvciAnICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1JlY2VpdmVkIHBpbmcgcmVzcG9uc2UnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0S2VlcGFsaXZlUGluZ1RpbWVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXBpbmdTZW50U3VjY2Vzc2Z1bGx5KSB7XG4gICAgICAgICAgICAgICAgcGluZ1NlbmRFcnJvciA9ICdQaW5nIHJldHVybmVkIGZhbHNlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gZ3JwYy9ncnBjLW5vZGUjMjEzOVxuICAgICAgICAgICAgcGluZ1NlbmRFcnJvciA9IChlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiAnJykgfHwgJ1Vua25vd24gZXJyb3InO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwaW5nU2VuZEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdQaW5nIHNlbmQgZmFpbGVkOiAnICsgcGluZ1NlbmRFcnJvcik7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIGtlZXBhbGl2ZSBwaW5nIHRpbWVyIGlmIGFwcHJvcHJpYXRlLiBJZiB0aGUgdGltZXIgYWxyZWFkeSByYW5cbiAgICAgKiBvdXQgd2hpbGUgdGhlcmUgd2VyZSBubyBhY3RpdmUgcmVxdWVzdHMsIGluc3RlYWQgc2VuZCBhIHBpbmcgaW1tZWRpYXRlbHkuXG4gICAgICogSWYgdGhlIHBpbmcgdGltZXIgaXMgYWxyZWFkeSBydW5uaW5nIG9yIGEgcGluZyBpcyBjdXJyZW50bHkgaW4gZmxpZ2h0LFxuICAgICAqIGluc3RlYWQgZG8gbm90aGluZyBhbmQgd2FpdCBmb3IgdGhlbSB0byByZXNvbHZlLlxuICAgICAqL1xuICAgIG1heWJlU3RhcnRLZWVwYWxpdmVQaW5nVGltZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5jYW5TZW5kUGluZygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1NlbmRLZWVwYWxpdmVQaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdTZW5kS2VlcGFsaXZlUGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5tYXliZVNlbmRQaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMua2VlcGFsaXZlVGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1N0YXJ0aW5nIGtlZXBhbGl2ZSB0aW1lciBmb3IgJyArIHRoaXMua2VlcGFsaXZlVGltZU1zICsgJ21zJyk7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXliZVNlbmRQaW5nKCk7XG4gICAgICAgICAgICB9LCB0aGlzLmtlZXBhbGl2ZVRpbWVNcyk7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmtlZXBhbGl2ZVRpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB9XG4gICAgICAgIC8qIE90aGVyd2lzZSwgdGhlcmUgaXMgYWxyZWFkeSBlaXRoZXIgYSBrZWVwYWxpdmUgdGltZXIgb3IgYSBwaW5nIHBlbmRpbmcsXG4gICAgICAgICAqIHdhaXQgZm9yIHRob3NlIHRvIHJlc29sdmUuICovXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB3aGljaGV2ZXIga2VlcGFsaXZlIHRpbWVvdXQgaXMgY3VycmVudGx5IGFjdGl2ZSwgaWYgYW55LlxuICAgICAqL1xuICAgIGNsZWFyS2VlcGFsaXZlVGltZW91dCgpIHtcbiAgICAgICAgaWYgKHRoaXMua2VlcGFsaXZlVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmtlZXBhbGl2ZVRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUFjdGl2ZUNhbGwoY2FsbCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUNhbGxzLmRlbGV0ZShjYWxsKTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ2FsbHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnVucmVmKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkQWN0aXZlQ2FsbChjYWxsKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2FsbHMuYWRkKGNhbGwpO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVDYWxscy5zaXplID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVmKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMua2VlcGFsaXZlV2l0aG91dENhbGxzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0S2VlcGFsaXZlUGluZ1RpbWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlQ2FsbChtZXRhZGF0YSwgaG9zdCwgbWV0aG9kLCBsaXN0ZW5lciwgc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG1ldGFkYXRhLnRvSHR0cDJIZWFkZXJzKCk7XG4gICAgICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX0FVVEhPUklUWV0gPSBob3N0O1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9VU0VSX0FHRU5UXSA9IHRoaXMudXNlckFnZW50O1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9DT05URU5UX1RZUEVdID0gJ2FwcGxpY2F0aW9uL2dycGMnO1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9NRVRIT0RdID0gJ1BPU1QnO1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9QQVRIXSA9IG1ldGhvZDtcbiAgICAgICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfVEVdID0gJ3RyYWlsZXJzJztcbiAgICAgICAgbGV0IGh0dHAyU3RyZWFtO1xuICAgICAgICAvKiBJbiB0aGVvcnksIGlmIGFuIGVycm9yIGlzIHRocm93biBieSBzZXNzaW9uLnJlcXVlc3QgYmVjYXVzZSBzZXNzaW9uIGhhc1xuICAgICAgICAgKiBiZWNvbWUgdW51c2FibGUgKGUuZy4gYmVjYXVzZSBpdCBoYXMgcmVjZWl2ZWQgYSBnb2F3YXkpLCB0aGlzIHN1YmNoYW5uZWxcbiAgICAgICAgICogc2hvdWxkIHNvb24gc2VlIHRoZSBjb3JyZXNwb25kaW5nIGNsb3NlIG9yIGdvYXdheSBldmVudCBhbnl3YXkgYW5kIGxlYXZlXG4gICAgICAgICAqIFJFQURZLiBCdXQgd2UgaGF2ZSBzZWVuIHJlcG9ydHMgdGhhdCB0aGlzIGRvZXMgbm90IGhhcHBlblxuICAgICAgICAgKiAoaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZWFwaXMvbm9kZWpzLWZpcmVzdG9yZS9pc3N1ZXMvMTAyMyNpc3N1ZWNvbW1lbnQtNjUzMjA0MDk2KVxuICAgICAgICAgKiBzbyBmb3IgZGVmZW5zZSBpbiBkZXB0aCwgd2UganVzdCBkaXNjYXJkIHRoZSBzZXNzaW9uIHdoZW4gd2Ugc2VlIGFuXG4gICAgICAgICAqIGVycm9yIGhlcmUuXG4gICAgICAgICAqL1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaHR0cDJTdHJlYW0gPSB0aGlzLnNlc3Npb24ucmVxdWVzdChoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmxvd0NvbnRyb2xUcmFjZSgnbG9jYWwgd2luZG93IHNpemU6ICcgK1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnN0YXRlLmxvY2FsV2luZG93U2l6ZSArXG4gICAgICAgICAgICAnIHJlbW90ZSB3aW5kb3cgc2l6ZTogJyArXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uc3RhdGUucmVtb3RlV2luZG93U2l6ZSk7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxzVHJhY2UoJ3Nlc3Npb24uY2xvc2VkPScgK1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmNsb3NlZCArXG4gICAgICAgICAgICAnIHNlc3Npb24uZGVzdHJveWVkPScgK1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmRlc3Ryb3llZCArXG4gICAgICAgICAgICAnIHNlc3Npb24uc29ja2V0LmRlc3Ryb3llZD0nICtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zb2NrZXQuZGVzdHJveWVkKTtcbiAgICAgICAgbGV0IGV2ZW50VHJhY2tlcjtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgICAgICBsZXQgY2FsbDtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbFN0YXJ0ZWQoKTtcbiAgICAgICAgICAgIGV2ZW50VHJhY2tlciA9IHtcbiAgICAgICAgICAgICAgICBhZGRNZXNzYWdlU2VudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZXNTZW50ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIuYWRkTWVzc2FnZVNlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFkZE1lc3NhZ2VSZWNlaXZlZDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZXNSZWNlaXZlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlci5hZGRNZXNzYWdlUmVjZWl2ZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uQ2FsbEVuZDogc3RhdHVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlci5vbkNhbGxFbmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLCBzdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUFjdGl2ZUNhbGwoY2FsbCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblN0cmVhbUVuZDogc3VjY2VzcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlci5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLm9uU3RyZWFtRW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlciwgc3VjY2Vzcyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBldmVudFRyYWNrZXIgPSB7XG4gICAgICAgICAgICAgICAgYWRkTWVzc2FnZVNlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlci5hZGRNZXNzYWdlU2VudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWRkTWVzc2FnZVJlY2VpdmVkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIuYWRkTWVzc2FnZVJlY2VpdmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkNhbGxFbmQ6IHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIub25DYWxsRW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlciwgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBY3RpdmVDYWxsKGNhbGwpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25TdHJlYW1FbmQ6IHN1Y2Nlc3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLm9uU3RyZWFtRW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlciwgc3VjY2Vzcyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FsbCA9IG5ldyBzdWJjaGFubmVsX2NhbGxfMS5IdHRwMlN1YmNoYW5uZWxDYWxsKGh0dHAyU3RyZWFtLCBldmVudFRyYWNrZXIsIGxpc3RlbmVyLCB0aGlzLCAoMCwgY2FsbF9udW1iZXJfMS5nZXROZXh0Q2FsbE51bWJlcikoKSk7XG4gICAgICAgIHRoaXMuYWRkQWN0aXZlQ2FsbChjYWxsKTtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIGdldENoYW5uZWx6UmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVselJlZjtcbiAgICB9XG4gICAgZ2V0UGVlck5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nO1xuICAgIH1cbiAgICBnZXRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLmNsb3NlKCk7XG4gICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikodGhpcy5jaGFubmVselJlZik7XG4gICAgfVxufVxuY2xhc3MgSHR0cDJTdWJjaGFubmVsQ29ubmVjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsVGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbFRhcmdldCA9IGNoYW5uZWxUYXJnZXQ7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNTaHV0ZG93biA9IGZhbHNlO1xuICAgIH1cbiAgICB0cmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy5jaGFubmVsVGFyZ2V0KSArICcgJyArIHRleHQpO1xuICAgIH1cbiAgICBjcmVhdGVTZXNzaW9uKHNlY3VyZUNvbm5lY3RSZXN1bHQsIGFkZHJlc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTaHV0ZG93bikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3VyZUNvbm5lY3RSZXN1bHQuc29ja2V0LmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDb25uZWN0aW9uIGNsb3NlZCBiZWZvcmUgc3RhcnRpbmcgSFRUUC8yIGhhbmRzaGFrZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBsZXQgcmVtb3RlTmFtZSA9IG51bGw7XG4gICAgICAgICAgICBsZXQgcmVhbFRhcmdldCA9IHRoaXMuY2hhbm5lbFRhcmdldDtcbiAgICAgICAgICAgIGlmICgnZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0JyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkVGFyZ2V0ID0gKDAsIHVyaV9wYXJzZXJfMS5wYXJzZVVyaSkob3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0J10pO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhbFRhcmdldCA9IHBhcnNlZFRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlTmFtZSA9ICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHBhcnNlZFRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gc2VjdXJlQ29ubmVjdFJlc3VsdC5zZWN1cmUgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UGF0aCA9ICgwLCByZXNvbHZlcl8xLmdldERlZmF1bHRBdXRob3JpdHkpKHJlYWxUYXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgY2xvc2VIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBMZWF2ZSB0aW1lIGZvciBlcnJvciBldmVudCB0byBoYXBwZW4gYmVmb3JlIHJlamVjdGluZ1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVwb3J0ZWRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwb3J0ZWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoYCR7ZXJyb3JNZXNzYWdlLnRyaW0oKX0gKCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdjb25uZWN0aW9uIGZhaWxlZCB3aXRoIGVycm9yICcgKyBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGlmICghcmVwb3J0ZWRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXBvcnRlZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGAke2Vycm9yTWVzc2FnZX0gKCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfSlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGh0dHAyLmNvbm5lY3QoYCR7c2NoZW1lfTovLyR7dGFyZ2V0UGF0aH1gLCB7XG4gICAgICAgICAgICAgICAgY3JlYXRlQ29ubmVjdGlvbjogKGF1dGhvcml0eSwgb3B0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWN1cmVDb25uZWN0UmVzdWx0LnNvY2tldDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxXaW5kb3dTaXplOiAoX2EgPSBvcHRpb25zWydncnBjLW5vZGUuZmxvd19jb250cm9sX3dpbmRvdyddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBodHRwMi5nZXREZWZhdWx0U2V0dGluZ3MoKS5pbml0aWFsV2luZG93U2l6ZSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gJ0ZhaWxlZCB0byBjb25uZWN0JztcbiAgICAgICAgICAgIGxldCByZXBvcnRlZEVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICBzZXNzaW9uLnVucmVmKCk7XG4gICAgICAgICAgICBzZXNzaW9uLm9uY2UoJ3JlbW90ZVNldHRpbmdzJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgc2VjdXJlQ29ubmVjdFJlc3VsdC5zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xvc2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBzZWN1cmVDb25uZWN0UmVzdWx0LnNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IEh0dHAyVHJhbnNwb3J0KHNlc3Npb24sIGFkZHJlc3MsIG9wdGlvbnMsIHJlbW90ZU5hbWUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXNzaW9uLm9uY2UoJ2Nsb3NlJywgY2xvc2VIYW5kbGVyKTtcbiAgICAgICAgICAgIHNlc3Npb24ub25jZSgnZXJyb3InLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgICAgc2VjdXJlQ29ubmVjdFJlc3VsdC5zb2NrZXQub25jZSgnY2xvc2UnLCBjbG9zZUhhbmRsZXIpO1xuICAgICAgICAgICAgc2VjdXJlQ29ubmVjdFJlc3VsdC5zb2NrZXQub25jZSgnZXJyb3InLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGNwQ29ubmVjdChhZGRyZXNzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgaHR0cF9wcm94eV8xLmdldFByb3hpZWRDb25uZWN0aW9uKShhZGRyZXNzLCBvcHRpb25zKS50aGVuKHByb3hpZWRTb2NrZXQgPT4ge1xuICAgICAgICAgICAgaWYgKHByb3hpZWRTb2NrZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJveGllZFNvY2tldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsb3NlQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdTb2NrZXQgY2xvc2VkJykpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvckNhbGxiYWNrID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb2NrZXQgPSBuZXQuY29ubmVjdChhZGRyZXNzLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xvc2VDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHNvY2tldCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQub25jZSgnY2xvc2UnLCBjbG9zZUNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uY2UoJ2Vycm9yJywgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBjb25uZWN0KGFkZHJlc3MsIHNlY3VyZUNvbm5lY3Rvciwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5pc1NodXRkb3duKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGNwQ29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgIGxldCBzZWN1cmVDb25uZWN0UmVzdWx0ID0gbnVsbDtcbiAgICAgICAgY29uc3QgYWRkcmVzc1N0cmluZyA9ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShhZGRyZXNzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoYWRkcmVzc1N0cmluZyArICcgV2FpdGluZyBmb3Igc2VjdXJlQ29ubmVjdG9yIHRvIGJlIHJlYWR5Jyk7XG4gICAgICAgICAgICBhd2FpdCBzZWN1cmVDb25uZWN0b3Iud2FpdEZvclJlYWR5KCk7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKGFkZHJlc3NTdHJpbmcgKyAnIHNlY3VyZUNvbm5lY3RvciBpcyByZWFkeScpO1xuICAgICAgICAgICAgdGNwQ29ubmVjdGlvbiA9IGF3YWl0IHRoaXMudGNwQ29ubmVjdChhZGRyZXNzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoYWRkcmVzc1N0cmluZyArICcgRXN0YWJsaXNoZWQgVENQIGNvbm5lY3Rpb24nKTtcbiAgICAgICAgICAgIHNlY3VyZUNvbm5lY3RSZXN1bHQgPSBhd2FpdCBzZWN1cmVDb25uZWN0b3IuY29ubmVjdCh0Y3BDb25uZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoYWRkcmVzc1N0cmluZyArICcgRXN0YWJsaXNoZWQgc2VjdXJlIGNvbm5lY3Rpb24nKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNlc3Npb24oc2VjdXJlQ29ubmVjdFJlc3VsdCwgYWRkcmVzcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRjcENvbm5lY3Rpb24gPT09IG51bGwgfHwgdGNwQ29ubmVjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGNwQ29ubmVjdGlvbi5kZXN0cm95KCk7XG4gICAgICAgICAgICBzZWN1cmVDb25uZWN0UmVzdWx0ID09PSBudWxsIHx8IHNlY3VyZUNvbm5lY3RSZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlY3VyZUNvbm5lY3RSZXN1bHQuc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2h1dGRvd24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5pc1NodXRkb3duID0gdHJ1ZTtcbiAgICAgICAgKF9hID0gdGhpcy5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkh0dHAyU3ViY2hhbm5lbENvbm5lY3RvciA9IEh0dHAyU3ViY2hhbm5lbENvbm5lY3Rvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zcG9ydC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJIdHRwMlN1YmNoYW5uZWxDb25uZWN0b3IiLCJodHRwMiIsInJlcXVpcmUiLCJjaGFubmVsel8xIiwiY29uc3RhbnRzXzEiLCJodHRwX3Byb3h5XzEiLCJsb2dnaW5nIiwicmVzb2x2ZXJfMSIsInN1YmNoYW5uZWxfYWRkcmVzc18xIiwidXJpX3BhcnNlcl8xIiwibmV0Iiwic3ViY2hhbm5lbF9jYWxsXzEiLCJjYWxsX251bWJlcl8xIiwiVFJBQ0VSX05BTUUiLCJGTE9XX0NPTlRST0xfVFJBQ0VSX05BTUUiLCJjbGllbnRWZXJzaW9uIiwidmVyc2lvbiIsIkhUVFAyX0hFQURFUl9BVVRIT1JJVFkiLCJIVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFIiwiSFRUUDJfSEVBREVSX01FVEhPRCIsIkhUVFAyX0hFQURFUl9QQVRIIiwiSFRUUDJfSEVBREVSX1RFIiwiSFRUUDJfSEVBREVSX1VTRVJfQUdFTlQiLCJjb25zdGFudHMiLCJLRUVQQUxJVkVfVElNRU9VVF9NUyIsInRvb01hbnlQaW5nc0RhdGEiLCJCdWZmZXIiLCJmcm9tIiwiSHR0cDJUcmFuc3BvcnQiLCJjb25zdHJ1Y3RvciIsInNlc3Npb24iLCJzdWJjaGFubmVsQWRkcmVzcyIsIm9wdGlvbnMiLCJyZW1vdGVOYW1lIiwia2VlcGFsaXZlVGltZXIiLCJwZW5kaW5nU2VuZEtlZXBhbGl2ZVBpbmciLCJhY3RpdmVDYWxscyIsIlNldCIsImRpc2Nvbm5lY3RMaXN0ZW5lcnMiLCJkaXNjb25uZWN0SGFuZGxlZCIsImNoYW5uZWx6RW5hYmxlZCIsImtlZXBhbGl2ZXNTZW50IiwibWVzc2FnZXNTZW50IiwibWVzc2FnZXNSZWNlaXZlZCIsImxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCIsImxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAiLCJzdWJjaGFubmVsQWRkcmVzc1N0cmluZyIsInN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmciLCJzdHJlYW1UcmFja2VyIiwiQ2hhbm5lbHpDYWxsVHJhY2tlclN0dWIiLCJDaGFubmVsekNhbGxUcmFja2VyIiwiY2hhbm5lbHpSZWYiLCJyZWdpc3RlckNoYW5uZWx6U29ja2V0IiwiZ2V0Q2hhbm5lbHpJbmZvIiwidXNlckFnZW50IiwiZmlsdGVyIiwiZSIsImpvaW4iLCJrZWVwYWxpdmVUaW1lTXMiLCJrZWVwYWxpdmVUaW1lb3V0TXMiLCJrZWVwYWxpdmVXaXRob3V0Q2FsbHMiLCJvbmNlIiwidHJhY2UiLCJoYW5kbGVEaXNjb25uZWN0IiwiZXJyb3JDb2RlIiwibGFzdFN0cmVhbUlEIiwib3BhcXVlRGF0YSIsInRvb01hbnlQaW5ncyIsIk5HSFRUUDJfRU5IQU5DRV9ZT1VSX0NBTE0iLCJlcXVhbHMiLCJ0b1N0cmluZyIsInJlcG9ydERpc2Nvbm5lY3RUb093bmVyIiwiZXJyb3IiLCJtZXNzYWdlIiwic29ja2V0IiwiaGFkRXJyb3IiLCJpc1RyYWNlckVuYWJsZWQiLCJvbiIsInNldHRpbmdzIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1heWJlU3RhcnRLZWVwYWxpdmVQaW5nVGltZXIiLCJfYSIsIl9iIiwiX2MiLCJzZXNzaW9uU29ja2V0IiwicmVtb3RlQWRkcmVzcyIsInN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3MiLCJyZW1vdGVQb3J0IiwibG9jYWxBZGRyZXNzIiwibG9jYWxQb3J0IiwidGxzSW5mbyIsImVuY3J5cHRlZCIsInRsc1NvY2tldCIsImNpcGhlckluZm8iLCJnZXRDaXBoZXIiLCJjZXJ0aWZpY2F0ZSIsImdldENlcnRpZmljYXRlIiwicGVlckNlcnRpZmljYXRlIiwiZ2V0UGVlckNlcnRpZmljYXRlIiwiY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWUiLCJzdGFuZGFyZE5hbWUiLCJjaXBoZXJTdWl0ZU90aGVyTmFtZSIsIm5hbWUiLCJsb2NhbENlcnRpZmljYXRlIiwicmF3IiwicmVtb3RlQ2VydGlmaWNhdGUiLCJzb2NrZXRJbmZvIiwic2VjdXJpdHkiLCJzdHJlYW1zU3RhcnRlZCIsImNhbGxzU3RhcnRlZCIsInN0cmVhbXNTdWNjZWVkZWQiLCJjYWxsc1N1Y2NlZWRlZCIsInN0cmVhbXNGYWlsZWQiLCJjYWxsc0ZhaWxlZCIsImtlZXBBbGl2ZXNTZW50IiwibGFzdExvY2FsU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcCIsImxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCIsImxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wIiwibG9jYWxGbG93Q29udHJvbFdpbmRvdyIsInN0YXRlIiwibG9jYWxXaW5kb3dTaXplIiwicmVtb3RlRmxvd0NvbnRyb2xXaW5kb3ciLCJyZW1vdGVXaW5kb3dTaXplIiwidGV4dCIsIkxvZ1ZlcmJvc2l0eSIsIkRFQlVHIiwiaWQiLCJrZWVwYWxpdmVUcmFjZSIsImZsb3dDb250cm9sVHJhY2UiLCJpbnRlcm5hbHNUcmFjZSIsImZvckVhY2giLCJsaXN0ZW5lciIsImNsZWFyS2VlcGFsaXZlVGltZW91dCIsImNhbGwiLCJvbkRpc2Nvbm5lY3QiLCJzZXRJbW1lZGlhdGUiLCJkZXN0cm95IiwiYWRkRGlzY29ubmVjdExpc3RlbmVyIiwicHVzaCIsImNhblNlbmRQaW5nIiwiZGVzdHJveWVkIiwic2l6ZSIsIm1heWJlU2VuZFBpbmciLCJjb25zb2xlIiwic2V0VGltZW91dCIsInVucmVmIiwicGluZ1NlbmRFcnJvciIsInBpbmdTZW50U3VjY2Vzc2Z1bGx5IiwicGluZyIsImVyciIsImR1cmF0aW9uIiwicGF5bG9hZCIsIkVycm9yIiwiY2xlYXJUaW1lb3V0IiwicmVtb3ZlQWN0aXZlQ2FsbCIsImRlbGV0ZSIsImFkZEFjdGl2ZUNhbGwiLCJhZGQiLCJyZWYiLCJjcmVhdGVDYWxsIiwibWV0YWRhdGEiLCJob3N0IiwibWV0aG9kIiwic3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIiLCJoZWFkZXJzIiwidG9IdHRwMkhlYWRlcnMiLCJodHRwMlN0cmVhbSIsInJlcXVlc3QiLCJjbG9zZWQiLCJldmVudFRyYWNrZXIiLCJhZGRDYWxsU3RhcnRlZCIsImFkZE1lc3NhZ2VTZW50IiwiRGF0ZSIsImFkZE1lc3NhZ2VSZWNlaXZlZCIsIm9uQ2FsbEVuZCIsInN0YXR1cyIsIm9uU3RyZWFtRW5kIiwic3VjY2VzcyIsImFkZENhbGxTdWNjZWVkZWQiLCJhZGRDYWxsRmFpbGVkIiwiSHR0cDJTdWJjaGFubmVsQ2FsbCIsImdldE5leHRDYWxsTnVtYmVyIiwiZ2V0Q2hhbm5lbHpSZWYiLCJnZXRQZWVyTmFtZSIsImdldE9wdGlvbnMiLCJzaHV0ZG93biIsImNsb3NlIiwidW5yZWdpc3RlckNoYW5uZWx6UmVmIiwiY2hhbm5lbFRhcmdldCIsImlzU2h1dGRvd24iLCJ1cmlUb1N0cmluZyIsImNyZWF0ZVNlc3Npb24iLCJzZWN1cmVDb25uZWN0UmVzdWx0IiwiYWRkcmVzcyIsIlByb21pc2UiLCJyZWplY3QiLCJyZXNvbHZlIiwicmVhbFRhcmdldCIsInBhcnNlZFRhcmdldCIsInBhcnNlVXJpIiwic2NoZW1lIiwic2VjdXJlIiwidGFyZ2V0UGF0aCIsImdldERlZmF1bHRBdXRob3JpdHkiLCJjbG9zZUhhbmRsZXIiLCJyZXBvcnRlZEVycm9yIiwiZXJyb3JNZXNzYWdlIiwidHJpbSIsInRvSVNPU3RyaW5nIiwiZXJyb3JIYW5kbGVyIiwiY29ubmVjdCIsImNyZWF0ZUNvbm5lY3Rpb24iLCJhdXRob3JpdHkiLCJvcHRpb24iLCJpbml0aWFsV2luZG93U2l6ZSIsImdldERlZmF1bHRTZXR0aW5ncyIsInJlbW92ZUFsbExpc3RlbmVycyIsInJlbW92ZUxpc3RlbmVyIiwidGNwQ29ubmVjdCIsImdldFByb3hpZWRDb25uZWN0aW9uIiwidGhlbiIsInByb3hpZWRTb2NrZXQiLCJjbG9zZUNhbGxiYWNrIiwiZXJyb3JDYWxsYmFjayIsInNlY3VyZUNvbm5lY3RvciIsInRjcENvbm5lY3Rpb24iLCJhZGRyZXNzU3RyaW5nIiwid2FpdEZvclJlYWR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/transport.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/uri-parser.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.parseUri = parseUri;\nexports.splitHostPort = splitHostPort;\nexports.combineHostPort = combineHostPort;\nexports.uriToString = uriToString;\n/*\n * The groups correspond to URI parts as follows:\n * 1. scheme\n * 2. authority\n * 3. path\n */ const URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\\/\\/([^/]*)\\/)?(.+)$/;\nfunction parseUri(uriString) {\n    const parsedUri = URI_REGEX.exec(uriString);\n    if (parsedUri === null) {\n        return null;\n    }\n    return {\n        scheme: parsedUri[1],\n        authority: parsedUri[2],\n        path: parsedUri[3]\n    };\n}\nconst NUMBER_REGEX = /^\\d+$/;\nfunction splitHostPort(path) {\n    if (path.startsWith(\"[\")) {\n        const hostEnd = path.indexOf(\"]\");\n        if (hostEnd === -1) {\n            return null;\n        }\n        const host = path.substring(1, hostEnd);\n        /* Only an IPv6 address should be in bracketed notation, and an IPv6\n         * address should have at least one colon */ if (host.indexOf(\":\") === -1) {\n            return null;\n        }\n        if (path.length > hostEnd + 1) {\n            if (path[hostEnd + 1] === \":\") {\n                const portString = path.substring(hostEnd + 2);\n                if (NUMBER_REGEX.test(portString)) {\n                    return {\n                        host: host,\n                        port: +portString\n                    };\n                } else {\n                    return null;\n                }\n            } else {\n                return null;\n            }\n        } else {\n            return {\n                host\n            };\n        }\n    } else {\n        const splitPath = path.split(\":\");\n        /* Exactly one colon means that this is host:port. Zero colons means that\n         * there is no port. And multiple colons means that this is a bare IPv6\n         * address with no port */ if (splitPath.length === 2) {\n            if (NUMBER_REGEX.test(splitPath[1])) {\n                return {\n                    host: splitPath[0],\n                    port: +splitPath[1]\n                };\n            } else {\n                return null;\n            }\n        } else {\n            return {\n                host: path\n            };\n        }\n    }\n}\nfunction combineHostPort(hostPort) {\n    if (hostPort.port === undefined) {\n        return hostPort.host;\n    } else {\n        // Only an IPv6 host should include a colon\n        if (hostPort.host.includes(\":\")) {\n            return `[${hostPort.host}]:${hostPort.port}`;\n        } else {\n            return `${hostPort.host}:${hostPort.port}`;\n        }\n    }\n}\nfunction uriToString(uri) {\n    let result = \"\";\n    if (uri.scheme !== undefined) {\n        result += uri.scheme + \":\";\n    }\n    if (uri.authority !== undefined) {\n        result += \"//\" + uri.authority + \"/\";\n    }\n    result += uri.path;\n    return result;\n} //# sourceMappingURL=uri-parser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdXJpLXBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0JBQWdCLEdBQUdFO0FBQ25CRixxQkFBcUIsR0FBR0c7QUFDeEJILHVCQUF1QixHQUFHSTtBQUMxQkosbUJBQW1CLEdBQUdLO0FBQ3RCOzs7OztDQUtDLEdBQ0QsTUFBTUMsWUFBWTtBQUNsQixTQUFTSixTQUFTSyxTQUFTO0lBQ3ZCLE1BQU1DLFlBQVlGLFVBQVVHLElBQUksQ0FBQ0Y7SUFDakMsSUFBSUMsY0FBYyxNQUFNO1FBQ3BCLE9BQU87SUFDWDtJQUNBLE9BQU87UUFDSEUsUUFBUUYsU0FBUyxDQUFDLEVBQUU7UUFDcEJHLFdBQVdILFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCSSxNQUFNSixTQUFTLENBQUMsRUFBRTtJQUN0QjtBQUNKO0FBQ0EsTUFBTUssZUFBZTtBQUNyQixTQUFTVixjQUFjUyxJQUFJO0lBQ3ZCLElBQUlBLEtBQUtFLFVBQVUsQ0FBQyxNQUFNO1FBQ3RCLE1BQU1DLFVBQVVILEtBQUtJLE9BQU8sQ0FBQztRQUM3QixJQUFJRCxZQUFZLENBQUMsR0FBRztZQUNoQixPQUFPO1FBQ1g7UUFDQSxNQUFNRSxPQUFPTCxLQUFLTSxTQUFTLENBQUMsR0FBR0g7UUFDL0I7a0RBQzBDLEdBQzFDLElBQUlFLEtBQUtELE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRztZQUMxQixPQUFPO1FBQ1g7UUFDQSxJQUFJSixLQUFLTyxNQUFNLEdBQUdKLFVBQVUsR0FBRztZQUMzQixJQUFJSCxJQUFJLENBQUNHLFVBQVUsRUFBRSxLQUFLLEtBQUs7Z0JBQzNCLE1BQU1LLGFBQWFSLEtBQUtNLFNBQVMsQ0FBQ0gsVUFBVTtnQkFDNUMsSUFBSUYsYUFBYVEsSUFBSSxDQUFDRCxhQUFhO29CQUMvQixPQUFPO3dCQUNISCxNQUFNQTt3QkFDTkssTUFBTSxDQUFDRjtvQkFDWDtnQkFDSixPQUNLO29CQUNELE9BQU87Z0JBQ1g7WUFDSixPQUNLO2dCQUNELE9BQU87WUFDWDtRQUNKLE9BQ0s7WUFDRCxPQUFPO2dCQUNISDtZQUNKO1FBQ0o7SUFDSixPQUNLO1FBQ0QsTUFBTU0sWUFBWVgsS0FBS1ksS0FBSyxDQUFDO1FBQzdCOztnQ0FFd0IsR0FDeEIsSUFBSUQsVUFBVUosTUFBTSxLQUFLLEdBQUc7WUFDeEIsSUFBSU4sYUFBYVEsSUFBSSxDQUFDRSxTQUFTLENBQUMsRUFBRSxHQUFHO2dCQUNqQyxPQUFPO29CQUNITixNQUFNTSxTQUFTLENBQUMsRUFBRTtvQkFDbEJELE1BQU0sQ0FBQ0MsU0FBUyxDQUFDLEVBQUU7Z0JBQ3ZCO1lBQ0osT0FDSztnQkFDRCxPQUFPO1lBQ1g7UUFDSixPQUNLO1lBQ0QsT0FBTztnQkFDSE4sTUFBTUw7WUFDVjtRQUNKO0lBQ0o7QUFDSjtBQUNBLFNBQVNSLGdCQUFnQnFCLFFBQVE7SUFDN0IsSUFBSUEsU0FBU0gsSUFBSSxLQUFLSSxXQUFXO1FBQzdCLE9BQU9ELFNBQVNSLElBQUk7SUFDeEIsT0FDSztRQUNELDJDQUEyQztRQUMzQyxJQUFJUSxTQUFTUixJQUFJLENBQUNVLFFBQVEsQ0FBQyxNQUFNO1lBQzdCLE9BQU8sQ0FBQyxDQUFDLEVBQUVGLFNBQVNSLElBQUksQ0FBQyxFQUFFLEVBQUVRLFNBQVNILElBQUksQ0FBQyxDQUFDO1FBQ2hELE9BQ0s7WUFDRCxPQUFPLENBQUMsRUFBRUcsU0FBU1IsSUFBSSxDQUFDLENBQUMsRUFBRVEsU0FBU0gsSUFBSSxDQUFDLENBQUM7UUFDOUM7SUFDSjtBQUNKO0FBQ0EsU0FBU2pCLFlBQVl1QixHQUFHO0lBQ3BCLElBQUlDLFNBQVM7SUFDYixJQUFJRCxJQUFJbEIsTUFBTSxLQUFLZ0IsV0FBVztRQUMxQkcsVUFBVUQsSUFBSWxCLE1BQU0sR0FBRztJQUMzQjtJQUNBLElBQUlrQixJQUFJakIsU0FBUyxLQUFLZSxXQUFXO1FBQzdCRyxVQUFVLE9BQU9ELElBQUlqQixTQUFTLEdBQUc7SUFDckM7SUFDQWtCLFVBQVVELElBQUloQixJQUFJO0lBQ2xCLE9BQU9pQjtBQUNYLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnljLWhvdXNpbmctYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3VyaS1wYXJzZXIuanM/MmFjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZVVyaSA9IHBhcnNlVXJpO1xuZXhwb3J0cy5zcGxpdEhvc3RQb3J0ID0gc3BsaXRIb3N0UG9ydDtcbmV4cG9ydHMuY29tYmluZUhvc3RQb3J0ID0gY29tYmluZUhvc3RQb3J0O1xuZXhwb3J0cy51cmlUb1N0cmluZyA9IHVyaVRvU3RyaW5nO1xuLypcbiAqIFRoZSBncm91cHMgY29ycmVzcG9uZCB0byBVUkkgcGFydHMgYXMgZm9sbG93czpcbiAqIDEuIHNjaGVtZVxuICogMi4gYXV0aG9yaXR5XG4gKiAzLiBwYXRoXG4gKi9cbmNvbnN0IFVSSV9SRUdFWCA9IC9eKD86KFtBLVphLXowLTkrLi1dKyk6KT8oPzpcXC9cXC8oW14vXSopXFwvKT8oLispJC87XG5mdW5jdGlvbiBwYXJzZVVyaSh1cmlTdHJpbmcpIHtcbiAgICBjb25zdCBwYXJzZWRVcmkgPSBVUklfUkVHRVguZXhlYyh1cmlTdHJpbmcpO1xuICAgIGlmIChwYXJzZWRVcmkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNjaGVtZTogcGFyc2VkVXJpWzFdLFxuICAgICAgICBhdXRob3JpdHk6IHBhcnNlZFVyaVsyXSxcbiAgICAgICAgcGF0aDogcGFyc2VkVXJpWzNdLFxuICAgIH07XG59XG5jb25zdCBOVU1CRVJfUkVHRVggPSAvXlxcZCskLztcbmZ1bmN0aW9uIHNwbGl0SG9zdFBvcnQocGF0aCkge1xuICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoJ1snKSkge1xuICAgICAgICBjb25zdCBob3N0RW5kID0gcGF0aC5pbmRleE9mKCddJyk7XG4gICAgICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG9zdCA9IHBhdGguc3Vic3RyaW5nKDEsIGhvc3RFbmQpO1xuICAgICAgICAvKiBPbmx5IGFuIElQdjYgYWRkcmVzcyBzaG91bGQgYmUgaW4gYnJhY2tldGVkIG5vdGF0aW9uLCBhbmQgYW4gSVB2NlxuICAgICAgICAgKiBhZGRyZXNzIHNob3VsZCBoYXZlIGF0IGxlYXN0IG9uZSBjb2xvbiAqL1xuICAgICAgICBpZiAoaG9zdC5pbmRleE9mKCc6JykgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPiBob3N0RW5kICsgMSkge1xuICAgICAgICAgICAgaWYgKHBhdGhbaG9zdEVuZCArIDFdID09PSAnOicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3J0U3RyaW5nID0gcGF0aC5zdWJzdHJpbmcoaG9zdEVuZCArIDIpO1xuICAgICAgICAgICAgICAgIGlmIChOVU1CRVJfUkVHRVgudGVzdChwb3J0U3RyaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogaG9zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6ICtwb3J0U3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhvc3QsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzcGxpdFBhdGggPSBwYXRoLnNwbGl0KCc6Jyk7XG4gICAgICAgIC8qIEV4YWN0bHkgb25lIGNvbG9uIG1lYW5zIHRoYXQgdGhpcyBpcyBob3N0OnBvcnQuIFplcm8gY29sb25zIG1lYW5zIHRoYXRcbiAgICAgICAgICogdGhlcmUgaXMgbm8gcG9ydC4gQW5kIG11bHRpcGxlIGNvbG9ucyBtZWFucyB0aGF0IHRoaXMgaXMgYSBiYXJlIElQdjZcbiAgICAgICAgICogYWRkcmVzcyB3aXRoIG5vIHBvcnQgKi9cbiAgICAgICAgaWYgKHNwbGl0UGF0aC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIGlmIChOVU1CRVJfUkVHRVgudGVzdChzcGxpdFBhdGhbMV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogc3BsaXRQYXRoWzBdLFxuICAgICAgICAgICAgICAgICAgICBwb3J0OiArc3BsaXRQYXRoWzFdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaG9zdDogcGF0aCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb21iaW5lSG9zdFBvcnQoaG9zdFBvcnQpIHtcbiAgICBpZiAoaG9zdFBvcnQucG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBob3N0UG9ydC5ob3N0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gT25seSBhbiBJUHY2IGhvc3Qgc2hvdWxkIGluY2x1ZGUgYSBjb2xvblxuICAgICAgICBpZiAoaG9zdFBvcnQuaG9zdC5pbmNsdWRlcygnOicpKSB7XG4gICAgICAgICAgICByZXR1cm4gYFske2hvc3RQb3J0Lmhvc3R9XToke2hvc3RQb3J0LnBvcnR9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtob3N0UG9ydC5ob3N0fToke2hvc3RQb3J0LnBvcnR9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHVyaVRvU3RyaW5nKHVyaSkge1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBpZiAodXJpLnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCArPSB1cmkuc2NoZW1lICsgJzonO1xuICAgIH1cbiAgICBpZiAodXJpLmF1dGhvcml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCArPSAnLy8nICsgdXJpLmF1dGhvcml0eSArICcvJztcbiAgICB9XG4gICAgcmVzdWx0ICs9IHVyaS5wYXRoO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmktcGFyc2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBhcnNlVXJpIiwic3BsaXRIb3N0UG9ydCIsImNvbWJpbmVIb3N0UG9ydCIsInVyaVRvU3RyaW5nIiwiVVJJX1JFR0VYIiwidXJpU3RyaW5nIiwicGFyc2VkVXJpIiwiZXhlYyIsInNjaGVtZSIsImF1dGhvcml0eSIsInBhdGgiLCJOVU1CRVJfUkVHRVgiLCJzdGFydHNXaXRoIiwiaG9zdEVuZCIsImluZGV4T2YiLCJob3N0Iiwic3Vic3RyaW5nIiwibGVuZ3RoIiwicG9ydFN0cmluZyIsInRlc3QiLCJwb3J0Iiwic3BsaXRQYXRoIiwic3BsaXQiLCJob3N0UG9ydCIsInVuZGVmaW5lZCIsImluY2x1ZGVzIiwidXJpIiwicmVzdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/proto-loader/build/src/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.loadFileDescriptorSetFromObject = exports.loadFileDescriptorSetFromBuffer = exports.fromJSON = exports.loadSync = exports.load = exports.IdempotencyLevel = exports.isAnyExtension = exports.Long = void 0;\nconst camelCase = __webpack_require__(/*! lodash.camelcase */ \"(rsc)/./node_modules/lodash.camelcase/index.js\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(rsc)/./node_modules/protobufjs/index.js\");\nconst descriptor = __webpack_require__(/*! protobufjs/ext/descriptor */ \"(rsc)/./node_modules/protobufjs/ext/descriptor/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/@grpc/proto-loader/build/src/util.js\");\nconst Long = __webpack_require__(/*! long */ \"(rsc)/./node_modules/long/umd/index.js\");\nexports.Long = Long;\nfunction isAnyExtension(obj) {\n    return \"@type\" in obj && typeof obj[\"@type\"] === \"string\";\n}\nexports.isAnyExtension = isAnyExtension;\nvar IdempotencyLevel;\n(function(IdempotencyLevel) {\n    IdempotencyLevel[\"IDEMPOTENCY_UNKNOWN\"] = \"IDEMPOTENCY_UNKNOWN\";\n    IdempotencyLevel[\"NO_SIDE_EFFECTS\"] = \"NO_SIDE_EFFECTS\";\n    IdempotencyLevel[\"IDEMPOTENT\"] = \"IDEMPOTENT\";\n})(IdempotencyLevel = exports.IdempotencyLevel || (exports.IdempotencyLevel = {}));\nconst descriptorOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    defaults: true,\n    oneofs: true,\n    json: true\n};\nfunction joinName(baseName, name) {\n    if (baseName === \"\") {\n        return name;\n    } else {\n        return baseName + \".\" + name;\n    }\n}\nfunction isHandledReflectionObject(obj) {\n    return obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum;\n}\nfunction isNamespaceBase(obj) {\n    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\nfunction getAllHandledReflectionObjects(obj, parentName) {\n    const objName = joinName(parentName, obj.name);\n    if (isHandledReflectionObject(obj)) {\n        return [\n            [\n                objName,\n                obj\n            ]\n        ];\n    } else {\n        if (isNamespaceBase(obj) && typeof obj.nested !== \"undefined\") {\n            return Object.keys(obj.nested).map((name)=>{\n                return getAllHandledReflectionObjects(obj.nested[name], objName);\n            }).reduce((accumulator, currentValue)=>accumulator.concat(currentValue), []);\n        }\n    }\n    return [];\n}\nfunction createDeserializer(cls, options) {\n    return function deserialize(argBuf) {\n        return cls.toObject(cls.decode(argBuf), options);\n    };\n}\nfunction createSerializer(cls) {\n    return function serialize(arg) {\n        if (Array.isArray(arg)) {\n            throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);\n        }\n        const message = cls.fromObject(arg);\n        return cls.encode(message).finish();\n    };\n}\nfunction mapMethodOptions(options) {\n    return (options || []).reduce((obj, item)=>{\n        for (const [key, value] of Object.entries(item)){\n            switch(key){\n                case \"uninterpreted_option\":\n                    obj.uninterpreted_option.push(item.uninterpreted_option);\n                    break;\n                default:\n                    obj[key] = value;\n            }\n        }\n        return obj;\n    }, {\n        deprecated: false,\n        idempotency_level: IdempotencyLevel.IDEMPOTENCY_UNKNOWN,\n        uninterpreted_option: []\n    });\n}\nfunction createMethodDefinition(method, serviceName, options, fileDescriptors) {\n    /* This is only ever called after the corresponding root.resolveAll(), so we\n     * can assume that the resolved request and response types are non-null */ const requestType = method.resolvedRequestType;\n    const responseType = method.resolvedResponseType;\n    return {\n        path: \"/\" + serviceName + \"/\" + method.name,\n        requestStream: !!method.requestStream,\n        responseStream: !!method.responseStream,\n        requestSerialize: createSerializer(requestType),\n        requestDeserialize: createDeserializer(requestType, options),\n        responseSerialize: createSerializer(responseType),\n        responseDeserialize: createDeserializer(responseType, options),\n        // TODO(murgatroid99): Find a better way to handle this\n        originalName: camelCase(method.name),\n        requestType: createMessageDefinition(requestType, fileDescriptors),\n        responseType: createMessageDefinition(responseType, fileDescriptors),\n        options: mapMethodOptions(method.parsedOptions)\n    };\n}\nfunction createServiceDefinition(service, name, options, fileDescriptors) {\n    const def = {};\n    for (const method of service.methodsArray){\n        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);\n    }\n    return def;\n}\nfunction createMessageDefinition(message, fileDescriptors) {\n    const messageDescriptor = message.toDescriptor(\"proto3\");\n    return {\n        format: \"Protocol Buffer 3 DescriptorProto\",\n        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors\n    };\n}\nfunction createEnumDefinition(enumType, fileDescriptors) {\n    const enumDescriptor = enumType.toDescriptor(\"proto3\");\n    return {\n        format: \"Protocol Buffer 3 EnumDescriptorProto\",\n        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors\n    };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options:\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\n * name: string, options: Options): MessageTypeDefinition; function\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\n * EnumTypeDefinition;\n */ function createDefinition(obj, name, options, fileDescriptors) {\n    if (obj instanceof Protobuf.Service) {\n        return createServiceDefinition(obj, name, options, fileDescriptors);\n    } else if (obj instanceof Protobuf.Type) {\n        return createMessageDefinition(obj, fileDescriptors);\n    } else if (obj instanceof Protobuf.Enum) {\n        return createEnumDefinition(obj, fileDescriptors);\n    } else {\n        throw new Error(\"Type mismatch in reflection object handling\");\n    }\n}\nfunction createPackageDefinition(root, options) {\n    const def = {};\n    root.resolveAll();\n    const descriptorList = root.toDescriptor(\"proto3\").file;\n    const bufferList = descriptorList.map((value)=>Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));\n    for (const [name, obj] of getAllHandledReflectionObjects(root, \"\")){\n        def[name] = createDefinition(obj, name, options, bufferList);\n    }\n    return def;\n}\nfunction createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {\n    options = options || {};\n    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);\n    root.resolveAll();\n    return createPackageDefinition(root, options);\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename One or multiple file paths to load. Can be an absolute path\n *     or relative to an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.json Represent Infinity and NaN as strings in float fields,\n *     and automatically decode google.protobuf.Any values.\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */ function load(filename, options) {\n    return (0, util_1.loadProtosWithOptions)(filename, options).then((loadedRoot)=>{\n        return createPackageDefinition(loadedRoot, options);\n    });\n}\nexports.load = load;\nfunction loadSync(filename, options) {\n    const loadedRoot = (0, util_1.loadProtosWithOptionsSync)(filename, options);\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.loadSync = loadSync;\nfunction fromJSON(json, options) {\n    options = options || {};\n    const loadedRoot = Protobuf.Root.fromJSON(json);\n    loadedRoot.resolveAll();\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.fromJSON = fromJSON;\nfunction loadFileDescriptorSetFromBuffer(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;\nfunction loadFileDescriptorSetFromObject(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;\n(0, util_1.addCommonProtos)(); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx1Q0FBdUMsR0FBR0EsdUNBQXVDLEdBQUdBLGdCQUFnQixHQUFHQSxnQkFBZ0IsR0FBR0EsWUFBWSxHQUFHQSx3QkFBd0IsR0FBR0Esc0JBQXNCLEdBQUdBLFlBQVksR0FBRyxLQUFLO0FBQ2pOLE1BQU1VLFlBQVlDLG1CQUFPQSxDQUFDLHdFQUFrQjtBQUM1QyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyw0REFBWTtBQUNyQyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQywwRkFBMkI7QUFDdEQsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUMseUVBQVE7QUFDL0IsTUFBTUYsT0FBT0UsbUJBQU9BLENBQUMsb0RBQU07QUFDM0JYLFlBQVksR0FBR1M7QUFDZixTQUFTRCxlQUFlTyxHQUFHO0lBQ3ZCLE9BQU8sV0FBWUEsT0FBUyxPQUFPQSxHQUFHLENBQUMsUUFBUSxLQUFLO0FBQ3hEO0FBQ0FmLHNCQUFzQixHQUFHUTtBQUN6QixJQUFJRDtBQUNILFVBQVVBLGdCQUFnQjtJQUN2QkEsZ0JBQWdCLENBQUMsc0JBQXNCLEdBQUc7SUFDMUNBLGdCQUFnQixDQUFDLGtCQUFrQixHQUFHO0lBQ3RDQSxnQkFBZ0IsQ0FBQyxhQUFhLEdBQUc7QUFDckMsR0FBR0EsbUJBQW1CUCxRQUFRTyxnQkFBZ0IsSUFBS1AsQ0FBQUEsd0JBQXdCLEdBQUcsQ0FBQztBQUMvRSxNQUFNZ0Isb0JBQW9CO0lBQ3RCQyxPQUFPQztJQUNQQyxPQUFPRDtJQUNQRSxPQUFPRjtJQUNQRyxVQUFVO0lBQ1ZDLFFBQVE7SUFDUkMsTUFBTTtBQUNWO0FBQ0EsU0FBU0MsU0FBU0MsUUFBUSxFQUFFQyxJQUFJO0lBQzVCLElBQUlELGFBQWEsSUFB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QVNELFNBQVM2RyxRQUFRLEVBQUVwRSxPQUFPO0lBQy9CLE1BQU11RSxhQUFhLENBQUMsR0FBR3ZHLE9BQU93Ryx5QkFBeUIsRUFBRUosVUFBVXBFO0lBQ25FLE9BQU93RCx3QkFBd0JlLFlBQVl2RTtBQUMvQztBQUNBOUMsZ0JBQWdCLEdBQUdLO0FBQ25CLFNBQVNELFNBQVNtQixJQUFJLEVBQUV1QixPQUFPO0lBQzNCQSxVQUFVQSxXQUFXLENBQUM7SUFDdEIsTUFBTXVFLGFBQWF6RyxTQUFTcUIsSUFBSSxDQUFDN0IsUUFBUSxDQUFDbUI7SUFDMUM4RixXQUFXYixVQUFVO0lBQ3JCLE9BQU9GLHdCQUF3QmUsWUFBWXZFO0FBQy9DO0FBQ0E5QyxnQkFBZ0IsR0FBR0k7QUFDbkIsU0FBU0QsZ0NBQWdDb0gsYUFBYSxFQUFFekUsT0FBTztJQUMzRCxNQUFNa0UsdUJBQXVCbkcsV0FBVzJHLGlCQUFpQixDQUFDdEUsTUFBTSxDQUFDcUU7SUFDakUsT0FBT1IseUNBQXlDQyxzQkFBc0JsRTtBQUMxRTtBQUNBOUMsdUNBQXVDLEdBQUdHO0FBQzFDLFNBQVNELGdDQUFnQ3FILGFBQWEsRUFBRXpFLE9BQU87SUFDM0QsTUFBTWtFLHVCQUF1Qm5HLFdBQVcyRyxpQkFBaUIsQ0FBQzlELFVBQVUsQ0FBQzZEO0lBQ3JFLE9BQU9SLHlDQUF5Q0Msc0JBQXNCbEU7QUFDMUU7QUFDQTlDLHVDQUF1QyxHQUFHRTtBQUN6QyxJQUFHWSxPQUFPMkcsZUFBZSxLQUMxQixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcz81ZmE1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdCA9IGV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlciA9IGV4cG9ydHMuZnJvbUpTT04gPSBleHBvcnRzLmxvYWRTeW5jID0gZXhwb3J0cy5sb2FkID0gZXhwb3J0cy5JZGVtcG90ZW5jeUxldmVsID0gZXhwb3J0cy5pc0FueUV4dGVuc2lvbiA9IGV4cG9ydHMuTG9uZyA9IHZvaWQgMDtcbmNvbnN0IGNhbWVsQ2FzZSA9IHJlcXVpcmUoXCJsb2Rhc2guY2FtZWxjYXNlXCIpO1xuY29uc3QgUHJvdG9idWYgPSByZXF1aXJlKFwicHJvdG9idWZqc1wiKTtcbmNvbnN0IGRlc2NyaXB0b3IgPSByZXF1aXJlKFwicHJvdG9idWZqcy9leHQvZGVzY3JpcHRvclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBMb25nID0gcmVxdWlyZShcImxvbmdcIik7XG5leHBvcnRzLkxvbmcgPSBMb25nO1xuZnVuY3Rpb24gaXNBbnlFeHRlbnNpb24ob2JqKSB7XG4gICAgcmV0dXJuICgnQHR5cGUnIGluIG9iaikgJiYgKHR5cGVvZiBvYmpbJ0B0eXBlJ10gPT09ICdzdHJpbmcnKTtcbn1cbmV4cG9ydHMuaXNBbnlFeHRlbnNpb24gPSBpc0FueUV4dGVuc2lvbjtcbnZhciBJZGVtcG90ZW5jeUxldmVsO1xuKGZ1bmN0aW9uIChJZGVtcG90ZW5jeUxldmVsKSB7XG4gICAgSWRlbXBvdGVuY3lMZXZlbFtcIklERU1QT1RFTkNZX1VOS05PV05cIl0gPSBcIklERU1QT1RFTkNZX1VOS05PV05cIjtcbiAgICBJZGVtcG90ZW5jeUxldmVsW1wiTk9fU0lERV9FRkZFQ1RTXCJdID0gXCJOT19TSURFX0VGRkVDVFNcIjtcbiAgICBJZGVtcG90ZW5jeUxldmVsW1wiSURFTVBPVEVOVFwiXSA9IFwiSURFTVBPVEVOVFwiO1xufSkoSWRlbXBvdGVuY3lMZXZlbCA9IGV4cG9ydHMuSWRlbXBvdGVuY3lMZXZlbCB8fCAoZXhwb3J0cy5JZGVtcG90ZW5jeUxldmVsID0ge30pKTtcbmNvbnN0IGRlc2NyaXB0b3JPcHRpb25zID0ge1xuICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgZW51bXM6IFN0cmluZyxcbiAgICBieXRlczogU3RyaW5nLFxuICAgIGRlZmF1bHRzOiB0cnVlLFxuICAgIG9uZW9mczogdHJ1ZSxcbiAgICBqc29uOiB0cnVlLFxufTtcbmZ1bmN0aW9uIGpvaW5OYW1lKGJhc2VOYW1lLCBuYW1lKSB7XG4gICAgaWYgKGJhc2VOYW1lID09PSAnJykge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBiYXNlTmFtZSArICcuJyArIG5hbWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNIYW5kbGVkUmVmbGVjdGlvbk9iamVjdChvYmopIHtcbiAgICByZXR1cm4gKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlNlcnZpY2UgfHxcbiAgICAgICAgb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuVHlwZSB8fFxuICAgICAgICBvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5FbnVtKTtcbn1cbmZ1bmN0aW9uIGlzTmFtZXNwYWNlQmFzZShvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuTmFtZXNwYWNlIHx8IG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlJvb3Q7XG59XG5mdW5jdGlvbiBnZXRBbGxIYW5kbGVkUmVmbGVjdGlvbk9iamVjdHMob2JqLCBwYXJlbnROYW1lKSB7XG4gICAgY29uc3Qgb2JqTmFtZSA9IGpvaW5OYW1lKHBhcmVudE5hbWUsIG9iai5uYW1lKTtcbiAgICBpZiAoaXNIYW5kbGVkUmVmbGVjdGlvbk9iamVjdChvYmopKSB7XG4gICAgICAgIHJldHVybiBbW29iak5hbWUsIG9ial1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGlzTmFtZXNwYWNlQmFzZShvYmopICYmIHR5cGVvZiBvYmoubmVzdGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iai5uZXN0ZWQpXG4gICAgICAgICAgICAgICAgLm1hcChuYW1lID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QWxsSGFuZGxlZFJlZmxlY3Rpb25PYmplY3RzKG9iai5uZXN0ZWRbbmFtZV0sIG9iak5hbWUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVkdWNlKChhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlKSA9PiBhY2N1bXVsYXRvci5jb25jYXQoY3VycmVudFZhbHVlKSwgW10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlc2VyaWFsaXplcihjbHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVzZXJpYWxpemUoYXJnQnVmKSB7XG4gICAgICAgIHJldHVybiBjbHMudG9PYmplY3QoY2xzLmRlY29kZShhcmdCdWYpLCBvcHRpb25zKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXplcihjbHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2VyaWFsaXplKGFyZykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzZXJpYWxpemUgbWVzc2FnZTogZXhwZWN0ZWQgb2JqZWN0IHdpdGggJHtjbHMubmFtZX0gc3RydWN0dXJlLCBnb3QgYXJyYXkgaW5zdGVhZGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjbHMuZnJvbU9iamVjdChhcmcpO1xuICAgICAgICByZXR1cm4gY2xzLmVuY29kZShtZXNzYWdlKS5maW5pc2goKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbWFwTWV0aG9kT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zIHx8IFtdKS5yZWR1Y2UoKG9iaiwgaXRlbSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhpdGVtKSkge1xuICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1bmludGVycHJldGVkX29wdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIG9iai51bmludGVycHJldGVkX29wdGlvbi5wdXNoKGl0ZW0udW5pbnRlcnByZXRlZF9vcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge1xuICAgICAgICBkZXByZWNhdGVkOiBmYWxzZSxcbiAgICAgICAgaWRlbXBvdGVuY3lfbGV2ZWw6IElkZW1wb3RlbmN5TGV2ZWwuSURFTVBPVEVOQ1lfVU5LTk9XTixcbiAgICAgICAgdW5pbnRlcnByZXRlZF9vcHRpb246IFtdLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlTWV0aG9kRGVmaW5pdGlvbihtZXRob2QsIHNlcnZpY2VOYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICAvKiBUaGlzIGlzIG9ubHkgZXZlciBjYWxsZWQgYWZ0ZXIgdGhlIGNvcnJlc3BvbmRpbmcgcm9vdC5yZXNvbHZlQWxsKCksIHNvIHdlXG4gICAgICogY2FuIGFzc3VtZSB0aGF0IHRoZSByZXNvbHZlZCByZXF1ZXN0IGFuZCByZXNwb25zZSB0eXBlcyBhcmUgbm9uLW51bGwgKi9cbiAgICBjb25zdCByZXF1ZXN0VHlwZSA9IG1ldGhvZC5yZXNvbHZlZFJlcXVlc3RUeXBlO1xuICAgIGNvbnN0IHJlc3BvbnNlVHlwZSA9IG1ldGhvZC5yZXNvbHZlZFJlc3BvbnNlVHlwZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiAnLycgKyBzZXJ2aWNlTmFtZSArICcvJyArIG1ldGhvZC5uYW1lLFxuICAgICAgICByZXF1ZXN0U3RyZWFtOiAhIW1ldGhvZC5yZXF1ZXN0U3RyZWFtLFxuICAgICAgICByZXNwb25zZVN0cmVhbTogISFtZXRob2QucmVzcG9uc2VTdHJlYW0sXG4gICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IGNyZWF0ZVNlcmlhbGl6ZXIocmVxdWVzdFR5cGUpLFxuICAgICAgICByZXF1ZXN0RGVzZXJpYWxpemU6IGNyZWF0ZURlc2VyaWFsaXplcihyZXF1ZXN0VHlwZSwgb3B0aW9ucyksXG4gICAgICAgIHJlc3BvbnNlU2VyaWFsaXplOiBjcmVhdGVTZXJpYWxpemVyKHJlc3BvbnNlVHlwZSksXG4gICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGNyZWF0ZURlc2VyaWFsaXplcihyZXNwb25zZVR5cGUsIG9wdGlvbnMpLFxuICAgICAgICAvLyBUT0RPKG11cmdhdHJvaWQ5OSk6IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzXG4gICAgICAgIG9yaWdpbmFsTmFtZTogY2FtZWxDYXNlKG1ldGhvZC5uYW1lKSxcbiAgICAgICAgcmVxdWVzdFR5cGU6IGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKHJlcXVlc3RUeXBlLCBmaWxlRGVzY3JpcHRvcnMpLFxuICAgICAgICByZXNwb25zZVR5cGU6IGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKHJlc3BvbnNlVHlwZSwgZmlsZURlc2NyaXB0b3JzKSxcbiAgICAgICAgb3B0aW9uczogbWFwTWV0aG9kT3B0aW9ucyhtZXRob2QucGFyc2VkT3B0aW9ucyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlcnZpY2VEZWZpbml0aW9uKHNlcnZpY2UsIG5hbWUsIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycykge1xuICAgIGNvbnN0IGRlZiA9IHt9O1xuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIHNlcnZpY2UubWV0aG9kc0FycmF5KSB7XG4gICAgICAgIGRlZlttZXRob2QubmFtZV0gPSBjcmVhdGVNZXRob2REZWZpbml0aW9uKG1ldGhvZCwgbmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKG1lc3NhZ2UsIGZpbGVEZXNjcmlwdG9ycykge1xuICAgIGNvbnN0IG1lc3NhZ2VEZXNjcmlwdG9yID0gbWVzc2FnZS50b0Rlc2NyaXB0b3IoJ3Byb3RvMycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZvcm1hdDogJ1Byb3RvY29sIEJ1ZmZlciAzIERlc2NyaXB0b3JQcm90bycsXG4gICAgICAgIHR5cGU6IG1lc3NhZ2VEZXNjcmlwdG9yLiR0eXBlLnRvT2JqZWN0KG1lc3NhZ2VEZXNjcmlwdG9yLCBkZXNjcmlwdG9yT3B0aW9ucyksXG4gICAgICAgIGZpbGVEZXNjcmlwdG9yUHJvdG9zOiBmaWxlRGVzY3JpcHRvcnMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVudW1EZWZpbml0aW9uKGVudW1UeXBlLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICBjb25zdCBlbnVtRGVzY3JpcHRvciA9IGVudW1UeXBlLnRvRGVzY3JpcHRvcigncHJvdG8zJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZm9ybWF0OiAnUHJvdG9jb2wgQnVmZmVyIDMgRW51bURlc2NyaXB0b3JQcm90bycsXG4gICAgICAgIHR5cGU6IGVudW1EZXNjcmlwdG9yLiR0eXBlLnRvT2JqZWN0KGVudW1EZXNjcmlwdG9yLCBkZXNjcmlwdG9yT3B0aW9ucyksXG4gICAgICAgIGZpbGVEZXNjcmlwdG9yUHJvdG9zOiBmaWxlRGVzY3JpcHRvcnMsXG4gICAgfTtcbn1cbi8qKlxuICogZnVuY3Rpb24gY3JlYXRlRGVmaW5pdGlvbihvYmo6IFByb3RvYnVmLlNlcnZpY2UsIG5hbWU6IHN0cmluZywgb3B0aW9uczpcbiAqIE9wdGlvbnMpOiBTZXJ2aWNlRGVmaW5pdGlvbjsgZnVuY3Rpb24gY3JlYXRlRGVmaW5pdGlvbihvYmo6IFByb3RvYnVmLlR5cGUsXG4gKiBuYW1lOiBzdHJpbmcsIG9wdGlvbnM6IE9wdGlvbnMpOiBNZXNzYWdlVHlwZURlZmluaXRpb247IGZ1bmN0aW9uXG4gKiBjcmVhdGVEZWZpbml0aW9uKG9iajogUHJvdG9idWYuRW51bSwgbmFtZTogc3RyaW5nLCBvcHRpb25zOiBPcHRpb25zKTpcbiAqIEVudW1UeXBlRGVmaW5pdGlvbjtcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGVmaW5pdGlvbihvYmosIG5hbWUsIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycykge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTZXJ2aWNlRGVmaW5pdGlvbihvYmosIG5hbWUsIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKG9iaiwgZmlsZURlc2NyaXB0b3JzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgUHJvdG9idWYuRW51bSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRW51bURlZmluaXRpb24ob2JqLCBmaWxlRGVzY3JpcHRvcnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeXBlIG1pc21hdGNoIGluIHJlZmxlY3Rpb24gb2JqZWN0IGhhbmRsaW5nJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUGFja2FnZURlZmluaXRpb24ocm9vdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRlZiA9IHt9O1xuICAgIHJvb3QucmVzb2x2ZUFsbCgpO1xuICAgIGNvbnN0IGRlc2NyaXB0b3JMaXN0ID0gcm9vdC50b0Rlc2NyaXB0b3IoJ3Byb3RvMycpLmZpbGU7XG4gICAgY29uc3QgYnVmZmVyTGlzdCA9IGRlc2NyaXB0b3JMaXN0Lm1hcCh2YWx1ZSA9PiBCdWZmZXIuZnJvbShkZXNjcmlwdG9yLkZpbGVEZXNjcmlwdG9yUHJvdG8uZW5jb2RlKHZhbHVlKS5maW5pc2goKSkpO1xuICAgIGZvciAoY29uc3QgW25hbWUsIG9ial0gb2YgZ2V0QWxsSGFuZGxlZFJlZmxlY3Rpb25PYmplY3RzKHJvb3QsICcnKSkge1xuICAgICAgICBkZWZbbmFtZV0gPSBjcmVhdGVEZWZpbml0aW9uKG9iaiwgbmFtZSwgb3B0aW9ucywgYnVmZmVyTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbkZyb21EZXNjcmlwdG9yU2V0KGRlY29kZWREZXNjcmlwdG9yU2V0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgcm9vdCA9IFByb3RvYnVmLlJvb3QuZnJvbURlc2NyaXB0b3IoZGVjb2RlZERlc2NyaXB0b3JTZXQpO1xuICAgIHJvb3QucmVzb2x2ZUFsbCgpO1xuICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihyb290LCBvcHRpb25zKTtcbn1cbi8qKlxuICogTG9hZCBhIC5wcm90byBmaWxlIHdpdGggdGhlIHNwZWNpZmllZCBvcHRpb25zLlxuICogQHBhcmFtIGZpbGVuYW1lIE9uZSBvciBtdWx0aXBsZSBmaWxlIHBhdGhzIHRvIGxvYWQuIENhbiBiZSBhbiBhYnNvbHV0ZSBwYXRoXG4gKiAgICAgb3IgcmVsYXRpdmUgdG8gYW4gaW5jbHVkZSBwYXRoLlxuICogQHBhcmFtIG9wdGlvbnMua2VlcENhc2UgUHJlc2VydmUgZmllbGQgbmFtZXMuIFRoZSBkZWZhdWx0IGlzIHRvIGNoYW5nZSB0aGVtXG4gKiAgICAgdG8gY2FtZWwgY2FzZS5cbiAqIEBwYXJhbSBvcHRpb25zLmxvbmdzIFRoZSB0eXBlIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVwcmVzZW50IGBsb25nYCB2YWx1ZXMuXG4gKiAgICAgVmFsaWQgb3B0aW9ucyBhcmUgYE51bWJlcmAgYW5kIGBTdHJpbmdgLiBEZWZhdWx0cyB0byBhIGBMb25nYCBvYmplY3QgdHlwZVxuICogICAgIGZyb20gYSBsaWJyYXJ5LlxuICogQHBhcmFtIG9wdGlvbnMuZW51bXMgVGhlIHR5cGUgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZXByZXNlbnQgYGVudW1gIHZhbHVlcy5cbiAqICAgICBUaGUgb25seSB2YWxpZCBvcHRpb24gaXMgYFN0cmluZ2AuIERlZmF1bHRzIHRvIHRoZSBudW1lcmljIHZhbHVlLlxuICogQHBhcmFtIG9wdGlvbnMuYnl0ZXMgVGhlIHR5cGUgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZXByZXNlbnQgYGJ5dGVzYFxuICogICAgIHZhbHVlcy4gVmFsaWQgb3B0aW9ucyBhcmUgYEFycmF5YCBhbmQgYFN0cmluZ2AuIFRoZSBkZWZhdWx0IGlzIHRvIHVzZVxuICogICAgIGBCdWZmZXJgLlxuICogQHBhcmFtIG9wdGlvbnMuZGVmYXVsdHMgU2V0IGRlZmF1bHQgdmFsdWVzIG9uIG91dHB1dCBvYmplY3RzLiBEZWZhdWx0cyB0b1xuICogICAgIGBmYWxzZWAuXG4gKiBAcGFyYW0gb3B0aW9ucy5hcnJheXMgU2V0IGVtcHR5IGFycmF5cyBmb3IgbWlzc2luZyBhcnJheSB2YWx1ZXMgZXZlbiBpZlxuICogICAgIGBkZWZhdWx0c2AgaXMgYGZhbHNlYC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqIEBwYXJhbSBvcHRpb25zLm9iamVjdHMgU2V0IGVtcHR5IG9iamVjdHMgZm9yIG1pc3Npbmcgb2JqZWN0IHZhbHVlcyBldmVuIGlmXG4gKiAgICAgYGRlZmF1bHRzYCBpcyBgZmFsc2VgLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICogQHBhcmFtIG9wdGlvbnMub25lb2ZzIFNldCB2aXJ0dWFsIG9uZW9mIHByb3BlcnRpZXMgdG8gdGhlIHByZXNlbnQgZmllbGQnc1xuICogICAgIG5hbWVcbiAqIEBwYXJhbSBvcHRpb25zLmpzb24gUmVwcmVzZW50IEluZmluaXR5IGFuZCBOYU4gYXMgc3RyaW5ncyBpbiBmbG9hdCBmaWVsZHMsXG4gKiAgICAgYW5kIGF1dG9tYXRpY2FsbHkgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5BbnkgdmFsdWVzLlxuICogQHBhcmFtIG9wdGlvbnMuaW5jbHVkZURpcnMgUGF0aHMgdG8gc2VhcmNoIGZvciBpbXBvcnRlZCBgLnByb3RvYCBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gbG9hZChmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiAoMCwgdXRpbF8xLmxvYWRQcm90b3NXaXRoT3B0aW9ucykoZmlsZW5hbWUsIG9wdGlvbnMpLnRoZW4obG9hZGVkUm9vdCA9PiB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihsb2FkZWRSb290LCBvcHRpb25zKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5mdW5jdGlvbiBsb2FkU3luYyhmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxvYWRlZFJvb3QgPSAoMCwgdXRpbF8xLmxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMpKGZpbGVuYW1lLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb24obG9hZGVkUm9vdCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmxvYWRTeW5jID0gbG9hZFN5bmM7XG5mdW5jdGlvbiBmcm9tSlNPTihqc29uLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgbG9hZGVkUm9vdCA9IFByb3RvYnVmLlJvb3QuZnJvbUpTT04oanNvbik7XG4gICAgbG9hZGVkUm9vdC5yZXNvbHZlQWxsKCk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKGxvYWRlZFJvb3QsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5mcm9tSlNPTiA9IGZyb21KU09OO1xuZnVuY3Rpb24gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlcihkZXNjcmlwdG9yU2V0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGVjb2RlZERlc2NyaXB0b3JTZXQgPSBkZXNjcmlwdG9yLkZpbGVEZXNjcmlwdG9yU2V0LmRlY29kZShkZXNjcmlwdG9yU2V0KTtcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb25Gcm9tRGVzY3JpcHRvclNldChkZWNvZGVkRGVzY3JpcHRvclNldCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21CdWZmZXIgPSBsb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tQnVmZmVyO1xuZnVuY3Rpb24gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdChkZXNjcmlwdG9yU2V0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGVjb2RlZERlc2NyaXB0b3JTZXQgPSBkZXNjcmlwdG9yLkZpbGVEZXNjcmlwdG9yU2V0LmZyb21PYmplY3QoZGVzY3JpcHRvclNldCk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uRnJvbURlc2NyaXB0b3JTZXQoZGVjb2RlZERlc2NyaXB0b3JTZXQsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5sb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tT2JqZWN0ID0gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdDtcbigwLCB1dGlsXzEuYWRkQ29tbW9uUHJvdG9zKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdCIsImxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21CdWZmZXIiLCJmcm9tSlNPTiIsImxvYWRTeW5jIiwibG9hZCIsIklkZW1wb3RlbmN5TGV2ZWwiLCJpc0FueUV4dGVuc2lvbiIsIkxvbmciLCJjYW1lbENhc2UiLCJyZXF1aXJlIiwiUHJvdG9idWYiLCJkZXNjcmlwdG9yIiwidXRpbF8xIiwib2JqIiwiZGVzY3JpcHRvck9wdGlvbnMiLCJsb25ncyIsIlN0cmluZyIsImVudW1zIiwiYnl0ZXMiLCJkZWZhdWx0cyIsIm9uZW9mcyIsImpzb24iLCJqb2luTmFtZSIsImJhc2VOYW1lIiwibmFtZSIsImlzSGFuZGxlZFJlZmxlY3Rpb25PYmplY3QiLCJTZXJ2aWNlIiwiVHlwZSIsIkVudW0iLCJpc05hbWVzcGFjZUJhc2UiLCJOYW1lc3BhY2UiLCJSb290IiwiZ2V0QWxsSGFuZGxlZFJlZmxlY3Rpb25PYmplY3RzIiwicGFyZW50TmFtZSIsIm9iak5hbWUiLCJuZXN0ZWQiLCJrZXlzIiwibWFwIiwicmVkdWNlIiwiYWNjdW11bGF0b3IiLCJjdXJyZW50VmFsdWUiLCJjb25jYXQiLCJjcmVhdGVEZXNlcmlhbGl6ZXIiLCJjbHMiLCJvcHRpb25zIiwiZGVzZXJpYWxpemUiLCJhcmdCdWYiLCJ0b09iamVjdCIsImRlY29kZSIsImNyZWF0ZVNlcmlhbGl6ZXIiLCJzZXJpYWxpemUiLCJhcmciLCJBcnJheSIsImlzQXJyYXkiLCJFcnJvciIsIm1lc3NhZ2UiLCJmcm9tT2JqZWN0IiwiZW5jb2RlIiwiZmluaXNoIiwibWFwTWV0aG9kT3B0aW9ucyIsIml0ZW0iLCJrZXkiLCJlbnRyaWVzIiwidW5pbnRlcnByZXRlZF9vcHRpb24iLCJwdXNoIiwiZGVwcmVjYXRlZCIsImlkZW1wb3RlbmN5X2xldmVsIiwiSURFTVBPVEVOQ1lfVU5LTk9XTiIsImNyZWF0ZU1ldGhvZERlZmluaXRpb24iLCJtZXRob2QiLCJzZXJ2aWNlTmFtZSIsImZpbGVEZXNjcmlwdG9ycyIsInJlcXVlc3RUeXBlIiwicmVzb2x2ZWRSZXF1ZXN0VHlwZSIsInJlc3BvbnNlVHlwZSIsInJlc29sdmVkUmVzcG9uc2VUeXBlIiwicGF0aCIsInJlcXVlc3RTdHJlYW0iLCJyZXNwb25zZVN0cmVhbSIsInJlcXVlc3RTZXJpYWxpemUiLCJyZXF1ZXN0RGVzZXJpYWxpemUiLCJyZXNwb25zZVNlcmlhbGl6ZSIsInJlc3BvbnNlRGVzZXJpYWxpemUiLCJvcmlnaW5hbE5hbWUiLCJjcmVhdGVNZXNzYWdlRGVmaW5pdGlvbiIsInBhcnNlZE9wdGlvbnMiLCJjcmVhdGVTZXJ2aWNlRGVmaW5pdGlvbiIsInNlcnZpY2UiLCJkZWYiLCJtZXRob2RzQXJyYXkiLCJtZXNzYWdlRGVzY3JpcHRvciIsInRvRGVzY3JpcHRvciIsImZvcm1hdCIsInR5cGUiLCIkdHlwZSIsImZpbGVEZXNjcmlwdG9yUHJvdG9zIiwiY3JlYXRlRW51bURlZmluaXRpb24iLCJlbnVtVHlwZSIsImVudW1EZXNjcmlwdG9yIiwiY3JlYXRlRGVmaW5pdGlvbiIsImNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uIiwicm9vdCIsInJlc29sdmVBbGwiLCJkZXNjcmlwdG9yTGlzdCIsImZpbGUiLCJidWZmZXJMaXN0IiwiQnVmZmVyIiwiZnJvbSIsIkZpbGVEZXNjcmlwdG9yUHJvdG8iLCJjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbkZyb21EZXNjcmlwdG9yU2V0IiwiZGVjb2RlZERlc2NyaXB0b3JTZXQiLCJmcm9tRGVzY3JpcHRvciIsImZpbGVuYW1lIiwibG9hZFByb3Rvc1dpdGhPcHRpb25zIiwidGhlbiIsImxvYWRlZFJvb3QiLCJsb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jIiwiZGVzY3JpcHRvclNldCIsIkZpbGVEZXNjcmlwdG9yU2V0IiwiYWRkQ29tbW9uUHJvdG9zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/proto-loader/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/proto-loader/build/src/util.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/util.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addCommonProtos = exports.loadProtosWithOptionsSync = exports.loadProtosWithOptions = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(rsc)/./node_modules/protobufjs/index.js\");\nfunction addIncludePathResolver(root, includePaths) {\n    const originalResolvePath = root.resolvePath;\n    root.resolvePath = (origin, target)=>{\n        if (path.isAbsolute(target)) {\n            return target;\n        }\n        for (const directory of includePaths){\n            const fullPath = path.join(directory, target);\n            try {\n                fs.accessSync(fullPath, fs.constants.R_OK);\n                return fullPath;\n            } catch (err) {\n                continue;\n            }\n        }\n        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);\n        return originalResolvePath(origin, target);\n    };\n}\nasync function loadProtosWithOptions(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            return Promise.reject(new Error(\"The includeDirs option must be an array\"));\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = await root.load(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptions = loadProtosWithOptions;\nfunction loadProtosWithOptionsSync(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            throw new Error(\"The includeDirs option must be an array\");\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = root.loadSync(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptionsSync = loadProtosWithOptionsSync;\n/**\n * Load Google's well-known proto files that aren't exposed by Protobuf.js.\n */ function addCommonProtos() {\n    // Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,\n    // and wrappers. compiler/plugin is excluded in Protobuf.js and here.\n    // Using constant strings for compatibility with tools like Webpack\n    const apiDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/api.json */ \"(rsc)/./node_modules/protobufjs/google/protobuf/api.json\");\n    const descriptorDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/descriptor.json */ \"(rsc)/./node_modules/protobufjs/google/protobuf/descriptor.json\");\n    const sourceContextDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/source_context.json */ \"(rsc)/./node_modules/protobufjs/google/protobuf/source_context.json\");\n    const typeDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/type.json */ \"(rsc)/./node_modules/protobufjs/google/protobuf/type.json\");\n    Protobuf.common(\"api\", apiDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common(\"descriptor\", descriptorDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common(\"source_context\", sourceContextDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common(\"type\", typeDescriptor.nested.google.nested.protobuf.nested);\n}\nexports.addCommonProtos = addCommonProtos; //# sourceMappingURL=util.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHVCQUF1QixHQUFHQSxpQ0FBaUMsR0FBR0EsNkJBQTZCLEdBQUcsS0FBSztBQUNuRyxNQUFNSyxLQUFLQyxtQkFBT0EsQ0FBQyxjQUFJO0FBQ3ZCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDLGtCQUFNO0FBQzNCLE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLDREQUFZO0FBQ3JDLFNBQVNHLHVCQUF1QkMsSUFBSSxFQUFFQyxZQUFZO0lBQzlDLE1BQU1DLHNCQUFzQkYsS0FBS0csV0FBVztJQUM1Q0gsS0FBS0csV0FBVyxHQUFHLENBQUNDLFFBQVFDO1FBQ3hCLElBQUlSLEtBQUtTLFVBQVUsQ0FBQ0QsU0FBUztZQUN6QixPQUFPQTtRQUNYO1FBQ0EsS0FBSyxNQUFNRSxhQUFhTixhQUFjO1lBQ2xDLE1BQU1PLFdBQVdYLEtBQUtZLElBQUksQ0FBQ0YsV0FBV0Y7WUFDdEMsSUFBSTtnQkFDQVYsR0FBR2UsVUFBVSxDQUFDRixVQUFVYixHQUFHZ0IsU0FBUyxDQUFDQyxJQUFJO2dCQUN6QyxPQUFPSjtZQUNYLEVBQ0EsT0FBT0ssS0FBSztnQkFDUjtZQUNKO1FBQ0o7UUFDQUMsUUFBUUMsV0FBVyxDQUFDLENBQUMsRUFBRVYsT0FBTyx1Q0FBdUMsRUFBRUosYUFBYSxDQUFDO1FBQ3JGLE9BQU9DLG9CQUFvQkUsUUFBUUM7SUFDdkM7QUFDSjtBQUNBLGVBQWVYLHNCQUFzQnNCLFFBQVEsRUFBRUMsT0FBTztJQUNsRCxNQUFNakIsT0FBTyxJQUFJRixTQUFTb0IsSUFBSTtJQUM5QkQsVUFBVUEsV0FBVyxDQUFDO0lBQ3RCLElBQUksQ0FBQyxDQUFDQSxRQUFRRSxXQUFXLEVBQUU7UUFDdkIsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNKLFFBQVFFLFdBQVcsR0FBRztZQUNyQyxPQUFPRyxRQUFRQyxNQUFNLENBQUMsSUFBSUMsTUFBTTtRQUNwQztRQUNBekIsdUJBQXVCQyxNQUFNaUIsUUFBUUUsV0FBVztJQUNwRDtJQUNBLE1BQU1NLGFBQWEsTUFBTXpCLEtBQUswQixJQUFJLENBQUNWLFVBQVVDO0lBQzdDUSxXQUFXRSxVQUFVO0lBQ3JCLE9BQU9GO0FBQ1g7QUFDQW5DLDZCQUE2QixHQUFHSTtBQUNoQyxTQUFTRCwwQkFBMEJ1QixRQUFRLEVBQUVDLE9BQU87SUFDaEQsTUFBTWpCLE9BQU8sSUFBSUYsU0FBU29CLElBQUk7SUFDOUJELFVBQVVBLFdBQVcsQ0FBQztJQUN0QixJQUFJLENBQUMsQ0FBQ0EsUUFBUUUsV0FBVyxFQUFFO1FBQ3ZCLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDSixRQUFRRSxXQUFXLEdBQUc7WUFDckMsTUFBTSxJQUFJSyxNQUFNO1FBQ3BCO1FBQ0F6Qix1QkFBdUJDLE1BQU1pQixRQUFRRSxXQUFXO0lBQ3BEO0lBQ0EsTUFBTU0sYUFBYXpCLEtBQUs0QixRQUFRLENBQUNaLFVBQVVDO0lBQzNDUSxXQUFXRSxVQUFVO0lBQ3JCLE9BQU9GO0FBQ1g7QUFDQW5DLGlDQUFpQyxHQUFHRztBQUNwQzs7Q0FFQyxHQUNELFNBQVNEO0lBQ0wsNEVBQTRFO0lBQzVFLHFFQUFxRTtJQUNyRSxtRUFBbUU7SUFDbkUsTUFBTXFDLGdCQUFnQmpDLG1CQUFPQSxDQUFDO0lBQzlCLE1BQU1rQyx1QkFBdUJsQyxtQkFBT0EsQ0FBQztJQUNyQyxNQUFNbUMsMEJBQTBCbkMsbUJBQU9BLENBQUM7SUFDeEMsTUFBTW9DLGlCQUFpQnBDLG1CQUFPQSxDQUFDO0lBQy9CRSxTQUFTbUMsTUFBTSxDQUFDLE9BQU9KLGNBQWNLLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDRCxNQUFNLENBQUNFLFFBQVEsQ0FBQ0YsTUFBTTtJQUN6RXBDLFNBQVNtQyxNQUFNLENBQUMsY0FBY0gscUJBQXFCSSxNQUFNLENBQUNDLE1BQU0sQ0FBQ0QsTUFBTSxDQUFDRSxRQUFRLENBQUNGLE1BQU07SUFDdkZwQyxTQUFTbUMsTUFBTSxDQUFDLGtCQUFrQkYsd0JBQXdCRyxNQUFNLENBQUNDLE1BQU0sQ0FBQ0QsTUFBTSxDQUFDRSxRQUFRLENBQUNGLE1BQU07SUFDOUZwQyxTQUFTbUMsTUFBTSxDQUFDLFFBQVFELGVBQWVFLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDRCxNQUFNLENBQUNFLFFBQVEsQ0FBQ0YsTUFBTTtBQUMvRTtBQUNBNUMsdUJBQXVCLEdBQUdFLGlCQUMxQixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy91dGlsLmpzPzY0MWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGRDb21tb25Qcm90b3MgPSBleHBvcnRzLmxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMgPSBleHBvcnRzLmxvYWRQcm90b3NXaXRoT3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgUHJvdG9idWYgPSByZXF1aXJlKFwicHJvdG9idWZqc1wiKTtcbmZ1bmN0aW9uIGFkZEluY2x1ZGVQYXRoUmVzb2x2ZXIocm9vdCwgaW5jbHVkZVBhdGhzKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxSZXNvbHZlUGF0aCA9IHJvb3QucmVzb2x2ZVBhdGg7XG4gICAgcm9vdC5yZXNvbHZlUGF0aCA9IChvcmlnaW4sIHRhcmdldCkgPT4ge1xuICAgICAgICBpZiAocGF0aC5pc0Fic29sdXRlKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBkaXJlY3Rvcnkgb2YgaW5jbHVkZVBhdGhzKSB7XG4gICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihkaXJlY3RvcnksIHRhcmdldCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZzLmFjY2Vzc1N5bmMoZnVsbFBhdGgsIGZzLmNvbnN0YW50cy5SX09LKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsbFBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhgJHt0YXJnZXR9IG5vdCBmb3VuZCBpbiBhbnkgb2YgdGhlIGluY2x1ZGUgcGF0aHMgJHtpbmNsdWRlUGF0aHN9YCk7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlc29sdmVQYXRoKG9yaWdpbiwgdGFyZ2V0KTtcbiAgICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZFByb3Rvc1dpdGhPcHRpb25zKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgcm9vdCA9IG5ldyBQcm90b2J1Zi5Sb290KCk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCEhb3B0aW9ucy5pbmNsdWRlRGlycykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5pbmNsdWRlRGlycykpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1RoZSBpbmNsdWRlRGlycyBvcHRpb24gbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRJbmNsdWRlUGF0aFJlc29sdmVyKHJvb3QsIG9wdGlvbnMuaW5jbHVkZURpcnMpO1xuICAgIH1cbiAgICBjb25zdCBsb2FkZWRSb290ID0gYXdhaXQgcm9vdC5sb2FkKGZpbGVuYW1lLCBvcHRpb25zKTtcbiAgICBsb2FkZWRSb290LnJlc29sdmVBbGwoKTtcbiAgICByZXR1cm4gbG9hZGVkUm9vdDtcbn1cbmV4cG9ydHMubG9hZFByb3Rvc1dpdGhPcHRpb25zID0gbG9hZFByb3Rvc1dpdGhPcHRpb25zO1xuZnVuY3Rpb24gbG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyhmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgUHJvdG9idWYuUm9vdCgpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghIW9wdGlvbnMuaW5jbHVkZURpcnMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuaW5jbHVkZURpcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNsdWRlRGlycyBvcHRpb24gbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEluY2x1ZGVQYXRoUmVzb2x2ZXIocm9vdCwgb3B0aW9ucy5pbmNsdWRlRGlycyk7XG4gICAgfVxuICAgIGNvbnN0IGxvYWRlZFJvb3QgPSByb290LmxvYWRTeW5jKGZpbGVuYW1lLCBvcHRpb25zKTtcbiAgICBsb2FkZWRSb290LnJlc29sdmVBbGwoKTtcbiAgICByZXR1cm4gbG9hZGVkUm9vdDtcbn1cbmV4cG9ydHMubG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyA9IGxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmM7XG4vKipcbiAqIExvYWQgR29vZ2xlJ3Mgd2VsbC1rbm93biBwcm90byBmaWxlcyB0aGF0IGFyZW4ndCBleHBvc2VkIGJ5IFByb3RvYnVmLmpzLlxuICovXG5mdW5jdGlvbiBhZGRDb21tb25Qcm90b3MoKSB7XG4gICAgLy8gUHJvdG9idWYuanMgZXhwb3NlczogYW55LCBkdXJhdGlvbiwgZW1wdHksIGZpZWxkX21hc2ssIHN0cnVjdCwgdGltZXN0YW1wLFxuICAgIC8vIGFuZCB3cmFwcGVycy4gY29tcGlsZXIvcGx1Z2luIGlzIGV4Y2x1ZGVkIGluIFByb3RvYnVmLmpzIGFuZCBoZXJlLlxuICAgIC8vIFVzaW5nIGNvbnN0YW50IHN0cmluZ3MgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0b29scyBsaWtlIFdlYnBhY2tcbiAgICBjb25zdCBhcGlEZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvYXBpLmpzb24nKTtcbiAgICBjb25zdCBkZXNjcmlwdG9yRGVzY3JpcHRvciA9IHJlcXVpcmUoJ3Byb3RvYnVmanMvZ29vZ2xlL3Byb3RvYnVmL2Rlc2NyaXB0b3IuanNvbicpO1xuICAgIGNvbnN0IHNvdXJjZUNvbnRleHREZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvc291cmNlX2NvbnRleHQuanNvbicpO1xuICAgIGNvbnN0IHR5cGVEZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvdHlwZS5qc29uJyk7XG4gICAgUHJvdG9idWYuY29tbW9uKCdhcGknLCBhcGlEZXNjcmlwdG9yLm5lc3RlZC5nb29nbGUubmVzdGVkLnByb3RvYnVmLm5lc3RlZCk7XG4gICAgUHJvdG9idWYuY29tbW9uKCdkZXNjcmlwdG9yJywgZGVzY3JpcHRvckRlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcbiAgICBQcm90b2J1Zi5jb21tb24oJ3NvdXJjZV9jb250ZXh0Jywgc291cmNlQ29udGV4dERlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcbiAgICBQcm90b2J1Zi5jb21tb24oJ3R5cGUnLCB0eXBlRGVzY3JpcHRvci5uZXN0ZWQuZ29vZ2xlLm5lc3RlZC5wcm90b2J1Zi5uZXN0ZWQpO1xufVxuZXhwb3J0cy5hZGRDb21tb25Qcm90b3MgPSBhZGRDb21tb25Qcm90b3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFkZENvbW1vblByb3RvcyIsImxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMiLCJsb2FkUHJvdG9zV2l0aE9wdGlvbnMiLCJmcyIsInJlcXVpcmUiLCJwYXRoIiwiUHJvdG9idWYiLCJhZGRJbmNsdWRlUGF0aFJlc29sdmVyIiwicm9vdCIsImluY2x1ZGVQYXRocyIsIm9yaWdpbmFsUmVzb2x2ZVBhdGgiLCJyZXNvbHZlUGF0aCIsIm9yaWdpbiIsInRhcmdldCIsImlzQWJzb2x1dGUiLCJkaXJlY3RvcnkiLCJmdWxsUGF0aCIsImpvaW4iLCJhY2Nlc3NTeW5jIiwiY29uc3RhbnRzIiwiUl9PSyIsImVyciIsInByb2Nlc3MiLCJlbWl0V2FybmluZyIsImZpbGVuYW1lIiwib3B0aW9ucyIsIlJvb3QiLCJpbmNsdWRlRGlycyIsIkFycmF5IiwiaXNBcnJheSIsIlByb21pc2UiLCJyZWplY3QiLCJFcnJvciIsImxvYWRlZFJvb3QiLCJsb2FkIiwicmVzb2x2ZUFsbCIsImxvYWRTeW5jIiwiYXBpRGVzY3JpcHRvciIsImRlc2NyaXB0b3JEZXNjcmlwdG9yIiwic291cmNlQ29udGV4dERlc2NyaXB0b3IiLCJ0eXBlRGVzY3JpcHRvciIsImNvbW1vbiIsIm5lc3RlZCIsImdvb2dsZSIsInByb3RvYnVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/proto-loader/build/src/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/package.json":
/*!*************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/package.json ***!
  \*************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"@grpc/grpc-js","version":"1.13.0","description":"gRPC Library for Node - pure JS implementation","homepage":"https://grpc.io/","repository":"https://github.com/grpc/grpc-node/tree/master/packages/grpc-js","main":"build/src/index.js","engines":{"node":">=12.10.0"},"keywords":[],"author":{"name":"Google Inc."},"types":"build/src/index.d.ts","license":"Apache-2.0","devDependencies":{"@grpc/proto-loader":"file:../proto-loader","@types/gulp":"^4.0.17","@types/gulp-mocha":"0.0.37","@types/lodash":"^4.14.202","@types/mocha":"^10.0.6","@types/ncp":"^2.0.8","@types/node":">=20.11.20","@types/pify":"^5.0.4","@types/semver":"^7.5.8","@typescript-eslint/eslint-plugin":"^7.1.0","@typescript-eslint/parser":"^7.1.0","@typescript-eslint/typescript-estree":"^7.1.0","clang-format":"^1.8.0","eslint":"^8.42.0","eslint-config-prettier":"^8.8.0","eslint-plugin-node":"^11.1.0","eslint-plugin-prettier":"^4.2.1","execa":"^2.0.3","gulp":"^4.0.2","gulp-mocha":"^6.0.0","lodash":"^4.17.21","madge":"^5.0.1","mocha-jenkins-reporter":"^0.4.1","ncp":"^2.0.0","pify":"^4.0.1","prettier":"^2.8.8","rimraf":"^3.0.2","semver":"^7.6.0","ts-node":"^10.9.2","typescript":"^5.3.3"},"contributors":[{"name":"Google Inc."}],"scripts":{"build":"npm run compile","clean":"rimraf ./build","compile":"tsc -p .","format":"clang-format -i -style=\\"{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}\\" src/*.ts test/*.ts","lint":"eslint src/*.ts test/*.ts","prepare":"npm run generate-types && npm run compile","test":"gulp test","check":"npm run lint","fix":"eslint --fix src/*.ts test/*.ts","pretest":"npm run generate-types && npm run generate-test-types && npm run compile","posttest":"npm run check && madge -c ./build/src","generate-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --includeDirs proto/ --include-dirs test/fixtures/ -O src/generated/ --grpcLib ../index channelz.proto","generate-test-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --include-dirs test/fixtures/ -O test/generated/ --grpcLib ../../src/index test_service.proto"},"dependencies":{"@grpc/proto-loader":"^0.7.13","@js-sdsl/ordered-map":"^4.4.2"},"files":["src/**/*.ts","build/src/**/*.{js,d.ts,js.map}","proto/*.proto","LICENSE","deps/envoy-api/envoy/api/v2/**/*.proto","deps/envoy-api/envoy/config/**/*.proto","deps/envoy-api/envoy/service/**/*.proto","deps/envoy-api/envoy/type/**/*.proto","deps/udpa/udpa/**/*.proto","deps/googleapis/google/api/*.proto","deps/googleapis/google/rpc/*.proto","deps/protoc-gen-validate/validate/**/*.proto"]}');

/***/ })

};
;