"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/is";
exports.ids = ["vendor-chunks/is"];
exports.modules = {

/***/ "(rsc)/./node_modules/is/index.js":
/*!**********************************!*\
  !*** ./node_modules/is/index.js ***!
  \**********************************/
/***/ ((module) => {

eval("/* globals window, HTMLElement */ \n/**!\n * is\n * the definitive JavaScript type testing library\n *\n * @copyright 2013-2014 Enrico Marino / Jordan Harband\n * @license MIT\n */ var objProto = Object.prototype;\nvar owns = objProto.hasOwnProperty;\nvar toStr = objProto.toString;\nvar symbolValueOf;\nif (typeof Symbol === \"function\") {\n    symbolValueOf = Symbol.prototype.valueOf;\n}\nvar bigIntValueOf;\nif (typeof BigInt === \"function\") {\n    bigIntValueOf = BigInt.prototype.valueOf;\n}\nvar isActualNaN = function(value) {\n    return value !== value;\n};\nvar NON_HOST_TYPES = {\n    \"boolean\": 1,\n    number: 1,\n    string: 1,\n    undefined: 1\n};\nvar base64Regex = /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{4}|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)$/;\nvar hexRegex = /^[A-Fa-f0-9]+$/;\n/**\n * Expose `is`\n */ var is = {};\n/**\n * Test general.\n */ /**\n * is.type\n * Test if `value` is a type of `type`.\n *\n * @param {*} value value to test\n * @param {String} type type\n * @return {Boolean} true if `value` is a type of `type`, false otherwise\n * @api public\n */ is.a = is.type = function(value, type) {\n    return typeof value === type;\n};\n/**\n * is.defined\n * Test if `value` is defined.\n *\n * @param {*} value value to test\n * @return {Boolean} true if 'value' is defined, false otherwise\n * @api public\n */ is.defined = function(value) {\n    return typeof value !== \"undefined\";\n};\n/**\n * is.empty\n * Test if `value` is empty.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is empty, false otherwise\n * @api public\n */ is.empty = function(value) {\n    var type = toStr.call(value);\n    var key;\n    if (type === \"[object Array]\" || type === \"[object Arguments]\" || type === \"[object String]\") {\n        return value.length === 0;\n    }\n    if (type === \"[object Object]\") {\n        for(key in value){\n            if (owns.call(value, key)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return !value;\n};\n/**\n * is.equal\n * Test if `value` is equal to `other`.\n *\n * @param {*} value value to test\n * @param {*} other value to compare with\n * @return {Boolean} true if `value` is equal to `other`, false otherwise\n */ is.equal = function equal(value, other) {\n    if (value === other) {\n        return true;\n    }\n    var type = toStr.call(value);\n    var key;\n    if (type !== toStr.call(other)) {\n        return false;\n    }\n    if (type === \"[object Object]\") {\n        for(key in value){\n            if (!is.equal(value[key], other[key]) || !(key in other)) {\n                return false;\n            }\n        }\n        for(key in other){\n            if (!is.equal(value[key], other[key]) || !(key in value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (type === \"[object Array]\") {\n        key = value.length;\n        if (key !== other.length) {\n            return false;\n        }\n        while(key--){\n            if (!is.equal(value[key], other[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (type === \"[object Function]\") {\n        return value.prototype === other.prototype;\n    }\n    if (type === \"[object Date]\") {\n        return value.getTime() === other.getTime();\n    }\n    return false;\n};\n/**\n * is.hosted\n * Test if `value` is hosted by `host`.\n *\n * @param {*} value to test\n * @param {*} host host to test with\n * @return {Boolean} true if `value` is hosted by `host`, false otherwise\n * @api public\n */ is.hosted = function(value, host) {\n    var type = typeof host[value];\n    return type === \"object\" ? !!host[value] : !NON_HOST_TYPES[type];\n};\n/**\n * is.instance\n * Test if `value` is an instance of `constructor`.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is an instance of `constructor`\n * @api public\n */ is.instance = is[\"instanceof\"] = function(value, constructor) {\n    return value instanceof constructor;\n};\n/**\n * is.nil / is.null\n * Test if `value` is null.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is null, false otherwise\n * @api public\n */ is.nil = is[\"null\"] = function(value) {\n    return value === null;\n};\n/**\n * is.undef / is.undefined\n * Test if `value` is undefined.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is undefined, false otherwise\n * @api public\n */ is.undef = is.undefined = function(value) {\n    return typeof value === \"undefined\";\n};\n/**\n * Test arguments.\n */ /**\n * is.args\n * Test if `value` is an arguments object.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is an arguments object, false otherwise\n * @api public\n */ is.args = is.arguments = function(value) {\n    var isStandardArguments = toStr.call(value) === \"[object Arguments]\";\n    var isOldArguments = !is.array(value) && is.arraylike(value) && is.object(value) && is.fn(value.callee);\n    return isStandardArguments || isOldArguments;\n};\n/**\n * Test array.\n */ /**\n * is.array\n * Test if 'value' is an array.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is an array, false otherwise\n * @api public\n */ is.array = Array.isArray || function(value) {\n    return toStr.call(value) === \"[object Array]\";\n};\n/**\n * is.arguments.empty\n * Test if `value` is an empty arguments object.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is an empty arguments object, false otherwise\n * @api public\n */ is.args.empty = function(value) {\n    return is.args(value) && value.length === 0;\n};\n/**\n * is.array.empty\n * Test if `value` is an empty array.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is an empty array, false otherwise\n * @api public\n */ is.array.empty = function(value) {\n    return is.array(value) && value.length === 0;\n};\n/**\n * is.arraylike\n * Test if `value` is an arraylike object.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is an arguments object, false otherwise\n * @api public\n */ is.arraylike = function(value) {\n    return !!value && !is.bool(value) && owns.call(value, \"length\") && isFinite(value.length) && is.number(value.length) && value.length >= 0;\n};\n/**\n * Test boolean.\n */ /**\n * is.bool\n * Test if `value` is a boolean.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is a boolean, false otherwise\n * @api public\n */ is.bool = is[\"boolean\"] = function(value) {\n    return toStr.call(value) === \"[object Boolean]\";\n};\n/**\n * is.false\n * Test if `value` is false.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is false, false otherwise\n * @api public\n */ is[\"false\"] = function(value) {\n    return is.bool(value) && Boolean(Number(value)) === false;\n};\n/**\n * is.true\n * Test if `value` is true.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is true, false otherwise\n * @api public\n */ is[\"true\"] = function(value) {\n    return is.bool(value) && Boolean(Number(value)) === true;\n};\n/**\n * Test date.\n */ /**\n * is.date\n * Test if `value` is a date.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is a date, false otherwise\n * @api public\n */ is.date = function(value) {\n    return toStr.call(value) === \"[object Date]\";\n};\n/**\n * is.date.valid\n * Test if `value` is a valid date.\n *\n * @param {*} value value to test\n * @returns {Boolean} true if `value` is a valid date, false otherwise\n */ is.date.valid = function(value) {\n    return is.date(value) && !isNaN(Number(value));\n};\n/**\n * Test element.\n */ /**\n * is.element\n * Test if `value` is an html element.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is an HTML Element, false otherwise\n * @api public\n */ is.element = function(value) {\n    return value !== undefined && typeof HTMLElement !== \"undefined\" && value instanceof HTMLElement && value.nodeType === 1;\n};\n/**\n * Test error.\n */ /**\n * is.error\n * Test if `value` is an error object.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is an error object, false otherwise\n * @api public\n */ is.error = function(value) {\n    return toStr.call(value) === \"[object Error]\";\n};\n/**\n * Test function.\n */ /**\n * is.fn / is.function (deprecated)\n * Test if `value` is a function.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is a function, false otherwise\n * @api public\n */ is.fn = is[\"function\"] = function(value) {\n    var isAlert =  false && 0;\n    if (isAlert) {\n        return true;\n    }\n    var str = toStr.call(value);\n    return str === \"[object Function]\" || str === \"[object GeneratorFunction]\" || str === \"[object AsyncFunction]\";\n};\n/**\n * Test number.\n */ /**\n * is.number\n * Test if `value` is a number.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is a number, false otherwise\n * @api public\n */ is.number = function(value) {\n    return toStr.call(value) === \"[object Number]\";\n};\n/**\n * is.infinite\n * Test if `value` is positive or negative infinity.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is positive or negative Infinity, false otherwise\n * @api public\n */ is.infinite = function(value) {\n    return value === Infinity || value === -Infinity;\n};\n/**\n * is.decimal\n * Test if `value` is a decimal number.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is a decimal number, false otherwise\n * @api public\n */ is.decimal = function(value) {\n    return is.number(value) && !isActualNaN(value) && !is.infinite(value) && value % 1 !== 0;\n};\n/**\n * is.divisibleBy\n * Test if `value` is divisible by `n`.\n *\n * @param {Number} value value to test\n * @param {Number} n dividend\n * @return {Boolean} true if `value` is divisible by `n`, false otherwise\n * @api public\n */ is.divisibleBy = function(value, n) {\n    var isDividendInfinite = is.infinite(value);\n    var isDivisorInfinite = is.infinite(n);\n    var isNonZeroNumber = is.number(value) && !isActualNaN(value) && is.number(n) && !isActualNaN(n) && n !== 0;\n    return isDividendInfinite || isDivisorInfinite || isNonZeroNumber && value % n === 0;\n};\n/**\n * is.integer\n * Test if `value` is an integer.\n *\n * @param value to test\n * @return {Boolean} true if `value` is an integer, false otherwise\n * @api public\n */ is.integer = is[\"int\"] = function(value) {\n    return is.number(value) && !isActualNaN(value) && value % 1 === 0;\n};\n/**\n * is.maximum\n * Test if `value` is greater than 'others' values.\n *\n * @param {Number} value value to test\n * @param {Array} others values to compare with\n * @return {Boolean} true if `value` is greater than `others` values\n * @api public\n */ is.maximum = function(value, others) {\n    if (isActualNaN(value)) {\n        throw new TypeError(\"NaN is not a valid value\");\n    } else if (!is.arraylike(others)) {\n        throw new TypeError(\"second argument must be array-like\");\n    }\n    var len = others.length;\n    while(--len >= 0){\n        if (value < others[len]) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * is.minimum\n * Test if `value` is less than `others` values.\n *\n * @param {Number} value value to test\n * @param {Array} others values to compare with\n * @return {Boolean} true if `value` is less than `others` values\n * @api public\n */ is.minimum = function(value, others) {\n    if (isActualNaN(value)) {\n        throw new TypeError(\"NaN is not a valid value\");\n    } else if (!is.arraylike(others)) {\n        throw new TypeError(\"second argument must be array-like\");\n    }\n    var len = others.length;\n    while(--len >= 0){\n        if (value > others[len]) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * is.nan\n * Test if `value` is not a number.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is not a number, false otherwise\n * @api public\n */ is.nan = function(value) {\n    return !is.number(value) || value !== value;\n};\n/**\n * is.even\n * Test if `value` is an even number.\n *\n * @param {Number} value value to test\n * @return {Boolean} true if `value` is an even number, false otherwise\n * @api public\n */ is.even = function(value) {\n    return is.infinite(value) || is.number(value) && value === value && value % 2 === 0;\n};\n/**\n * is.odd\n * Test if `value` is an odd number.\n *\n * @param {Number} value value to test\n * @return {Boolean} true if `value` is an odd number, false otherwise\n * @api public\n */ is.odd = function(value) {\n    return is.infinite(value) || is.number(value) && value === value && value % 2 !== 0;\n};\n/**\n * is.ge\n * Test if `value` is greater than or equal to `other`.\n *\n * @param {Number} value value to test\n * @param {Number} other value to compare with\n * @return {Boolean}\n * @api public\n */ is.ge = function(value, other) {\n    if (isActualNaN(value) || isActualNaN(other)) {\n        throw new TypeError(\"NaN is not a valid value\");\n    }\n    return !is.infinite(value) && !is.infinite(other) && value >= other;\n};\n/**\n * is.gt\n * Test if `value` is greater than `other`.\n *\n * @param {Number} value value to test\n * @param {Number} other value to compare with\n * @return {Boolean}\n * @api public\n */ is.gt = function(value, other) {\n    if (isActualNaN(value) || isActualNaN(other)) {\n        throw new TypeError(\"NaN is not a valid value\");\n    }\n    return !is.infinite(value) && !is.infinite(other) && value > other;\n};\n/**\n * is.le\n * Test if `value` is less than or equal to `other`.\n *\n * @param {Number} value value to test\n * @param {Number} other value to compare with\n * @return {Boolean} if 'value' is less than or equal to 'other'\n * @api public\n */ is.le = function(value, other) {\n    if (isActualNaN(value) || isActualNaN(other)) {\n        throw new TypeError(\"NaN is not a valid value\");\n    }\n    return !is.infinite(value) && !is.infinite(other) && value <= other;\n};\n/**\n * is.lt\n * Test if `value` is less than `other`.\n *\n * @param {Number} value value to test\n * @param {Number} other value to compare with\n * @return {Boolean} if `value` is less than `other`\n * @api public\n */ is.lt = function(value, other) {\n    if (isActualNaN(value) || isActualNaN(other)) {\n        throw new TypeError(\"NaN is not a valid value\");\n    }\n    return !is.infinite(value) && !is.infinite(other) && value < other;\n};\n/**\n * is.within\n * Test if `value` is within `start` and `finish`.\n *\n * @param {Number} value value to test\n * @param {Number} start lower bound\n * @param {Number} finish upper bound\n * @return {Boolean} true if 'value' is is within 'start' and 'finish'\n * @api public\n */ is.within = function(value, start, finish) {\n    if (isActualNaN(value) || isActualNaN(start) || isActualNaN(finish)) {\n        throw new TypeError(\"NaN is not a valid value\");\n    } else if (!is.number(value) || !is.number(start) || !is.number(finish)) {\n        throw new TypeError(\"all arguments must be numbers\");\n    }\n    var isAnyInfinite = is.infinite(value) || is.infinite(start) || is.infinite(finish);\n    return isAnyInfinite || value >= start && value <= finish;\n};\n/**\n * Test object.\n */ /**\n * is.object\n * Test if `value` is an object.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is an object, false otherwise\n * @api public\n */ is.object = function(value) {\n    return toStr.call(value) === \"[object Object]\";\n};\n/**\n * is.primitive\n * Test if `value` is a primitive.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is a primitive, false otherwise\n * @api public\n */ is.primitive = function isPrimitive(value) {\n    if (!value) {\n        return true;\n    }\n    if (typeof value === \"object\" || is.object(value) || is.fn(value) || is.array(value)) {\n        return false;\n    }\n    return true;\n};\n/**\n * is.hash\n * Test if `value` is a hash - a plain object literal.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is a hash, false otherwise\n * @api public\n */ is.hash = function(value) {\n    return is.object(value) && value.constructor === Object && !value.nodeType && !value.setInterval;\n};\n/**\n * Test regexp.\n */ /**\n * is.regexp\n * Test if `value` is a regular expression.\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is a regexp, false otherwise\n * @api public\n */ is.regexp = function(value) {\n    return toStr.call(value) === \"[object RegExp]\";\n};\n/**\n * Test string.\n */ /**\n * is.string\n * Test if `value` is a string.\n *\n * @param {*} value value to test\n * @return {Boolean} true if 'value' is a string, false otherwise\n * @api public\n */ is.string = function(value) {\n    return toStr.call(value) === \"[object String]\";\n};\n/**\n * Test base64 string.\n */ /**\n * is.base64\n * Test if `value` is a valid base64 encoded string.\n *\n * @param {*} value value to test\n * @return {Boolean} true if 'value' is a base64 encoded string, false otherwise\n * @api public\n */ is.base64 = function(value) {\n    return is.string(value) && (!value.length || base64Regex.test(value));\n};\n/**\n * Test base64 string.\n */ /**\n * is.hex\n * Test if `value` is a valid hex encoded string.\n *\n * @param {*} value value to test\n * @return {Boolean} true if 'value' is a hex encoded string, false otherwise\n * @api public\n */ is.hex = function(value) {\n    return is.string(value) && (!value.length || hexRegex.test(value));\n};\n/**\n * is.symbol\n * Test if `value` is an ES6 Symbol\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is a Symbol, false otherise\n * @api public\n */ is.symbol = function(value) {\n    return typeof Symbol === \"function\" && toStr.call(value) === \"[object Symbol]\" && typeof symbolValueOf.call(value) === \"symbol\";\n};\n/**\n * is.bigint\n * Test if `value` is an ES-proposed BigInt\n *\n * @param {*} value value to test\n * @return {Boolean} true if `value` is a BigInt, false otherise\n * @api public\n */ is.bigint = function(value) {\n    // eslint-disable-next-line valid-typeof\n    return typeof BigInt === \"function\" && toStr.call(value) === \"[object BigInt]\" && typeof bigIntValueOf.call(value) === \"bigint\";\n};\nmodule.exports = is;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMvQjtBQUVBOztDQUVDLEdBRUQ7Ozs7Ozs7Q0FPQyxHQUVETyxHQUFHSixNQUFNLEdBQUcsU0FBVUgsS0FBSztJQUN6QixPQUFPUixNQUFNb0IsSUFBSSxDQUFDWixXQUFXO0FBQy9CO0FBRUE7O0NBRUMsR0FFRDs7Ozs7OztDQU9DLEdBRURPLEdBQUd5RSxNQUFNLEdBQUcsU0FBVWhGLEtBQUs7SUFDekIsT0FBT08sR0FBR0osTUFBTSxDQUFDSCxVQUFXLEVBQUNBLE1BQU1jLE1BQU0sSUFBSVQsWUFBWTRFLElBQUksQ0FBQ2pGLE1BQUs7QUFDckU7QUFFQTs7Q0FFQyxHQUVEOzs7Ozs7O0NBT0MsR0FFRE8sR0FBRzJFLEdBQUcsR0FBRyxTQUFVbEYsS0FBSztJQUN0QixPQUFPTyxHQUFHSixNQUFNLENBQUNILFVBQVcsRUFBQ0EsTUFBTWMsTUFBTSxJQUFJUixTQUFTMkUsSUFBSSxDQUFDakYsTUFBSztBQUNsRTtBQUVBOzs7Ozs7O0NBT0MsR0FFRE8sR0FBRzRFLE1BQU0sR0FBRyxTQUFVbkYsS0FBSztJQUN6QixPQUFPLE9BQU9MLFdBQVcsY0FBY0gsTUFBTW9CLElBQUksQ0FBQ1osV0FBVyxxQkFBcUIsT0FBT04sY0FBY2tCLElBQUksQ0FBQ1osV0FBVztBQUN6SDtBQUVBOzs7Ozs7O0NBT0MsR0FFRE8sR0FBRzZFLE1BQU0sR0FBRyxTQUFVcEYsS0FBSztJQUN6Qix3Q0FBd0M7SUFDeEMsT0FBTyxPQUFPRixXQUFXLGNBQWNOLE1BQU1vQixJQUFJLENBQUNaLFdBQVcscUJBQXFCLE9BQU9ILGNBQWNlLElBQUksQ0FBQ1osV0FBVztBQUN6SDtBQUVBcUYsT0FBT0MsT0FBTyxHQUFHL0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ueWMtaG91c2luZy1hcHAvLi9ub2RlX21vZHVsZXMvaXMvaW5kZXguanM/N2ZkMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIHdpbmRvdywgSFRNTEVsZW1lbnQgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiohXG4gKiBpc1xuICogdGhlIGRlZmluaXRpdmUgSmF2YVNjcmlwdCB0eXBlIHRlc3RpbmcgbGlicmFyeVxuICpcbiAqIEBjb3B5cmlnaHQgMjAxMy0yMDE0IEVucmljbyBNYXJpbm8gLyBKb3JkYW4gSGFyYmFuZFxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxudmFyIG9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBvd25zID0gb2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHIgPSBvYmpQcm90by50b1N0cmluZztcbnZhciBzeW1ib2xWYWx1ZU9mO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgc3ltYm9sVmFsdWVPZiA9IFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZjtcbn1cbnZhciBiaWdJbnRWYWx1ZU9mO1xuaWYgKHR5cGVvZiBCaWdJbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgYmlnSW50VmFsdWVPZiA9IEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZjtcbn1cbnZhciBpc0FjdHVhbE5hTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcbnZhciBOT05fSE9TVF9UWVBFUyA9IHtcbiAgJ2Jvb2xlYW4nOiAxLFxuICBudW1iZXI6IDEsXG4gIHN0cmluZzogMSxcbiAgdW5kZWZpbmVkOiAxXG59O1xuXG52YXIgYmFzZTY0UmVnZXggPSAvXihbQS1aYS16MC05Ky9dezR9KSooW0EtWmEtejAtOSsvXXs0fXxbQS1aYS16MC05Ky9dezN9PXxbQS1aYS16MC05Ky9dezJ9PT0pJC87XG52YXIgaGV4UmVnZXggPSAvXltBLUZhLWYwLTldKyQvO1xuXG4vKipcbiAqIEV4cG9zZSBgaXNgXG4gKi9cblxudmFyIGlzID0ge307XG5cbi8qKlxuICogVGVzdCBnZW5lcmFsLlxuICovXG5cbi8qKlxuICogaXMudHlwZVxuICogVGVzdCBpZiBgdmFsdWVgIGlzIGEgdHlwZSBvZiBgdHlwZWAuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0eXBlXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGB2YWx1ZWAgaXMgYSB0eXBlIG9mIGB0eXBlYCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmlzLmEgPSBpcy50eXBlID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IHR5cGU7XG59O1xuXG4vKipcbiAqIGlzLmRlZmluZWRcbiAqIFRlc3QgaWYgYHZhbHVlYCBpcyBkZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiAndmFsdWUnIGlzIGRlZmluZWQsIGZhbHNlIG90aGVyd2lzZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5pcy5kZWZpbmVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xufTtcblxuLyoqXG4gKiBpcy5lbXB0eVxuICogVGVzdCBpZiBgdmFsdWVgIGlzIGVtcHR5LlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBgdmFsdWVgIGlzIGVtcHR5LCBmYWxzZSBvdGhlcndpc2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuaXMuZW1wdHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0b1N0ci5jYWxsKHZhbHVlKTtcbiAgdmFyIGtleTtcblxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJyB8fCB0eXBlID09PSAnW29iamVjdCBBcmd1bWVudHNdJyB8fCB0eXBlID09PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPT09IDA7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICBmb3IgKGtleSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKG93bnMuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuICF2YWx1ZTtcbn07XG5cbi8qKlxuICogaXMuZXF1YWxcbiAqIFRlc3QgaWYgYHZhbHVlYCBpcyBlcXVhbCB0byBgb3RoZXJgLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgdmFsdWUgdG8gdGVzdFxuICogQHBhcmFtIHsqfSBvdGhlciB2YWx1ZSB0byBjb21wYXJlIHdpdGhcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYHZhbHVlYCBpcyBlcXVhbCB0byBgb3RoZXJgLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuXG5pcy5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKHZhbHVlLCBvdGhlcikge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgdHlwZSA9IHRvU3RyLmNhbGwodmFsdWUpO1xuICB2YXIga2V5O1xuXG4gIGlmICh0eXBlICE9PSB0b1N0ci5jYWxsKG90aGVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIGZvciAoa2V5IGluIHZhbHVlKSB7XG4gICAgICBpZiAoIWlzLmVxdWFsKHZhbHVlW2tleV0sIG90aGVyW2tleV0pIHx8ICEoa2V5IGluIG90aGVyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoa2V5IGluIG90aGVyKSB7XG4gICAgICBpZiAoIWlzLmVxdWFsKHZhbHVlW2tleV0sIG90aGVyW2tleV0pIHx8ICEoa2V5IGluIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICBrZXkgPSB2YWx1ZS5sZW5ndGg7XG4gICAgaWYgKGtleSAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHdoaWxlIChrZXktLSkge1xuICAgICAgaWYgKCFpcy5lcXVhbCh2YWx1ZVtrZXldLCBvdGhlcltrZXldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICByZXR1cm4gdmFsdWUucHJvdG90eXBlID09PSBvdGhlci5wcm90b3R5cGU7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgRGF0ZV0nKSB7XG4gICAgcmV0dXJuIHZhbHVlLmdldFRpbWUoKSA9PT0gb3RoZXIuZ2V0VGltZSgpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBpcy5ob3N0ZWRcbiAqIFRlc3QgaWYgYHZhbHVlYCBpcyBob3N0ZWQgYnkgYGhvc3RgLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgdG8gdGVzdFxuICogQHBhcmFtIHsqfSBob3N0IGhvc3QgdG8gdGVzdCB3aXRoXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGB2YWx1ZWAgaXMgaG9zdGVkIGJ5IGBob3N0YCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmlzLmhvc3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaG9zdCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBob3N0W3ZhbHVlXTtcbiAgcmV0dXJuIHR5cGUgPT09ICdvYmplY3QnID8gISFob3N0W3ZhbHVlXSA6ICFOT05fSE9TVF9UWVBFU1t0eXBlXTtcbn07XG5cbi8qKlxuICogaXMuaW5zdGFuY2VcbiAqIFRlc3QgaWYgYHZhbHVlYCBpcyBhbiBpbnN0YW5jZSBvZiBgY29uc3RydWN0b3JgLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIGluc3RhbmNlIG9mIGBjb25zdHJ1Y3RvcmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuaXMuaW5zdGFuY2UgPSBpc1snaW5zdGFuY2VvZiddID0gZnVuY3Rpb24gKHZhbHVlLCBjb25zdHJ1Y3Rvcikge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcjtcbn07XG5cbi8qKlxuICogaXMubmlsIC8gaXMubnVsbFxuICogVGVzdCBpZiBgdmFsdWVgIGlzIG51bGwuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGB2YWx1ZWAgaXMgbnVsbCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmlzLm5pbCA9IGlzWydudWxsJ10gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xufTtcblxuLyoqXG4gKiBpcy51bmRlZiAvIGlzLnVuZGVmaW5lZFxuICogVGVzdCBpZiBgdmFsdWVgIGlzIHVuZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYHZhbHVlYCBpcyB1bmRlZmluZWQsIGZhbHNlIG90aGVyd2lzZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5pcy51bmRlZiA9IGlzLnVuZGVmaW5lZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcbn07XG5cbi8qKlxuICogVGVzdCBhcmd1bWVudHMuXG4gKi9cblxuLyoqXG4gKiBpcy5hcmdzXG4gKiBUZXN0IGlmIGB2YWx1ZWAgaXMgYW4gYXJndW1lbnRzIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYHZhbHVlYCBpcyBhbiBhcmd1bWVudHMgb2JqZWN0LCBmYWxzZSBvdGhlcndpc2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuaXMuYXJncyA9IGlzLmFyZ3VtZW50cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IHRvU3RyLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcbiAgdmFyIGlzT2xkQXJndW1lbnRzID0gIWlzLmFycmF5KHZhbHVlKSAmJiBpcy5hcnJheWxpa2UodmFsdWUpICYmIGlzLm9iamVjdCh2YWx1ZSkgJiYgaXMuZm4odmFsdWUuY2FsbGVlKTtcbiAgcmV0dXJuIGlzU3RhbmRhcmRBcmd1bWVudHMgfHwgaXNPbGRBcmd1bWVudHM7XG59O1xuXG4vKipcbiAqIFRlc3QgYXJyYXkuXG4gKi9cblxuLyoqXG4gKiBpcy5hcnJheVxuICogVGVzdCBpZiAndmFsdWUnIGlzIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBmYWxzZSBvdGhlcndpc2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuaXMuYXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdG9TdHIuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vKipcbiAqIGlzLmFyZ3VtZW50cy5lbXB0eVxuICogVGVzdCBpZiBgdmFsdWVgIGlzIGFuIGVtcHR5IGFyZ3VtZW50cyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgYXJndW1lbnRzIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5pcy5hcmdzLmVtcHR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiBpcy5hcmdzKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDA7XG59O1xuXG4vKipcbiAqIGlzLmFycmF5LmVtcHR5XG4gKiBUZXN0IGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgYXJyYXkuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgYXJyYXksIGZhbHNlIG90aGVyd2lzZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuaXMuYXJyYXkuZW1wdHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIGlzLmFycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDA7XG59O1xuXG4vKipcbiAqIGlzLmFycmF5bGlrZVxuICogVGVzdCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5bGlrZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gYXJndW1lbnRzIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmlzLmFycmF5bGlrZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiAhaXMuYm9vbCh2YWx1ZSlcbiAgICAmJiBvd25zLmNhbGwodmFsdWUsICdsZW5ndGgnKVxuICAgICYmIGlzRmluaXRlKHZhbHVlLmxlbmd0aClcbiAgICAmJiBpcy5udW1iZXIodmFsdWUubGVuZ3RoKVxuICAgICYmIHZhbHVlLmxlbmd0aCA+PSAwO1xufTtcblxuLyoqXG4gKiBUZXN0IGJvb2xlYW4uXG4gKi9cblxuLyoqXG4gKiBpcy5ib29sXG4gKiBUZXN0IGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgYm9vbGVhbiwgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmlzLmJvb2wgPSBpc1snYm9vbGVhbiddID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0b1N0ci5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xufTtcblxuLyoqXG4gKiBpcy5mYWxzZVxuICogVGVzdCBpZiBgdmFsdWVgIGlzIGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBgdmFsdWVgIGlzIGZhbHNlLCBmYWxzZSBvdGhlcndpc2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuaXNbJ2ZhbHNlJ10gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIGlzLmJvb2wodmFsdWUpICYmIEJvb2xlYW4oTnVtYmVyKHZhbHVlKSkgPT09IGZhbHNlO1xufTtcblxuLyoqXG4gKiBpcy50cnVlXG4gKiBUZXN0IGlmIGB2YWx1ZWAgaXMgdHJ1ZS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYHZhbHVlYCBpcyB0cnVlLCBmYWxzZSBvdGhlcndpc2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuaXNbJ3RydWUnXSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gaXMuYm9vbCh2YWx1ZSkgJiYgQm9vbGVhbihOdW1iZXIodmFsdWUpKSA9PT0gdHJ1ZTtcbn07XG5cbi8qKlxuICogVGVzdCBkYXRlLlxuICovXG5cbi8qKlxuICogaXMuZGF0ZVxuICogVGVzdCBpZiBgdmFsdWVgIGlzIGEgZGF0ZS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYHZhbHVlYCBpcyBhIGRhdGUsIGZhbHNlIG90aGVyd2lzZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5pcy5kYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0b1N0ci5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufTtcblxuLyoqXG4gKiBpcy5kYXRlLnZhbGlkXG4gKiBUZXN0IGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBkYXRlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGRhdGUsIGZhbHNlIG90aGVyd2lzZVxuICovXG5pcy5kYXRlLnZhbGlkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiBpcy5kYXRlKHZhbHVlKSAmJiAhaXNOYU4oTnVtYmVyKHZhbHVlKSk7XG59O1xuXG4vKipcbiAqIFRlc3QgZWxlbWVudC5cbiAqL1xuXG4vKipcbiAqIGlzLmVsZW1lbnRcbiAqIFRlc3QgaWYgYHZhbHVlYCBpcyBhbiBodG1sIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gSFRNTCBFbGVtZW50LCBmYWxzZSBvdGhlcndpc2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuaXMuZWxlbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZFxuICAgICYmIHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50XG4gICAgJiYgdmFsdWUubm9kZVR5cGUgPT09IDE7XG59O1xuXG4vKipcbiAqIFRlc3QgZXJyb3IuXG4gKi9cblxuLyoqXG4gKiBpcy5lcnJvclxuICogVGVzdCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYHZhbHVlYCBpcyBhbiBlcnJvciBvYmplY3QsIGZhbHNlIG90aGVyd2lzZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5pcy5lcnJvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdG9TdHIuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEVycm9yXSc7XG59O1xuXG4vKipcbiAqIFRlc3QgZnVuY3Rpb24uXG4gKi9cblxuLyoqXG4gKiBpcy5mbiAvIGlzLmZ1bmN0aW9uIChkZXByZWNhdGVkKVxuICogVGVzdCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmlzLmZuID0gaXNbJ2Z1bmN0aW9uJ10gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIGlzQWxlcnQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSA9PT0gd2luZG93LmFsZXJ0O1xuICBpZiAoaXNBbGVydCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcbiAgcmV0dXJuIHN0ciA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJyB8fCBzdHIgPT09ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScgfHwgc3RyID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7XG59O1xuXG4vKipcbiAqIFRlc3QgbnVtYmVyLlxuICovXG5cbi8qKlxuICogaXMubnVtYmVyXG4gKiBUZXN0IGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIsIGZhbHNlIG90aGVyd2lzZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5pcy5udW1iZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHRvU3RyLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJztcbn07XG5cbi8qKlxuICogaXMuaW5maW5pdGVcbiAqIFRlc3QgaWYgYHZhbHVlYCBpcyBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBpbmZpbml0eS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYHZhbHVlYCBpcyBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBJbmZpbml0eSwgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5pcy5pbmZpbml0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IEluZmluaXR5IHx8IHZhbHVlID09PSAtSW5maW5pdHk7XG59O1xuXG4vKipcbiAqIGlzLmRlY2ltYWxcbiAqIFRlc3QgaWYgYHZhbHVlYCBpcyBhIGRlY2ltYWwgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgZGVjaW1hbCBudW1iZXIsIGZhbHNlIG90aGVyd2lzZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5pcy5kZWNpbWFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiBpcy5udW1iZXIodmFsdWUpICYmICFpc0FjdHVhbE5hTih2YWx1ZSkgJiYgIWlzLmluZmluaXRlKHZhbHVlKSAmJiB2YWx1ZSAlIDEgIT09IDA7XG59O1xuXG4vKipcbiAqIGlzLmRpdmlzaWJsZUJ5XG4gKiBUZXN0IGlmIGB2YWx1ZWAgaXMgZGl2aXNpYmxlIGJ5IGBuYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdmFsdWUgdG8gdGVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IG4gZGl2aWRlbmRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYHZhbHVlYCBpcyBkaXZpc2libGUgYnkgYG5gLCBmYWxzZSBvdGhlcndpc2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuaXMuZGl2aXNpYmxlQnkgPSBmdW5jdGlvbiAodmFsdWUsIG4pIHtcbiAgdmFyIGlzRGl2aWRlbmRJbmZpbml0ZSA9IGlzLmluZmluaXRlKHZhbHVlKTtcbiAgdmFyIGlzRGl2aXNvckluZmluaXRlID0gaXMuaW5maW5pdGUobik7XG4gIHZhciBpc05vblplcm9OdW1iZXIgPSBpcy5udW1iZXIodmFsdWUpICYmICFpc0FjdHVhbE5hTih2YWx1ZSkgJiYgaXMubnVtYmVyKG4pICYmICFpc0FjdHVhbE5hTihuKSAmJiBuICE9PSAwO1xuICByZXR1cm4gaXNEaXZpZGVuZEluZmluaXRlIHx8IGlzRGl2aXNvckluZmluaXRlIHx8IChpc05vblplcm9OdW1iZXIgJiYgdmFsdWUgJSBuID09PSAwKTtcbn07XG5cbi8qKlxuICogaXMuaW50ZWdlclxuICogVGVzdCBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIuXG4gKlxuICogQHBhcmFtIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLCBmYWxzZSBvdGhlcndpc2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuaXMuaW50ZWdlciA9IGlzWydpbnQnXSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gaXMubnVtYmVyKHZhbHVlKSAmJiAhaXNBY3R1YWxOYU4odmFsdWUpICYmIHZhbHVlICUgMSA9PT0gMDtcbn07XG5cbi8qKlxuICogaXMubWF4aW11bVxuICogVGVzdCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiAnb3RoZXJzJyB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHZhbHVlIHRvIHRlc3RcbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVycyB2YWx1ZXMgdG8gY29tcGFyZSB3aXRoXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcnNgIHZhbHVlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5pcy5tYXhpbXVtID0gZnVuY3Rpb24gKHZhbHVlLCBvdGhlcnMpIHtcbiAgaWYgKGlzQWN0dWFsTmFOKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05hTiBpcyBub3QgYSB2YWxpZCB2YWx1ZScpO1xuICB9IGVsc2UgaWYgKCFpcy5hcnJheWxpa2Uob3RoZXJzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NlY29uZCBhcmd1bWVudCBtdXN0IGJlIGFycmF5LWxpa2UnKTtcbiAgfVxuICB2YXIgbGVuID0gb3RoZXJzLmxlbmd0aDtcblxuICB3aGlsZSAoLS1sZW4gPj0gMCkge1xuICAgIGlmICh2YWx1ZSA8IG90aGVyc1tsZW5dKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIGlzLm1pbmltdW1cbiAqIFRlc3QgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyc2AgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlcnMgdmFsdWVzIHRvIGNvbXBhcmUgd2l0aFxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJzYCB2YWx1ZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuaXMubWluaW11bSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3RoZXJzKSB7XG4gIGlmIChpc0FjdHVhbE5hTih2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOYU4gaXMgbm90IGEgdmFsaWQgdmFsdWUnKTtcbiAgfSBlbHNlIGlmICghaXMuYXJyYXlsaWtlKG90aGVycykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhcnJheS1saWtlJyk7XG4gIH1cbiAgdmFyIGxlbiA9IG90aGVycy5sZW5ndGg7XG5cbiAgd2hpbGUgKC0tbGVuID49IDApIHtcbiAgICBpZiAodmFsdWUgPiBvdGhlcnNbbGVuXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBpcy5uYW5cbiAqIFRlc3QgaWYgYHZhbHVlYCBpcyBub3QgYSBudW1iZXIuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGB2YWx1ZWAgaXMgbm90IGEgbnVtYmVyLCBmYWxzZSBvdGhlcndpc2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuaXMubmFuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiAhaXMubnVtYmVyKHZhbHVlKSB8fCB2YWx1ZSAhPT0gdmFsdWU7XG59O1xuXG4vKipcbiAqIGlzLmV2ZW5cbiAqIFRlc3QgaWYgYHZhbHVlYCBpcyBhbiBldmVuIG51bWJlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIGV2ZW4gbnVtYmVyLCBmYWxzZSBvdGhlcndpc2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuaXMuZXZlbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gaXMuaW5maW5pdGUodmFsdWUpIHx8IChpcy5udW1iZXIodmFsdWUpICYmIHZhbHVlID09PSB2YWx1ZSAmJiB2YWx1ZSAlIDIgPT09IDApO1xufTtcblxuLyoqXG4gKiBpcy5vZGRcbiAqIFRlc3QgaWYgYHZhbHVlYCBpcyBhbiBvZGQgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gb2RkIG51bWJlciwgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmlzLm9kZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gaXMuaW5maW5pdGUodmFsdWUpIHx8IChpcy5udW1iZXIodmFsdWUpICYmIHZhbHVlID09PSB2YWx1ZSAmJiB2YWx1ZSAlIDIgIT09IDApO1xufTtcblxuLyoqXG4gKiBpcy5nZVxuICogVGVzdCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gb3RoZXIgdmFsdWUgdG8gY29tcGFyZSB3aXRoXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5pcy5nZSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3RoZXIpIHtcbiAgaWYgKGlzQWN0dWFsTmFOKHZhbHVlKSB8fCBpc0FjdHVhbE5hTihvdGhlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOYU4gaXMgbm90IGEgdmFsaWQgdmFsdWUnKTtcbiAgfVxuICByZXR1cm4gIWlzLmluZmluaXRlKHZhbHVlKSAmJiAhaXMuaW5maW5pdGUob3RoZXIpICYmIHZhbHVlID49IG90aGVyO1xufTtcblxuLyoqXG4gKiBpcy5ndFxuICogVGVzdCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gb3RoZXIgdmFsdWUgdG8gY29tcGFyZSB3aXRoXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5pcy5ndCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3RoZXIpIHtcbiAgaWYgKGlzQWN0dWFsTmFOKHZhbHVlKSB8fCBpc0FjdHVhbE5hTihvdGhlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOYU4gaXMgbm90IGEgdmFsaWQgdmFsdWUnKTtcbiAgfVxuICByZXR1cm4gIWlzLmluZmluaXRlKHZhbHVlKSAmJiAhaXMuaW5maW5pdGUob3RoZXIpICYmIHZhbHVlID4gb3RoZXI7XG59O1xuXG4vKipcbiAqIGlzLmxlXG4gKiBUZXN0IGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHZhbHVlIHRvIHRlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBvdGhlciB2YWx1ZSB0byBjb21wYXJlIHdpdGhcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlmICd2YWx1ZScgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICdvdGhlcidcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuaXMubGUgPSBmdW5jdGlvbiAodmFsdWUsIG90aGVyKSB7XG4gIGlmIChpc0FjdHVhbE5hTih2YWx1ZSkgfHwgaXNBY3R1YWxOYU4ob3RoZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTmFOIGlzIG5vdCBhIHZhbGlkIHZhbHVlJyk7XG4gIH1cbiAgcmV0dXJuICFpcy5pbmZpbml0ZSh2YWx1ZSkgJiYgIWlzLmluZmluaXRlKG90aGVyKSAmJiB2YWx1ZSA8PSBvdGhlcjtcbn07XG5cbi8qKlxuICogaXMubHRcbiAqIFRlc3QgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdmFsdWUgdG8gdGVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IG90aGVyIHZhbHVlIHRvIGNvbXBhcmUgd2l0aFxuICogQHJldHVybiB7Qm9vbGVhbn0gaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5pcy5sdCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3RoZXIpIHtcbiAgaWYgKGlzQWN0dWFsTmFOKHZhbHVlKSB8fCBpc0FjdHVhbE5hTihvdGhlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOYU4gaXMgbm90IGEgdmFsaWQgdmFsdWUnKTtcbiAgfVxuICByZXR1cm4gIWlzLmluZmluaXRlKHZhbHVlKSAmJiAhaXMuaW5maW5pdGUob3RoZXIpICYmIHZhbHVlIDwgb3RoZXI7XG59O1xuXG4vKipcbiAqIGlzLndpdGhpblxuICogVGVzdCBpZiBgdmFsdWVgIGlzIHdpdGhpbiBgc3RhcnRgIGFuZCBgZmluaXNoYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdmFsdWUgdG8gdGVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IGxvd2VyIGJvdW5kXG4gKiBAcGFyYW0ge051bWJlcn0gZmluaXNoIHVwcGVyIGJvdW5kXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmICd2YWx1ZScgaXMgaXMgd2l0aGluICdzdGFydCcgYW5kICdmaW5pc2gnXG4gKiBAYXBpIHB1YmxpY1xuICovXG5pcy53aXRoaW4gPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBmaW5pc2gpIHtcbiAgaWYgKGlzQWN0dWFsTmFOKHZhbHVlKSB8fCBpc0FjdHVhbE5hTihzdGFydCkgfHwgaXNBY3R1YWxOYU4oZmluaXNoKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05hTiBpcyBub3QgYSB2YWxpZCB2YWx1ZScpO1xuICB9IGVsc2UgaWYgKCFpcy5udW1iZXIodmFsdWUpIHx8ICFpcy5udW1iZXIoc3RhcnQpIHx8ICFpcy5udW1iZXIoZmluaXNoKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FsbCBhcmd1bWVudHMgbXVzdCBiZSBudW1iZXJzJyk7XG4gIH1cbiAgdmFyIGlzQW55SW5maW5pdGUgPSBpcy5pbmZpbml0ZSh2YWx1ZSkgfHwgaXMuaW5maW5pdGUoc3RhcnQpIHx8IGlzLmluZmluaXRlKGZpbmlzaCk7XG4gIHJldHVybiBpc0FueUluZmluaXRlIHx8ICh2YWx1ZSA+PSBzdGFydCAmJiB2YWx1ZSA8PSBmaW5pc2gpO1xufTtcblxuLyoqXG4gKiBUZXN0IG9iamVjdC5cbiAqL1xuXG4vKipcbiAqIGlzLm9iamVjdFxuICogVGVzdCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGZhbHNlIG90aGVyd2lzZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuaXMub2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0b1N0ci5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59O1xuXG4vKipcbiAqIGlzLnByaW1pdGl2ZVxuICogVGVzdCBpZiBgdmFsdWVgIGlzIGEgcHJpbWl0aXZlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgcHJpbWl0aXZlLCBmYWxzZSBvdGhlcndpc2VcbiAqIEBhcGkgcHVibGljXG4gKi9cbmlzLnByaW1pdGl2ZSA9IGZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCBpcy5vYmplY3QodmFsdWUpIHx8IGlzLmZuKHZhbHVlKSB8fCBpcy5hcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIGlzLmhhc2hcbiAqIFRlc3QgaWYgYHZhbHVlYCBpcyBhIGhhc2ggLSBhIHBsYWluIG9iamVjdCBsaXRlcmFsLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgaGFzaCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmlzLmhhc2ggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIGlzLm9iamVjdCh2YWx1ZSkgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiAhdmFsdWUubm9kZVR5cGUgJiYgIXZhbHVlLnNldEludGVydmFsO1xufTtcblxuLyoqXG4gKiBUZXN0IHJlZ2V4cC5cbiAqL1xuXG4vKipcbiAqIGlzLnJlZ2V4cFxuICogVGVzdCBpZiBgdmFsdWVgIGlzIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBmYWxzZSBvdGhlcndpc2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuaXMucmVnZXhwID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0b1N0ci5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59O1xuXG4vKipcbiAqIFRlc3Qgc3RyaW5nLlxuICovXG5cbi8qKlxuICogaXMuc3RyaW5nXG4gKiBUZXN0IGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmICd2YWx1ZScgaXMgYSBzdHJpbmcsIGZhbHNlIG90aGVyd2lzZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5pcy5zdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHRvU3RyLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBTdHJpbmddJztcbn07XG5cbi8qKlxuICogVGVzdCBiYXNlNjQgc3RyaW5nLlxuICovXG5cbi8qKlxuICogaXMuYmFzZTY0XG4gKiBUZXN0IGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmICd2YWx1ZScgaXMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcsIGZhbHNlIG90aGVyd2lzZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5pcy5iYXNlNjQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIGlzLnN0cmluZyh2YWx1ZSkgJiYgKCF2YWx1ZS5sZW5ndGggfHwgYmFzZTY0UmVnZXgudGVzdCh2YWx1ZSkpO1xufTtcblxuLyoqXG4gKiBUZXN0IGJhc2U2NCBzdHJpbmcuXG4gKi9cblxuLyoqXG4gKiBpcy5oZXhcbiAqIFRlc3QgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGhleCBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgJ3ZhbHVlJyBpcyBhIGhleCBlbmNvZGVkIHN0cmluZywgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmlzLmhleCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gaXMuc3RyaW5nKHZhbHVlKSAmJiAoIXZhbHVlLmxlbmd0aCB8fCBoZXhSZWdleC50ZXN0KHZhbHVlKSk7XG59O1xuXG4vKipcbiAqIGlzLnN5bWJvbFxuICogVGVzdCBpZiBgdmFsdWVgIGlzIGFuIEVTNiBTeW1ib2xcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYHZhbHVlYCBpcyBhIFN5bWJvbCwgZmFsc2Ugb3RoZXJpc2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuaXMuc3ltYm9sID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHRvU3RyLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBTeW1ib2xdJyAmJiB0eXBlb2Ygc3ltYm9sVmFsdWVPZi5jYWxsKHZhbHVlKSA9PT0gJ3N5bWJvbCc7XG59O1xuXG4vKipcbiAqIGlzLmJpZ2ludFxuICogVGVzdCBpZiBgdmFsdWVgIGlzIGFuIEVTLXByb3Bvc2VkIEJpZ0ludFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgQmlnSW50LCBmYWxzZSBvdGhlcmlzZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5pcy5iaWdpbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHZhbGlkLXR5cGVvZlxuICByZXR1cm4gdHlwZW9mIEJpZ0ludCA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0ci5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQmlnSW50XScgJiYgdHlwZW9mIGJpZ0ludFZhbHVlT2YuY2FsbCh2YWx1ZSkgPT09ICdiaWdpbnQnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpcztcbiJdLCJuYW1lcyI6WyJvYmpQcm90byIsIk9iamVjdCIsInByb3RvdHlwZSIsIm93bnMiLCJoYXNPd25Qcm9wZXJ0eSIsInRvU3RyIiwidG9TdHJpbmciLCJzeW1ib2xWYWx1ZU9mIiwiU3ltYm9sIiwidmFsdWVPZiIsImJpZ0ludFZhbHVlT2YiLCJCaWdJbnQiLCJpc0FjdHVhbE5hTiIsInZhbHVlIiwiTk9OX0hPU1RfVFlQRVMiLCJudW1iZXIiLCJzdHJpbmciLCJ1bmRlZmluZWQiLCJiYXNlNjRSZWdleCIsImhleFJlZ2V4IiwiaXMiLCJhIiwidHlwZSIsImRlZmluZWQiLCJlbXB0eSIsImNhbGwiLCJrZXkiLCJsZW5ndGgiLCJlcXVhbCIsIm90aGVyIiwiZ2V0VGltZSIsImhvc3RlZCIsImhvc3QiLCJpbnN0YW5jZSIsImNvbnN0cnVjdG9yIiwibmlsIiwidW5kZWYiLCJhcmdzIiwiYXJndW1lbnRzIiwiaXNTdGFuZGFyZEFyZ3VtZW50cyIsImlzT2xkQXJndW1lbnRzIiwiYXJyYXkiLCJhcnJheWxpa2UiLCJvYmplY3QiLCJmbiIsImNhbGxlZSIsIkFycmF5IiwiaXNBcnJheSIsImJvb2wiLCJpc0Zpbml0ZSIsIkJvb2xlYW4iLCJOdW1iZXIiLCJkYXRlIiwidmFsaWQiLCJpc05hTiIsImVsZW1lbnQiLCJIVE1MRWxlbWVudCIsIm5vZGVUeXBlIiwiZXJyb3IiLCJpc0FsZXJ0Iiwid2luZG93IiwiYWxlcnQiLCJzdHIiLCJpbmZpbml0ZSIsIkluZmluaXR5IiwiZGVjaW1hbCIsImRpdmlzaWJsZUJ5IiwibiIsImlzRGl2aWRlbmRJbmZpbml0ZSIsImlzRGl2aXNvckluZmluaXRlIiwiaXNOb25aZXJvTnVtYmVyIiwiaW50ZWdlciIsIm1heGltdW0iLCJvdGhlcnMiLCJUeXBlRXJyb3IiLCJsZW4iLCJtaW5pbXVtIiwibmFuIiwiZXZlbiIsIm9kZCIsImdlIiwiZ3QiLCJsZSIsImx0Iiwid2l0aGluIiwic3RhcnQiLCJmaW5pc2giLCJpc0FueUluZmluaXRlIiwicHJpbWl0aXZlIiwiaXNQcmltaXRpdmUiLCJoYXNoIiwic2V0SW50ZXJ2YWwiLCJyZWdleHAiLCJiYXNlNjQiLCJ0ZXN0IiwiaGV4Iiwic3ltYm9sIiwiYmlnaW50IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/is/index.js\n");

/***/ })

};
;