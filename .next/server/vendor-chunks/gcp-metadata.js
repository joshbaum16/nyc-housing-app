"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/gcp-metadata";
exports.ids = ["vendor-chunks/gcp-metadata"];
exports.modules = {

/***/ "(rsc)/./node_modules/gcp-metadata/build/src/gcp-residency.js":
/*!**************************************************************!*\
  !*** ./node_modules/gcp-metadata/build/src/gcp-residency.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.GCE_LINUX_BIOS_PATHS = void 0;\nexports.isGoogleCloudServerless = isGoogleCloudServerless;\nexports.isGoogleComputeEngineLinux = isGoogleComputeEngineLinux;\nexports.isGoogleComputeEngineMACAddress = isGoogleComputeEngineMACAddress;\nexports.isGoogleComputeEngine = isGoogleComputeEngine;\nexports.detectGCPResidency = detectGCPResidency;\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst os_1 = __webpack_require__(/*! os */ \"os\");\n/**\n * Known paths unique to Google Compute Engine Linux instances\n */ exports.GCE_LINUX_BIOS_PATHS = {\n    BIOS_DATE: \"/sys/class/dmi/id/bios_date\",\n    BIOS_VENDOR: \"/sys/class/dmi/id/bios_vendor\"\n};\nconst GCE_MAC_ADDRESS_REGEX = /^42:01/;\n/**\n * Determines if the process is running on a Google Cloud Serverless environment (Cloud Run or Cloud Functions instance).\n *\n * Uses the:\n * - {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.\n * - {@link https://cloud.google.com/functions/docs/env-var Cloud Functions environment variables}.\n *\n * @returns {boolean} `true` if the process is running on GCP serverless, `false` otherwise.\n */ function isGoogleCloudServerless() {\n    /**\n     * `CLOUD_RUN_JOB` is used for Cloud Run Jobs\n     * - See {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.\n     *\n     * `FUNCTION_NAME` is used in older Cloud Functions environments:\n     * - See {@link https://cloud.google.com/functions/docs/env-var Python 3.7 and Go 1.11}.\n     *\n     * `K_SERVICE` is used in Cloud Run and newer Cloud Functions environments:\n     * - See {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.\n     * - See {@link https://cloud.google.com/functions/docs/env-var Cloud Functions newer runtimes}.\n     */ const isGFEnvironment = process.env.CLOUD_RUN_JOB || process.env.FUNCTION_NAME || process.env.K_SERVICE;\n    return !!isGFEnvironment;\n}\n/**\n * Determines if the process is running on a Linux Google Compute Engine instance.\n *\n * @returns {boolean} `true` if the process is running on Linux GCE, `false` otherwise.\n */ function isGoogleComputeEngineLinux() {\n    if ((0, os_1.platform)() !== \"linux\") return false;\n    try {\n        // ensure this file exist\n        (0, fs_1.statSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_DATE);\n        // ensure this file exist and matches\n        const biosVendor = (0, fs_1.readFileSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_VENDOR, \"utf8\");\n        return /Google/.test(biosVendor);\n    } catch (_a) {\n        return false;\n    }\n}\n/**\n * Determines if the process is running on a Google Compute Engine instance with a known\n * MAC address.\n *\n * @returns {boolean} `true` if the process is running on GCE (as determined by MAC address), `false` otherwise.\n */ function isGoogleComputeEngineMACAddress() {\n    const interfaces = (0, os_1.networkInterfaces)();\n    for (const item of Object.values(interfaces)){\n        if (!item) continue;\n        for (const { mac } of item){\n            if (GCE_MAC_ADDRESS_REGEX.test(mac)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n/**\n * Determines if the process is running on a Google Compute Engine instance.\n *\n * @returns {boolean} `true` if the process is running on GCE, `false` otherwise.\n */ function isGoogleComputeEngine() {\n    return isGoogleComputeEngineLinux() || isGoogleComputeEngineMACAddress();\n}\n/**\n * Determines if the process is running on Google Cloud Platform.\n *\n * @returns {boolean} `true` if the process is running on GCP, `false` otherwise.\n */ function detectGCPResidency() {\n    return isGoogleCloudServerless() || isGoogleComputeEngine();\n} //# sourceMappingURL=gcp-residency.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2NwLW1ldGFkYXRhL2J1aWxkL3NyYy9nY3AtcmVzaWRlbmN5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDRCQUE0QixHQUFHLEtBQUs7QUFDcENBLCtCQUErQixHQUFHRztBQUNsQ0gsa0NBQWtDLEdBQUdJO0FBQ3JDSix1Q0FBdUMsR0FBR0s7QUFDMUNMLDZCQUE2QixHQUFHTTtBQUNoQ04sMEJBQTBCLEdBQUdPO0FBQzdCLE1BQU1DLE9BQU9DLG1CQUFPQSxDQUFDLGNBQUk7QUFDekIsTUFBTUMsT0FBT0QsbUJBQU9BLENBQUMsY0FBSTtBQUN6Qjs7Q0FFQyxHQUNEVCw0QkFBNEIsR0FBRztJQUMzQlcsV0FBVztJQUNYQyxhQUFhO0FBQ2pCO0FBQ0EsTUFBTUMsd0JBQXdCO0FBQzlCOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU1Y7SUFDTDs7Ozs7Ozs7OztLQVVDLEdBQ0QsTUFBTVcsa0JBQWtCQyxRQUFRQyxHQUFHLENBQUNDLGFBQWEsSUFDN0NGLFFBQVFDLEdBQUcsQ0FBQ0UsYUFBYSxJQUN6QkgsUUFBUUMsR0FBRyxDQUFDRyxTQUFTO0lBQ3pCLE9BQU8sQ0FBQyxDQUFDTDtBQUNiO0FBQ0E7Ozs7Q0FJQyxHQUNELFNBQVNWO0lBQ0wsSUFBSSxDQUFDLEdBQUdNLEtBQUtVLFFBQVEsUUFBUSxTQUN6QixPQUFPO0lBQ1gsSUFBSTtRQUNBLHlCQUF5QjtRQUN4QixJQUFHWixLQUFLYSxRQUFRLEVBQUVyQixRQUFRRSxvQkFBb0IsQ0FBQ1MsU0FBUztRQUN6RCxxQ0FBcUM7UUFDckMsTUFBTVcsYUFBYSxDQUFDLEdBQUdkLEtBQUtlLFlBQVksRUFBRXZCLFFBQVFFLG9CQUFvQixDQUFDVSxXQUFXLEVBQUU7UUFDcEYsT0FBTyxTQUFTWSxJQUFJLENBQUNGO0lBQ3pCLEVBQ0EsT0FBT0csSUFBSTtRQUNQLE9BQU87SUFDWDtBQUNKO0FBQ0E7Ozs7O0NBS0MsR0FDRCxTQUFTcEI7SUFDTCxNQUFNcUIsYUFBYSxDQUFDLEdBQUdoQixLQUFLaUIsaUJBQWlCO0lBQzdDLEtBQUssTUFBTUMsUUFBUTlCLE9BQU8rQixNQUFNLENBQUNILFlBQWE7UUFDMUMsSUFBSSxDQUFDRSxNQUNEO1FBQ0osS0FBSyxNQUFNLEVBQUVFLEdBQUcsRUFBRSxJQUFJRixLQUFNO1lBQ3hCLElBQUlmLHNCQUFzQlcsSUFBSSxDQUFDTSxNQUFNO2dCQUNqQyxPQUFPO1lBQ1g7UUFDSjtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBQ0E7Ozs7Q0FJQyxHQUNELFNBQVN4QjtJQUNMLE9BQU9GLGdDQUFnQ0M7QUFDM0M7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU0U7SUFDTCxPQUFPSiw2QkFBNkJHO0FBQ3hDLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnljLWhvdXNpbmctYXBwLy4vbm9kZV9tb2R1bGVzL2djcC1tZXRhZGF0YS9idWlsZC9zcmMvZ2NwLXJlc2lkZW5jeS5qcz82MDFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5HQ0VfTElOVVhfQklPU19QQVRIUyA9IHZvaWQgMDtcbmV4cG9ydHMuaXNHb29nbGVDbG91ZFNlcnZlcmxlc3MgPSBpc0dvb2dsZUNsb3VkU2VydmVybGVzcztcbmV4cG9ydHMuaXNHb29nbGVDb21wdXRlRW5naW5lTGludXggPSBpc0dvb2dsZUNvbXB1dGVFbmdpbmVMaW51eDtcbmV4cG9ydHMuaXNHb29nbGVDb21wdXRlRW5naW5lTUFDQWRkcmVzcyA9IGlzR29vZ2xlQ29tcHV0ZUVuZ2luZU1BQ0FkZHJlc3M7XG5leHBvcnRzLmlzR29vZ2xlQ29tcHV0ZUVuZ2luZSA9IGlzR29vZ2xlQ29tcHV0ZUVuZ2luZTtcbmV4cG9ydHMuZGV0ZWN0R0NQUmVzaWRlbmN5ID0gZGV0ZWN0R0NQUmVzaWRlbmN5O1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IG9zXzEgPSByZXF1aXJlKFwib3NcIik7XG4vKipcbiAqIEtub3duIHBhdGhzIHVuaXF1ZSB0byBHb29nbGUgQ29tcHV0ZSBFbmdpbmUgTGludXggaW5zdGFuY2VzXG4gKi9cbmV4cG9ydHMuR0NFX0xJTlVYX0JJT1NfUEFUSFMgPSB7XG4gICAgQklPU19EQVRFOiAnL3N5cy9jbGFzcy9kbWkvaWQvYmlvc19kYXRlJyxcbiAgICBCSU9TX1ZFTkRPUjogJy9zeXMvY2xhc3MvZG1pL2lkL2Jpb3NfdmVuZG9yJyxcbn07XG5jb25zdCBHQ0VfTUFDX0FERFJFU1NfUkVHRVggPSAvXjQyOjAxLztcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIGEgR29vZ2xlIENsb3VkIFNlcnZlcmxlc3MgZW52aXJvbm1lbnQgKENsb3VkIFJ1biBvciBDbG91ZCBGdW5jdGlvbnMgaW5zdGFuY2UpLlxuICpcbiAqIFVzZXMgdGhlOlxuICogLSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL3J1bi9kb2NzL2NvbnRhaW5lci1jb250cmFjdCNlbnYtdmFycyBDbG91ZCBSdW4gZW52aXJvbm1lbnQgdmFyaWFibGVzfS5cbiAqIC0ge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9mdW5jdGlvbnMvZG9jcy9lbnYtdmFyIENsb3VkIEZ1bmN0aW9ucyBlbnZpcm9ubWVudCB2YXJpYWJsZXN9LlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByb2Nlc3MgaXMgcnVubmluZyBvbiBHQ1Agc2VydmVybGVzcywgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzR29vZ2xlQ2xvdWRTZXJ2ZXJsZXNzKCkge1xuICAgIC8qKlxuICAgICAqIGBDTE9VRF9SVU5fSk9CYCBpcyB1c2VkIGZvciBDbG91ZCBSdW4gSm9ic1xuICAgICAqIC0gU2VlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vcnVuL2RvY3MvY29udGFpbmVyLWNvbnRyYWN0I2Vudi12YXJzIENsb3VkIFJ1biBlbnZpcm9ubWVudCB2YXJpYWJsZXN9LlxuICAgICAqXG4gICAgICogYEZVTkNUSU9OX05BTUVgIGlzIHVzZWQgaW4gb2xkZXIgQ2xvdWQgRnVuY3Rpb25zIGVudmlyb25tZW50czpcbiAgICAgKiAtIFNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2Z1bmN0aW9ucy9kb2NzL2Vudi12YXIgUHl0aG9uIDMuNyBhbmQgR28gMS4xMX0uXG4gICAgICpcbiAgICAgKiBgS19TRVJWSUNFYCBpcyB1c2VkIGluIENsb3VkIFJ1biBhbmQgbmV3ZXIgQ2xvdWQgRnVuY3Rpb25zIGVudmlyb25tZW50czpcbiAgICAgKiAtIFNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL3J1bi9kb2NzL2NvbnRhaW5lci1jb250cmFjdCNlbnYtdmFycyBDbG91ZCBSdW4gZW52aXJvbm1lbnQgdmFyaWFibGVzfS5cbiAgICAgKiAtIFNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2Z1bmN0aW9ucy9kb2NzL2Vudi12YXIgQ2xvdWQgRnVuY3Rpb25zIG5ld2VyIHJ1bnRpbWVzfS5cbiAgICAgKi9cbiAgICBjb25zdCBpc0dGRW52aXJvbm1lbnQgPSBwcm9jZXNzLmVudi5DTE9VRF9SVU5fSk9CIHx8XG4gICAgICAgIHByb2Nlc3MuZW52LkZVTkNUSU9OX05BTUUgfHxcbiAgICAgICAgcHJvY2Vzcy5lbnYuS19TRVJWSUNFO1xuICAgIHJldHVybiAhIWlzR0ZFbnZpcm9ubWVudDtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIGEgTGludXggR29vZ2xlIENvbXB1dGUgRW5naW5lIGluc3RhbmNlLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByb2Nlc3MgaXMgcnVubmluZyBvbiBMaW51eCBHQ0UsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0dvb2dsZUNvbXB1dGVFbmdpbmVMaW51eCgpIHtcbiAgICBpZiAoKDAsIG9zXzEucGxhdGZvcm0pKCkgIT09ICdsaW51eCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBlbnN1cmUgdGhpcyBmaWxlIGV4aXN0XG4gICAgICAgICgwLCBmc18xLnN0YXRTeW5jKShleHBvcnRzLkdDRV9MSU5VWF9CSU9TX1BBVEhTLkJJT1NfREFURSk7XG4gICAgICAgIC8vIGVuc3VyZSB0aGlzIGZpbGUgZXhpc3QgYW5kIG1hdGNoZXNcbiAgICAgICAgY29uc3QgYmlvc1ZlbmRvciA9ICgwLCBmc18xLnJlYWRGaWxlU3luYykoZXhwb3J0cy5HQ0VfTElOVVhfQklPU19QQVRIUy5CSU9TX1ZFTkRPUiwgJ3V0ZjgnKTtcbiAgICAgICAgcmV0dXJuIC9Hb29nbGUvLnRlc3QoYmlvc1ZlbmRvcik7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gYSBHb29nbGUgQ29tcHV0ZSBFbmdpbmUgaW5zdGFuY2Ugd2l0aCBhIGtub3duXG4gKiBNQUMgYWRkcmVzcy5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gR0NFIChhcyBkZXRlcm1pbmVkIGJ5IE1BQyBhZGRyZXNzKSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzR29vZ2xlQ29tcHV0ZUVuZ2luZU1BQ0FkZHJlc3MoKSB7XG4gICAgY29uc3QgaW50ZXJmYWNlcyA9ICgwLCBvc18xLm5ldHdvcmtJbnRlcmZhY2VzKSgpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBPYmplY3QudmFsdWVzKGludGVyZmFjZXMpKSB7XG4gICAgICAgIGlmICghaXRlbSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbWFjIH0gb2YgaXRlbSkge1xuICAgICAgICAgICAgaWYgKEdDRV9NQUNfQUREUkVTU19SRUdFWC50ZXN0KG1hYykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHByb2Nlc3MgaXMgcnVubmluZyBvbiBhIEdvb2dsZSBDb21wdXRlIEVuZ2luZSBpbnN0YW5jZS5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gR0NFLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNHb29nbGVDb21wdXRlRW5naW5lKCkge1xuICAgIHJldHVybiBpc0dvb2dsZUNvbXB1dGVFbmdpbmVMaW51eCgpIHx8IGlzR29vZ2xlQ29tcHV0ZUVuZ2luZU1BQ0FkZHJlc3MoKTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIEdvb2dsZSBDbG91ZCBQbGF0Zm9ybS5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gR0NQLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0R0NQUmVzaWRlbmN5KCkge1xuICAgIHJldHVybiBpc0dvb2dsZUNsb3VkU2VydmVybGVzcygpIHx8IGlzR29vZ2xlQ29tcHV0ZUVuZ2luZSgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2NwLXJlc2lkZW5jeS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJHQ0VfTElOVVhfQklPU19QQVRIUyIsImlzR29vZ2xlQ2xvdWRTZXJ2ZXJsZXNzIiwiaXNHb29nbGVDb21wdXRlRW5naW5lTGludXgiLCJpc0dvb2dsZUNvbXB1dGVFbmdpbmVNQUNBZGRyZXNzIiwiaXNHb29nbGVDb21wdXRlRW5naW5lIiwiZGV0ZWN0R0NQUmVzaWRlbmN5IiwiZnNfMSIsInJlcXVpcmUiLCJvc18xIiwiQklPU19EQVRFIiwiQklPU19WRU5ET1IiLCJHQ0VfTUFDX0FERFJFU1NfUkVHRVgiLCJpc0dGRW52aXJvbm1lbnQiLCJwcm9jZXNzIiwiZW52IiwiQ0xPVURfUlVOX0pPQiIsIkZVTkNUSU9OX05BTUUiLCJLX1NFUlZJQ0UiLCJwbGF0Zm9ybSIsInN0YXRTeW5jIiwiYmlvc1ZlbmRvciIsInJlYWRGaWxlU3luYyIsInRlc3QiLCJfYSIsImludGVyZmFjZXMiLCJuZXR3b3JrSW50ZXJmYWNlcyIsIml0ZW0iLCJ2YWx1ZXMiLCJtYWMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gcp-metadata/build/src/gcp-residency.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/gcp-metadata/build/src/index.js":
/*!******************************************************!*\
  !*** ./node_modules/gcp-metadata/build/src/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.gcpResidencyCache = exports.METADATA_SERVER_DETECTION = exports.HEADERS = exports.HEADER_VALUE = exports.HEADER_NAME = exports.SECONDARY_HOST_ADDRESS = exports.HOST_ADDRESS = exports.BASE_PATH = void 0;\nexports.instance = instance;\nexports.project = project;\nexports.universe = universe;\nexports.bulk = bulk;\nexports.isAvailable = isAvailable;\nexports.resetIsAvailableCache = resetIsAvailableCache;\nexports.getGCPResidency = getGCPResidency;\nexports.setGCPResidency = setGCPResidency;\nexports.requestTimeout = requestTimeout;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nconst jsonBigint = __webpack_require__(/*! json-bigint */ \"(rsc)/./node_modules/json-bigint/index.js\");\nconst gcp_residency_1 = __webpack_require__(/*! ./gcp-residency */ \"(rsc)/./node_modules/gcp-metadata/build/src/gcp-residency.js\");\nconst logger = __webpack_require__(/*! google-logging-utils */ \"(rsc)/./node_modules/google-logging-utils/build/src/index.js\");\nexports.BASE_PATH = \"/computeMetadata/v1\";\nexports.HOST_ADDRESS = \"http://169.254.169.254\";\nexports.SECONDARY_HOST_ADDRESS = \"http://metadata.google.internal.\";\nexports.HEADER_NAME = \"Metadata-Flavor\";\nexports.HEADER_VALUE = \"Google\";\nexports.HEADERS = Object.freeze({\n    [exports.HEADER_NAME]: exports.HEADER_VALUE\n});\nconst log = logger.log(\"gcp metadata\");\n/**\n * Metadata server detection override options.\n *\n * Available via `process.env.METADATA_SERVER_DETECTION`.\n */ exports.METADATA_SERVER_DETECTION = Object.freeze({\n    \"assume-present\": \"don't try to ping the metadata server, but assume it's present\",\n    none: \"don't try to ping the metadata server, but don't try to use it either\",\n    \"bios-only\": \"treat the result of a BIOS probe as canonical (don't fall back to pinging)\",\n    \"ping-only\": \"skip the BIOS probe, and go straight to pinging\"\n});\n/**\n * Returns the base URL while taking into account the GCE_METADATA_HOST\n * environment variable if it exists.\n *\n * @returns The base URL, e.g., http://169.254.169.254/computeMetadata/v1.\n */ function getBaseUrl(baseUrl) {\n    if (!baseUrl) {\n        baseUrl = process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST || exports.HOST_ADDRESS;\n    }\n    // If no scheme is provided default to HTTP:\n    if (!/^https?:\\/\\//.test(baseUrl)) {\n        baseUrl = `http://${baseUrl}`;\n    }\n    return new URL(exports.BASE_PATH, baseUrl).href;\n}\n// Accepts an options object passed from the user to the API. In previous\n// versions of the API, it referred to a `Request` or an `Axios` request\n// options object.  Now it refers to an object with very limited property\n// names. This is here to help ensure users don't pass invalid options when\n// they  upgrade from 0.4 to 0.5 to 0.8.\nfunction validate(options) {\n    Object.keys(options).forEach((key)=>{\n        switch(key){\n            case \"params\":\n            case \"property\":\n            case \"headers\":\n                break;\n            case \"qs\":\n                throw new Error(\"'qs' is not a valid configuration option. Please use 'params' instead.\");\n            default:\n                throw new Error(`'${key}' is not a valid configuration option.`);\n        }\n    });\n}\nasync function metadataAccessor(type, options = {}, noResponseRetries = 3, fastFail = false) {\n    let metadataKey = \"\";\n    let params = {};\n    let headers = {};\n    if (typeof type === \"object\") {\n        const metadataAccessor = type;\n        metadataKey = metadataAccessor.metadataKey;\n        params = metadataAccessor.params || params;\n        headers = metadataAccessor.headers || headers;\n        noResponseRetries = metadataAccessor.noResponseRetries || noResponseRetries;\n        fastFail = metadataAccessor.fastFail || fastFail;\n    } else {\n        metadataKey = type;\n    }\n    if (typeof options === \"string\") {\n        metadataKey += `/${options}`;\n    } else {\n        validate(options);\n        if (options.property) {\n            metadataKey += `/${options.property}`;\n        }\n        headers = options.headers || headers;\n        params = options.params || params;\n    }\n    const requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1.request;\n    const req = {\n        url: `${getBaseUrl()}/${metadataKey}`,\n        headers: {\n            ...exports.HEADERS,\n            ...headers\n        },\n        retryConfig: {\n            noResponseRetries\n        },\n        params,\n        responseType: \"text\",\n        timeout: requestTimeout()\n    };\n    log.info(\"instance request %j\", req);\n    const res = await requestMethod(req);\n    log.info(\"instance metadata is %s\", res.data);\n    // NOTE: node.js converts all incoming headers to lower case.\n    if (res.headers[exports.HEADER_NAME.toLowerCase()] !== exports.HEADER_VALUE) {\n        throw new Error(`Invalid response from metadata service: incorrect ${exports.HEADER_NAME} header. Expected '${exports.HEADER_VALUE}', got ${res.headers[exports.HEADER_NAME.toLowerCase()] ? `'${res.headers[exports.HEADER_NAME.toLowerCase()]}'` : \"no header\"}`);\n    }\n    if (typeof res.data === \"string\") {\n        try {\n            return jsonBigint.parse(res.data);\n        } catch (_a) {\n        /* ignore */ }\n    }\n    return res.data;\n}\nasync function fastFailMetadataRequest(options) {\n    var _a;\n    const secondaryOptions = {\n        ...options,\n        url: (_a = options.url) === null || _a === void 0 ? void 0 : _a.toString().replace(getBaseUrl(), getBaseUrl(exports.SECONDARY_HOST_ADDRESS))\n    };\n    // We race a connection between DNS/IP to metadata server. There are a couple\n    // reasons for this:\n    //\n    // 1. the DNS is slow in some GCP environments; by checking both, we might\n    //    detect the runtime environment signficantly faster.\n    // 2. we can't just check the IP, which is tarpitted and slow to respond\n    //    on a user's local machine.\n    //\n    // Additional logic has been added to make sure that we don't create an\n    // unhandled rejection in scenarios where a failure happens sometime\n    // after a success.\n    //\n    // Note, however, if a failure happens prior to a success, a rejection should\n    // occur, this is for folks running locally.\n    //\n    let responded = false;\n    const r1 = (0, gaxios_1.request)(options).then((res)=>{\n        responded = true;\n        return res;\n    }).catch((err)=>{\n        if (responded) {\n            return r2;\n        } else {\n            responded = true;\n            throw err;\n        }\n    });\n    const r2 = (0, gaxios_1.request)(secondaryOptions).then((res)=>{\n        responded = true;\n        return res;\n    }).catch((err)=>{\n        if (responded) {\n            return r1;\n        } else {\n            responded = true;\n            throw err;\n        }\n    });\n    return Promise.race([\n        r1,\n        r2\n    ]);\n}\n/**\n * Obtain metadata for the current GCE instance.\n *\n * @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}\n *\n * @example\n * ```\n * const serviceAccount: {} = await instance('service-accounts/');\n * const serviceAccountEmail: string = await instance('service-accounts/default/email');\n * ```\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction instance(options) {\n    return metadataAccessor(\"instance\", options);\n}\n/**\n * Obtain metadata for the current GCP project.\n *\n * @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}\n *\n * @example\n * ```\n * const projectId: string = await project('project-id');\n * const numericProjectId: number = await project('numeric-project-id');\n * ```\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction project(options) {\n    return metadataAccessor(\"project\", options);\n}\n/**\n * Obtain metadata for the current universe.\n *\n * @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}\n *\n * @example\n * ```\n * const universeDomain: string = await universe('universe-domain');\n * ```\n */ function universe(options) {\n    return metadataAccessor(\"universe\", options);\n}\n/**\n * Retrieve metadata items in parallel.\n *\n * @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}\n *\n * @example\n * ```\n * const data = await bulk([\n *   {\n *     metadataKey: 'instance',\n *   },\n *   {\n *     metadataKey: 'project/project-id',\n *   },\n * ] as const);\n *\n * // data.instance;\n * // data['project/project-id'];\n * ```\n *\n * @param properties The metadata properties to retrieve\n * @returns The metadata in `metadatakey:value` format\n */ async function bulk(properties) {\n    const r = {};\n    await Promise.all(properties.map((item)=>{\n        return (async ()=>{\n            const res = await metadataAccessor(item);\n            const key = item.metadataKey;\n            r[key] = res;\n        })();\n    }));\n    return r;\n}\n/*\n * How many times should we retry detecting GCP environment.\n */ function detectGCPAvailableRetries() {\n    return process.env.DETECT_GCP_RETRIES ? Number(process.env.DETECT_GCP_RETRIES) : 0;\n}\nlet cachedIsAvailableResponse;\n/**\n * Determine if the metadata server is currently available.\n */ async function isAvailable() {\n    if (process.env.METADATA_SERVER_DETECTION) {\n        const value = process.env.METADATA_SERVER_DETECTION.trim().toLocaleLowerCase();\n        if (!(value in exports.METADATA_SERVER_DETECTION)) {\n            throw new RangeError(`Unknown \\`METADATA_SERVER_DETECTION\\` env variable. Got \\`${value}\\`, but it should be \\`${Object.keys(exports.METADATA_SERVER_DETECTION).join(\"`, `\")}\\`, or unset`);\n        }\n        switch(value){\n            case \"assume-present\":\n                return true;\n            case \"none\":\n                return false;\n            case \"bios-only\":\n                return getGCPResidency();\n            case \"ping-only\":\n        }\n    }\n    try {\n        // If a user is instantiating several GCP libraries at the same time,\n        // this may result in multiple calls to isAvailable(), to detect the\n        // runtime environment. We use the same promise for each of these calls\n        // to reduce the network load.\n        if (cachedIsAvailableResponse === undefined) {\n            cachedIsAvailableResponse = metadataAccessor(\"instance\", undefined, detectGCPAvailableRetries(), // If the default HOST_ADDRESS has been overridden, we should not\n            // make an effort to try SECONDARY_HOST_ADDRESS (as we are likely in\n            // a non-GCP environment):\n            !(process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST));\n        }\n        await cachedIsAvailableResponse;\n        return true;\n    } catch (e) {\n        const err = e;\n        if (process.env.DEBUG_AUTH) {\n            console.info(err);\n        }\n        if (err.type === \"request-timeout\") {\n            // If running in a GCP environment, metadata endpoint should return\n            // within ms.\n            return false;\n        }\n        if (err.response && err.response.status === 404) {\n            return false;\n        } else {\n            if (!(err.response && err.response.status === 404) && // A warning is emitted if we see an unexpected err.code, or err.code\n            // is not populated:\n            (!err.code || ![\n                \"EHOSTDOWN\",\n                \"EHOSTUNREACH\",\n                \"ENETUNREACH\",\n                \"ENOENT\",\n                \"ENOTFOUND\",\n                \"ECONNREFUSED\"\n            ].includes(err.code))) {\n                let code = \"UNKNOWN\";\n                if (err.code) code = err.code;\n                process.emitWarning(`received unexpected error = ${err.message} code = ${code}`, \"MetadataLookupWarning\");\n            }\n            // Failure to resolve the metadata service means that it is not available.\n            return false;\n        }\n    }\n}\n/**\n * reset the memoized isAvailable() lookup.\n */ function resetIsAvailableCache() {\n    cachedIsAvailableResponse = undefined;\n}\n/**\n * A cache for the detected GCP Residency.\n */ exports.gcpResidencyCache = null;\n/**\n * Detects GCP Residency.\n * Caches results to reduce costs for subsequent calls.\n *\n * @see setGCPResidency for setting\n */ function getGCPResidency() {\n    if (exports.gcpResidencyCache === null) {\n        setGCPResidency();\n    }\n    return exports.gcpResidencyCache;\n}\n/**\n * Sets the detected GCP Residency.\n * Useful for forcing metadata server detection behavior.\n *\n * Set `null` to autodetect the environment (default behavior).\n * @see getGCPResidency for getting\n */ function setGCPResidency(value = null) {\n    exports.gcpResidencyCache = value !== null ? value : (0, gcp_residency_1.detectGCPResidency)();\n}\n/**\n * Obtain the timeout for requests to the metadata server.\n *\n * In certain environments and conditions requests can take longer than\n * the default timeout to complete. This function will determine the\n * appropriate timeout based on the environment.\n *\n * @returns {number} a request timeout duration in milliseconds.\n */ function requestTimeout() {\n    return getGCPResidency() ? 0 : 3000;\n}\n__exportStar(__webpack_require__(/*! ./gcp-residency */ \"(rsc)/./node_modules/gcp-metadata/build/src/gcp-residency.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2NwLW1ldGFkYXRhL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ0QsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPUCxPQUFPUSx3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBSixPQUFPYyxjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0wsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSVcsZUFBZSxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLFlBQVksSUFBSyxTQUFTWixDQUFDLEVBQUVhLFFBQU87SUFDakUsSUFBSyxJQUFJQyxLQUFLZCxFQUFHLElBQUljLE1BQU0sYUFBYSxDQUFDakIsT0FBT2tCLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFVBQVNDLElBQUlsQixnQkFBZ0JpQixVQUFTYixHQUFHYztBQUMzSDtBQUNBakIsOENBQTZDO0lBQUVxQixPQUFPO0FBQUssQ0FBQyxFQUFDO0FB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Q0MsUUFBUSxDQUFDdkIsSUFBSXNCLElBQUksSUFBSTtnQkFDM0IsSUFBSUEsT0FBTztnQkFDWCxJQUFJdEIsSUFBSXNCLElBQUksRUFDUkEsT0FBT3RCLElBQUlzQixJQUFJO2dCQUNuQmhFLFFBQVFrRSxXQUFXLENBQUMsQ0FBQyw0QkFBNEIsRUFBRXhCLElBQUl5QixPQUFPLENBQUMsUUFBUSxFQUFFSCxLQUFLLENBQUMsRUFBRTtZQUNyRjtZQUNBLDBFQUEwRTtZQUMxRSxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxTQUFTOUU7SUFDTG9FLDRCQUE0QmpHO0FBQ2hDO0FBQ0E7O0NBRUMsR0FDRFUseUJBQXlCLEdBQUc7QUFDNUI7Ozs7O0NBS0MsR0FDRCxTQUFTb0I7SUFDTCxJQUFJcEIsUUFBUU0saUJBQWlCLEtBQUssTUFBTTtRQUNwQ2U7SUFDSjtJQUNBLE9BQU9yQixRQUFRTSxpQkFBaUI7QUFDcEM7QUFDQTs7Ozs7O0NBTUMsR0FDRCxTQUFTZSxnQkFBZ0JoQixRQUFRLElBQUk7SUFDakNMLHlCQUF5QixHQUFHSyxVQUFVLE9BQU9BLFFBQVEsQ0FBQyxHQUFHcUIsZ0JBQWdCMkUsa0JBQWtCO0FBQy9GO0FBQ0E7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTL0U7SUFDTCxPQUFPRixvQkFBb0IsSUFBSTtBQUNuQztBQUNBckIsYUFBYXlCLG1CQUFPQSxDQUFDLHFGQUFpQixHQUFHeEIsVUFDekMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnljLWhvdXNpbmctYXBwLy4vbm9kZV9tb2R1bGVzL2djcC1tZXRhZGF0YS9idWlsZC9zcmMvaW5kZXguanM/ZjE1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nY3BSZXNpZGVuY3lDYWNoZSA9IGV4cG9ydHMuTUVUQURBVEFfU0VSVkVSX0RFVEVDVElPTiA9IGV4cG9ydHMuSEVBREVSUyA9IGV4cG9ydHMuSEVBREVSX1ZBTFVFID0gZXhwb3J0cy5IRUFERVJfTkFNRSA9IGV4cG9ydHMuU0VDT05EQVJZX0hPU1RfQUREUkVTUyA9IGV4cG9ydHMuSE9TVF9BRERSRVNTID0gZXhwb3J0cy5CQVNFX1BBVEggPSB2b2lkIDA7XG5leHBvcnRzLmluc3RhbmNlID0gaW5zdGFuY2U7XG5leHBvcnRzLnByb2plY3QgPSBwcm9qZWN0O1xuZXhwb3J0cy51bml2ZXJzZSA9IHVuaXZlcnNlO1xuZXhwb3J0cy5idWxrID0gYnVsaztcbmV4cG9ydHMuaXNBdmFpbGFibGUgPSBpc0F2YWlsYWJsZTtcbmV4cG9ydHMucmVzZXRJc0F2YWlsYWJsZUNhY2hlID0gcmVzZXRJc0F2YWlsYWJsZUNhY2hlO1xuZXhwb3J0cy5nZXRHQ1BSZXNpZGVuY3kgPSBnZXRHQ1BSZXNpZGVuY3k7XG5leHBvcnRzLnNldEdDUFJlc2lkZW5jeSA9IHNldEdDUFJlc2lkZW5jeTtcbmV4cG9ydHMucmVxdWVzdFRpbWVvdXQgPSByZXF1ZXN0VGltZW91dDtcbmNvbnN0IGdheGlvc18xID0gcmVxdWlyZShcImdheGlvc1wiKTtcbmNvbnN0IGpzb25CaWdpbnQgPSByZXF1aXJlKFwianNvbi1iaWdpbnRcIik7XG5jb25zdCBnY3BfcmVzaWRlbmN5XzEgPSByZXF1aXJlKFwiLi9nY3AtcmVzaWRlbmN5XCIpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZShcImdvb2dsZS1sb2dnaW5nLXV0aWxzXCIpO1xuZXhwb3J0cy5CQVNFX1BBVEggPSAnL2NvbXB1dGVNZXRhZGF0YS92MSc7XG5leHBvcnRzLkhPU1RfQUREUkVTUyA9ICdodHRwOi8vMTY5LjI1NC4xNjkuMjU0JztcbmV4cG9ydHMuU0VDT05EQVJZX0hPU1RfQUREUkVTUyA9ICdodHRwOi8vbWV0YWRhdGEuZ29vZ2xlLmludGVybmFsLic7XG5leHBvcnRzLkhFQURFUl9OQU1FID0gJ01ldGFkYXRhLUZsYXZvcic7XG5leHBvcnRzLkhFQURFUl9WQUxVRSA9ICdHb29nbGUnO1xuZXhwb3J0cy5IRUFERVJTID0gT2JqZWN0LmZyZWV6ZSh7IFtleHBvcnRzLkhFQURFUl9OQU1FXTogZXhwb3J0cy5IRUFERVJfVkFMVUUgfSk7XG5jb25zdCBsb2cgPSBsb2dnZXIubG9nKCdnY3AgbWV0YWRhdGEnKTtcbi8qKlxuICogTWV0YWRhdGEgc2VydmVyIGRldGVjdGlvbiBvdmVycmlkZSBvcHRpb25zLlxuICpcbiAqIEF2YWlsYWJsZSB2aWEgYHByb2Nlc3MuZW52Lk1FVEFEQVRBX1NFUlZFUl9ERVRFQ1RJT05gLlxuICovXG5leHBvcnRzLk1FVEFEQVRBX1NFUlZFUl9ERVRFQ1RJT04gPSBPYmplY3QuZnJlZXplKHtcbiAgICAnYXNzdW1lLXByZXNlbnQnOiBcImRvbid0IHRyeSB0byBwaW5nIHRoZSBtZXRhZGF0YSBzZXJ2ZXIsIGJ1dCBhc3N1bWUgaXQncyBwcmVzZW50XCIsXG4gICAgbm9uZTogXCJkb24ndCB0cnkgdG8gcGluZyB0aGUgbWV0YWRhdGEgc2VydmVyLCBidXQgZG9uJ3QgdHJ5IHRvIHVzZSBpdCBlaXRoZXJcIixcbiAgICAnYmlvcy1vbmx5JzogXCJ0cmVhdCB0aGUgcmVzdWx0IG9mIGEgQklPUyBwcm9iZSBhcyBjYW5vbmljYWwgKGRvbid0IGZhbGwgYmFjayB0byBwaW5naW5nKVwiLFxuICAgICdwaW5nLW9ubHknOiAnc2tpcCB0aGUgQklPUyBwcm9iZSwgYW5kIGdvIHN0cmFpZ2h0IHRvIHBpbmdpbmcnLFxufSk7XG4vKipcbiAqIFJldHVybnMgdGhlIGJhc2UgVVJMIHdoaWxlIHRha2luZyBpbnRvIGFjY291bnQgdGhlIEdDRV9NRVRBREFUQV9IT1NUXG4gKiBlbnZpcm9ubWVudCB2YXJpYWJsZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHJldHVybnMgVGhlIGJhc2UgVVJMLCBlLmcuLCBodHRwOi8vMTY5LjI1NC4xNjkuMjU0L2NvbXB1dGVNZXRhZGF0YS92MS5cbiAqL1xuZnVuY3Rpb24gZ2V0QmFzZVVybChiYXNlVXJsKSB7XG4gICAgaWYgKCFiYXNlVXJsKSB7XG4gICAgICAgIGJhc2VVcmwgPVxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuR0NFX01FVEFEQVRBX0lQIHx8XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuR0NFX01FVEFEQVRBX0hPU1QgfHxcbiAgICAgICAgICAgICAgICBleHBvcnRzLkhPU1RfQUREUkVTUztcbiAgICB9XG4gICAgLy8gSWYgbm8gc2NoZW1lIGlzIHByb3ZpZGVkIGRlZmF1bHQgdG8gSFRUUDpcbiAgICBpZiAoIS9eaHR0cHM/OlxcL1xcLy8udGVzdChiYXNlVXJsKSkge1xuICAgICAgICBiYXNlVXJsID0gYGh0dHA6Ly8ke2Jhc2VVcmx9YDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVUkwoZXhwb3J0cy5CQVNFX1BBVEgsIGJhc2VVcmwpLmhyZWY7XG59XG4vLyBBY2NlcHRzIGFuIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCBmcm9tIHRoZSB1c2VyIHRvIHRoZSBBUEkuIEluIHByZXZpb3VzXG4vLyB2ZXJzaW9ucyBvZiB0aGUgQVBJLCBpdCByZWZlcnJlZCB0byBhIGBSZXF1ZXN0YCBvciBhbiBgQXhpb3NgIHJlcXVlc3Rcbi8vIG9wdGlvbnMgb2JqZWN0LiAgTm93IGl0IHJlZmVycyB0byBhbiBvYmplY3Qgd2l0aCB2ZXJ5IGxpbWl0ZWQgcHJvcGVydHlcbi8vIG5hbWVzLiBUaGlzIGlzIGhlcmUgdG8gaGVscCBlbnN1cmUgdXNlcnMgZG9uJ3QgcGFzcyBpbnZhbGlkIG9wdGlvbnMgd2hlblxuLy8gdGhleSAgdXBncmFkZSBmcm9tIDAuNCB0byAwLjUgdG8gMC44LlxuZnVuY3Rpb24gdmFsaWRhdGUob3B0aW9ucykge1xuICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3BhcmFtcyc6XG4gICAgICAgICAgICBjYXNlICdwcm9wZXJ0eSc6XG4gICAgICAgICAgICBjYXNlICdoZWFkZXJzJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3FzJzpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIncXMnIGlzIG5vdCBhIHZhbGlkIGNvbmZpZ3VyYXRpb24gb3B0aW9uLiBQbGVhc2UgdXNlICdwYXJhbXMnIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCcke2tleX0nIGlzIG5vdCBhIHZhbGlkIGNvbmZpZ3VyYXRpb24gb3B0aW9uLmApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBtZXRhZGF0YUFjY2Vzc29yKHR5cGUsIG9wdGlvbnMgPSB7fSwgbm9SZXNwb25zZVJldHJpZXMgPSAzLCBmYXN0RmFpbCA9IGZhbHNlKSB7XG4gICAgbGV0IG1ldGFkYXRhS2V5ID0gJyc7XG4gICAgbGV0IHBhcmFtcyA9IHt9O1xuICAgIGxldCBoZWFkZXJzID0ge307XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBtZXRhZGF0YUFjY2Vzc29yID0gdHlwZTtcbiAgICAgICAgbWV0YWRhdGFLZXkgPSBtZXRhZGF0YUFjY2Vzc29yLm1ldGFkYXRhS2V5O1xuICAgICAgICBwYXJhbXMgPSBtZXRhZGF0YUFjY2Vzc29yLnBhcmFtcyB8fCBwYXJhbXM7XG4gICAgICAgIGhlYWRlcnMgPSBtZXRhZGF0YUFjY2Vzc29yLmhlYWRlcnMgfHwgaGVhZGVycztcbiAgICAgICAgbm9SZXNwb25zZVJldHJpZXMgPSBtZXRhZGF0YUFjY2Vzc29yLm5vUmVzcG9uc2VSZXRyaWVzIHx8IG5vUmVzcG9uc2VSZXRyaWVzO1xuICAgICAgICBmYXN0RmFpbCA9IG1ldGFkYXRhQWNjZXNzb3IuZmFzdEZhaWwgfHwgZmFzdEZhaWw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtZXRhZGF0YUtleSA9IHR5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWV0YWRhdGFLZXkgKz0gYC8ke29wdGlvbnN9YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhbGlkYXRlKG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgbWV0YWRhdGFLZXkgKz0gYC8ke29wdGlvbnMucHJvcGVydHl9YDtcbiAgICAgICAgfVxuICAgICAgICBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IGhlYWRlcnM7XG4gICAgICAgIHBhcmFtcyA9IG9wdGlvbnMucGFyYW1zIHx8IHBhcmFtcztcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdE1ldGhvZCA9IGZhc3RGYWlsID8gZmFzdEZhaWxNZXRhZGF0YVJlcXVlc3QgOiBnYXhpb3NfMS5yZXF1ZXN0O1xuICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgICAgdXJsOiBgJHtnZXRCYXNlVXJsKCl9LyR7bWV0YWRhdGFLZXl9YCxcbiAgICAgICAgaGVhZGVyczogeyAuLi5leHBvcnRzLkhFQURFUlMsIC4uLmhlYWRlcnMgfSxcbiAgICAgICAgcmV0cnlDb25maWc6IHsgbm9SZXNwb25zZVJldHJpZXMgfSxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgICAgdGltZW91dDogcmVxdWVzdFRpbWVvdXQoKSxcbiAgICB9O1xuICAgIGxvZy5pbmZvKCdpbnN0YW5jZSByZXF1ZXN0ICVqJywgcmVxKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0TWV0aG9kKHJlcSk7XG4gICAgbG9nLmluZm8oJ2luc3RhbmNlIG1ldGFkYXRhIGlzICVzJywgcmVzLmRhdGEpO1xuICAgIC8vIE5PVEU6IG5vZGUuanMgY29udmVydHMgYWxsIGluY29taW5nIGhlYWRlcnMgdG8gbG93ZXIgY2FzZS5cbiAgICBpZiAocmVzLmhlYWRlcnNbZXhwb3J0cy5IRUFERVJfTkFNRS50b0xvd2VyQ2FzZSgpXSAhPT0gZXhwb3J0cy5IRUFERVJfVkFMVUUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIGZyb20gbWV0YWRhdGEgc2VydmljZTogaW5jb3JyZWN0ICR7ZXhwb3J0cy5IRUFERVJfTkFNRX0gaGVhZGVyLiBFeHBlY3RlZCAnJHtleHBvcnRzLkhFQURFUl9WQUxVRX0nLCBnb3QgJHtyZXMuaGVhZGVyc1tleHBvcnRzLkhFQURFUl9OQU1FLnRvTG93ZXJDYXNlKCldID8gYCcke3Jlcy5oZWFkZXJzW2V4cG9ydHMuSEVBREVSX05BTUUudG9Mb3dlckNhc2UoKV19J2AgOiAnbm8gaGVhZGVyJ31gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXMuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBqc29uQmlnaW50LnBhcnNlKHJlcy5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIC8qIGlnbm9yZSAqL1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXMuZGF0YTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZhc3RGYWlsTWV0YWRhdGFSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgc2Vjb25kYXJ5T3B0aW9ucyA9IHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgdXJsOiAoX2EgPSBvcHRpb25zLnVybCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvU3RyaW5nKCkucmVwbGFjZShnZXRCYXNlVXJsKCksIGdldEJhc2VVcmwoZXhwb3J0cy5TRUNPTkRBUllfSE9TVF9BRERSRVNTKSksXG4gICAgfTtcbiAgICAvLyBXZSByYWNlIGEgY29ubmVjdGlvbiBiZXR3ZWVuIEROUy9JUCB0byBtZXRhZGF0YSBzZXJ2ZXIuIFRoZXJlIGFyZSBhIGNvdXBsZVxuICAgIC8vIHJlYXNvbnMgZm9yIHRoaXM6XG4gICAgLy9cbiAgICAvLyAxLiB0aGUgRE5TIGlzIHNsb3cgaW4gc29tZSBHQ1AgZW52aXJvbm1lbnRzOyBieSBjaGVja2luZyBib3RoLCB3ZSBtaWdodFxuICAgIC8vICAgIGRldGVjdCB0aGUgcnVudGltZSBlbnZpcm9ubWVudCBzaWduZmljYW50bHkgZmFzdGVyLlxuICAgIC8vIDIuIHdlIGNhbid0IGp1c3QgY2hlY2sgdGhlIElQLCB3aGljaCBpcyB0YXJwaXR0ZWQgYW5kIHNsb3cgdG8gcmVzcG9uZFxuICAgIC8vICAgIG9uIGEgdXNlcidzIGxvY2FsIG1hY2hpbmUuXG4gICAgLy9cbiAgICAvLyBBZGRpdGlvbmFsIGxvZ2ljIGhhcyBiZWVuIGFkZGVkIHRvIG1ha2Ugc3VyZSB0aGF0IHdlIGRvbid0IGNyZWF0ZSBhblxuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb24gaW4gc2NlbmFyaW9zIHdoZXJlIGEgZmFpbHVyZSBoYXBwZW5zIHNvbWV0aW1lXG4gICAgLy8gYWZ0ZXIgYSBzdWNjZXNzLlxuICAgIC8vXG4gICAgLy8gTm90ZSwgaG93ZXZlciwgaWYgYSBmYWlsdXJlIGhhcHBlbnMgcHJpb3IgdG8gYSBzdWNjZXNzLCBhIHJlamVjdGlvbiBzaG91bGRcbiAgICAvLyBvY2N1ciwgdGhpcyBpcyBmb3IgZm9sa3MgcnVubmluZyBsb2NhbGx5LlxuICAgIC8vXG4gICAgbGV0IHJlc3BvbmRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHIxID0gKDAsIGdheGlvc18xLnJlcXVlc3QpKG9wdGlvbnMpXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgIHJlc3BvbmRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlmIChyZXNwb25kZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3BvbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCByMiA9ICgwLCBnYXhpb3NfMS5yZXF1ZXN0KShzZWNvbmRhcnlPcHRpb25zKVxuICAgICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICByZXNwb25kZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICBpZiAocmVzcG9uZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcjE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNwb25kZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbcjEsIHIyXSk7XG59XG4vKipcbiAqIE9idGFpbiBtZXRhZGF0YSBmb3IgdGhlIGN1cnJlbnQgR0NFIGluc3RhbmNlLlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9jb21wdXRlL2RvY3MvbWV0YWRhdGEvcHJlZGVmaW5lZC1tZXRhZGF0YS1rZXlzfVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIGNvbnN0IHNlcnZpY2VBY2NvdW50OiB7fSA9IGF3YWl0IGluc3RhbmNlKCdzZXJ2aWNlLWFjY291bnRzLycpO1xuICogY29uc3Qgc2VydmljZUFjY291bnRFbWFpbDogc3RyaW5nID0gYXdhaXQgaW5zdGFuY2UoJ3NlcnZpY2UtYWNjb3VudHMvZGVmYXVsdC9lbWFpbCcpO1xuICogYGBgXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBpbnN0YW5jZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG1ldGFkYXRhQWNjZXNzb3IoJ2luc3RhbmNlJywgb3B0aW9ucyk7XG59XG4vKipcbiAqIE9idGFpbiBtZXRhZGF0YSBmb3IgdGhlIGN1cnJlbnQgR0NQIHByb2plY3QuXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2NvbXB1dGUvZG9jcy9tZXRhZGF0YS9wcmVkZWZpbmVkLW1ldGFkYXRhLWtleXN9XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogY29uc3QgcHJvamVjdElkOiBzdHJpbmcgPSBhd2FpdCBwcm9qZWN0KCdwcm9qZWN0LWlkJyk7XG4gKiBjb25zdCBudW1lcmljUHJvamVjdElkOiBudW1iZXIgPSBhd2FpdCBwcm9qZWN0KCdudW1lcmljLXByb2plY3QtaWQnKTtcbiAqIGBgYFxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gcHJvamVjdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG1ldGFkYXRhQWNjZXNzb3IoJ3Byb2plY3QnLCBvcHRpb25zKTtcbn1cbi8qKlxuICogT2J0YWluIG1ldGFkYXRhIGZvciB0aGUgY3VycmVudCB1bml2ZXJzZS5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vY29tcHV0ZS9kb2NzL21ldGFkYXRhL3ByZWRlZmluZWQtbWV0YWRhdGEta2V5c31cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBjb25zdCB1bml2ZXJzZURvbWFpbjogc3RyaW5nID0gYXdhaXQgdW5pdmVyc2UoJ3VuaXZlcnNlLWRvbWFpbicpO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHVuaXZlcnNlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbWV0YWRhdGFBY2Nlc3NvcigndW5pdmVyc2UnLCBvcHRpb25zKTtcbn1cbi8qKlxuICogUmV0cmlldmUgbWV0YWRhdGEgaXRlbXMgaW4gcGFyYWxsZWwuXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2NvbXB1dGUvZG9jcy9tZXRhZGF0YS9wcmVkZWZpbmVkLW1ldGFkYXRhLWtleXN9XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogY29uc3QgZGF0YSA9IGF3YWl0IGJ1bGsoW1xuICogICB7XG4gKiAgICAgbWV0YWRhdGFLZXk6ICdpbnN0YW5jZScsXG4gKiAgIH0sXG4gKiAgIHtcbiAqICAgICBtZXRhZGF0YUtleTogJ3Byb2plY3QvcHJvamVjdC1pZCcsXG4gKiAgIH0sXG4gKiBdIGFzIGNvbnN0KTtcbiAqXG4gKiAvLyBkYXRhLmluc3RhbmNlO1xuICogLy8gZGF0YVsncHJvamVjdC9wcm9qZWN0LWlkJ107XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHJvcGVydGllcyBUaGUgbWV0YWRhdGEgcHJvcGVydGllcyB0byByZXRyaWV2ZVxuICogQHJldHVybnMgVGhlIG1ldGFkYXRhIGluIGBtZXRhZGF0YWtleTp2YWx1ZWAgZm9ybWF0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGJ1bGsocHJvcGVydGllcykge1xuICAgIGNvbnN0IHIgPSB7fTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9wZXJ0aWVzLm1hcChpdGVtID0+IHtcbiAgICAgICAgcmV0dXJuIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBtZXRhZGF0YUFjY2Vzc29yKGl0ZW0pO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gaXRlbS5tZXRhZGF0YUtleTtcbiAgICAgICAgICAgIHJba2V5XSA9IHJlcztcbiAgICAgICAgfSkoKTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIHI7XG59XG4vKlxuICogSG93IG1hbnkgdGltZXMgc2hvdWxkIHdlIHJldHJ5IGRldGVjdGluZyBHQ1AgZW52aXJvbm1lbnQuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdEdDUEF2YWlsYWJsZVJldHJpZXMoKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LkRFVEVDVF9HQ1BfUkVUUklFU1xuICAgICAgICA/IE51bWJlcihwcm9jZXNzLmVudi5ERVRFQ1RfR0NQX1JFVFJJRVMpXG4gICAgICAgIDogMDtcbn1cbmxldCBjYWNoZWRJc0F2YWlsYWJsZVJlc3BvbnNlO1xuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIG1ldGFkYXRhIHNlcnZlciBpcyBjdXJyZW50bHkgYXZhaWxhYmxlLlxuICovXG5hc3luYyBmdW5jdGlvbiBpc0F2YWlsYWJsZSgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTUVUQURBVEFfU0VSVkVSX0RFVEVDVElPTikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHByb2Nlc3MuZW52Lk1FVEFEQVRBX1NFUlZFUl9ERVRFQ1RJT04udHJpbSgpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghKHZhbHVlIGluIGV4cG9ydHMuTUVUQURBVEFfU0VSVkVSX0RFVEVDVElPTikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbmtub3duIFxcYE1FVEFEQVRBX1NFUlZFUl9ERVRFQ1RJT05cXGAgZW52IHZhcmlhYmxlLiBHb3QgXFxgJHt2YWx1ZX1cXGAsIGJ1dCBpdCBzaG91bGQgYmUgXFxgJHtPYmplY3Qua2V5cyhleHBvcnRzLk1FVEFEQVRBX1NFUlZFUl9ERVRFQ1RJT04pLmpvaW4oJ2AsIGAnKX1cXGAsIG9yIHVuc2V0YCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnYXNzdW1lLXByZXNlbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSAnYmlvcy1vbmx5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0R0NQUmVzaWRlbmN5KCk7XG4gICAgICAgICAgICBjYXNlICdwaW5nLW9ubHknOlxuICAgICAgICAgICAgLy8gY29udGludWUsIHdlIHdhbnQgdG8gcGluZyB0aGUgc2VydmVyXG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gSWYgYSB1c2VyIGlzIGluc3RhbnRpYXRpbmcgc2V2ZXJhbCBHQ1AgbGlicmFyaWVzIGF0IHRoZSBzYW1lIHRpbWUsXG4gICAgICAgIC8vIHRoaXMgbWF5IHJlc3VsdCBpbiBtdWx0aXBsZSBjYWxscyB0byBpc0F2YWlsYWJsZSgpLCB0byBkZXRlY3QgdGhlXG4gICAgICAgIC8vIHJ1bnRpbWUgZW52aXJvbm1lbnQuIFdlIHVzZSB0aGUgc2FtZSBwcm9taXNlIGZvciBlYWNoIG9mIHRoZXNlIGNhbGxzXG4gICAgICAgIC8vIHRvIHJlZHVjZSB0aGUgbmV0d29yayBsb2FkLlxuICAgICAgICBpZiAoY2FjaGVkSXNBdmFpbGFibGVSZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYWNoZWRJc0F2YWlsYWJsZVJlc3BvbnNlID0gbWV0YWRhdGFBY2Nlc3NvcignaW5zdGFuY2UnLCB1bmRlZmluZWQsIGRldGVjdEdDUEF2YWlsYWJsZVJldHJpZXMoKSwgXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVmYXVsdCBIT1NUX0FERFJFU1MgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgd2Ugc2hvdWxkIG5vdFxuICAgICAgICAgICAgLy8gbWFrZSBhbiBlZmZvcnQgdG8gdHJ5IFNFQ09OREFSWV9IT1NUX0FERFJFU1MgKGFzIHdlIGFyZSBsaWtlbHkgaW5cbiAgICAgICAgICAgIC8vIGEgbm9uLUdDUCBlbnZpcm9ubWVudCk6XG4gICAgICAgICAgICAhKHByb2Nlc3MuZW52LkdDRV9NRVRBREFUQV9JUCB8fCBwcm9jZXNzLmVudi5HQ0VfTUVUQURBVEFfSE9TVCkpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGNhY2hlZElzQXZhaWxhYmxlUmVzcG9uc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBlcnIgPSBlO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuREVCVUdfQVVUSCkge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyci50eXBlID09PSAncmVxdWVzdC10aW1lb3V0Jykge1xuICAgICAgICAgICAgLy8gSWYgcnVubmluZyBpbiBhIEdDUCBlbnZpcm9ubWVudCwgbWV0YWRhdGEgZW5kcG9pbnQgc2hvdWxkIHJldHVyblxuICAgICAgICAgICAgLy8gd2l0aGluIG1zLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIucmVzcG9uc2UgJiYgZXJyLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIShlcnIucmVzcG9uc2UgJiYgZXJyLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSAmJlxuICAgICAgICAgICAgICAgIC8vIEEgd2FybmluZyBpcyBlbWl0dGVkIGlmIHdlIHNlZSBhbiB1bmV4cGVjdGVkIGVyci5jb2RlLCBvciBlcnIuY29kZVxuICAgICAgICAgICAgICAgIC8vIGlzIG5vdCBwb3B1bGF0ZWQ6XG4gICAgICAgICAgICAgICAgKCFlcnIuY29kZSB8fFxuICAgICAgICAgICAgICAgICAgICAhW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0VIT1NURE9XTicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRUhPU1RVTlJFQUNIJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFTkVUVU5SRUFDSCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU5PRU5UJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFTk9URk9VTkQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VDT05OUkVGVVNFRCcsXG4gICAgICAgICAgICAgICAgICAgIF0uaW5jbHVkZXMoZXJyLmNvZGUpKSkge1xuICAgICAgICAgICAgICAgIGxldCBjb2RlID0gJ1VOS05PV04nO1xuICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSlcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IGVyci5jb2RlO1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoYHJlY2VpdmVkIHVuZXhwZWN0ZWQgZXJyb3IgPSAke2Vyci5tZXNzYWdlfSBjb2RlID0gJHtjb2RlfWAsICdNZXRhZGF0YUxvb2t1cFdhcm5pbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZhaWx1cmUgdG8gcmVzb2x2ZSB0aGUgbWV0YWRhdGEgc2VydmljZSBtZWFucyB0aGF0IGl0IGlzIG5vdCBhdmFpbGFibGUuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIHJlc2V0IHRoZSBtZW1vaXplZCBpc0F2YWlsYWJsZSgpIGxvb2t1cC5cbiAqL1xuZnVuY3Rpb24gcmVzZXRJc0F2YWlsYWJsZUNhY2hlKCkge1xuICAgIGNhY2hlZElzQXZhaWxhYmxlUmVzcG9uc2UgPSB1bmRlZmluZWQ7XG59XG4vKipcbiAqIEEgY2FjaGUgZm9yIHRoZSBkZXRlY3RlZCBHQ1AgUmVzaWRlbmN5LlxuICovXG5leHBvcnRzLmdjcFJlc2lkZW5jeUNhY2hlID0gbnVsbDtcbi8qKlxuICogRGV0ZWN0cyBHQ1AgUmVzaWRlbmN5LlxuICogQ2FjaGVzIHJlc3VsdHMgdG8gcmVkdWNlIGNvc3RzIGZvciBzdWJzZXF1ZW50IGNhbGxzLlxuICpcbiAqIEBzZWUgc2V0R0NQUmVzaWRlbmN5IGZvciBzZXR0aW5nXG4gKi9cbmZ1bmN0aW9uIGdldEdDUFJlc2lkZW5jeSgpIHtcbiAgICBpZiAoZXhwb3J0cy5nY3BSZXNpZGVuY3lDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgICBzZXRHQ1BSZXNpZGVuY3koKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydHMuZ2NwUmVzaWRlbmN5Q2FjaGU7XG59XG4vKipcbiAqIFNldHMgdGhlIGRldGVjdGVkIEdDUCBSZXNpZGVuY3kuXG4gKiBVc2VmdWwgZm9yIGZvcmNpbmcgbWV0YWRhdGEgc2VydmVyIGRldGVjdGlvbiBiZWhhdmlvci5cbiAqXG4gKiBTZXQgYG51bGxgIHRvIGF1dG9kZXRlY3QgdGhlIGVudmlyb25tZW50IChkZWZhdWx0IGJlaGF2aW9yKS5cbiAqIEBzZWUgZ2V0R0NQUmVzaWRlbmN5IGZvciBnZXR0aW5nXG4gKi9cbmZ1bmN0aW9uIHNldEdDUFJlc2lkZW5jeSh2YWx1ZSA9IG51bGwpIHtcbiAgICBleHBvcnRzLmdjcFJlc2lkZW5jeUNhY2hlID0gdmFsdWUgIT09IG51bGwgPyB2YWx1ZSA6ICgwLCBnY3BfcmVzaWRlbmN5XzEuZGV0ZWN0R0NQUmVzaWRlbmN5KSgpO1xufVxuLyoqXG4gKiBPYnRhaW4gdGhlIHRpbWVvdXQgZm9yIHJlcXVlc3RzIHRvIHRoZSBtZXRhZGF0YSBzZXJ2ZXIuXG4gKlxuICogSW4gY2VydGFpbiBlbnZpcm9ubWVudHMgYW5kIGNvbmRpdGlvbnMgcmVxdWVzdHMgY2FuIHRha2UgbG9uZ2VyIHRoYW5cbiAqIHRoZSBkZWZhdWx0IHRpbWVvdXQgdG8gY29tcGxldGUuIFRoaXMgZnVuY3Rpb24gd2lsbCBkZXRlcm1pbmUgdGhlXG4gKiBhcHByb3ByaWF0ZSB0aW1lb3V0IGJhc2VkIG9uIHRoZSBlbnZpcm9ubWVudC5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhIHJlcXVlc3QgdGltZW91dCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbmZ1bmN0aW9uIHJlcXVlc3RUaW1lb3V0KCkge1xuICAgIHJldHVybiBnZXRHQ1BSZXNpZGVuY3koKSA/IDAgOiAzMDAwO1xufVxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2djcC1yZXNpZGVuY3lcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZXhwb3J0U3RhciIsImV4cG9ydHMiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmFsdWUiLCJnY3BSZXNpZGVuY3lDYWNoZSIsIk1FVEFEQVRBX1NFUlZFUl9ERVRFQ1RJT04iLCJIRUFERVJTIiwiSEVBREVSX1ZBTFVFIiwiSEVBREVSX05BTUUiLCJTRUNPTkRBUllfSE9TVF9BRERSRVNTIiwiSE9TVF9BRERSRVNTIiwiQkFTRV9QQVRIIiwiaW5zdGFuY2UiLCJwcm9qZWN0IiwidW5pdmVyc2UiLCJidWxrIiwiaXNBdmFpbGFibGUiLCJyZXNldElzQXZhaWxhYmxlQ2FjaGUiLCJnZXRHQ1BSZXNpZGVuY3kiLCJzZXRHQ1BSZXNpZGVuY3kiLCJyZXF1ZXN0VGltZW91dCIsImdheGlvc18xIiwicmVxdWlyZSIsImpzb25CaWdpbnQiLCJnY3BfcmVzaWRlbmN5XzEiLCJsb2dnZXIiLCJmcmVlemUiLCJsb2ciLCJub25lIiwiZ2V0QmFzZVVybCIsImJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiR0NFX01FVEFEQVRBX0lQIiwiR0NFX01FVEFEQVRBX0hPU1QiLCJ0ZXN0IiwiVVJMIiwiaHJlZiIsInZhbGlkYXRlIiwib3B0aW9ucyIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiRXJyb3IiLCJtZXRhZGF0YUFjY2Vzc29yIiwidHlwZSIsIm5vUmVzcG9uc2VSZXRyaWVzIiwiZmFzdEZhaWwiLCJtZXRhZGF0YUtleSIsInBhcmFtcyIsImhlYWRlcnMiLCJwcm9wZXJ0eSIsInJlcXVlc3RNZXRob2QiLCJmYXN0RmFpbE1ldGFkYXRhUmVxdWVzdCIsInJlcXVlc3QiLCJyZXEiLCJ1cmwiLCJyZXRyeUNvbmZpZyIsInJlc3BvbnNlVHlwZSIsInRpbWVvdXQiLCJpbmZvIiwicmVzIiwiZGF0YSIsInRvTG93ZXJDYXNlIiwicGFyc2UiLCJfYSIsInNlY29uZGFyeU9wdGlvbnMiLCJ0b1N0cmluZyIsInJlcGxhY2UiLCJyZXNwb25kZWQiLCJyMSIsInRoZW4iLCJjYXRjaCIsImVyciIsInIyIiwiUHJvbWlzZSIsInJhY2UiLCJwcm9wZXJ0aWVzIiwiciIsImFsbCIsIm1hcCIsIml0ZW0iLCJkZXRlY3RHQ1BBdmFpbGFibGVSZXRyaWVzIiwiREVURUNUX0dDUF9SRVRSSUVTIiwiTnVtYmVyIiwiY2FjaGVkSXNBdmFpbGFibGVSZXNwb25zZSIsInRyaW0iLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsIlJhbmdlRXJyb3IiLCJqb2luIiwiZSIsIkRFQlVHX0FVVEgiLCJjb25zb2xlIiwicmVzcG9uc2UiLCJzdGF0dXMiLCJjb2RlIiwiaW5jbHVkZXMiLCJlbWl0V2FybmluZyIsIm1lc3NhZ2UiLCJkZXRlY3RHQ1BSZXNpZGVuY3kiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gcp-metadata/build/src/index.js\n");

/***/ })

};
;